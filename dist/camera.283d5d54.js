// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backend = hn;
exports.buffer = er;
exports.customGrad = ea;
exports.deprecationWarn = Xe;
exports.disableDeprecationWarnings = je;
exports.dispose = tn;
exports.disposeVariables = Ye;
exports.enableDebugMode = Ke;
exports.enableProdMode = qe;
exports.engine = $e;
exports.env = i;
exports.fill = Hn;
exports.findBackend = un;
exports.findBackendFactory = cn;
exports.getBackend = an;
exports.getGradient = h;
exports.getKernel = l;
exports.getKernelsForBackend = f;
exports.grad = $o;
exports.grads = Qo;
exports.keep = en;
exports.linspace = qn;
exports.memory = Qe;
exports.nextFrame = Hd;
exports.ones = zn;
exports.op = An;
exports.print = nr;
exports.profile = Je;
exports.range = Kn;
exports.ready = on;
exports.registerBackend = ln;
exports.registerGradient = p;
exports.registerKernel = d;
exports.removeBackend = sn;
exports.scalar = On;
exports.setBackend = rn;
exports.setPlatform = fn;
exports.sumOutType = Dt;
exports.tensor = Fn;
exports.tensor1d = Mn;
exports.tensor2d = Bn;
exports.tensor3d = Pn;
exports.tensor4d = Ln;
exports.tensor5d = Wn;
exports.tensor6d = Un;
exports.tidy = Ze;
exports.time = nn;
exports.unregisterGradient = m;
exports.unregisterKernel = v;
exports.valueAndGrad = Jo;
exports.valueAndGrads = Zo;
exports.variable = Vn;
exports.variableGrads = ta;
exports.zeros = Gn;
exports.inTopKAsync = exports.image = exports.imag = exports.ifft = exports.hannWindow = exports.hammingWindow = exports.greaterStrict = exports.greaterEqualStrict = exports.greaterEqual = exports.greater = exports.gather_util = exports.gatherND = exports.gather = exports.fused = exports.frame = exports.floorDiv = exports.floor = exports.fft = exports.eye = exports.expm1 = exports.expandDims = exports.exp = exports.erf = exports.equalStrict = exports.equal = exports.elu = exports.dropout = exports.dot = exports.divStrict = exports.divNoNan = exports.div = exports.diag = exports.depthwiseConv2d = exports.depthToSpace = exports.cumsum = exports.cosh = exports.cos = exports.conv3dTranspose = exports.conv3d = exports.conv2dTranspose = exports.conv2d = exports.conv1d = exports.concat4d = exports.concat3d = exports.concat2d = exports.concat1d = exports.concat = exports.complex = exports.clone = exports.clipByValue = exports.ceil = exports.cast = exports.browser = exports.broadcastTo = exports.booleanMaskAsync = exports.batchToSpaceND = exports.batchNormalization4d = exports.batchNormalization3d = exports.batchNormalization2d = exports.batchNormalization = exports.batchNorm4d = exports.batchNorm3d = exports.batchNorm2d = exports.batchNorm = exports.basicLSTMCell = exports.backend_util = exports.avgPool3d = exports.avgPool = exports.atanh = exports.atan2 = exports.atan = exports.asinh = exports.asin = exports.argMin = exports.argMax = exports.any = exports.all = exports.addStrict = exports.addN = exports.add = exports.acosh = exports.acos = exports.abs = exports.Variable = exports.TensorBuffer = exports.Tensor = exports.SGDOptimizer = exports.Reduction = exports.Rank = exports.RMSPropOptimizer = exports.Optimizer = exports.MomentumOptimizer = exports.KernelBackend = exports.Environment = exports.ENV = exports.DataStorage = exports.AdamaxOptimizer = exports.AdamOptimizer = exports.AdagradOptimizer = exports.AdadeltaOptimizer = void 0;
exports.square = exports.sqrt = exports.split = exports.spectral = exports.sparseToDense = exports.spaceToBatchND = exports.softplus = exports.softmax = exports.slice_util = exports.slice4d = exports.slice3d = exports.slice2d = exports.slice1d = exports.slice = exports.sinh = exports.sin = exports.signal = exports.sign = exports.sigmoid = exports.setdiff1dAsync = exports.serialization = exports.separableConv2d = exports.selu = exports.scatter_util = exports.scatterND = exports.rsqrt = exports.round = exports.rfft = exports.reverse4d = exports.reverse3d = exports.reverse2d = exports.reverse1d = exports.reverse = exports.reshape = exports.relu6 = exports.relu = exports.reciprocal = exports.real = exports.randomUniform = exports.randomNormal = exports.randomGamma = exports.rand = exports.prod = exports.prelu = exports.powStrict = exports.pow = exports.pool = exports.pad4d = exports.pad3d = exports.pad2d = exports.pad1d = exports.pad = exports.outerProduct = exports.onesLike = exports.oneHot = exports.notEqualStrict = exports.notEqual = exports.norm = exports.neg = exports.multinomial = exports.multiRNNCell = exports.mulStrict = exports.mul = exports.movingAverage = exports.moments = exports.modStrict = exports.mod = exports.minimumStrict = exports.minimum = exports.min = exports.mean = exports.maximumStrict = exports.maximum = exports.maxPool3d = exports.maxPool = exports.max = exports.math = exports.matMul = exports.losses = exports.logicalXor = exports.logicalOr = exports.logicalNot = exports.logicalAnd = exports.logSumExp = exports.logSoftmax = exports.logSigmoid = exports.log1p = exports.log = exports.localResponseNormalization = exports.linalg = exports.lessStrict = exports.lessEqualStrict = exports.lessEqual = exports.less = exports.leakyRelu = exports.isNaN = exports.isInf = exports.isFinite = exports.irfft = exports.io = void 0;
exports.zerosLike = exports.whereAsync = exports.where = exports.webgl = exports.version_core = exports.util = exports.unstack = exports.unsortedSegmentSum = exports.truncatedNormal = exports.transpose = exports.train = exports.topk = exports.tile = exports.test_util = exports.tensor_util = exports.tanh = exports.tan = exports.sum = exports.subStrict = exports.sub = exports.stridedSlice = exports.stft = exports.step = exports.stack = exports.squeeze = exports.squaredDifferenceStrict = exports.squaredDifference = void 0;

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var t = function (e, n) {
  return (t = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (t, e) {
    t.__proto__ = e;
  } || function (t, e) {
    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
  })(e, n);
};

function e(e, n) {
  function r() {
    this.constructor = e;
  }

  t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());
}

function n(t, e, n, r) {
  return new (n || (n = Promise))(function (o, a) {
    function i(t) {
      try {
        u(r.next(t));
      } catch (t) {
        a(t);
      }
    }

    function s(t) {
      try {
        u(r.throw(t));
      } catch (t) {
        a(t);
      }
    }

    function u(t) {
      t.done ? o(t.value) : new n(function (e) {
        e(t.value);
      }).then(i, s);
    }

    u((r = r.apply(t, e || [])).next());
  });
}

function r(t, e) {
  var n,
      r,
      o,
      a,
      i = {
    label: 0,
    sent: function () {
      if (1 & o[0]) throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  };
  return a = {
    next: s(0),
    throw: s(1),
    return: s(2)
  }, "function" == typeof Symbol && (a[Symbol.iterator] = function () {
    return this;
  }), a;

  function s(a) {
    return function (s) {
      return function (a) {
        if (n) throw new TypeError("Generator is already executing.");

        for (; i;) try {
          if (n = 1, r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, a[1])).done) return o;

          switch (r = 0, o && (a = [2 & a[0], o.value]), a[0]) {
            case 0:
            case 1:
              o = a;
              break;

            case 4:
              return i.label++, {
                value: a[1],
                done: !1
              };

            case 5:
              i.label++, r = a[1], a = [0];
              continue;

            case 7:
              a = i.ops.pop(), i.trys.pop();
              continue;

            default:
              if (!(o = (o = i.trys).length > 0 && o[o.length - 1]) && (6 === a[0] || 2 === a[0])) {
                i = 0;
                continue;
              }

              if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {
                i.label = a[1];
                break;
              }

              if (6 === a[0] && i.label < o[1]) {
                i.label = o[1], o = a;
                break;
              }

              if (o && i.label < o[2]) {
                i.label = o[2], i.ops.push(a);
                break;
              }

              o[2] && i.ops.pop(), i.trys.pop();
              continue;
          }

          a = e.call(t, i);
        } catch (t) {
          a = [6, t], r = 0;
        } finally {
          n = o = 0;
        }

        if (5 & a[0]) throw a[1];
        return {
          value: a[0] ? a[1] : void 0,
          done: !0
        };
      }([a, s]);
    };
  }
}

var o = function () {
  function t(t) {
    this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();
  }

  return t.prototype.setPlatform = function (t, e) {
    null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e + "."), this.platformName = t, this.platform = e;
  }, t.prototype.registerFlag = function (t, e, n) {
    if (this.flagRegistry[t] = {
      evaluationFn: e,
      setHook: n
    }, null != this.urlFlags[t]) {
      var r = this.urlFlags[t];
      console.warn("Setting feature override from URL " + t + ": " + r + "."), this.set(t, r);
    }
  }, t.prototype.get = function (t) {
    return t in this.flags ? this.flags[t] : (this.flags[t] = this.evaluateFlag(t), this.flags[t]);
  }, t.prototype.getNumber = function (t) {
    return this.get(t);
  }, t.prototype.getBool = function (t) {
    return this.get(t);
  }, t.prototype.getFlags = function () {
    return this.flags;
  }, Object.defineProperty(t.prototype, "features", {
    get: function () {
      return this.flags;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.set = function (t, e) {
    if (null == this.flagRegistry[t]) throw new Error("Cannot set flag " + t + " as it has not been registered.");
    this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e);
  }, t.prototype.evaluateFlag = function (t) {
    if (null == this.flagRegistry[t]) throw new Error("Cannot evaluate flag '" + t + "': no evaluation function found.");
    return this.flagRegistry[t].evaluationFn();
  }, t.prototype.setFlags = function (t) {
    this.flags = Object.assign({}, t);
  }, t.prototype.reset = function () {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }, t.prototype.populateURLFlags = function () {
    var t = this;

    if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
      var e,
          n,
          r = (e = this.global.location.search, n = {}, e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (t) {
        for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];

        return a(n, e[0], e[1]), e.join("=");
      }), n);
      if ("tfjsflags" in r) r.tfjsflags.split(",").forEach(function (e) {
        var n = e.split(":"),
            r = n[0],
            o = n[1];

        t.urlFlags[r] = function (t, e) {
          if ("true" === (e = e.toLowerCase()) || "false" === e) return "true" === e;
          if ("" + +e === e) return +e;
          throw new Error("Could not parse value flag value " + e + " for flag " + t + ".");
        }(r, o);
      });
    }
  }, t;
}();

exports.Environment = o;

function a(t, e, n) {
  t[decodeURIComponent(e)] = decodeURIComponent(n || "");
}

function i() {
  return s;
}

var s = null;
exports.ENV = s;
var u = new Map(),
    c = new Map();

function l(t, e) {
  var n = g(t, e);
  return u.get(n);
}

function h(t) {
  return c.get(t);
}

function f(t) {
  for (var e = u.entries(), n = [];;) {
    var r = e.next(),
        o = r.done,
        a = r.value;
    if (o) break;
    var i = a[0],
        s = a[1];
    i.split("_")[0] === t && n.push(s);
  }

  return n;
}

function d(t) {
  var e = t.kernelName,
      n = t.backendName,
      r = g(e, n);
  if (u.has(r)) throw new Error("The kernel '" + e + "' for backend '" + n + "' is already registered");
  u.set(r, t);
}

function p(t) {
  var e = t.kernelName;
  c.has(e) && console.warn("Overriding the gradient for '" + e + "'"), c.set(e, t);
}

function v(t, e) {
  var n = g(t, e);
  if (!u.has(n)) throw new Error("The kernel '" + t + "' for backend '" + e + "' is not registered");
  u.delete(n);
}

function m(t) {
  if (!c.has(t)) throw new Error("The gradient '" + t + "' for backend is not registered");
  c.delete(t);
}

function g(t, e) {
  return e + "_" + t;
}

function y(t) {
  for (var e = t.length, n = 0, r = 0; e > 0;) r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n;
}

function x(t, e, n) {
  return Math.max(t, Math.min(e, n));
}

function b(t) {
  return t % 2 == 0 ? t : t + 1;
}

function w(t) {
  for (var e = 0, n = 0; n < t.length; n++) e += t[n];

  return e;
}

function C(t, e) {
  if (!t) throw new Error("string" == typeof e ? e : e());
}

function E(t, e, n) {
  void 0 === n && (n = ""), C(S(t, e), function () {
    return n + " Shapes " + t + " and " + e + " must match";
  });
}

function R(t) {
  C(null != t, function () {
    return "The input to the tensor constructor must be a non-null value.";
  });
}

function I(t, e, n) {
  if (void 0 === e && (e = []), void 0 === n && (n = !1), null == e && (e = []), Array.isArray(t) || V(t) && !n) for (var r = 0; r < t.length; ++r) I(t[r], e, n);else e.push(t);
  return e;
}

function k(t) {
  if (0 === t.length) return 1;

  for (var e = t[0], n = 1; n < t.length; n++) e *= t[n];

  return e;
}

function S(t, e) {
  if (t === e) return !0;
  if (null == t || null == e) return !1;
  if (t.length !== e.length) return !1;

  for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;

  return !0;
}

function A(t) {
  return t % 1 == 0;
}

function T(t) {
  if (null != Math.tanh) return Math.tanh(t);
  if (t === 1 / 0) return 1;
  if (t === -1 / 0) return -1;
  var e = Math.exp(2 * t);
  return (e - 1) / (e + 1);
}

function D(t) {
  var e = Math.ceil(Math.sqrt(t));
  return [e, Math.ceil(t / e)];
}

function N(t, e) {
  return e <= t.length ? t : t + " ".repeat(e - t.length);
}

function F(t, e, n) {
  return void 0 === e && (e = function (t) {
    return 0;
  }), new Promise(function (r, o) {
    var a = 0,
        i = function () {
      if (t()) r();else {
        a++;
        var s = e(a);
        null != n && a >= n ? o() : setTimeout(i, s);
      }
    };

    i();
  });
}

function _(t, e) {
  for (var n = 1, r = -1, o = 0; o < t.length; ++o) if (t[o] >= 0) n *= t[o];else if (-1 === t[o]) {
    if (-1 !== r) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + o);
    r = o;
  } else if (t[o] < 0) throw Error("Shapes can not be < 0. Found " + t[o] + " at dim " + o);

  if (-1 === r) {
    if (e > 0 && e !== n) throw Error("Size(" + e + ") must match the product of shape " + t);
    return t;
  }

  if (0 === n) throw Error("Cannot infer the missing size in [" + t + "] when there are 0 elements");
  if (e % n != 0) throw Error("The implicit shape can't be a fractional number. Got " + e + " / " + n);
  var a = t.slice();
  return a[r] = e / n, a;
}

function O(t, e) {
  var n = e.length;
  return C((t = null == t ? e.map(function (t, e) {
    return e;
  }) : [].concat(t)).every(function (t) {
    return t >= -n && t < n;
  }), function () {
    return "All values in axis param must be in range [-" + n + ", " + n + ") but got axis " + t;
  }), C(t.every(function (t) {
    return A(t);
  }), function () {
    return "All values in axis param must be integers but got axis " + t;
  }), t.map(function (t) {
    return t < 0 ? n + t : t;
  });
}

function M(t, e) {
  for (var n = [], r = [], o = null != e && Array.isArray(e) && 0 === e.length, a = null == e || o ? null : O(e, t).sort(), i = 0, s = 0; s < t.length; ++s) {
    if (null != a) {
      if (a[i] === s && 1 !== t[s]) throw new Error("Can't squeeze axis " + s + " since its dim '" + t[s] + "' is not 1");
      (null == a[i] || a[i] > s) && 1 === t[s] && (n.push(t[s]), r.push(s)), a[i] <= s && i++;
    }

    1 !== t[s] && (n.push(t[s]), r.push(s));
  }

  return {
    newShape: n,
    keptDims: r
  };
}

function B(t, e) {
  var n = null;
  if (null == t || "float32" === t) n = new Float32Array(e);else if ("int32" === t) n = new Int32Array(e);else {
    if ("bool" !== t) throw new Error("Unknown data type " + t);
    n = new Uint8Array(e);
  }
  return n;
}

function P(t, e) {
  var n = null;
  if (null == t || "float32" === t) n = new Float32Array(e);else if ("int32" === t) n = new Int32Array(e);else if ("bool" === t) n = new Uint8Array(e);else {
    if ("string" !== t) throw new Error("Unknown data type " + t);
    n = new Array(e);
  }
  return n;
}

function L(t, e) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + e + " being uploaded contains " + r + ".");
  }
}

function W(t) {
  return "bool" === t || "complex64" === t || "float32" === t || "int32" === t || "string" === t;
}

function U(t, e) {
  return "complex64" !== e && ("float32" !== e || "complex64" === t) && ("int32" !== e || "float32" === t || "complex64" === t) && ("bool" !== e || "bool" !== t);
}

function V(t) {
  return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array;
}

function z(t) {
  if ("float32" === t || "int32" === t) return 4;
  if ("complex64" === t) return 8;
  if ("bool" === t) return 1;
  throw new Error("Unknown dtype " + t);
}

function G(t) {
  if (null == t) return 0;
  var e = 0;
  return t.forEach(function (t) {
    return e += t.length;
  }), e;
}

function H(t) {
  return "string" == typeof t || t instanceof String;
}

function q(t) {
  return "boolean" == typeof t;
}

function K(t) {
  return "number" == typeof t;
}

function j(t) {
  return Array.isArray(t) ? j(t[0]) : t instanceof Float32Array ? "float32" : t instanceof Int32Array || t instanceof Uint8Array ? "int32" : K(t) ? "float32" : H(t) ? "string" : q(t) ? "bool" : "float32";
}

function X(t) {
  return !!(t && t.constructor && t.call && t.apply);
}

function Y(t, e) {
  for (var n = e; n < t; ++n) if (t % n == 0) return n;

  return t;
}

function $(t) {
  var e = t.length;
  if (e < 2) return [];
  var n = new Array(e - 1);
  n[e - 2] = t[e - 1];

  for (var r = e - 3; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];

  return n;
}

function Q(t, e, n) {
  if ("string" === e) throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(t) && (t = I(t)), n && L(t, e), function (t, e) {
    return t instanceof Float32Array && "float32" === e || t instanceof Int32Array && "int32" === e || t instanceof Uint8Array && "bool" === e;
  }(t, e)) return t;
  if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
  if ("int32" === e) return new Int32Array(t);

  if ("bool" === e) {
    for (var r = new Uint8Array(t.length), o = 0; o < r.length; ++o) 0 !== Math.round(t[o]) && (r[o] = 1);

    return r;
  }

  throw new Error("Unknown data type " + e);
}

function J(t, e) {
  if (0 === t.length) return e[0];
  var n = t.reduce(function (t, e) {
    return t * e;
  });
  if (0 === n) return [];
  if (n !== e.length) throw new Error("[" + t + "] does not match the input size.");
  return function t(e, n, r) {
    var o = new Array();
    if (1 === n.length) for (var a = n[0], i = 0; i < a; i++) o[i] = r[e + i];else {
      a = n[0];
      var s = n.slice(1),
          u = s.reduce(function (t, e) {
        return t * e;
      });

      for (i = 0; i < a; i++) o[i] = t(e + i * u, s, r);
    }
    return o;
  }(0, t, e);
}

function Z(t, e) {
  for (var n = tt(t, e), r = 0; r < n.length; r++) n[r] = 1;

  return n;
}

function tt(t, e) {
  if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
  if ("int32" === e) return new Int32Array(t);
  if ("bool" === e) return new Uint8Array(t);
  throw new Error("Unknown data type " + e);
}

function et() {
  return i().platform.now();
}

function nt(t) {
  t.forEach(function (e) {
    C(Number.isInteger(e) && e >= 0, function () {
      return "Tensor must have a shape comprised of positive integers but got shape [" + t + "].";
    });
  });
}

function rt(t, e) {
  return void 0 === e && (e = "utf-8"), e = e || "utf-8", i().platform.encode(t, e);
}

function ot(t, e) {
  return void 0 === e && (e = "utf-8"), e = e || "utf-8", i().platform.decode(t, e);
}

function at(t, e, n) {
  if (0 === e) return 0;
  if (1 === e) return t[0];

  for (var r = t[t.length - 1], o = 0; o < t.length - 1; ++o) r += n[o] * t[o];

  return r;
}

function it(t, e, n) {
  if (0 === e) return [];
  if (1 === e) return [t];

  for (var r = new Array(e), o = 0; o < r.length - 1; ++o) r[o] = Math.floor(t / n[o]), t -= r[o] * n[o];

  return r[r.length - 1] = t, r;
}

var st = Object.freeze({
  shuffle: y,
  clamp: x,
  nearestLargerEven: b,
  sum: w,
  randUniform: function (t, e) {
    var n = Math.random();
    return e * n + (1 - n) * t;
  },
  distSquared: function (t, e) {
    for (var n = 0, r = 0; r < t.length; r++) {
      var o = Number(t[r]) - Number(e[r]);
      n += o * o;
    }

    return n;
  },
  assert: C,
  assertShapesMatch: E,
  assertNonNull: R,
  flatten: I,
  sizeFromShape: k,
  isScalarShape: function (t) {
    return 0 === t.length;
  },
  arraysEqual: S,
  isInt: A,
  tanh: T,
  sizeToSquarishShape: D,
  createShuffledIndices: function (t) {
    for (var e = new Uint32Array(t), n = 0; n < t; ++n) e[n] = n;

    return y(e), e;
  },
  rightPad: N,
  repeatedTry: F,
  inferFromImplicitShape: _,
  parseAxisParam: O,
  squeezeShape: M,
  getTypedArrayFromDType: B,
  getArrayFromDType: P,
  checkConversionForErrors: L,
  isValidDtype: W,
  hasEncodingLoss: U,
  isTypedArray: V,
  bytesPerElement: z,
  bytesFromStringArray: G,
  isString: H,
  isBoolean: q,
  isNumber: K,
  inferDtype: j,
  isFunction: X,
  nearestDivisor: Y,
  computeStrides: $,
  toTypedArray: Q,
  toNestedArray: J,
  makeOnesTypedArray: Z,
  makeZerosTypedArray: tt,
  now: et,
  assertNonNegativeIntegerDimensions: nt,
  fetch: function (t, e) {
    return i().platform.fetch(t, e);
  },
  encodeString: rt,
  decodeString: ot,
  locToIndex: at,
  indexToLoc: it
}),
    ut = function () {
  function t(t, e) {
    this.backendTimer = t, this.logger = e, null == e && (this.logger = new ct());
  }

  return t.prototype.profileKernel = function (t, e, n) {
    var r,
        o = this,
        a = this.backendTimer.time(function () {
      r = n();
    });
    return r.forEach(function (n) {
      n.data().then(function (r) {
        !function (t, e, n) {
          if ("float32" !== e) return !1;

          for (var r = 0; r < t.length; r++) {
            var o = t[r];
            if (isNaN(o) || !isFinite(o)) return console.warn("Found " + o + " in the result of '" + n + "'"), !0;
          }
        }(r, n.dtype, t), a.then(function (a) {
          var i = "";
          null != a.getExtraProfileInfo && (i = a.getExtraProfileInfo()), o.logger.logKernelProfile(t, n, r, a.kernelMs, e, i);
        });
      });
    }), r;
  }, t;
}();

exports.util = st;

var ct = function () {
  function t() {}

  return t.prototype.logKernelProfile = function (t, e, n, r, o, a) {
    var i = "number" == typeof r ? N(r + "ms", 9) : r.error,
        s = N(t, 25),
        u = e.rank,
        c = e.size,
        l = N(e.shape.toString(), 14),
        h = "";

    for (var f in o) {
      var d = o[f].shape || e.shape,
          p = d.length;
      h += f + ": " + p + "D " + (p > 0 ? d : "") + " ";
    }

    console.log("%c" + s + "\t%c" + i + "\t%c" + u + "D " + l + "\t%c" + c + "\t%c" + h + "\t%c" + a, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }, t;
}();

var lt = 20,
    ht = 3,
    ft = 7;

function dt(t, e, n, r) {
  var o = $(e),
      a = function (t, e, n, r) {
    var o = k(e),
        a = r[r.length - 1],
        i = new Array(a).fill(0),
        s = e.length,
        u = "complex64" === n ? mt(t) : t;
    if (s > 1) for (var c = 0; c < o / a; c++) for (var l = c * a, h = 0; h < a; h++) i[h] = Math.max(i[h], pt(u[l + h], 0, n).length);
    return i;
  }(t, e, n, o),
      i = e.length,
      s = function t(e, n, r, o, a, i) {
    void 0 === i && (i = !0);
    var s = "complex64" === r ? 2 : 1,
        u = n[0],
        c = n.length;

    if (0 === c) {
      return "complex64" === r ? [pt(mt(e)[0], 0, r)] : "bool" === r ? [vt(e[0])] : [e[0].toString()];
    }

    if (1 === c) {
      if (u > lt) {
        var l = ht * s,
            h = Array.from(e.slice(0, l)),
            f = Array.from(e.slice((u - ht) * s, u * s));
        return "complex64" === r && (h = mt(h), f = mt(f)), ["[" + h.map(function (t, e) {
          return pt(t, a[e], r);
        }).join(", ") + ", ..., " + f.map(function (t, e) {
          return pt(t, a[u - ht + e], r);
        }).join(", ") + "]"];
      }

      return ["[" + ("complex64" === r ? mt(e) : Array.from(e)).map(function (t, e) {
        return pt(t, a[e], r);
      }).join(", ") + "]"];
    }

    var d = n.slice(1),
        p = o.slice(1),
        v = o[0] * s,
        m = [];

    if (u > lt) {
      for (var g = 0; g < ht; g++) {
        var y = (x = g * v) + v;
        m.push.apply(m, t(e.slice(x, y), d, r, p, a, !1));
      }

      m.push("...");

      for (g = u - ht; g < u; g++) {
        y = (x = g * v) + v;
        m.push.apply(m, t(e.slice(x, y), d, r, p, a, g === u - 1));
      }
    } else for (g = 0; g < u; g++) {
      var x;
      y = (x = g * v) + v;
      m.push.apply(m, t(e.slice(x, y), d, r, p, a, g === u - 1));
    }

    var b = 2 === c ? "," : "";
    m[0] = "[" + m[0] + b;

    for (g = 1; g < m.length - 1; g++) m[g] = " " + m[g] + b;

    var w = ",\n";

    for (g = 2; g < c; g++) w += "\n";

    return m[m.length - 1] = " " + m[m.length - 1] + "]" + (i ? "" : w), m;
  }(t, e, n, o, a),
      u = ["Tensor"];

  return r && (u.push("  dtype: " + n), u.push("  rank: " + i), u.push("  shape: [" + e + "]"), u.push("  values:")), u.push(s.map(function (t) {
    return "    " + t;
  }).join("\n")), u.join("\n");
}

function pt(t, e, n) {
  return N(Array.isArray(t) ? parseFloat(t[0].toFixed(ft)) + " + " + parseFloat(t[1].toFixed(ft)) + "j" : H(t) ? "'" + t + "'" : "bool" === n ? vt(t) : parseFloat(t.toFixed(ft)).toString(), e);
}

function vt(t) {
  return 0 === t ? "false" : "true";
}

function mt(t) {
  for (var e = [], n = 0; n < t.length; n += 2) e.push([t[n], t[n + 1]]);

  return e;
}

var gt = function () {
  function t(t, e, n) {
    var r = this;

    if (this.dtype = e, this.shape = t.slice(), this.size = k(t), null != n) {
      var o = n.length;
      C(o === this.size, function () {
        return "Length of values '" + o + "' does not match the size inferred by the shape '" + r.size + "'.";
      });
    }

    if ("complex64" === e) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n || P(e, this.size), this.strides = $(t);
  }

  return t.prototype.set = function (t) {
    for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];

    0 === n.length && (n = [0]), C(n.length === this.rank, function () {
      return "The number of provided coordinates (" + n.length + ") must match the rank (" + e.rank + ")";
    });
    var o = this.locToIndex(n);
    this.values[o] = t;
  }, t.prototype.get = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];

    0 === t.length && (t = [0]);

    for (var n = 0, r = 0, o = t; r < o.length; r++) {
      var a = o[r];

      if (a < 0 || a >= this.shape[n]) {
        var i = "Requested out of range element at " + t + ".   Buffer shape=" + this.shape;
        throw new Error(i);
      }

      n++;
    }

    for (var s = t[t.length - 1], u = 0; u < t.length - 1; ++u) s += this.strides[u] * t[u];

    return this.values[s];
  }, t.prototype.locToIndex = function (t) {
    if (0 === this.rank) return 0;
    if (1 === this.rank) return t[0];

    for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n) e += this.strides[n] * t[n];

    return e;
  }, t.prototype.indexToLoc = function (t) {
    if (0 === this.rank) return [];
    if (1 === this.rank) return [t];

    for (var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n) e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];

    return e[e.length - 1] = t, e;
  }, Object.defineProperty(t.prototype, "rank", {
    get: function () {
      return this.shape.length;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.toTensor = function () {
    return yt().makeTensor(this.values, this.shape, this.dtype);
  }, t;
}(),
    yt = null,
    xt = null,
    bt = null;

exports.TensorBuffer = gt;

var wt = function () {
  function t(t, e, n, r) {
    this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || "float32", this.size = k(t), this.strides = $(t), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }

  return t.prototype.flatten = function () {
    return this.throwIfDisposed(), this.as1D();
  }, t.prototype.asScalar = function () {
    return this.throwIfDisposed(), C(1 === this.size, function () {
      return "The array must have only 1 element.";
    }), this.reshape([]);
  }, t.prototype.as1D = function () {
    return this.throwIfDisposed(), this.reshape([this.size]);
  }, t.prototype.as2D = function (t, e) {
    return this.throwIfDisposed(), this.reshape([t, e]);
  }, t.prototype.as3D = function (t, e, n) {
    return this.throwIfDisposed(), this.reshape([t, e, n]);
  }, t.prototype.as4D = function (t, e, n, r) {
    return this.throwIfDisposed(), this.reshape([t, e, n, r]);
  }, t.prototype.as5D = function (t, e, n, r, o) {
    return this.throwIfDisposed(), this.reshape([t, e, n, r, o]);
  }, t.prototype.asType = function (t) {
    return this.throwIfDisposed(), xt.cast(this, t);
  }, Object.defineProperty(t.prototype, "rank", {
    get: function () {
      return this.shape.length;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.buffer = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.data()];

          case 1:
            return t = e.sent(), [2, xt.buffer(this.shape, this.dtype, t)];
        }
      });
    });
  }, t.prototype.bufferSync = function () {
    return xt.buffer(this.shape, this.dtype, this.dataSync());
  }, t.prototype.array = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.data()];

          case 1:
            return t = e.sent(), [2, J(this.shape, t)];
        }
      });
    });
  }, t.prototype.arraySync = function () {
    return J(this.shape, this.dataSync());
  }, t.prototype.data = function () {
    return n(this, void 0, void 0, function () {
      var t, e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return this.throwIfDisposed(), t = yt().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t];

          case 1:
            e = n.sent();

            try {
              return [2, e.map(function (t) {
                return ot(t);
              })];
            } catch (t) {
              throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }

            n.label = 2;

          case 2:
            return [2, t];
        }
      });
    });
  }, t.prototype.dataSync = function () {
    this.throwIfDisposed();
    var t = yt().readSync(this.dataId);
    if ("string" === this.dtype) try {
      return t.map(function (t) {
        return ot(t);
      });
    } catch (t) {
      throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
    }
    return t;
  }, t.prototype.bytes = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return this.throwIfDisposed(), [4, yt().read(this.dataId)];

          case 1:
            return t = e.sent(), "string" === this.dtype ? [2, t] : [2, new Uint8Array(t.buffer)];
        }
      });
    });
  }, t.prototype.dispose = function () {
    this.isDisposed || (yt().disposeTensor(this), this.isDisposedInternal = !0);
  }, Object.defineProperty(t.prototype, "isDisposed", {
    get: function () {
      return this.isDisposedInternal;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.throwIfDisposed = function () {
    if (this.isDisposed) throw new Error("Tensor is disposed.");
  }, t.prototype.toFloat = function () {
    return this.asType("float32");
  }, t.prototype.toInt = function () {
    return this.asType("int32");
  }, t.prototype.toBool = function () {
    return this.asType("bool");
  }, t.prototype.print = function (t) {
    return void 0 === t && (t = !1), xt.print(this, t);
  }, t.prototype.reshape = function (t) {
    return this.throwIfDisposed(), xt.reshape(this, t);
  }, t.prototype.reshapeAs = function (t) {
    return this.throwIfDisposed(), this.reshape(t.shape);
  }, t.prototype.expandDims = function (t) {
    return void 0 === t && (t = 0), xt.expandDims(this, t);
  }, t.prototype.cumsum = function (t, e, n) {
    return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), xt.cumsum(this, t, e, n);
  }, t.prototype.squeeze = function (t) {
    return this.throwIfDisposed(), xt.squeeze(this, t);
  }, t.prototype.clone = function () {
    return this.throwIfDisposed(), xt.clone(this);
  }, t.prototype.toString = function (t) {
    return void 0 === t && (t = !1), dt(this.dataSync(), this.shape, this.dtype, t);
  }, t.prototype.gather = function (t, e) {
    return void 0 === e && (e = 0), this.throwIfDisposed(), xt.gather(this, t, e);
  }, t.prototype.matMul = function (t, e, n) {
    return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), xt.matMul(this, t, e, n);
  }, t.prototype.dot = function (t) {
    return this.throwIfDisposed(), xt.dot(this, t);
  }, t.prototype.norm = function (t, e, n) {
    return void 0 === t && (t = "euclidean"), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), xt.norm(this, t, e, n);
  }, t.prototype.slice = function (t, e) {
    return this.throwIfDisposed(), xt.slice(this, t, e);
  }, t.prototype.reverse = function (t) {
    return this.throwIfDisposed(), xt.reverse(this, t);
  }, t.prototype.concat = function (e, n) {
    return void 0 === n && (n = 0), this.throwIfDisposed(), e instanceof t && (e = [e]), xt.concat([this].concat(e), n);
  }, t.prototype.split = function (t, e) {
    return void 0 === e && (e = 0), this.throwIfDisposed(), xt.split(this, t, e);
  }, t.prototype.stack = function (t, e) {
    return void 0 === e && (e = 0), xt.stack([this, t], e);
  }, t.prototype.unstack = function (t) {
    return void 0 === t && (t = 0), xt.unstack(this, t);
  }, t.prototype.pad = function (t, e) {
    return void 0 === e && (e = 0), xt.pad(this, t, e);
  }, t.prototype.batchNormalization = function (t, e, n, r, o) {
    return void 0 === n && (n = .001), bt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t, e, o, r, n);
  }, t.prototype.batchNorm = function (t, e, n, r, o) {
    return void 0 === o && (o = .001), this.throwIfDisposed(), xt.batchNorm(this, t, e, n, r, o);
  }, t.prototype.all = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.all(this, t, e);
  }, t.prototype.any = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.any(this, t, e);
  }, t.prototype.logSumExp = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.logSumExp(this, t, e);
  }, t.prototype.sum = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.sum(this, t, e);
  }, t.prototype.prod = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.prod(this, t, e);
  }, t.prototype.mean = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.mean(this, t, e);
  }, t.prototype.min = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.min(this, t, e);
  }, t.prototype.max = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.max(this, t, e);
  }, t.prototype.argMin = function (t) {
    return void 0 === t && (t = null), this.throwIfDisposed(), xt.argMin(this, t);
  }, t.prototype.argMax = function (t) {
    return void 0 === t && (t = null), this.throwIfDisposed(), xt.argMax(this, t);
  }, t.prototype.cast = function (t) {
    return this.throwIfDisposed(), xt.cast(this, t);
  }, t.prototype.add = function (t) {
    return this.throwIfDisposed(), xt.add(this, t);
  }, t.prototype.addStrict = function (t) {
    return this.throwIfDisposed(), xt.addStrict(this, t);
  }, t.prototype.atan2 = function (t) {
    return this.throwIfDisposed(), xt.atan2(this, t);
  }, t.prototype.sub = function (t) {
    return this.throwIfDisposed(), xt.sub(this, t);
  }, t.prototype.subStrict = function (t) {
    return this.throwIfDisposed(), xt.subStrict(this, t);
  }, t.prototype.pow = function (t) {
    return this.throwIfDisposed(), xt.pow(this, t);
  }, t.prototype.powStrict = function (t) {
    return this.throwIfDisposed(), xt.powStrict(this, t);
  }, t.prototype.mul = function (t) {
    return this.throwIfDisposed(), xt.mul(this, t);
  }, t.prototype.mulStrict = function (t) {
    return this.throwIfDisposed(), xt.mulStrict(this, t);
  }, t.prototype.floorDiv = function (t) {
    return this.throwIfDisposed(), xt.floorDiv(this, t);
  }, t.prototype.divStrict = function (t) {
    return this.throwIfDisposed(), xt.divStrict(this, t);
  }, t.prototype.minimum = function (t) {
    return this.throwIfDisposed(), xt.minimum(this, t);
  }, t.prototype.minimumStrict = function (t) {
    return this.throwIfDisposed(), xt.minimumStrict(this, t);
  }, t.prototype.maximum = function (t) {
    return this.throwIfDisposed(), xt.maximum(this, t);
  }, t.prototype.maximumStrict = function (t) {
    return this.throwIfDisposed(), xt.maximumStrict(this, t);
  }, t.prototype.mod = function (t) {
    return this.throwIfDisposed(), xt.mod(this, t);
  }, t.prototype.modStrict = function (t) {
    return this.throwIfDisposed(), xt.modStrict(this, t);
  }, t.prototype.squaredDifferenceStrict = function (t) {
    return this.throwIfDisposed(), xt.squaredDifferenceStrict(this, t);
  }, t.prototype.transpose = function (t) {
    return this.throwIfDisposed(), xt.transpose(this, t);
  }, t.prototype.notEqual = function (t) {
    return this.throwIfDisposed(), xt.notEqual(this, t);
  }, t.prototype.notEqualStrict = function (t) {
    return this.throwIfDisposed(), xt.notEqualStrict(this, t);
  }, t.prototype.less = function (t) {
    return this.throwIfDisposed(), xt.less(this, t);
  }, t.prototype.lessStrict = function (t) {
    return this.throwIfDisposed(), xt.lessStrict(this, t);
  }, t.prototype.equal = function (t) {
    return this.throwIfDisposed(), xt.equal(this, t);
  }, t.prototype.equalStrict = function (t) {
    return this.throwIfDisposed(), xt.equalStrict(this, t);
  }, t.prototype.lessEqual = function (t) {
    return this.throwIfDisposed(), xt.lessEqual(this, t);
  }, t.prototype.lessEqualStrict = function (t) {
    return this.throwIfDisposed(), xt.lessEqualStrict(this, t);
  }, t.prototype.greater = function (t) {
    return this.throwIfDisposed(), xt.greater(this, t);
  }, t.prototype.greaterStrict = function (t) {
    return this.throwIfDisposed(), xt.greaterStrict(this, t);
  }, t.prototype.greaterEqual = function (t) {
    return this.throwIfDisposed(), xt.greaterEqual(this, t);
  }, t.prototype.greaterEqualStrict = function (t) {
    return this.throwIfDisposed(), xt.greaterEqualStrict(this, t);
  }, t.prototype.logicalAnd = function (t) {
    return this.throwIfDisposed(), xt.logicalAnd(this, t);
  }, t.prototype.logicalOr = function (t) {
    return this.throwIfDisposed(), xt.logicalOr(this, t);
  }, t.prototype.logicalNot = function () {
    return this.throwIfDisposed(), xt.logicalNot(this);
  }, t.prototype.logicalXor = function (t) {
    return this.throwIfDisposed(), xt.logicalXor(this, t);
  }, t.prototype.where = function (t, e) {
    return this.throwIfDisposed(), xt.where(t, this, e);
  }, t.prototype.neg = function () {
    return this.throwIfDisposed(), xt.neg(this);
  }, t.prototype.ceil = function () {
    return this.throwIfDisposed(), xt.ceil(this);
  }, t.prototype.floor = function () {
    return this.throwIfDisposed(), xt.floor(this);
  }, t.prototype.sign = function () {
    return this.throwIfDisposed(), xt.sign(this);
  }, t.prototype.isNaN = function () {
    return this.throwIfDisposed(), xt.isNaN(this);
  }, t.prototype.isInf = function () {
    return this.throwIfDisposed(), xt.isInf(this);
  }, t.prototype.isFinite = function () {
    return this.throwIfDisposed(), xt.isFinite(this);
  }, t.prototype.exp = function () {
    return this.throwIfDisposed(), xt.exp(this);
  }, t.prototype.expm1 = function () {
    return this.throwIfDisposed(), xt.expm1(this);
  }, t.prototype.log = function () {
    return this.throwIfDisposed(), xt.log(this);
  }, t.prototype.log1p = function () {
    return this.throwIfDisposed(), xt.log1p(this);
  }, t.prototype.sqrt = function () {
    return this.throwIfDisposed(), xt.sqrt(this);
  }, t.prototype.rsqrt = function () {
    return this.throwIfDisposed(), xt.rsqrt(this);
  }, t.prototype.square = function () {
    return this.throwIfDisposed(), xt.square(this);
  }, t.prototype.reciprocal = function () {
    return this.throwIfDisposed(), xt.reciprocal(this);
  }, t.prototype.abs = function () {
    return this.throwIfDisposed(), xt.abs(this);
  }, t.prototype.clipByValue = function (t, e) {
    return this.throwIfDisposed(), xt.clipByValue(this, t, e);
  }, t.prototype.relu = function () {
    return this.throwIfDisposed(), xt.relu(this);
  }, t.prototype.relu6 = function () {
    return this.throwIfDisposed(), xt.relu6(this);
  }, t.prototype.elu = function () {
    return this.throwIfDisposed(), xt.elu(this);
  }, t.prototype.selu = function () {
    return this.throwIfDisposed(), xt.selu(this);
  }, t.prototype.leakyRelu = function (t) {
    return void 0 === t && (t = .2), this.throwIfDisposed(), xt.leakyRelu(this, t);
  }, t.prototype.prelu = function (t) {
    return this.throwIfDisposed(), xt.prelu(this, t);
  }, t.prototype.sigmoid = function () {
    return this.throwIfDisposed(), xt.sigmoid(this);
  }, t.prototype.logSigmoid = function () {
    return this.throwIfDisposed(), xt.logSigmoid(this);
  }, t.prototype.softplus = function () {
    return this.throwIfDisposed(), xt.softplus(this);
  }, t.prototype.zerosLike = function () {
    return this.throwIfDisposed(), xt.zerosLike(this);
  }, t.prototype.onesLike = function () {
    return this.throwIfDisposed(), xt.onesLike(this);
  }, t.prototype.sin = function () {
    return this.throwIfDisposed(), xt.sin(this);
  }, t.prototype.cos = function () {
    return this.throwIfDisposed(), xt.cos(this);
  }, t.prototype.tan = function () {
    return this.throwIfDisposed(), xt.tan(this);
  }, t.prototype.asin = function () {
    return this.throwIfDisposed(), xt.asin(this);
  }, t.prototype.acos = function () {
    return this.throwIfDisposed(), xt.acos(this);
  }, t.prototype.atan = function () {
    return this.throwIfDisposed(), xt.atan(this);
  }, t.prototype.sinh = function () {
    return this.throwIfDisposed(), xt.sinh(this);
  }, t.prototype.cosh = function () {
    return this.throwIfDisposed(), xt.cosh(this);
  }, t.prototype.tanh = function () {
    return this.throwIfDisposed(), xt.tanh(this);
  }, t.prototype.asinh = function () {
    return this.throwIfDisposed(), xt.asinh(this);
  }, t.prototype.acosh = function () {
    return this.throwIfDisposed(), xt.acosh(this);
  }, t.prototype.atanh = function () {
    return this.throwIfDisposed(), xt.atanh(this);
  }, t.prototype.erf = function () {
    return this.throwIfDisposed(), xt.erf(this);
  }, t.prototype.round = function () {
    return this.throwIfDisposed(), xt.round(this);
  }, t.prototype.step = function (t) {
    return void 0 === t && (t = 0), this.throwIfDisposed(), xt.step(this, t);
  }, t.prototype.softmax = function (t) {
    return void 0 === t && (t = -1), this.throwIfDisposed(), xt.softmax(this, t);
  }, t.prototype.logSoftmax = function (t) {
    return void 0 === t && (t = -1), this.throwIfDisposed(), xt.logSoftmax(this, t);
  }, t.prototype.resizeBilinear = function (t, e) {
    return void 0 === e && (e = !1), this.throwIfDisposed(), xt.image.resizeBilinear(this, t, e);
  }, t.prototype.resizeNearestNeighbor = function (t, e) {
    return void 0 === e && (e = !1), this.throwIfDisposed(), xt.image.resizeNearestNeighbor(this, t, e);
  }, t.prototype.conv1d = function (t, e, n, r, o, a) {
    return void 0 === r && (r = "NWC"), void 0 === o && (o = 1), this.throwIfDisposed(), xt.conv1d(this, t, e, n, r, o, a);
  }, t.prototype.conv2d = function (t, e, n, r, o, a) {
    return void 0 === r && (r = "NHWC"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), xt.conv2d(this, t, e, n, r, o, a);
  }, t.prototype.conv2dTranspose = function (t, e, n, r, o) {
    return this.throwIfDisposed(), xt.conv2dTranspose(this, t, e, n, r, o);
  }, t.prototype.depthwiseConv2D = function (t, e, n, r, o, a) {
    return void 0 === r && (r = "NHWC"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), xt.depthwiseConv2d(this, t, e, n, r, o, a);
  }, t.prototype.separableConv2d = function (t, e, n, r, o, a) {
    return void 0 === o && (o = [1, 1]), void 0 === a && (a = "NHWC"), this.throwIfDisposed(), xt.separableConv2d(this, t, e, n, r, o, a);
  }, t.prototype.avgPool = function (t, e, n, r) {
    return this.throwIfDisposed(), xt.avgPool(this, t, e, n, r);
  }, t.prototype.maxPool = function (t, e, n, r) {
    return this.throwIfDisposed(), xt.maxPool(this, t, e, n, r);
  }, t.prototype.localResponseNormalization = function (t, e, n, r) {
    return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), xt.localResponseNormalization(this, t, e, n, r);
  }, t.prototype.pool = function (t, e, n, r, o) {
    return this.throwIfDisposed(), xt.pool(this, t, e, n, r, o);
  }, t.prototype.variable = function (t, e, n) {
    return void 0 === t && (t = !0), this.throwIfDisposed(), yt().makeVariable(this, t, e, n);
  }, t.prototype.unsortedSegmentSum = function (t, e) {
    return this.throwIfDisposed(), xt.unsortedSegmentSum(this, t, e);
  }, t.prototype.batchToSpaceND = function (t, e) {
    return this.throwIfDisposed(), xt.batchToSpaceND(this, t, e);
  }, t.prototype.spaceToBatchND = function (t, e) {
    return this.throwIfDisposed(), xt.spaceToBatchND(this, t, e);
  }, t.prototype.topk = function (t, e) {
    return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), xt.topk(this, t, e);
  }, t.prototype.stridedSlice = function (t, e, n, r, o, a, i, s) {
    return void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.throwIfDisposed(), xt.stridedSlice(this, t, e, n, r, o, a, i, s);
  }, t.prototype.depthToSpace = function (t, e) {
    return this.throwIfDisposed(), xt.depthToSpace(this, t, e);
  }, t.prototype.fft = function () {
    return this.throwIfDisposed(), xt.spectral.fft(this);
  }, t.prototype.ifft = function () {
    return this.throwIfDisposed(), xt.spectral.ifft(this);
  }, t.prototype.rfft = function () {
    return this.throwIfDisposed(), xt.spectral.rfft(this);
  }, t.prototype.irfft = function () {
    return this.throwIfDisposed(), xt.spectral.irfft(this);
  }, t;
}();

exports.Tensor = wt;
Object.defineProperty(wt, Symbol.hasInstance, {
  value: function (t) {
    return !!t && null != t.dataId && null != t.shape && null != t.dtype;
  }
});

var Ct,
    Et,
    Rt,
    It,
    kt,
    St = function (t) {
  function n(e, n, r, o) {
    var a = t.call(this, e.shape, e.dtype, e.dataId, o) || this;
    return a.trainable = n, a.name = r, a;
  }

  return e(n, t), n.prototype.assign = function (t) {
    if (t.dtype !== this.dtype) throw new Error("dtype of the new value (" + t.dtype + ") and previous value (" + this.dtype + ") must match");
    if (!S(t.shape, this.shape)) throw new Error("shape of the new value (" + t.shape + ") and previous value (" + this.shape + ") must match");
    yt().disposeTensor(this), this.dataId = t.dataId, yt().incRef(this, null);
  }, n.prototype.dispose = function () {
    yt().disposeVariable(this), this.isDisposedInternal = !0;
  }, n;
}(wt);

exports.Variable = St;
exports.Rank = Ct;
Object.defineProperty(St, Symbol.hasInstance, {
  value: function (t) {
    return t instanceof wt && null != t.assign && t.assign instanceof Function;
  }
}), function (t) {
  t.R0 = "R0", t.R1 = "R1", t.R2 = "R2", t.R3 = "R3", t.R4 = "R4", t.R5 = "R5", t.R6 = "R6";
}(Ct || (exports.Rank = Ct = {})), function (t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "int32", t.complex64 = "complex64";
}(Et || (Et = {})), function (t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "bool", t.complex64 = "complex64";
}(Rt || (Rt = {})), function (t) {
  t.float32 = "float32", t.int32 = "float32", t.bool = "float32", t.complex64 = "complex64";
}(It || (It = {})), function (t) {
  t.float32 = "complex64", t.int32 = "complex64", t.bool = "complex64", t.complex64 = "complex64";
}(kt || (kt = {}));
var At = {
  float32: It,
  int32: Et,
  bool: Rt,
  complex64: kt
};

function Tt(t, e) {
  if ("string" === t || "string" === e) {
    if ("string" === t && "string" === e) return "string";
    throw new Error("Can not upcast " + t + " with " + e);
  }

  return At[t][e];
}

function Dt(t) {
  return Tt(t, "int32");
}

function Nt(t, e) {
  if (t.dtype === e.dtype) return [t, e];
  var n = Tt(t.dtype, e.dtype);
  return [t.cast(n), e.cast(n)];
}

function Ft(t, e) {
  C(t.dtype === e.dtype, function () {
    return "The dtypes of the first(" + t.dtype + ") and second(" + e.dtype + ") input must match";
  });
}

function _t(t) {
  var e = [];
  return function t(e, n, r) {
    if (null == e) return;
    if (e instanceof wt) return void n.push(e);
    if (o = e, !Array.isArray(o) && "object" != typeof o) return;
    var o;
    var a = e;

    for (var i in a) {
      var s = a[i];
      r.has(s) || (r.add(s), t(s, n, r));
    }
  }(t, e, new Set()), e;
}

var Ot,
    Mt = Object.freeze({
  makeTypesMatch: Nt,
  assertTypesMatch: Ft,
  isTensorInList: function (t, e) {
    return e.some(function (e) {
      return e.id === t.id;
    });
  },
  getTensorsInContainer: _t
}),
    Bt = function () {
  function t() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = !1, this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null
    };
  }

  return t.prototype.dispose = function () {
    for (var t in this.registeredVariables) this.registeredVariables[t].dispose();
  }, t;
}(),
    Pt = function () {
  function t(t) {
    this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Bt();
  }

  return t.prototype.ready = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (null != this.pendingBackendInit) return [2, this.pendingBackendInit.then(function () {})];
            if (null != this.backendInstance) return [2];
            t = this.getSortedBackends(), e = 0, r.label = 1;

          case 1:
            return e < t.length ? (n = t[e], [4, this.initializeBackend(n).success]) : [3, 5];

          case 2:
            return r.sent() ? [4, this.setBackend(n)] : [3, 4];

          case 3:
            return r.sent(), [2];

          case 4:
            return e++, [3, 1];

          case 5:
            throw new Error("Could not initialize any backends, all backend initializations failed.");
        }
      });
    });
  }, Object.defineProperty(t.prototype, "backend", {
    get: function () {
      if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");

      if (null == this.backendInstance) {
        var t = this.initializeBackendsAndReturnBest(),
            e = t.name;
        if (t.asyncInit) throw new Error("The highest priority backend '" + e + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
        this.setBackend(e);
      }

      return this.backendInstance;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.backendNames = function () {
    return Object.keys(this.registryFactory);
  }, t.prototype.findBackend = function (t) {
    if (!(t in this.registry)) {
      if (!(t in this.registryFactory)) return null;
      if (this.initializeBackend(t).asyncInit) return null;
    }

    return this.registry[t];
  }, t.prototype.findBackendFactory = function (t) {
    return t in this.registryFactory ? this.registryFactory[t].factory : null;
  }, t.prototype.registerBackend = function (t, e, n) {
    return void 0 === n && (n = 1), t in this.registryFactory ? (console.warn(t + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[t] = {
      factory: e,
      priority: n
    }, !0);
  }, t.prototype.setBackend = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (null == this.registryFactory[t]) throw new Error("Backend name '" + t + "' not found in registry");
            return this.backendName = t, null != this.registry[t] ? [3, 4] : (this.backendInstance = null, e = this.initializeBackend(t), n = e.success, e.asyncInit ? [4, n] : [3, 2]);

          case 1:
            return o = r.sent(), [3, 3];

          case 2:
            o = n, r.label = 3;

          case 3:
            if (!o) return [2, !1];
            r.label = 4;

          case 4:
            return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new ut(this.backendInstance), [2, !0];
        }
      });
    });
  }, t.prototype.setupRegisteredKernels = function () {
    var t = this;
    f(this.backendName).forEach(function (e) {
      null != e.setupFunc && e.setupFunc(t.backendInstance);
    });
  }, t.prototype.disposeRegisteredKernels = function (t) {
    var e = this;
    f(t).forEach(function (n) {
      null != n.disposeFunc && n.disposeFunc(e.registry[t]);
    });
  }, t.prototype.initializeBackend = function (t) {
    var e = this,
        n = this.registryFactory[t];
    if (null == n) throw new Error("Cannot initialize backend " + t + ", no registration found.");

    try {
      var r = n.factory();

      if (Promise.resolve(r) === r) {
        var o = ++this.pendingBackendInitId,
            a = r.then(function (n) {
          return !(o < e.pendingBackendInitId) && (e.registry[t] = n, e.pendingBackendInit = null, !0);
        }).catch(function (n) {
          return !(o < e.pendingBackendInitId) && (e.pendingBackendInit = null, console.warn("Initialization of backend " + t + " failed"), console.warn(n.stack || n.message), !1);
        });
        return this.pendingBackendInit = a, {
          success: a,
          asyncInit: !0
        };
      }

      return this.registry[t] = r, {
        success: !0,
        asyncInit: !1
      };
    } catch (e) {
      return console.warn("Initialization of backend " + t + " failed"), console.warn(e.stack || e.message), {
        success: !1,
        asyncInit: !1
      };
    }
  }, t.prototype.removeBackend = function (t) {
    if (!(t in this.registryFactory)) throw new Error(t + " backend not found in registry");
    this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }, t.prototype.getSortedBackends = function () {
    var t = this;
    if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort(function (e, n) {
      return t.registryFactory[n].priority - t.registryFactory[e].priority;
    });
  }, t.prototype.initializeBackendsAndReturnBest = function () {
    for (var t = this.getSortedBackends(), e = 0; e < t.length; e++) {
      var n = t[e],
          r = this.initializeBackend(n),
          o = r.success,
          a = r.asyncInit;
      if (a || o) return {
        name: n,
        asyncInit: a
      };
    }

    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }, t.prototype.moveData = function (t, e) {
    var n = this.state.tensorInfo.get(e),
        r = n.backend,
        o = this.readSync(e);
    r.disposeData(e), n.backend = t, t.move(e, o, n.shape, n.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }, t.prototype.tidy = function (t, e) {
    var n,
        r = this,
        o = null;

    if (null == e) {
      if ("function" != typeof t) throw new Error("Please provide a function to tidy()");
      e = t;
    } else {
      if ("string" != typeof t && !(t instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if ("function" != typeof e) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      o = t;
    }

    return this.scopedRun(function () {
      return r.startScope(o);
    }, function () {
      return r.endScope(n);
    }, function () {
      return (n = e()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n;
    });
  }, t.prototype.scopedRun = function (t, e, n) {
    t();

    try {
      var r = n();
      return e(), r;
    } catch (t) {
      throw e(), t;
    }
  }, t.prototype.nextTensorId = function () {
    return t.nextTensorId++;
  }, t.prototype.nextVariableId = function () {
    return t.nextVariableId++;
  }, t.prototype.clone = function (t) {
    var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype),
        n = {
      x: t
    };
    return this.addTapeNode(this.state.activeScope.name, n, [e], function (t) {
      return {
        x: function () {
          return t.toFloat();
        }
      };
    }, [], {}), e;
  }, t.prototype.runKernel = function (t, e, n, r, o) {
    return this.runKernelFunc(null, e, null, t, n, r, o);
  }, t.prototype.shouldCheckForMemLeaks = function () {
    return this.ENV.getBool("IS_TEST");
  }, t.prototype.checkKernelForMemLeak = function (t, e, n) {
    var r = this.backend.numDataIds(),
        o = 0;
    n.forEach(function (t) {
      o += "complex64" === t.dtype ? 3 : 1;
    });
    var a = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
        i = r - e - o - a;
    if (i > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + i + " data ids) after running '" + t + "'");
  }, t.prototype.runKernelFunc = function (t, e, n, r, o, a, i) {
    var s,
        u = this,
        c = [],
        h = this.isTapeOn();
    null == r && (r = null != this.state.activeScope ? this.state.activeScope.name : "");
    var f,
        d = this.state.numBytes,
        p = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    var v,
        m = l(r, this.backendName);
    if (null != m) f = function () {
      var t = u.backend.numDataIds();
      v = m.kernelFunc({
        inputs: e,
        attrs: o,
        backend: u.backend
      });
      var n = Array.isArray(v) ? v : [v];
      u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, t, n);
      var s = n.map(function (t) {
        var e = t.dataId,
            n = t.shape,
            r = t.dtype;
        return u.makeTensorFromDataId(e, n, r);
      });

      if (h) {
        var l = u.getTensorsForGradient(r, e, s);

        if (null == l) {
          null == i && (i = []);
          var f = s.filter(function (t, e) {
            return i[e];
          });
          l = (a || []).slice().concat(f);
        }

        c = u.saveTensorsForBackwardMode(l);
      }

      return s;
    };else {
      var g = function (t) {
        h && (c = t.map(function (t) {
          return u.keep(u.clone(t));
        }));
      };

      f = function () {
        var e = u.backend.numDataIds();
        v = u.tidy(function () {
          return t(u.backend, g);
        });
        var n = Array.isArray(v) ? v : [v];
        return u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, e, n), n;
      };
    }
    return this.scopedRun(function () {
      return u.state.kernelDepth++;
    }, function () {
      return u.state.kernelDepth--;
    }, function () {
      s = u.ENV.getBool("DEBUG") ? u.profiler.profileKernel(r, e, function () {
        return f();
      }) : f();
    }), h && this.addTapeNode(r, e, s, n, c, o), this.state.profiling && this.state.activeProfile.kernels.push({
      name: r,
      bytesAdded: this.state.numBytes - d,
      totalBytesSnapshot: this.state.numBytes,
      tensorsAdded: this.state.numTensors - p,
      totalTensorsSnapshot: this.state.numTensors,
      inputShapes: Object.keys(e).map(function (t) {
        return e[t].shape;
      }),
      outputShapes: s.map(function (t) {
        return t.shape;
      })
    }), Array.isArray(v) ? s : s[0];
  }, t.prototype.saveTensorsForBackwardMode = function (t) {
    var e = this;
    return t.map(function (t) {
      return e.keep(e.clone(t));
    });
  }, t.prototype.getTensorsForGradient = function (t, e, n) {
    var r = h(t);

    if (null != r) {
      var o = r.inputsToSave || [],
          a = r.outputsToSave || [],
          i = o.map(function (t) {
        return e[t];
      }),
          s = n.filter(function (t, e) {
        return a[e];
      });
      return i.concat(s);
    }

    return null;
  }, t.prototype.makeTensor = function (t, e, n, r) {
    if (null == t) throw new Error("Values passed to engine.makeTensor() are null");
    n = n || "float32", r = r || this.backend;
    var o = t;
    "string" === n && H(t[0]) && (o = t.map(function (t) {
      return rt(t);
    }));
    var a = r.write(o, e, n),
        i = new wt(e, n, a, this.nextTensorId());

    if (this.incRef(i, r), "string" === n) {
      var s = this.state.tensorInfo.get(a),
          u = G(o);
      this.state.numBytes += u - s.bytes, s.bytes = u;
    }

    return i;
  }, t.prototype.makeTensorFromDataId = function (t, e, n, r) {
    var o = new wt(e, n = n || "float32", t, this.nextTensorId());
    return this.incRef(o, r), o;
  }, t.prototype.makeVariable = function (t, e, n, r) {
    void 0 === e && (e = !0), n = n || this.nextVariableId().toString(), null != r && r !== t.dtype && (t = t.asType(r));
    var o = new St(t, e, n, this.nextTensorId());
    if (null != this.state.registeredVariables[o.name]) throw new Error("Variable with name " + o.name + " was already registered");
    return this.state.registeredVariables[o.name] = o, this.incRef(o, this.backend), o;
  }, t.prototype.incRef = function (t, e) {
    var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0;

    if (this.state.numTensors++, "string" === t.dtype && this.state.numStringTensors++, 0 === n) {
      this.state.numDataBuffers++;
      var r = 0;
      "complex64" !== t.dtype && "string" !== t.dtype && (r = t.size * z(t.dtype)), this.state.tensorInfo.set(t.dataId, {
        backend: e || this.backend,
        dtype: t.dtype,
        shape: t.shape,
        bytes: r,
        refCount: 0
      }), this.state.numBytes += r;
    }

    this.state.tensorInfo.get(t.dataId).refCount++, t instanceof St || this.track(t);
  }, t.prototype.disposeTensor = function (t) {
    if (this.state.tensorInfo.has(t.dataId)) {
      this.state.numTensors--, "string" === t.dtype && this.state.numStringTensors--;
      var e = this.state.tensorInfo.get(t.dataId);
      e.refCount <= 1 ? ("complex64" !== t.dtype && (this.state.numBytes -= e.bytes), this.state.numDataBuffers--, e.backend.disposeData(t.dataId), this.state.tensorInfo.delete(t.dataId)) : this.state.tensorInfo.get(t.dataId).refCount--;
    }
  }, t.prototype.disposeVariables = function () {
    for (var t in this.state.registeredVariables) {
      var e = this.state.registeredVariables[t];
      this.disposeVariable(e);
    }
  }, t.prototype.disposeVariable = function (t) {
    this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name];
  }, t.prototype.memory = function () {
    var t = this.backend.memory();
    return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, null == t.reasons && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t;
  }, t.prototype.profile = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n;
      return r(this, function (r) {
        return this.state.profiling = !0, e = this.state.numBytes, n = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function (t) {
          return t.totalBytesSnapshot;
        })), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - n, [2, this.state.activeProfile];
      });
    });
  }, t.prototype.isTapeOn = function () {
    return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
  }, t.prototype.addTapeNode = function (t, e, n, r, o, a) {
    var i = this,
        s = {
      id: this.state.nextTapeNodeId++,
      kernelName: t,
      inputs: e,
      outputs: n,
      saved: o
    },
        u = h(t);
    null != u && (r = u.gradFunc), null != r && (s.gradient = function (t) {
      return t = t.map(function (t, e) {
        if (null == t) {
          var r = n[e],
              o = tt(r.size, r.dtype);
          return i.makeTensor(o, r.shape, r.dtype);
        }

        return t;
      }), r(t.length > 1 ? t : t[0], o, a);
    }), this.state.activeTape.push(s);
  }, t.prototype.keep = function (t) {
    return t.kept = !0, t;
  }, t.prototype.startTape = function () {
    0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
  }, t.prototype.endTape = function () {
    this.state.gradientDepth--;
  }, t.prototype.startScope = function (t) {
    var e = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e;
  }, t.prototype.endScope = function (t) {
    for (var e = this, n = _t(t), r = new Set(n.map(function (t) {
      return t.id;
    })), o = 0; o < this.state.activeScope.track.length; o++) {
      var a = this.state.activeScope.track[o];
      a.kept || r.has(a.id) || a.dispose();
    }

    var i = this.state.scopeStack.pop();
    this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach(function (t) {
      t.kept || t.scopeId !== i.id || e.track(t);
    });
  }, t.prototype.gradients = function (t, e, n, r) {
    var o = this;
    if (void 0 === r && (r = !1), C(e.length > 0, function () {
      return "gradients() received an empty list of xs.";
    }), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n.dtype + "'");
    var a = this.scopedRun(function () {
      return o.startTape();
    }, function () {
      return o.endTape();
    }, function () {
      return o.tidy("forward", t);
    });
    C(a instanceof wt, function () {
      return "The result y returned by f() must be a tensor.";
    });

    var i = function (t, e, n) {
      for (var r = {}, o = {}, a = 0; a < e.length; a++) r[e[a].id] = !0;

      for (a = 0; a < t.length; a++) {
        var i = (p = t[a]).inputs;

        for (var s in i) {
          for (var u = i[s], c = !1, l = 0; l < e.length; l++) if (r[u.id]) {
            p.outputs.forEach(function (t) {
              return r[t.id] = !0;
            }), c = !0, o[p.id] = !0;
            break;
          }

          if (c) break;
        }
      }

      var h = {};
      h[n.id] = !0;
      var f = {};

      for (a = t.length - 1; a >= 0; a--) for (i = (p = t[a]).inputs, l = 0; l < p.outputs.length; l++) if (h[p.outputs[l].id]) {
        for (var s in i) h[i[s].id] = !0, f[p.id] = !0;

        break;
      }

      var d = [];

      for (a = 0; a < t.length; a++) {
        var p;

        if (o[(p = t[a]).id] && f[p.id]) {
          var v = {};

          for (var s in p.inputs) {
            var m = p.inputs[s];
            r[m.id] && (v[s] = m);
          }

          var g = Object.assign({}, p);
          g.inputs = v, g.outputs = p.outputs, d.push(g);
        }
      }

      return d;
    }(this.state.activeTape, e, a);

    if (!r && 0 === i.length && e.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", function () {
      var t,
          r,
          s = {};
      s[a.id] = null == n ? (t = a.shape, r = Z(k(t), "float32"), Lt.makeTensor(r, t, "float32")) : n, function (t, e, n) {
        for (var r = function (r) {
          var o = e[r],
              a = [];
          if (o.outputs.forEach(function (e) {
            var n = t[e.id];
            null != n ? a.push(n) : a.push(null);
          }), null == o.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + o.kernelName + ".");

          var i = o.gradient(a),
              s = function (e) {
            if (!(e in i)) throw new Error("Cannot backprop through input " + e + ". Available gradients found: " + Object.keys(i) + ".");
            var r = n(function () {
              return i[e]();
            });
            if ("float32" !== r.dtype) throw new Error("Error in gradient for op " + o.kernelName + ". The gradient of input " + e + " must have 'float32' dtype, but has '" + r.dtype + "'");
            var a = o.inputs[e];
            if (!S(r.shape, a.shape)) throw new Error("Error in gradient for op " + o.kernelName + ". The gradient of input '" + e + "' has shape '" + r.shape + "', which does not match the shape of the input '" + a.shape + "'");
            if (null == t[a.id]) t[a.id] = r;else {
              var s = t[a.id];
              t[a.id] = s.add(r), s.dispose();
            }
          };

          for (var u in o.inputs) s(u);
        }, o = e.length - 1; o >= 0; o--) r(o);
      }(s, i, function (t) {
        return o.tidy(t);
      });
      var u = e.map(function (t) {
        return s[t.id];
      });
      return 0 === o.state.gradientDepth && (o.state.activeTape.forEach(function (t) {
        for (var e = 0, n = t.saved; e < n.length; e++) {
          n[e].dispose();
        }
      }), o.state.activeTape = null), {
        value: a,
        grads: u
      };
    });
  }, t.prototype.customGrad = function (t) {
    var e = this;
    return C(X(t), function () {
      return "The f passed in customGrad(f) must be a function.";
    }), function () {
      for (var n, r = [], o = 0; o < arguments.length; o++) r[o] = arguments[o];

      C(r.every(function (t) {
        return t instanceof wt;
      }), function () {
        return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
      });
      var a = {};
      return r.forEach(function (t, e) {
        a[e] = t;
      }), e.runKernelFunc(function (e, o) {
        return C((n = t.apply(void 0, r.concat([o]))).value instanceof wt, function () {
          return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
        }), C(X(n.gradFunc), function () {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
        }), n.value;
      }, a, function (t, e) {
        var o = n.gradFunc(t, e),
            a = Array.isArray(o) ? o : [o];
        C(a.length === r.length, function () {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
        }), C(a.every(function (t) {
          return t instanceof wt;
        }), function () {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
        });
        var i = {};
        return a.forEach(function (t, e) {
          i[e] = function () {
            return t;
          };
        }), i;
      });
    };
  }, t.prototype.readSync = function (t) {
    return this.state.tensorInfo.get(t).backend.readSync(t);
  }, t.prototype.read = function (t) {
    return this.state.tensorInfo.get(t).backend.read(t);
  }, t.prototype.time = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return e = et(), [4, this.backend.time(t)];

          case 1:
            return (n = r.sent()).wallMs = et() - e, [2, n];
        }
      });
    });
  }, t.prototype.track = function (t) {
    return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t;
  }, Object.defineProperty(t.prototype, "registeredVariables", {
    get: function () {
      return this.state.registeredVariables;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.reset = function () {
    for (var t in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Bt(), this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];

    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }, t.nextTensorId = 0, t.nextVariableId = 0, t;
}();

exports.tensor_util = Mt;

var Lt = function () {
  var t = function () {
    if (null == Ot) {
      var t = void 0;
      if ("undefined" != typeof window) t = window;else if ("undefined" != typeof global) t = global;else if ("undefined" != typeof process) t = process;else {
        if ("undefined" == typeof self) throw new Error("Could not find a global object");
        t = self;
      }
      Ot = t;
    }

    return Ot;
  }();

  if (null == t._tfengine) {
    var e = new o(t);
    t._tfengine = new Pt(e);
  }

  return function (t) {
    exports.ENV = s = t;
  }(t._tfengine.ENV), yt = function () {
    return t._tfengine;
  }, t._tfengine;
}();

function Wt() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}

var Ut = i();
Ut.registerFlag("DEBUG", function () {
  return !1;
}, function (t) {
  t && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Ut.registerFlag("IS_BROWSER", function () {
  return Wt();
}), Ut.registerFlag("IS_NODE", function () {
  return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
}), Ut.registerFlag("IS_CHROME", function () {
  return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), Ut.registerFlag("PROD", function () {
  return !1;
}), Ut.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function () {
  return Ut.getBool("DEBUG");
}), Ut.registerFlag("DEPRECATION_WARNINGS_ENABLED", function () {
  return !0;
}), Ut.registerFlag("IS_TEST", function () {
  return !1;
});
var Vt,
    zt,
    Gt,
    Ht = {},
    qt = {
  alpha: !1,
  antialias: !1,
  premultipliedAlpha: !1,
  preserveDrawingBuffer: !1,
  depth: !1,
  stencil: !1,
  failIfMajorPerformanceCaveat: !0
};

function Kt(t, e) {
  Ht[t] = e;
}

function jt(t) {
  t in Ht || (Ht[t] = function (t) {
    if (1 !== t && 2 !== t) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");

    var e = function (t) {
      if ("undefined" != typeof OffscreenCanvas && 2 === t) return new OffscreenCanvas(300, 150);
      if ("undefined" != typeof document) return document.createElement("canvas");
      throw new Error("Cannot create a canvas in this context");
    }(t);

    if (e.addEventListener("webglcontextlost", function (e) {
      e.preventDefault(), delete Ht[t];
    }, !1), 1 === t) return e.getContext("webgl", qt) || e.getContext("experimental-webgl", qt);
    return e.getContext("webgl2", qt);
  }(t));
  var e = Ht[t];
  return e.isContextLost() ? (delete Ht[t], jt(t)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), Ht[t]);
}

function Xt(t, e) {
  return [e, t];
}

function Yt(t) {
  var e = k(t);
  return D(Math.ceil(e / 4));
}

function $t(t, e) {
  return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(t / 2))];
}

function Qt(t, e) {
  var n,
      r,
      o,
      a,
      s,
      u,
      c,
      l,
      h,
      f = t;
  return 2 === i().getNumber("WEBGL_VERSION") ? (n = f.R32F, r = f.R16F, o = f.RGBA16F, a = f.RGBA32F, s = f.RED, u = 4, c = 1, l = f.HALF_FLOAT, h = f.FLOAT) : (n = t.RGBA, r = t.RGBA, o = t.RGBA, a = f.RGBA, s = t.RGBA, u = 4, c = 4, l = null != e ? e.HALF_FLOAT_OES : null, h = t.FLOAT), {
    internalFormatFloat: n,
    internalFormatHalfFloat: r,
    internalFormatPackedHalfFloat: o,
    internalFormatPackedFloat: a,
    textureFormatFloat: s,
    downloadTextureFormat: t.RGBA,
    downloadUnpackNumChannels: u,
    defaultNumChannels: c,
    textureTypeHalfFloat: l,
    textureTypeFloat: h
  };
}

function Jt(t, e, n) {
  var r = n();
  return e && function (t) {
    var e = t.getError();
    if (e !== t.NO_ERROR) throw new Error("WebGL Error: " + ne(t, e));
  }(t), r;
}

!function (t) {
  t[t.DENSE = 0] = "DENSE", t[t.SHARED_BATCH = 1] = "SHARED_BATCH";
}(Vt || (Vt = {})), function (t) {
  t[t.RENDER = 0] = "RENDER", t[t.UPLOAD = 1] = "UPLOAD", t[t.PIXELS = 2] = "PIXELS", t[t.DOWNLOAD = 3] = "DOWNLOAD";
}(zt || (zt = {})), function (t) {
  t[t.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t[t.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t[t.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t[t.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(Gt || (Gt = {}));
var Zt = 5.96e-8,
    te = 65504;

function ee(t) {
  return !!(i().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t || Zt < Math.abs(t) && Math.abs(t) < te);
}

function ne(t, e) {
  switch (e) {
    case t.NO_ERROR:
      return "NO_ERROR";

    case t.INVALID_ENUM:
      return "INVALID_ENUM";

    case t.INVALID_VALUE:
      return "INVALID_VALUE";

    case t.INVALID_OPERATION:
      return "INVALID_OPERATION";

    case t.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";

    case t.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";

    case t.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";

    default:
      return "Unknown error code " + e;
  }
}

function re(t, e, n) {
  return ke(t, e, function () {
    return t.getExtension(n);
  }, 'Extension "' + n + '" not supported on this browser.');
}

function oe(t, e, n) {
  var r = ke(t, e, function () {
    return t.createShader(t.VERTEX_SHADER);
  }, "Unable to create vertex WebGLShader.");
  if (Jt(t, e, function () {
    return t.shaderSource(r, n);
  }), Jt(t, e, function () {
    return t.compileShader(r);
  }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(r)), new Error("Failed to compile vertex shader.");
  return r;
}

function ae(t, e, n) {
  var r = ke(t, e, function () {
    return t.createShader(t.FRAGMENT_SHADER);
  }, "Unable to create fragment WebGLShader.");
  if (Jt(t, e, function () {
    return t.shaderSource(r, n);
  }), Jt(t, e, function () {
    return t.compileShader(r);
  }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw function (t, e) {
    var n = ue.exec(e);
    if (null == n) return console.log("Couldn't parse line number in error: " + e), void console.log(t);

    for (var r = +n[1], o = t.split("\n"), a = o.length.toString().length + 2, i = o.map(function (t, e) {
      return N((e + 1).toString(), a) + t;
    }), s = 0, u = 0; u < i.length; u++) s = Math.max(i[u].length, s);

    var c = i.slice(0, r - 1),
        l = i.slice(r - 1, r),
        h = i.slice(r);
    console.log(c.join("\n")), console.log(e.split("\n")[0]), console.log("%c " + N(l[0], s), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h.join("\n"));
  }(n, t.getShaderInfoLog(r)), new Error("Failed to compile fragment shader.");
  return r;
}

var ie,
    se,
    ue = /ERROR: [0-9]+:([0-9]+):/g;

function ce(t, e) {
  return ke(t, e, function () {
    return t.createProgram();
  }, "Unable to create WebGLProgram.");
}

function le(t, e, n) {
  if (Jt(t, e, function () {
    return t.linkProgram(n);
  }), !1 === t.getProgramParameter(n, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Failed to link vertex and fragment shaders.");
}

function he(t, e, n) {
  if (Jt(t, e, function () {
    return t.validateProgram(n);
  }), !1 === t.getProgramParameter(n, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Shader program validation failed.");
}

function fe(t, e, n) {
  var r = ke(t, e, function () {
    return t.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Jt(t, e, function () {
    return t.bindBuffer(t.ARRAY_BUFFER, r);
  }), Jt(t, e, function () {
    return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW);
  }), r;
}

function de(t, e, n) {
  var r = ke(t, e, function () {
    return t.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Jt(t, e, function () {
    return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r);
  }), Jt(t, e, function () {
    return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW);
  }), r;
}

function pe(t, e) {
  return ke(t, e, function () {
    return t.createTexture();
  }, "Unable to create WebGLTexture.");
}

function ve(t, e) {
  var n = i().getNumber("WEBGL_MAX_TEXTURE_SIZE");

  if (t <= 0 || e <= 0) {
    var r = "[" + t + "x" + e + "]";
    throw new Error("Requested texture size " + r + " is invalid.");
  }

  if (t > n || e > n) {
    r = "[" + t + "x" + e + "]";
    throw new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU " + ("[" + n + "x" + n + "]") + ".");
  }
}

function me(t, e) {
  return ke(t, e, function () {
    return t.createFramebuffer();
  }, "Unable to create WebGLFramebuffer.");
}

function ge(t, e, n, r, o, a, i, s) {
  var u = t.getAttribLocation(n, r);
  return -1 !== u && (Jt(t, e, function () {
    return t.bindBuffer(t.ARRAY_BUFFER, o);
  }), Jt(t, e, function () {
    return t.vertexAttribPointer(u, a, t.FLOAT, !1, i, s);
  }), Jt(t, e, function () {
    return t.enableVertexAttribArray(u);
  }), !0);
}

function ye(t, e, n, r) {
  Se(t, r), Jt(t, e, function () {
    return t.activeTexture(t.TEXTURE0 + r);
  }), Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, n);
  });
}

function xe(t, e, n, r) {
  return ke(t, e, function () {
    return t.getUniformLocation(n, r);
  }, 'uniform "' + r + '" not present in program.');
}

function be(t, e, n) {
  return t.getUniformLocation(e, n);
}

function we(t, e, n, r, o, a) {
  Jt(t, e, function () {
    return ye(t, e, r, a);
  }), Jt(t, e, function () {
    return t.uniform1i(o, a);
  });
}

function Ce(t, e, n, r) {
  Jt(t, e, function () {
    return t.bindFramebuffer(t.FRAMEBUFFER, r);
  }), Jt(t, e, function () {
    return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
  });
}

function Ee(t, e, n) {
  Jt(t, e, function () {
    return t.bindFramebuffer(t.FRAMEBUFFER, n);
  }), Jt(t, e, function () {
    return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0);
  });
}

function Re(t) {
  var e = t.checkFramebufferStatus(t.FRAMEBUFFER);
  if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + Ie(t, e));
}

function Ie(t, e) {
  switch (e) {
    case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

    case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

    case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

    case t.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";

    default:
      return "unknown error " + e;
  }
}

function ke(t, e, n, r) {
  var o = Jt(t, e, function () {
    return n();
  });
  if (null == o) throw new Error(r);
  return o;
}

function Se(t, e) {
  var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
      r = e + t.TEXTURE0;
  if (r < t.TEXTURE0 || r > n) throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + n + "]") + ".");
}

function Ae(t, e) {
  return void 0 === e && (e = 2), k(t.slice(0, t.length - e));
}

function Te(t) {
  if (0 === t.length) throw Error("Cannot get rows and columns of an empty shape array.");
  return [t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]];
}

function De(t) {
  var e = [1, 1, 1];
  return 0 === t.length || 1 === t.length && 1 === t[0] || (e = [Ae(t)].concat(Te(t))), e;
}

function Ne(t, e) {
  var n;
  void 0 === e && (e = !1);
  var r = i().getNumber("WEBGL_MAX_TEXTURE_SIZE");

  if (e && (r *= 2, 1 === (t = t.map(function (e, n) {
    return n >= t.length - 2 ? b(t[n]) : t[n];
  })).length && (t = [2, t[0]])), 2 !== t.length) {
    var o = M(t);
    t = o.newShape;
  }

  var a = k(t);
  if (t.length <= 1 && a <= r) return [1, a];
  if (2 === t.length && t[0] <= r && t[1] <= r) return t;
  if (3 === t.length && t[0] * t[1] <= r && t[2] <= r) return [t[0] * t[1], t[2]];
  if (3 === t.length && t[0] <= r && t[1] * t[2] <= r) return [t[0], t[1] * t[2]];
  if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r) return [t[0] * t[1] * t[2], t[3]];
  if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r) return [t[0], t[1] * t[2] * t[3]];

  if (e) {
    var s = Ae(t),
        u = 2,
        c = 2;
    return t.length && (u = (n = Te(t))[0], c = n[1]), D(a = s * (u / 2) * (c / 2)).map(function (t) {
      return 2 * t;
    });
  }

  return D(a);
}

function Fe(t) {
  return t % 2 == 0;
}

function _e(t, e) {
  if (S(t = t.slice(-2), e = e.slice(-2))) return !0;
  if (!t.length || !e.length) return !0;
  if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;

  if (t.length !== e.length) {
    var n = t.slice(-1)[0],
        r = e.slice(-1)[0];
    if (n === r) return !0;
    if (Fe(n) && Fe(r) && (1 === t[0] || 1 === e[0])) return !0;
  }

  return t[1] === e[1] && Fe(t[0]) && Fe(e[0]);
}

function Oe(t) {
  if (null == ie) {
    var e = jt(t);
    ie = e.getParameter(e.MAX_TEXTURE_SIZE);
  }

  return ie;
}

function Me(t) {
  if (null == se) {
    var e = jt(t);
    se = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
  }

  return Math.min(16, se);
}

function Be(t) {
  if (0 === t) return 0;
  var e = jt(t);
  return Pe(e, "EXT_disjoint_timer_query_webgl2") && 2 === t ? 2 : Pe(e, "EXT_disjoint_timer_query") ? 1 : 0;
}

function Pe(t, e) {
  return null != t.getExtension(e);
}

function Le(t) {
  try {
    if (null != jt(t)) return !0;
  } catch (t) {
    return !1;
  }

  return !1;
}

function We(t) {
  if (0 === t) return !1;
  var e = jt(t);

  if (1 === t) {
    if (!Pe(e, "OES_texture_float")) return !1;
  } else if (!Pe(e, "EXT_color_buffer_float")) return !1;

  return Ve(e);
}

function Ue(t) {
  if (0 === t) return !1;
  var e = jt(t);

  if (1 !== t) {
    if (Pe(e, "EXT_color_buffer_float")) return Ve(e);

    if (Pe(e, "EXT_color_buffer_half_float")) {
      var n = e.getExtension("EXT_color_buffer_half_float");
      return function (t, e) {
        var n = Qt(t, e),
            r = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, r);
        t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
        var o = t.createFramebuffer();
        t.bindFramebuffer(t.FRAMEBUFFER, o), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);
        var a = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
        return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(o), a;
      }(e, n);
    }

    return !1;
  }

  return !!Pe(e, "OES_texture_float") && !!Pe(e, "WEBGL_color_buffer_float") && Ve(e);
}

function Ve(t) {
  var e = Qt(t),
      n = t.createTexture();
  t.bindTexture(t.TEXTURE_2D, n);
  t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);
  var r = t.createFramebuffer();
  t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
  var o = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
  return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), o;
}

function ze(t) {
  return 2 === t && null != jt(t).fenceSync;
}

var Ge = Object.freeze({
  callAndCheck: Jt,
  canBeRepresented: ee,
  getWebGLErrorMessage: ne,
  getExtensionOrThrow: re,
  createVertexShader: oe,
  createFragmentShader: ae,
  createProgram: ce,
  linkProgram: le,
  validateProgram: he,
  createStaticVertexBuffer: fe,
  createStaticIndexBuffer: de,
  getNumChannels: function () {
    return 2 === i().getNumber("WEBGL_VERSION") ? 1 : 4;
  },
  createTexture: pe,
  validateTextureSize: ve,
  createFramebuffer: me,
  bindVertexBufferToProgramAttribute: ge,
  bindTextureUnit: ye,
  unbindTextureUnit: function (t, e, n) {
    Se(t, n), Jt(t, e, function () {
      return t.activeTexture(t.TEXTURE0 + n);
    }), Jt(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, null);
    });
  },
  getProgramUniformLocationOrThrow: xe,
  getProgramUniformLocation: be,
  bindTextureToProgramUniformSampler: we,
  bindCanvasToFramebuffer: function (t, e) {
    Jt(t, e, function () {
      return t.bindFramebuffer(t.FRAMEBUFFER, null);
    }), Jt(t, e, function () {
      return t.viewport(0, 0, t.canvas.width, t.canvas.height);
    }), Jt(t, e, function () {
      return t.scissor(0, 0, t.canvas.width, t.canvas.height);
    });
  },
  bindColorTextureToFramebuffer: Ce,
  unbindColorTextureFromFramebuffer: Ee,
  validateFramebuffer: Re,
  getFramebufferErrorMessage: Ie,
  getBatchDim: Ae,
  getRowsCols: Te,
  getShapeAs3D: De,
  getTextureShapeFromLogicalShape: Ne,
  isReshapeFree: _e,
  getWebGLMaxTextureSize: Oe,
  resetMaxTextureSize: function () {
    ie = null;
  },
  resetMaxTexturesInShader: function () {
    se = null;
  },
  getMaxTexturesInShader: Me,
  getWebGLDisjointQueryTimerVersion: Be,
  hasExtension: Pe,
  isWebGLVersionEnabled: Le,
  isCapableOfRenderingToFloatTexture: We,
  isDownloadFloatTextureEnabled: Ue,
  isWebGLFenceEnabled: ze
}),
    He = i();

function qe() {
  i().set("PROD", !0);
}

function Ke() {
  i().set("DEBUG", !0);
}

function je() {
  i().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}

function Xe(t) {
  i().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}

function Ye() {
  Lt.disposeVariables();
}

function $e() {
  return Lt;
}

function Qe() {
  return Lt.memory();
}

function Je(t) {
  return Lt.profile(t);
}

function Ze(t, e) {
  return Lt.tidy(t, e);
}

function tn(t) {
  _t(t).forEach(function (t) {
    return t.dispose();
  });
}

function en(t) {
  return Lt.keep(t);
}

function nn(t) {
  return Lt.time(t);
}

function rn(t) {
  return Lt.setBackend(t);
}

function on() {
  return Lt.ready();
}

function an() {
  return Lt.backendName;
}

function sn(t) {
  Lt.removeBackend(t);
}

function un(t) {
  return Lt.findBackend(t);
}

function cn(t) {
  return Lt.findBackendFactory(t);
}

function ln(t, e, n) {
  return void 0 === n && (n = 1), Lt.registerBackend(t, e, n);
}

function hn() {
  return Lt.backend;
}

function fn(t, e) {
  i().setPlatform(t, e);
}

function dn() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];

  i().getBool("IS_TEST") || console.warn.apply(console, t);
}

function pn(t, e) {
  var n = t;
  if (V(t)) return "string" === e ? [] : [t.length];
  if (!Array.isArray(t)) return [];

  for (var r = []; Array.isArray(n) || V(n) && "string" !== e;) r.push(n.length), n = n[0];

  return Array.isArray(t) && i().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t(e, n, r) {
    if (r = r || [], !Array.isArray(e) && !V(e)) return void C(0 === n.length, function () {
      return "Element arr[" + r.join("][") + "] is a primitive, but should be an array/TypedArray of " + n[0] + " elements";
    });
    C(n.length > 0, function () {
      return "Element arr[" + r.join("][") + "] should be a primitive, but is an array of " + e.length + " elements";
    }), C(e.length === n[0], function () {
      return "Element arr[" + r.join("][") + "] should have " + n[0] + " elements, but has " + e.length + " elements";
    });

    for (var o = n.slice(1), a = 0; a < e.length; ++a) t(e[a], o, r.concat(a));
  }(t, r, []), r;
}

function vn(t, e, n, r) {
  if (null != t && ("numeric" !== t && t !== e || "numeric" === t && "string" === e)) throw new Error("Argument '" + n + "' passed to '" + r + "' must be " + t + " tensor, but got " + e + " tensor");
}

function mn(t, e, n, r) {
  if (void 0 === r && (r = "numeric"), t instanceof wt) return vn(r, t.dtype, e, n), t;
  var o = j(t);

  if ("string" !== o && ["bool", "int32", "float32"].indexOf(r) >= 0 && (o = r), vn(r, o, e, n), null == t || !V(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) {
    var a = null == t ? "null" : t.constructor.name;
    throw new Error("Argument '" + e + "' passed to '" + n + "' must be a Tensor or TensorLike, but got '" + a + "'");
  }

  var s = pn(t, o);
  V(t) || Array.isArray(t) || (t = [t]);
  var u = "string" !== o ? Q(t, o, i().getBool("DEBUG")) : I(t, [], !0);
  return Lt.makeTensor(u, s, o);
}

function gn(t, e, n, r) {
  if (void 0 === r && (r = "numeric"), !Array.isArray(t)) throw new Error("Argument " + e + " passed to " + n + " must be a `Tensor[]` or `TensorLike[]`");
  return t.map(function (t, r) {
    return mn(t, e + "[" + r + "]", n);
  }, r);
}

function yn(t, e) {
  for (var n = 0; n < t.length; ++n) if (t[t.length - n - 1] !== e - 1 - n) return !1;

  return !0;
}

function xn(t, e, n) {
  for (var r = t.length + e.length, o = [], a = 0, i = 0, s = 0; s < r; s++) -1 === n.indexOf(s) ? o.push(t[a++]) : o.push(e[i++]);

  return o;
}

function bn(t, e) {
  for (var n = [], r = t.length, o = 0; o < r; o++) -1 === e.indexOf(o) && n.push(t[o]);

  return [n, e.map(function (e) {
    return t[e];
  })];
}

function wn(t, e) {
  return xn(t, e.map(function (t) {
    return 1;
  }), e);
}

function Cn(t, e, n) {
  C(yn(e, n), function () {
    return t + " supports only inner-most axes for now. Got axes " + e + " and rank-" + n + " input.";
  });
}

function En(t, e) {
  if (yn(t, e)) return null;

  for (var n = [], r = 0; r < e; ++r) -1 === t.indexOf(r) && n.push(r);

  return t.forEach(function (t) {
    return n.push(t);
  }), n;
}

function Rn(t) {
  return t.map(function (t, e) {
    return [e, t];
  }).sort(function (t, e) {
    return t[1] - e[1];
  }).map(function (t) {
    return t[0];
  });
}

function In(t, e) {
  for (var n = [], r = e - t; r < e; ++r) n.push(r);

  return n;
}

function kn(t, e) {
  var n = t[0].length;
  t.forEach(function (t, e) {
    C(t.length === n, function () {
      return "Error in concat" + n + "D: rank of tensors[" + e + "] must be the same as the rank of the rest (" + n + ")";
    });
  }), C(e >= 0 && e < n, function () {
    return "Error in concat" + n + "D: axis must be between 0 and " + (n - 1) + ".";
  });
  var r = t[0];
  t.forEach(function (t, o) {
    for (var a = 0; a < n; a++) C(a === e || t[a] === r[a], function () {
      return "Error in concat" + n + "D: Shape of tensors[" + o + "] (" + t + ") does not match the shape of the rest (" + r + ") along the non-concatenated axis " + o + ".";
    });
  });
}

function Sn(t, e) {
  for (var n = t[0].slice(), r = 1; r < t.length; r++) n[e] += t[r][e];

  return n;
}

function An(t) {
  var e = Object.keys(t);
  if (1 !== e.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e.length + " keys.");
  var n = e[0],
      r = t[n];
  n.endsWith("_") && (n = n.substring(0, n.length - 1));

  var o = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];

    Lt.startScope(n);

    try {
      var o = r.apply(void 0, t);
      return o instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Lt.endScope(o), o;
    } catch (t) {
      throw Lt.endScope(null), t;
    }
  };

  return Object.defineProperty(o, "name", {
    value: n,
    configurable: !0
  }), o;
}

He.registerFlag("HAS_WEBGL", function () {
  return He.getNumber("WEBGL_VERSION") > 0;
}), He.registerFlag("WEBGL_VERSION", function () {
  return Le(2) ? 2 : Le(1) ? 1 : 0;
}), He.registerFlag("WEBGL_BUFFER_SUPPORTED", function () {
  return 2 === He.get("WEBGL_VERSION");
}), He.registerFlag("WEBGL_CPU_FORWARD", function () {
  return !0;
}), He.registerFlag("WEBGL_FORCE_F16_TEXTURES", function () {
  return !1;
}), He.registerFlag("WEBGL_PACK", function () {
  return He.getBool("HAS_WEBGL");
}), He.registerFlag("WEBGL_PACK_NORMALIZATION", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_CLIP", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_DEPTHWISECONV", function () {
  return !1;
}), He.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_REDUCE", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_LAZILY_UNPACK", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_CONV_IM2COL", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function () {
  return Oe(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function () {
  return Me(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function () {
  var t = He.getNumber("WEBGL_VERSION");
  return 0 === t ? 0 : Be(t);
}), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function () {
  return He.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))));
  var t;
}), He.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function () {
  return We(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function () {
  return !He.getBool("WEBGL_FORCE_F16_TEXTURES") && He.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), He.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function () {
  return Ue(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_FENCE_API_ENABLED", function () {
  return ze(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function () {
  return He.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), bt = Xe;
var Tn = An({
  complex_: function (t, e) {
    var n = mn(t, "real", "complex"),
        r = mn(e, "imag", "complex");
    return E(n.shape, r.shape, "real and imag shapes, " + n.shape + " and " + r.shape + ", must match in call to tf.complex()."), Lt.runKernelFunc(function (t) {
      return t.complex(n, r);
    }, {
      $real: n,
      $imag: r
    });
  }
}),
    Dn = An({
  real_: function (t) {
    var e = mn(t, "input", "real");
    return Lt.runKernelFunc(function (t) {
      return t.real(e);
    }, {
      $input: e
    });
  }
}),
    Nn = An({
  imag_: function (t) {
    var e = mn(t, "input", "imag");
    return Lt.runKernelFunc(function (t) {
      return t.imag(e);
    }, {
      $input: e
    });
  }
});
exports.imag = Nn;
exports.real = Dn;
exports.complex = Tn;

function Fn(t, e, n) {
  return _n(t, e, pn(t, n), n);
}

function _n(t, e, n, r) {
  if (null == r && (r = j(t)), "complex64" === r) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!V(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");

  if (null != e) {
    nt(e);
    var o = k(e),
        a = k(n);
    C(o === a, function () {
      return "Based on the provided shape, [" + e + "], the tensor should have " + o + " values but has " + a;
    });

    for (var s = 0; s < n.length; ++s) {
      var u = n[s],
          c = s !== n.length - 1 || u !== k(e.slice(s));
      C(n[s] === e[s] || !c, function () {
        return "Error creating a new Tensor. Inferred shape (" + n + ") does not match the provided shape (" + e + "). ";
      });
    }
  }

  return V(t) || Array.isArray(t) || (t = [t]), e = e || n, t = "string" !== r ? Q(t, r, i().getBool("DEBUG")) : I(t, [], !0), Lt.makeTensor(t, e, r);
}

function On(t, e) {
  if ((V(t) && "string" !== e || Array.isArray(t)) && "complex64" !== e) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === e && V(t) && !(t instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return _n(t, [], [], e);
}

function Mn(t, e) {
  R(t);
  var n = pn(t, e);
  if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return _n(t, null, n, e);
}

function Bn(t, e, n) {
  if (R(t), null != e && 2 !== e.length) throw new Error("tensor2d() requires shape to have two numbers");
  var r = pn(t, n);
  if (2 !== r.length && 1 !== r.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return _n(t, e, r, n);
}

function Pn(t, e, n) {
  if (R(t), null != e && 3 !== e.length) throw new Error("tensor3d() requires shape to have three numbers");
  var r = pn(t, n);
  if (3 !== r.length && 1 !== r.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return _n(t, e, r, n);
}

function Ln(t, e, n) {
  if (R(t), null != e && 4 !== e.length) throw new Error("tensor4d() requires shape to have four numbers");
  var r = pn(t, n);
  if (4 !== r.length && 1 !== r.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return _n(t, e, r, n);
}

function Wn(t, e, n) {
  if (R(t), null != e && 5 !== e.length) throw new Error("tensor5d() requires shape to have five numbers");
  var r = pn(t, n);
  if (5 !== r.length && 1 !== r.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return _n(t, e, r, n);
}

function Un(t, e, n) {
  if (R(t), null != e && 6 !== e.length) throw new Error("tensor6d() requires shape to have six numbers");
  var r = pn(t, n);
  if (6 !== r.length && 1 !== r.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return _n(t, e = e || r, r, n);
}

function Vn(t, e, n, r) {
  return void 0 === e && (e = !0), Lt.makeVariable(t, e, n, r);
}

function zn(t, e) {
  if (void 0 === e && (e = "float32"), "complex64" === e) {
    var n = zn(t, "float32"),
        r = Gn(t, "float32");
    return Tn(n, r);
  }

  var o = Z(k(t), e);
  return Lt.makeTensor(o, t, e);
}

function Gn(t, e) {
  if (void 0 === e && (e = "float32"), "complex64" === e) {
    var n = Gn(t, "float32"),
        r = Gn(t, "float32");
    return Tn(n, r);
  }

  var o = tt(k(t), e);
  return Lt.makeTensor(o, t, e);
}

function Hn(t, e, n) {
  return Lt.runKernelFunc(function (r) {
    return r.fill(t, e, n);
  }, {});
}

function qn(t, e, n) {
  if (n <= 0) throw new Error("The number of values should be positive.");
  return Lt.runKernelFunc(function (r) {
    return r.linspace(t, e, n);
  }, {});
}

function Kn(t, e, n, r) {
  if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), 0 === n) throw new Error("Cannot have a step of zero");
  if (t === e || t < e && n < 0 || e < t && n > 1) return Gn([0], r);
  var o = tt(Math.abs(Math.ceil((e - t) / n)), r);
  e < t && 1 === n && (n = -1), o[0] = t;

  for (var a = 1; a < o.length; a++) o[a] = o[a - 1] + n;

  return Mn(o, r);
}

var jn = An({
  onesLike_: function (t) {
    var e = mn(t, "x", "onesLike");

    if ("complex64" === e.dtype) {
      var n = jn(Dn(e)),
          r = Xn(Nn(e));
      return Tn(n, r);
    }

    return Lt.runKernelFunc(function (t) {
      return t.onesLike(e);
    }, {
      x: e
    }, function (t, e) {
      return {
        x: function () {
          return Xn(t);
        }
      };
    }, "OnesLike");
  }
}),
    Xn = An({
  zerosLike_: function (t) {
    var e = mn(t, "x", "zerosLike");
    return Lt.runKernelFunc(function (t) {
      return t.zerosLike(e);
    }, {
      x: e
    }, function (t, e) {
      return {
        x: function () {
          return Xn(t);
        }
      };
    }, "ZerosLike");
  }
});
exports.zerosLike = Xn;
exports.onesLike = jn;
var Yn = An({
  concat_: function (t, e) {
    void 0 === e && (e = 0), C(t.length >= 1, function () {
      return "Pass at least one tensor to concat";
    });
    var n = gn(t, "tensors", "concat");
    "complex64" === n[0].dtype && n.forEach(function (t) {
      if ("complex64" !== t.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t.dtype + ". ");
    }), e = O(e, n[0].shape)[0];
    var r = Sn(n.map(function (t) {
      return t.shape;
    }), e);
    if (0 === k(r)) return Fn([], r);
    if (1 === (n = n.filter(function (t) {
      return t.size > 0;
    })).length) return n[0];
    var o = n.map(function (t) {
      return t.shape;
    });
    kn(o, e);
    var a = n,
        i = {
      axis: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.concat(n, e);
    }, a, function (t) {
      var n = o.map(function (t) {
        return t[e];
      });
      return tr(t, n, e).map(function (t) {
        return function () {
          return t;
        };
      });
    }, "Concat", i);
  }
}),
    $n = An({
  concat1d_: function (t) {
    return Yn(t, 0);
  }
}),
    Qn = An({
  concat2d_: function (t, e) {
    return Yn(t, e);
  }
}),
    Jn = An({
  concat3d_: function (t, e) {
    return Yn(t, e);
  }
}),
    Zn = An({
  concat4d_: function (t, e) {
    return Yn(t, e);
  }
}),
    tr = An({
  split_: function (t, e, n) {
    void 0 === n && (n = 0);
    var r,
        o = mn(t, "x", "split");
    return n = O(n, o.shape)[0], "number" == typeof e ? (C(o.shape[n] % e == 0, function () {
      return "Number of splits must evenly divide the axis.";
    }), r = new Array(e).fill(o.shape[n] / e)) : (C(o.shape[n] === e.reduce(function (t, e) {
      return t + e;
    }), function () {
      return "The sum of sizes must match the size of the axis dimension.";
    }), r = e), Lt.runKernelFunc(function (t) {
      return t.split(o, r, n);
    }, {
      $x: o
    }, function (t) {
      return {
        $x: function () {
          return Yn(t, n);
        }
      };
    });
  }
});
exports.split = tr;
exports.concat4d = Zn;
exports.concat3d = Jn;
exports.concat2d = Qn;
exports.concat1d = $n;
exports.concat = Yn;

function er(t, e, n) {
  return void 0 === e && (e = "float32"), e = e || "float32", nt(t), new gt(t, e, n);
}

function nr(t, e) {
  void 0 === e && (e = !1), console.log(t.toString(e));
}

var rr = An({
  batchToSpaceND_: function (t, e, n) {
    var r = mn(t, "x", "batchToSpaceND"),
        o = e.reduce(function (t, e) {
      return t * e;
    });
    return C(r.rank >= 1 + e.length, function () {
      return "input rank is " + r.rank + " but should be > than blockShape.length " + e.length;
    }), C(n.length === e.length, function () {
      return "crops.length is " + n.length + " but should be equal to blockShape.length  " + e.length;
    }), C(r.shape[0] % o == 0, function () {
      return "input tensor batch is " + r.shape[0] + " but is not divisible by the product of the elements of blockShape " + e.join(" * ") + " === " + o;
    }), Lt.runKernelFunc(function (t) {
      return t.batchToSpaceND(r, e, n);
    }, {
      $x: r
    }, function (t) {
      return {
        $x: function () {
          return t.spaceToBatchND(e, n);
        }
      };
    });
  }
}),
    or = An({
  cast_: function (t, e) {
    var n = mn(t, "x", "cast");
    if (!W(e)) throw new Error("Failed to cast to unknown dtype " + e);
    if ("string" === e && "string" !== n.dtype || "string" !== e && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
    var r = {
      dtype: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.cast(n, e);
    }, {
      x: n
    }, function (t) {
      return {
        x: function () {
          return t.clone();
        }
      };
    }, "Cast", r);
  }
}),
    ar = An({
  cumsum_: function (t, e, n, r) {
    void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);
    var o = mn(t, "x", "cumsum"),
        a = En([e |= 0], o.rank),
        i = o;
    null != a && (i = o.transpose(a));
    var s = In(1, o.rank)[0],
        u = Lt.runKernelFunc(function (t) {
      return t.cumsum(i, s, n, r);
    }, {
      permutedX: i
    }, function (t) {
      return {
        permutedX: function () {
          return t.cumsum(e, n, !r);
        }
      };
    });
    return null != a && (u = u.transpose(a)), u;
  }
}),
    ir = An({
  depthToSpace_: function (t, e, n) {
    void 0 === n && (n = "NHWC");
    var r = mn(t, "x", "depthToSpace"),
        o = "NHWC" === n ? r.shape[1] : r.shape[2],
        a = "NHWC" === n ? r.shape[2] : r.shape[3],
        i = "NHWC" === n ? r.shape[3] : r.shape[1];
    return C(o * e >= 0, function () {
      return "Negative dimension size caused by overflow when multiplying\n      " + o + " and " + e + "  for depthToSpace with input shape\n      " + r.shape;
    }), C(a * e >= 0, function () {
      return "Negative dimension size caused by overflow when multiplying\n      " + a + " and " + e + " for depthToSpace with input shape\n          " + r.shape;
    }), C(i % (e * e) == 0, function () {
      return "Dimension size must be evenly divisible by " + e * e + " but is " + i + " for depthToSpace with input shape " + r.shape;
    }), Lt.runKernelFunc(function (t) {
      return t.depthToSpace(r, e, n);
    }, {
      $x: r
    });
  }
}),
    sr = An({
  expandDims_: function (t, e) {
    void 0 === e && (e = 0);
    var n = mn(t, "x", "expandDims", null);
    C(e <= n.rank, function () {
      return "Axis must be <= rank of the tensor";
    });
    var r = n.shape.slice();
    return e < 0 && (C(-(n.rank + 1) <= e, function () {
      return "Axis must be in the interval [" + -(n.rank + 1) + ", " + n.rank + "]";
    }), e = n.rank + e + 1), r.splice(e, 0, 1), dr(n, r);
  }
}),
    ur = An({
  pad_: function (t, e, n) {
    void 0 === n && (n = 0);
    var r = mn(t, "x", "pad");
    if (0 === r.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    var o = {
      paddings: e,
      constantValue: n
    };
    return Lt.runKernelFunc(function (t) {
      return t.pad(r, e, n);
    }, {
      x: r
    }, function (t) {
      var n = e.map(function (t) {
        return t[0];
      });
      return {
        x: function () {
          return t.slice(n, r.shape);
        }
      };
    }, "PadV2", o);
  }
}),
    cr = An({
  pad1d_: function (t, e, n) {
    return void 0 === n && (n = 0), C(2 === e.length, function () {
      return "Invalid number of paddings. Must be length of 2.";
    }), ur(t, [e], n);
  }
}),
    lr = An({
  pad2d_: function (t, e, n) {
    return void 0 === n && (n = 0), C(2 === e.length && 2 === e[0].length && 2 === e[1].length, function () {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), ur(t, e, n);
  }
}),
    hr = An({
  pad3d_: function (t, e, n) {
    return void 0 === n && (n = 0), C(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, function () {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), ur(t, e, n);
  }
}),
    fr = An({
  pad4d_: function (t, e, n) {
    return void 0 === n && (n = 0), C(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, function () {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), ur(t, e, n);
  }
}),
    dr = An({
  reshape_: function (t, e) {
    var n = mn(t, "x", "reshape", null);
    e = _(e, n.size), C(n.size === k(e), function () {
      return "new shape and old shape must have the same number of elements.";
    });
    var r = {
      shape: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.reshape(n, e);
    }, {
      x: n
    }, function (t) {
      return {
        x: function () {
          return t.reshape(n.shape);
        }
      };
    }, "Reshape", r);
  }
}),
    pr = An({
  spaceToBatchND_: function (t, e, n) {
    var r = mn(t, "x", "spaceToBatchND");
    return C(r.rank >= 1 + e.length, function () {
      return "input rank " + r.rank + " should be > than [blockShape] " + e.length;
    }), C(n.length === e.length, function () {
      return "paddings.shape[0] " + n.length + " must be equal to [blockShape] " + e.length;
    }), C(r.shape.reduce(function (t, r, o) {
      return o > 0 && o <= e.length ? t && (r + n[o - 1][0] + n[o - 1][1]) % e[o - 1] == 0 : t;
    }, !0), function () {
      return "input spatial dimensions " + r.shape.slice(1) + " with paddings " + n.toString() + " must be divisible by blockShapes " + e.toString();
    }), Lt.runKernelFunc(function (t) {
      return t.spaceToBatchND(r, e, n);
    }, {
      $x: r
    }, function (t) {
      return {
        $x: function () {
          return t.batchToSpaceND(e, n);
        }
      };
    });
  }
}),
    vr = An({
  squeeze_: function (t, e) {
    var n = mn(t, "x", "squeeze");
    return dr(n, M(n.shape, e).newShape);
  }
}),
    mr = An({
  stack_: function (t, e) {
    void 0 === e && (e = 0);
    var n = gn(t, "tensors", "stack");
    if (C(n.length >= 1, function () {
      return "Pass at least one tensor to tf.stack";
    }), 1 === n.length) return n[0].expandDims(e);
    var r = n[0].rank,
        o = n[0].shape,
        a = n[0].dtype;
    C(e <= r, function () {
      return "Axis must be <= rank of the tensor";
    }), n.forEach(function (t) {
      E(o, t.shape, "All tensors passed to stack must have matching shapes");
    }), n.forEach(function (t) {
      C(a === t.dtype, function () {
        return "All tensors passed to stack must have matching dtypes";
      });
    });
    var i = n.map(function (t) {
      return t.expandDims(e);
    });
    return Yn(i, e);
  }
}),
    gr = An({
  unstack_: function (t, e) {
    void 0 === e && (e = 0), e = e || 0;
    var n = mn(t, "x", "unstack");
    C(e >= -n.shape.length && e < n.shape.length, function () {
      return "Axis = " + e + " is not in [-" + n.shape.length + ", " + n.shape.length + ")";
    }), e < 0 && (e += n.shape.length);
    var r = {
      axis: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.unstack(n, e);
    }, {
      x: n
    }, function (t) {
      return {
        x: function () {
          return mr(t, e);
        }
      };
    }, "Unpack", r);
  }
}),
    yr = function (t, e) {
  return n(this, void 0, void 0, function () {
    var n, o, a, i, s, u, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = mn(t, "x", "setdiff1d"), o = mn(e, "y", "setdiff1d"), C(n.dtype === o.dtype, function () {
            return "x and y should have the same dtype, but got x (" + n.dtype + ") and y (" + o.dtype + ").";
          }), C(1 === n.rank, function () {
            return "x should be 1D tensor, but got x (" + n.shape + ").";
          }), C(1 === o.rank, function () {
            return "y should be 1D tensor, but got y (" + o.shape + ").";
          }), [4, n.data()];

        case 1:
          return a = r.sent(), [4, o.data()];

        case 2:
          for (i = r.sent(), s = new Set(i), u = 0, h = 0; h < a.length; h++) s.has(a[h]) || u++;

          for (c = new gt([u], n.dtype), l = new gt([u], "int32"), h = 0, f = 0; h < a.length; h++) s.has(a[h]) || (c.values[f] = a[h], l.values[f] = h, f++);

          return [2, [c.toTensor(), l.toTensor()]];
      }
    });
  });
};

exports.setdiff1dAsync = yr;
exports.unstack = gr;
exports.stack = mr;
exports.squeeze = vr;
exports.spaceToBatchND = pr;
exports.reshape = dr;
exports.pad4d = fr;
exports.pad3d = hr;
exports.pad2d = lr;
exports.pad1d = cr;
exports.pad = ur;
exports.expandDims = sr;
exports.depthToSpace = ir;
exports.cumsum = ar;
exports.cast = or;
exports.batchToSpaceND = rr;

function xr(t, e, n, r) {
  void 0 === r && (r = !0);
  var o = [];
  if (r) (o = o.concat(e.slice(0))).push(t[0] / n), o = o.concat(t.slice(1));else {
    o = o.concat(t[0]);

    for (var a = e.length, i = 0; i < a; ++i) o = o.concat([t[i + 1] / e[i], e[i]]);

    o = o.concat(t.slice(a + 1));
  }
  return o;
}

function br(t, e, n) {
  void 0 === n && (n = !0);
  var r = [];

  if (n) {
    r.push(e);

    for (var o = e + 1; o < t; ++o) o <= 2 * e ? (r.push(o), r.push(o - (e + 1))) : r.push(o);
  } else {
    var a = [],
        i = [];

    for (o = 1; o < t; ++o) o >= 2 * e + 1 || o % 2 == 1 ? i.push(o) : a.push(o);

    r.push.apply(r, a), r.push(0), r.push.apply(r, i);
  }

  return r;
}

function wr(t, e, n, r) {
  void 0 === r && (r = !0);
  var o = [];
  r ? o.push(t[0] / n) : o.push(t[0] * n);

  for (var a = 1; a < t.length; ++a) a <= e.length ? r ? o.push(e[a - 1] * t[a]) : o.push(t[a] / e[a - 1]) : o.push(t[a]);

  return o;
}

function Cr(t, e) {
  for (var n = [0], r = 0; r < e; ++r) n.push(t[r][0]);

  return n;
}

function Er(t, e, n) {
  for (var r = t.slice(0, 1), o = 0; o < n; ++o) r.push(t[o + 1] - e[o][0] - e[o][1]);

  return r;
}

var Rr = "Div",
    Ir = "SquaredDifference",
    kr = "BroadcastTo",
    Sr = "OneHot",
    Ar = "Identity",
    Tr = "Tile";

function Dr(t, e) {
  for (var n = t.length, r = [], o = 0; o < n; o++) {
    var a = n - 1 - o,
        i = t[a] || 1;
    (e[e.length - 1 - o] || 1) > 1 && 1 === i && r.unshift(a);
  }

  return r;
}

function Nr(t, e) {
  for (var n = [], r = 0; r < e.length; r++) {
    var o = t[t.length - r - 1],
        a = e.length - r - 1,
        i = e[a];
    (null == o || 1 === o && i > 1) && n.unshift(a);
  }

  return n;
}

function Fr(t, e) {
  for (var n = [], r = Math.max(t.length, e.length), o = 0; o < r; o++) {
    var a = t[t.length - o - 1];
    null == a && (a = 1);
    var i = e[e.length - o - 1];
    if (null == i && (i = 1), 1 === a) n.unshift(i);else if (1 === i) n.unshift(a);else {
      if (a !== i) throw Error("Operands could not be broadcast together with shapes " + t + " and " + e + ".");
      n.unshift(a);
    }
  }

  return n;
}

var _r = An({
  abs_: function (t) {
    var e = mn(t, "x", "abs");
    return "complex64" === e.dtype ? Lt.runKernelFunc(function (t) {
      return t.complexAbs(e);
    }, {
      $x: e
    }) : Lt.runKernelFunc(function (t, n) {
      var r = t.abs(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mul(n.toFloat().step(-1));
        }
      };
    }, "Abs");
  }
}),
    Or = An({
  acos_: function (t) {
    var e = mn(t, "x", "acos");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.acos(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(On(1).sub(n.toFloat().square()).sqrt()).neg();
        }
      };
    });
  }
}),
    Mr = An({
  acosh_: function (t) {
    var e = mn(t, "x", "acosh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.acosh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(n.toFloat().square().sub(1).sqrt());
        }
      };
    });
  }
}),
    Br = An({
  asin_: function (t) {
    var e = mn(t, "x", "asin");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.asin(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(On(1).sub(n.toFloat().square()).sqrt());
        }
      };
    });
  }
}),
    Pr = An({
  asinh_: function (t) {
    var e = mn(t, "x", "asinh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.asinh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(On(1).add(n.toFloat().square()).sqrt());
        }
      };
    });
  }
}),
    Lr = An({
  atan_: function (t) {
    var e = mn(t, "x", "atan");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.atan(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.toFloat().square().add(1));
        }
      };
    });
  }
}),
    Wr = An({
  atanh_: function (t) {
    var e = mn(t, "x", "atanh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.atanh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(On(1).sub(n.toFloat().square()));
        }
      };
    });
  }
}),
    Ur = An({
  ceil_: function (t) {
    var e = mn(t, "x", "ceil");
    return Lt.runKernelFunc(function (t) {
      return t.ceil(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    Vr = An({
  clipByValue_: function (t, e, n) {
    var r = mn(t, "x", "clipByValue");
    C(e <= n, function () {
      return "Error in clip: min (" + e + ") must be less than or equal to max (" + n + ").";
    });
    var o = [r],
        a = {
      min: e,
      max: n
    };
    return Lt.runKernelFunc(function (t, o) {
      var a = t.clip(r, e, n);
      return o([r]), a;
    }, {
      x: r
    }, function (t, r) {
      var o = r[0];
      return {
        x: function () {
          return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)), Xn(t));
        }
      };
    }, "ClipByValue", a, o);
  }
}),
    zr = An({
  cos_: function (t) {
    var e = mn(t, "x", "cos"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      var r = t.cos(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return n.toFloat().sin().neg().mul(t);
        }
      };
    }, "Cos", {}, n);
  }
}),
    Gr = An({
  cosh_: function (t) {
    var e = mn(t, "x", "cosh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.cosh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return n.toFloat().sinh().mulStrict(t);
        }
      };
    });
  }
}),
    Hr = An({
  erf_: function (t) {
    var e = mn(t, "x", "erf");
    return C("int32" === e.dtype || "float32" === e.dtype, function () {
      return "Input dtype must be `int32` or `float32`.";
    }), "int32" === e.dtype && (e = e.toFloat()), Lt.runKernelFunc(function (t, n) {
      var r = t.erf(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
        }
      };
    });
  }
}),
    qr = An({
  exp_: function (t) {
    var e = mn(t, "x", "exp");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.exp(e);
      return n([r]), r;
    }, {
      x: e
    }, function (t, e) {
      return {
        x: function () {
          return t.mulStrict(e[0]);
        }
      };
    }, "Exp", {}, [], [!0]);
  }
}),
    Kr = An({
  expm1_: function (t) {
    var e = mn(t, "x", "expm1");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.expm1(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.exp());
        }
      };
    });
  }
}),
    jr = An({
  floor_: function (t) {
    var e = mn(t, "x", "floor");
    return Lt.runKernelFunc(function (t) {
      return t.floor(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    Xr = An({
  log_: function (t) {
    var e = mn(t, "x", "log"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      var r = t.log(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.div(n.toFloat());
        }
      };
    }, "Log", {}, n);
  }
}),
    Yr = An({
  log1p_: function (t) {
    var e = mn(t, "x", "log1p");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.log1p(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.add(1));
        }
      };
    });
  }
}),
    $r = An({
  logSigmoid_: function (t) {
    var e = mn(t, "x", "logSigmoid");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.softplus(e.neg()).neg();
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.neg().sigmoid());
        }
      };
    });
  }
}),
    Qr = An({
  neg_: function (t) {
    var e = mn(t, "x", "neg"),
        n = [e];
    return Lt.runKernelFunc(function (t) {
      return t.neg(e);
    }, {
      x: e
    }, function (t) {
      return {
        x: function () {
          return t.neg();
        }
      };
    }, "Neg", {}, n);
  }
}),
    Jr = An({
  reciprocal_: function (t) {
    var e = mn(t, "x", "reciprocal");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.reciprocal(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.square().neg());
        }
      };
    });
  }
}),
    Zr = An({
  round_: function (t) {
    var e = mn(t, "x", "round");
    return Lt.runKernelFunc(function (t) {
      return t.round(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    to = An({
  rsqrt_: function (t) {
    var e = mn(t, "x", "rsqrt"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      var r = t.rsqrt(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.div(n.pow(1.5).mul(2)).neg();
        }
      };
    }, "Rsqrt", {}, n);
  }
}),
    eo = An({
  sigmoid_: function (t) {
    var e = mn(t, "x", "sigmoid");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.sigmoid(e);
      return n([r]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mul(n.mul(On(1).sub(n)));
        }
      };
    }, "Sigmoid");
  }
}),
    no = An({
  sign_: function (t) {
    var e = mn(t, "x", "sign");
    return Lt.runKernelFunc(function (t) {
      return t.sign(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    ro = An({
  isNaN_: function (t) {
    var e = mn(t, "x", "isNaN");
    return Lt.runKernelFunc(function (t) {
      return t.isNaN(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    oo = An({
  isInf_: function (t) {
    var e = mn(t, "x", "isInf");
    return Lt.runKernelFunc(function (t) {
      return t.isInf(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    ao = An({
  isFinite_: function (t) {
    var e = mn(t, "x", "isFinite");
    return Lt.runKernelFunc(function (t) {
      return t.isFinite(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    io = An({
  sin_: function (t) {
    var e = mn(t, "x", "sin"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      var r = t.sin(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return n.toFloat().cos().mul(t);
        }
      };
    }, "Sin", {}, n);
  }
}),
    so = An({
  sinh_: function (t) {
    var e = mn(t, "x", "sinh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.sinh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return n.toFloat().cosh().mulStrict(t);
        }
      };
    });
  }
}),
    uo = An({
  softplus_: function (t) {
    var e = mn(t, "x", "softplus");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.softplus(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.sigmoid());
        }
      };
    });
  }
}),
    co = An({
  sqrt_: function (t) {
    var e = mn(t, "x", "sqrt");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.sqrt(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.toFloat().sqrt().mul(2));
        }
      };
    });
  }
}),
    lo = An({
  step_: function (t, e) {
    void 0 === e && (e = 0);
    var n = mn(t, "x", "step");
    return Lt.runKernelFunc(function (t) {
      return t.step(n, e);
    }, {
      $x: n
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    ho = An({
  tan_: function (t) {
    var e = mn(t, "x", "tan");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.tan(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.cos().square());
        }
      };
    });
  }
}),
    fo = An({
  tanh_: function (t) {
    var e = mn(t, "x", "tanh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.tanh(e);
      return n([r]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return On(1).sub(n.square()).mulStrict(t);
        }
      };
    }, "Tanh", {}, null, [!0]);
  }
});

exports.tanh = fo;
exports.tan = ho;
exports.step = lo;
exports.sqrt = co;
exports.softplus = uo;
exports.sinh = so;
exports.sin = io;
exports.isFinite = ao;
exports.isInf = oo;
exports.isNaN = ro;
exports.sign = no;
exports.sigmoid = eo;
exports.rsqrt = to;
exports.round = Zr;
exports.reciprocal = Jr;
exports.neg = Qr;
exports.logSigmoid = $r;
exports.log1p = Yr;
exports.log = Xr;
exports.floor = jr;
exports.expm1 = Kr;
exports.exp = qr;
exports.erf = Hr;
exports.cosh = Gr;
exports.cos = zr;
exports.clipByValue = Vr;
exports.ceil = Ur;
exports.atanh = Wr;
exports.atan = Lr;
exports.asinh = Pr;
exports.asin = Br;
exports.acosh = Mr;
exports.acos = Or;
exports.abs = _r;
var po = An({
  add_: function (t, e) {
    var n,
        r = mn(t, "a", "add"),
        o = mn(e, "b", "add");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Fr(r.shape, o.shape);
    return Lt.runKernelFunc(function (t) {
      return t.add(r, o);
    }, {
      a: r,
      b: o
    }, function (t) {
      return {
        a: function () {
          var e = t,
              n = Nr(r.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);
        },
        b: function () {
          var e = t,
              n = Nr(o.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.reshape(o.shape);
        }
      };
    }, "Add");
  }
}),
    vo = An({
  addN_: function (t) {
    C(Array.isArray(t), function () {
      return "The argument passed to tf.addN() must be a list of tensors";
    }), C(t.length >= 1, function () {
      return "Must pass at least one tensor to tf.addN(), but got " + t.length;
    });
    var e = t.map(function (t, e) {
      return mn(t, "tensors" + e, "addN");
    }),
        n = e[0];
    e.forEach(function (t) {
      if (t.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
    }), e.forEach(function (t) {
      if (!S(t.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
    });
    var r = e;
    return Lt.runKernelFunc(function (t) {
      return t.addN(e);
    }, r, function (t) {
      var n = {};
      return e.forEach(function (e, r) {
        n[r] = function () {
          return t.clone();
        };
      }), n;
    }, "AddN");
  }
}),
    mo = An({
  addStrict_: function (t, e) {
    var n = mn(t, "a", "addStrict"),
        r = mn(e, "b", "addStrict");
    return E(n.shape, r.shape, "Error in addStrict: "), n.add(r);
  }
}),
    go = An({
  atan2_: function (t, e) {
    var n,
        r = mn(t, "a", "atan2"),
        o = mn(e, "b", "atan2");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Fr(r.shape, o.shape);
    return Lt.runKernelFunc(function (t, e) {
      var n = t.atan2(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          var e = po(n.square(), r.square()),
              o = t.mul(r.div(e)),
              i = Nr(n.shape, a);
          return i.length > 0 && (o = o.sum(i)), o.reshape(n.shape);
        },
        $b: function () {
          var e = po(n.square(), r.square()),
              o = Qr(t.mul(n.div(e))),
              i = Nr(r.shape, a);
          return i.length > 0 && (o = o.sum(i)), o.reshape(r.shape);
        }
      };
    });
  }
}),
    yo = An({
  divStrict_: function (t, e) {
    var n = mn(t, "a", "div"),
        r = mn(e, "b", "div");
    return E(n.shape, r.shape, "Error in divideStrict: "), n.div(r);
  }
}),
    xo = An({
  floorDiv_: function (t, e) {
    var n,
        r = mn(t, "a", "floorDiv"),
        o = mn(e, "b", "floorDiv");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Fr(r.shape, o.shape);
    return Lt.runKernelFunc(function (t, e) {
      var n = t.floorDiv(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          var e = t.div(r.toFloat()),
              o = Nr(n.shape, a);
          return o.length > 0 ? e.sum(o).reshape(n.shape) : e;
        },
        b: function () {
          var e = t.mul(n.toFloat()),
              o = Nr(r.shape, a);
          o.length > 0 && (e = e.sum(o).reshape(r.shape));
          var i = r.square();
          return e.div(i.toFloat()).neg();
        }
      };
    }, "FloorDiv");
  }
}),
    bo = An({
  maximum_: function (t, e) {
    var n,
        r = mn(t, "a", "maximum"),
        o = mn(e, "b", "maximum");
    return n = Nt(r, o), r = n[0], o = n[1], "bool" === r.dtype && (r = r.toInt(), o = o.toInt()), Fr(r.shape, o.shape), Lt.runKernelFunc(function (t, e) {
      var n = t.maximum(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          return t.mul(n.greaterEqual(r).toFloat());
        },
        b: function () {
          return t.mul(n.less(r).toFloat());
        }
      };
    }, "Maximum");
  }
}),
    wo = An({
  maximumStrict_: function (t, e) {
    var n = mn(t, "a", "maximumStrict"),
        r = mn(e, "b", "maximumStrict");
    return E(n.shape, r.shape, "Error in maximumStrict: "), n.maximum(r);
  }
}),
    Co = An({
  minimum_: function (t, e) {
    var n,
        r = mn(t, "a", "minimum"),
        o = mn(e, "b", "minimum");
    return n = Nt(r, o), r = n[0], o = n[1], "bool" === r.dtype && (r = r.toInt(), o = o.toInt()), Fr(r.shape, o.shape), Lt.runKernelFunc(function (t, e) {
      var n = t.minimum(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          return t.mul(n.lessEqual(r).toFloat());
        },
        b: function () {
          return t.mul(n.greater(r).toFloat());
        }
      };
    }, "Minimum");
  }
}),
    Eo = An({
  minimumStrict_: function (t, e) {
    var n = mn(t, "a", "minimumStrict"),
        r = mn(e, "b", "minimumStrict");
    return E(n.shape, r.shape, "Error in minimumStrict: "), n.minimum(r);
  }
}),
    Ro = An({
  mod_: function (t, e) {
    var n,
        r = mn(t, "a", "mod"),
        o = mn(e, "b", "mod");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Fr(r.shape, o.shape);
    return Lt.runKernelFunc(function (t, e) {
      var n = t.mod(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          var e = Nr(n.shape, a);
          return e.length > 0 ? t.sum(e).reshape(n.shape) : t;
        },
        $b: function () {
          var e = t.mul(n.div(r).floor().neg()),
              o = Nr(r.shape, a);
          return o.length > 0 ? e.sum(o).reshape(r.shape) : e;
        }
      };
    });
  }
}),
    Io = An({
  modStrict_: function (t, e) {
    var n = mn(t, "a", "modStrict"),
        r = mn(e, "b", "modStrict");
    return E(n.shape, r.shape, "Error in modStrict: "), n.mod(r);
  }
}),
    ko = An({
  mul_: function (t, e) {
    var n,
        r = mn(t, "a", "mul"),
        o = mn(e, "b", "mul");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Fr(r.shape, o.shape);
    return Lt.runKernelFunc(function (t, e) {
      var n = t.multiply(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          var e = t.mul(r.toFloat()),
              o = Nr(n.shape, a);
          return o.length > 0 ? e.sum(o).reshape(n.shape) : e;
        },
        b: function () {
          var e = t.mul(n.toFloat()),
              o = Nr(r.shape, a);
          return o.length > 0 ? e.sum(o).reshape(r.shape) : e;
        }
      };
    }, "Mul");
  }
}),
    So = An({
  mulStrict_: function (t, e) {
    var n = mn(t, "a", "mul"),
        r = mn(e, "b", "mul");
    return E(n.shape, r.shape, "Error in multiplyStrict: "), n.mul(r);
  }
}),
    Ao = An({
  pow_: function (t, e) {
    var n,
        r = mn(t, "base", "pow"),
        o = mn(e, "exp", "pow");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Fr(r.shape, o.shape),
        i = [r, o];
    return Lt.runKernelFunc(function (t, e) {
      var n = t.pow(r, o);
      return e([r, o, n]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1],
          o = e[2];
      return {
        a: function () {
          var e = r.toFloat(),
              o = t.mul(e.mul(n.pow(e.sub(On(1))))),
              i = Nr(n.shape, a);
          return i.length > 0 && (o = o.sum(i)), o.reshape(n.shape);
        },
        b: function () {
          var e = n.greater(0),
              i = n.log().where(e, Xn(n)),
              s = t.mul(o.mul(i)),
              u = Nr(r.shape, a);
          return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape);
        }
      };
    }, "Pow", {}, i, [!0]);
  }
}),
    To = An({
  powStrict_: function (t, e) {
    return E(t.shape, e.shape, "Error in powStrict: "), t.pow(e);
  }
}),
    Do = An({
  squaredDifferenceStrict_: function (t, e) {
    var n = mn(t, "a", "squaredDifferenceStrict"),
        r = mn(e, "b", "squaredDifferenceStrict");
    return E(n.shape, r.shape, "Error in squaredDifferenceStrict: "), n.squaredDifference(r);
  }
}),
    No = An({
  sub_: function (t, e) {
    var n,
        r = mn(t, "a", "sub"),
        o = mn(e, "b", "sub");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Fr(r.shape, o.shape);
    return Lt.runKernelFunc(function (t) {
      return t.subtract(r, o);
    }, {
      a: r,
      b: o
    }, function (t) {
      return {
        a: function () {
          var e = t,
              n = Nr(r.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);
        },
        b: function () {
          var e = t,
              n = Nr(o.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.neg().reshape(o.shape);
        }
      };
    }, "Sub");
  }
}),
    Fo = An({
  subStrict_: function (t, e) {
    var n = mn(t, "a", "subStrict"),
        r = mn(e, "b", "subStrict");
    return E(n.shape, r.shape, "Error in subStrict: "), n.sub(r);
  }
});
exports.subStrict = Fo;
exports.sub = No;
exports.squaredDifferenceStrict = Do;
exports.powStrict = To;
exports.pow = Ao;
exports.mulStrict = So;
exports.mul = ko;
exports.modStrict = Io;
exports.mod = Ro;
exports.minimumStrict = Eo;
exports.minimum = Co;
exports.maximumStrict = wo;
exports.maximum = bo;
exports.floorDiv = xo;
exports.divStrict = yo;
exports.atan2 = go;
exports.addStrict = mo;
exports.addN = vo;
exports.add = po;

var _o = An({
  div_: function (t, e) {
    var n,
        r = mn(t, "a", "div"),
        o = mn(e, "b", "div");
    if (n = Nt(r, o), r = n[0], o = n[1], "int32" === r.dtype && "int32" === o.dtype) return xo(r, o);
    var a = {
      a: r,
      b: o
    };
    return Lt.runKernelFunc(function (t, e) {
      var n = t.realDivide(r, o);
      return e([r, o]), n;
    }, a, null, Rr, {});
  }
});

exports.div = _o;

function Oo(t, e) {
  if (t.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t.rank + ".");
  if (e.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
  if ("int32" !== e.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e.dtype + ".");
  if (e.shape[e.rank - 1] > t.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e.shape[e.rank - 1] + " vs. " + t.rank);
  if (0 === t.size) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t.shape + ".");

  for (var n = e.shape, r = n[n.length - 1], o = 1, a = 0; a < n.length - 1; ++a) o *= n[a];

  var i = t.shape,
      s = n.slice();
  s.pop();
  var u = 1;

  for (a = r; a < t.rank; ++a) u *= i[a], s.push(i[a]);

  var c = $(t.shape).map(function (t) {
    return t / u;
  }).concat([1]).slice(0, r);
  return [s, o, u, c];
}

var Mo = Object.freeze({
  prepareAndValidate: Oo
}),
    Bo = 30;
exports.gather_util = Mo;

function Po(t) {
  return t <= Bo ? t : Y(t, Math.floor(Math.sqrt(t)));
}

function Lo(t, e, n) {
  var r = e.rank > 1 ? e.shape[e.rank - 1] : 1,
      o = e.rank > 1 ? e.rank - 1 : 1,
      a = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n.shape + ", indices.shape: " + e.shape + ", shape: " + t + ", sliceDim: " + r + ", and batchDim: " + o + ".";
  if (n.rank < o) throw new Error(a + " update.rank < " + o + ". ");
  if (t.length < r + (n.rank - o)) throw new Error(a + " Output shape length < " + (r + (n.rank - o)));
  if (n.rank !== o + t.length - r) throw new Error(a + " update.rank != " + (o + t.length - r));

  for (var i = 0; i < o; ++i) if (n.shape[i] !== e.shape[i]) throw new Error(a + " updates.shape[" + i + "] (" + n.shape[i] + ") != indices.shape[" + i + "] (" + e.shape[i] + ").");

  for (i = 0; i < n.rank - o; ++i) if (n.shape[i + o] !== t[i + r]) throw new Error(a + " updates.shape[" + (i + o) + "] (" + n.shape[i + o] + ") != shape[" + (i + o) + "] (" + t[i + o] + ")");
}

function Wo(t, e, n) {
  if (e.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
  if (t.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t.rank + ".");
  if ("int32" !== e.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e.dtype);
  if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n);

  if (0 === n.length) {
    if (0 === e.size) throw new Error("Indices specified for empty output. indices shape: " + e.shape);
    if (0 === t.size) throw new Error("Updates specified for empty output. updates shape: " + t.shape);
  }

  Lo(n, e, t);
}

function Uo(t, e, n) {
  for (var r = e.shape.length, o = r > 1 ? e.shape[r - 1] : 1, a = n.length, i = 1, s = o; s < a; ++s) i *= n[s];

  var u = o < 1 ? 1 : o;
  return {
    sliceRank: o,
    numUpdates: k(e.shape) / u,
    sliceSize: i,
    strides: $(n.slice(0, o)).concat([1]),
    outputSize: k(n)
  };
}

var Vo = Object.freeze({
  validateUpdateShape: Lo,
  validateInput: Wo,
  calculateShapes: Uo
});
exports.scatter_util = Vo;

function zo(t, e, n) {
  C(t.rank === e.length, function () {
    return "Error in slice" + t.rank + "D: Length of begin " + e + " must match the rank of the array (" + t.rank + ").";
  }), C(t.rank === n.length, function () {
    return "Error in slice" + t.rank + "D: Length of size " + n + " must match the rank of the array (" + t.rank + ").";
  });

  for (var r = function (r) {
    C(e[r] + n[r] <= t.shape[r], function () {
      return "Error in slice" + t.rank + "D: begin[" + r + "] + size[" + r + "] (" + (e[r] + n[r]) + ") would overflow input.shape[" + r + "] (" + t.shape[r] + ")";
    });
  }, o = 0; o < t.rank; ++o) r(o);
}

function Go(t) {
  for (var e = [], n = 0; t > 0;) 1 & t && e.push(n), t /= 2, n++;

  return e;
}

function Ho(t, e, n) {
  for (var r = [], o = 0; o < t.length; o++) r[o] = Math.ceil((e[o] - t[o]) / n[o]);

  return r;
}

function qo(t, e, n, r, o) {
  var a = e[o],
      i = n[o] || 1;
  (t & 1 << o || null == a) && (a = i > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var s = r[o];
  return a < 0 && (a += s), a = x(0, a, s - 1);
}

function Ko(t, e, n, r, o) {
  var a = e[o],
      i = n[o] || 1;
  (t & 1 << o || null == a) && (a = i > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var s = r[o];
  return a < 0 && (a += s), a = i > 0 ? x(0, a, s) : x(-1, a, s - 1);
}

function jo(t, e, n) {
  for (var r = n.length, o = 0; o < n.length; o++) if (n[o] > 1) {
    r = o;
    break;
  }

  for (o = r + 1; o < n.length; o++) if (e[o] > 0 || n[o] !== t[o]) return !1;

  return !0;
}

function Xo(t, e) {
  for (var n = t.length > 0 ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++) n += t[r] * e[r];

  return n;
}

var Yo = Object.freeze({
  assertParamsValid: zo,
  maskToAxes: Go,
  computeOutShape: Ho,
  startForAxis: qo,
  stopForAxis: Ko,
  isSliceContinous: jo,
  computeFlatOffset: Xo
});
exports.slice_util = Yo;

function $o(t) {
  return C(X(t), function () {
    return "The f passed in grad(f) must be a function";
  }), function (e, n) {
    var r = mn(e, "x", "tf.grad", null),
        o = null != n ? mn(n, "dy", "tf.grad") : null;
    return Lt.tidy(function () {
      var e = Lt.gradients(function () {
        return t(r);
      }, [r], o),
          n = e.value,
          a = e.grads;
      return null != o && E(n.shape, o.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), na(a), a[0];
    });
  };
}

function Qo(t) {
  return C(X(t), function () {
    return "The f passed in grads(f) must be a function";
  }), function (e, n) {
    C(Array.isArray(e), function () {
      return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
    });
    var r = gn(e, "args", "tf.grads", null),
        o = null != n ? mn(n, "dy", "tf.grads") : null;
    return Lt.tidy(function () {
      var e = Lt.gradients(function () {
        return t.apply(void 0, r);
      }, r, o),
          n = e.value,
          a = e.grads;
      return null != o && E(n.shape, o.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), na(a), a;
    });
  };
}

function Jo(t) {
  return C(X(t), function () {
    return "The f passed in valueAndGrad(f) must be a function";
  }), function (e, n) {
    C(e instanceof wt, function () {
      return "The x passed in valueAndGrad(f)(x) must be a tensor";
    }), C(null == n || n instanceof wt, function () {
      return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
    });
    var r = Lt.gradients(function () {
      return t(e);
    }, [e], n),
        o = r.grads,
        a = r.value;
    return na(o), {
      grad: o[0],
      value: a
    };
  };
}

function Zo(t) {
  return C(X(t), function () {
    return "The f passed in valueAndGrads(f) must be a function";
  }), function (e, n) {
    C(Array.isArray(e) && e.every(function (t) {
      return t instanceof wt;
    }), function () {
      return "The args passed in valueAndGrads(f)(args) must be array of tensors";
    }), C(null == n || n instanceof wt, function () {
      return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
    });
    var r = Lt.gradients(function () {
      return t.apply(void 0, e);
    }, e, n);
    return null != n && E(r.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), na(r.grads), r;
  };
}

function ta(t, e) {
  C(X(t), function () {
    return "The f passed in variableGrads(f) must be a function";
  }), C(null == e || Array.isArray(e) && e.every(function (t) {
    return t instanceof St;
  }), function () {
    return "The varList passed in variableGrads(f, varList) must be an array of variables";
  });
  var n = null != e;
  if (!n) for (var r in e = [], Lt.registeredVariables) e.push(Lt.registeredVariables[r]);
  var o = n ? e.filter(function (t) {
    return !t.trainable;
  }) : null,
      a = e.length;
  C((e = e.filter(function (t) {
    return t.trainable;
  })).length > 0, function () {
    return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + a + " variables is trainable.";
  });
  var i = Lt.gradients(t, e, null, !0),
      s = i.value,
      u = i.grads;
  C(u.some(function (t) {
    return null != t;
  }), function () {
    return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
  }), C(0 === s.rank, function () {
    return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s.rank + " tensor";
  });
  var c = {};
  return e.forEach(function (t, e) {
    null != u[e] && (c[t.name] = u[e]);
  }), null != o && o.forEach(function (t) {
    return c[t.name] = null;
  }), {
    value: s,
    grads: c
  };
}

function ea(t) {
  return Lt.customGrad(t);
}

function na(t) {
  if (t.filter(function (t) {
    return null == t;
  }).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
}

var ra = An({
  softmax_: function (t, e) {
    void 0 === e && (e = -1);
    var n = mn(t, "logits", "softmax", "float32");
    if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and dim was " + e);
    return Lt.runKernelFunc(function (t, r) {
      var o = t.softmax(n, e);
      return r([o]), o;
    }, {
      logits: n
    }, function (t, n) {
      var r = n[0],
          o = t.mul(r);
      return {
        logits: function () {
          return o.sub(o.sum([e], !0).mul(r));
        }
      };
    }, "Softmax", {
      dim: e
    }, [], [!0]);
  }
}),
    oa = An({
  logSoftmax_: function (t, e) {
    void 0 === e && (e = -1);
    var n = mn(t, "logits", "logSoftmax");
    if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and axis was " + e);
    return ea(function (t, n) {
      var r = t.max(e, !0),
          o = t.sub(r),
          a = o.toFloat().sub(o.exp().sum(e, !0).log());
      n([a]);
      return {
        value: a,
        gradFunc: function (t, n) {
          var r = n[0].exp();
          return t.sub(t.sum(e, !0).mul(r));
        }
      };
    })(n);
  }
}),
    aa = function () {
  function t(t, e) {
    this.backend = t, this.dataMover = e, this.data = new WeakMap(), this.dataIdsCount = 0;
  }

  return t.prototype.get = function (t) {
    return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t);
  }, t.prototype.set = function (t, e) {
    this.dataIdsCount++, this.data.set(t, e);
  }, t.prototype.has = function (t) {
    return this.data.has(t);
  }, t.prototype.delete = function (t) {
    return this.dataIdsCount--, this.data.delete(t);
  }, t.prototype.numDataIds = function () {
    return this.dataIdsCount;
  }, t;
}(),
    ia = function () {
  function t() {}

  return t.prototype.time = function (t) {
    return sa("time");
  }, t.prototype.read = function (t) {
    return sa("read");
  }, t.prototype.readSync = function (t) {
    return sa("readSync");
  }, t.prototype.numDataIds = function () {
    return sa("numDataIds");
  }, t.prototype.disposeData = function (t) {
    return sa("disposeData");
  }, t.prototype.write = function (t, e, n) {
    return sa("write");
  }, t.prototype.move = function (t, e, n, r) {
    return sa("move");
  }, t.prototype.memory = function () {
    return sa("memory");
  }, t.prototype.floatPrecision = function () {
    return sa("floatPrecision");
  }, t.prototype.epsilon = function () {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, t.prototype.batchMatMul = function (t, e, n, r) {
    return sa("batchMatMul");
  }, t.prototype.fusedBatchMatMul = function (t) {
    t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights;
    return sa("fusedBatchMatMul");
  }, t.prototype.slice = function (t, e, n) {
    return sa("slice");
  }, t.prototype.stridedSlice = function (t, e, n, r) {
    return sa("stridedSlice");
  }, t.prototype.unstack = function (t, e) {
    return sa("unstack");
  }, t.prototype.reverse = function (t, e) {
    return sa("reverse");
  }, t.prototype.concat = function (t, e) {
    return sa("concat");
  }, t.prototype.neg = function (t) {
    return sa("neg");
  }, t.prototype.add = function (t, e) {
    return sa("add");
  }, t.prototype.addN = function (t) {
    return sa("addN");
  }, t.prototype.subtract = function (t, e) {
    return sa("subtract");
  }, t.prototype.multiply = function (t, e) {
    return sa("multiply");
  }, t.prototype.realDivide = function (t, e) {
    return sa("realDivide");
  }, t.prototype.floorDiv = function (t, e) {
    return sa("floorDiv");
  }, t.prototype.sum = function (t, e) {
    return sa("sum");
  }, t.prototype.prod = function (t, e) {
    return sa("prod");
  }, t.prototype.unsortedSegmentSum = function (t, e, n) {
    return sa("unsortedSegmentSum");
  }, t.prototype.argMin = function (t, e) {
    return sa("argMin");
  }, t.prototype.argMax = function (t, e) {
    return sa("argMax");
  }, t.prototype.equal = function (t, e) {
    return sa("equal");
  }, t.prototype.notEqual = function (t, e) {
    return sa("notEqual");
  }, t.prototype.less = function (t, e) {
    return sa("less");
  }, t.prototype.lessEqual = function (t, e) {
    return sa("lessEqual");
  }, t.prototype.greater = function (t, e) {
    return sa("greater");
  }, t.prototype.greaterEqual = function (t, e) {
    return sa("greaterEqual");
  }, t.prototype.logicalNot = function (t) {
    return sa("logicalNot");
  }, t.prototype.logicalAnd = function (t, e) {
    return sa("logicalAnd");
  }, t.prototype.logicalOr = function (t, e) {
    return sa("logicalOr");
  }, t.prototype.where = function (t) {
    return sa("where");
  }, t.prototype.select = function (t, e, n) {
    return sa("select");
  }, t.prototype.topk = function (t, e, n) {
    return sa("topk");
  }, t.prototype.min = function (t, e) {
    return sa("min");
  }, t.prototype.minimum = function (t, e) {
    return sa("minimum");
  }, t.prototype.mod = function (t, e) {
    return sa("mod");
  }, t.prototype.max = function (t, e) {
    return sa("max");
  }, t.prototype.maximum = function (t, e) {
    return sa("maximum");
  }, t.prototype.all = function (t, e) {
    return sa("all");
  }, t.prototype.any = function (t, e) {
    return sa("any");
  }, t.prototype.squaredDifference = function (t, e) {
    return sa("squaredDifference");
  }, t.prototype.ceil = function (t) {
    return sa("ceil");
  }, t.prototype.floor = function (t) {
    return sa("floor");
  }, t.prototype.round = function (t) {
    return sa("round");
  }, t.prototype.sign = function (t) {
    return sa("sign");
  }, t.prototype.isNaN = function (t) {
    return sa("isNaN");
  }, t.prototype.isInf = function (t) {
    return sa("isInf");
  }, t.prototype.isFinite = function (t) {
    return sa("isFinite");
  }, t.prototype.pow = function (t, e) {
    return sa("pow");
  }, t.prototype.exp = function (t) {
    return sa("exp");
  }, t.prototype.expm1 = function (t) {
    return sa("expm1");
  }, t.prototype.softmax = function (t, e) {
    return sa("softmax");
  }, t.prototype.log = function (t) {
    return sa("log");
  }, t.prototype.log1p = function (t) {
    return sa("log1p");
  }, t.prototype.sqrt = function (t) {
    return sa("sqrt");
  }, t.prototype.rsqrt = function (t) {
    return sa("rsqrt");
  }, t.prototype.square = function (t) {
    return sa("square");
  }, t.prototype.reciprocal = function (t) {
    return sa("reciprocal");
  }, t.prototype.relu = function (t) {
    return sa("relu");
  }, t.prototype.relu6 = function (t) {
    return sa("relu6");
  }, t.prototype.prelu = function (t, e) {
    return sa("prelu");
  }, t.prototype.elu = function (t) {
    return sa("elu");
  }, t.prototype.eluDer = function (t, e) {
    return sa("eluDer");
  }, t.prototype.selu = function (t) {
    return sa("selu");
  }, t.prototype.int = function (t) {
    return sa("int");
  }, t.prototype.clip = function (t, e, n) {
    return sa("clip");
  }, t.prototype.abs = function (t) {
    return sa("abs");
  }, t.prototype.complexAbs = function (t) {
    return sa("complexAbs");
  }, t.prototype.sigmoid = function (t) {
    return sa("sigmoid");
  }, t.prototype.softplus = function (t) {
    return sa("softplus");
  }, t.prototype.sin = function (t) {
    return sa("sin");
  }, t.prototype.cos = function (t) {
    return sa("cos");
  }, t.prototype.tan = function (t) {
    return sa("tan");
  }, t.prototype.asin = function (t) {
    return sa("asin");
  }, t.prototype.acos = function (t) {
    return sa("acos");
  }, t.prototype.atan = function (t) {
    return sa("atan");
  }, t.prototype.atan2 = function (t, e) {
    return sa("atan2");
  }, t.prototype.sinh = function (t) {
    return sa("sinh");
  }, t.prototype.cosh = function (t) {
    return sa("cosh");
  }, t.prototype.tanh = function (t) {
    return sa("tanh");
  }, t.prototype.asinh = function (t) {
    return sa("asinh");
  }, t.prototype.acosh = function (t) {
    return sa("acosh");
  }, t.prototype.atanh = function (t) {
    return sa("atanh");
  }, t.prototype.erf = function (t) {
    return sa("erf");
  }, t.prototype.step = function (t, e) {
    return sa("step");
  }, t.prototype.fusedConv2d = function (t) {
    t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;
    return sa("fusedConv2d");
  }, t.prototype.conv2d = function (t, e, n) {
    return sa("conv2d");
  }, t.prototype.conv2dDerInput = function (t, e, n) {
    return sa("conv2dDerInput");
  }, t.prototype.conv2dDerFilter = function (t, e, n) {
    return sa("conv2dDerFilter");
  }, t.prototype.fusedDepthwiseConv2D = function (t) {
    t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;
    return sa("fusedDepthwiseConv2D");
  }, t.prototype.depthwiseConv2D = function (t, e, n) {
    return sa("depthwiseConv2D");
  }, t.prototype.depthwiseConv2DDerInput = function (t, e, n) {
    return sa("depthwiseConv2DDerInput");
  }, t.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
    return sa("depthwiseConv2DDerFilter");
  }, t.prototype.conv3d = function (t, e, n) {
    return sa("conv3d");
  }, t.prototype.conv3dDerInput = function (t, e, n) {
    return sa("conv3dDerInput");
  }, t.prototype.conv3dDerFilter = function (t, e, n) {
    return sa("conv3dDerFilter");
  }, t.prototype.maxPool = function (t, e) {
    return sa("maxPool");
  }, t.prototype.maxPoolBackprop = function (t, e, n, r) {
    return sa("maxPoolBackprop");
  }, t.prototype.avgPool = function (t, e) {
    return sa("avgPool");
  }, t.prototype.avgPoolBackprop = function (t, e, n) {
    return sa("avgPoolBackprop");
  }, t.prototype.avgPool3d = function (t, e) {
    return sa("avgPool3d");
  }, t.prototype.avgPool3dBackprop = function (t, e, n) {
    return sa("avgPool3dBackprop");
  }, t.prototype.maxPool3d = function (t, e) {
    return sa("maxPool3d");
  }, t.prototype.maxPool3dBackprop = function (t, e, n, r) {
    return sa("maxPool3dBackprop");
  }, t.prototype.reshape = function (t, e) {
    return sa("reshape");
  }, t.prototype.cast = function (t, e) {
    return sa("cast");
  }, t.prototype.tile = function (t, e) {
    return sa("tile");
  }, t.prototype.pad = function (t, e, n) {
    return sa("pad");
  }, t.prototype.transpose = function (t, e) {
    return sa("transpose");
  }, t.prototype.gather = function (t, e, n) {
    return sa("gather");
  }, t.prototype.gatherND = function (t, e) {
    return sa("gatherND");
  }, t.prototype.scatterND = function (t, e, n) {
    return sa("scatterND");
  }, t.prototype.batchToSpaceND = function (t, e, n) {
    return sa("batchToSpaceND");
  }, t.prototype.spaceToBatchND = function (t, e, n) {
    return sa("spaceToBatchND");
  }, t.prototype.resizeBilinear = function (t, e, n, r) {
    return sa("resizeBilinear");
  }, t.prototype.resizeBilinearBackprop = function (t, e, n) {
    return sa("resizeBilinearBackprop");
  }, t.prototype.resizeNearestNeighbor = function (t, e, n, r) {
    return sa("resizeNearestNeighbor");
  }, t.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
    return sa("resizeNearestNeighborBackprop");
  }, t.prototype.batchNormalization = function (t, e, n, r, o, a) {
    return sa("batchNormalization");
  }, t.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
    return sa("localResponseNormalization4D");
  }, t.prototype.LRNGrad = function (t, e, n, r, o, a, i) {
    return sa("LRNGrad");
  }, t.prototype.multinomial = function (t, e, n, r) {
    return sa("multinomial");
  }, t.prototype.oneHot = function (t, e, n, r) {
    return sa("oneHot");
  }, t.prototype.cumsum = function (t, e, n, r) {
    return sa("cumsum");
  }, t.prototype.nonMaxSuppression = function (t, e, n, r, o) {
    return sa("nonMaxSuppression");
  }, t.prototype.fft = function (t) {
    return sa("fft");
  }, t.prototype.ifft = function (t) {
    return sa("ifft");
  }, t.prototype.complex = function (t, e) {
    return sa("complex");
  }, t.prototype.real = function (t) {
    return sa("real");
  }, t.prototype.imag = function (t) {
    return sa("imag");
  }, t.prototype.cropAndResize = function (t, e, n, r, o, a) {
    return sa("cropAndResize");
  }, t.prototype.depthToSpace = function (t, e, n) {
    return sa("depthToSpace");
  }, t.prototype.split = function (t, e, n) {
    return sa("split");
  }, t.prototype.sparseToDense = function (t, e, n, r) {
    return sa("sparseToDense");
  }, t.prototype.diag = function (t) {
    return sa("diag");
  }, t.prototype.fill = function (t, e, n) {
    return sa("fill");
  }, t.prototype.onesLike = function (t) {
    return sa("onesLike");
  }, t.prototype.zerosLike = function (t) {
    return sa("zerosLike");
  }, t.prototype.linspace = function (t, e, n) {
    return sa("linspace");
  }, t.prototype.dispose = function () {
    return sa("dispose");
  }, t;
}();

exports.KernelBackend = ia;
exports.DataStorage = aa;
exports.logSoftmax = oa;
exports.softmax = ra;

function sa(t) {
  throw new Error("'" + t + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}

function ua(t, e, n, r, o, a, i) {
  void 0 === i && (i = "channelsLast");
  var s,
      u = da(e),
      c = u[0],
      l = u[1];
  if ("channelsLast" === i) s = [c, l, t[3], t[3]];else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat " + i);
    s = [c, l, t[1], t[1]];
  }
  return la(t, s, n, r, o, a, !1, i);
}

function ca(t, e, n, r, o, a, i) {
  void 0 === i && (i = "NDHWC");
  var s,
      u,
      c = pa(e),
      l = c[0],
      h = c[1],
      f = c[2];
  if ("NDHWC" === i) u = "channelsLast", s = [l, h, f, t[4], t[4]];else {
    if ("NCDHW" !== i) throw new Error("Unknown dataFormat " + i);
    u = "channelsFirst", s = [l, h, f, t[1], t[1]];
  }
  return ha(t, s, n, r, o, !1, u, a);
}

function la(t, e, n, r, o, a, i, s) {
  void 0 === i && (i = !1), void 0 === s && (s = "channelsLast");
  var u = [-1, -1, -1, -1],
      c = u[0],
      l = u[1],
      h = u[2],
      f = u[3];
  if ("channelsLast" === s) c = t[0], l = t[1], h = t[2], f = t[3];else {
    if ("channelsFirst" !== s) throw new Error("Unknown dataFormat " + s);
    c = t[0], f = t[1], l = t[2], h = t[3];
  }

  var d,
      p = e[0],
      v = e[1],
      m = e[3],
      g = da(n),
      y = g[0],
      x = g[1],
      b = da(r),
      w = b[0],
      E = b[1],
      R = va(p, w),
      I = va(v, E),
      k = function (t, e, n, r, o, a, i, s) {
    var u, c, l;

    if ("number" == typeof t) {
      u = {
        top: t,
        bottom: t,
        left: t,
        right: t,
        type: 0 === t ? "VALID" : "NUMBER"
      };

      var h = function (t, e, n, r, o) {
        null == r && (r = fa(t, e, n));
        var a = t[0],
            i = t[1],
            s = ma((a - e + 2 * r) / n + 1, o);
        C(A(s), function () {
          return "The output # of rows (" + s + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var u = ma((i - e + 2 * r) / n + 1, o);
        return C(A(u), function () {
          return "The output # of columns (" + u + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [s, u];
      }([e, n], a, r, t, s);

      c = h[0], l = h[1];
    } else if ("same" === t) {
      c = Math.ceil(e / r), l = Math.ceil(n / o);
      var f = Math.max(0, (c - 1) * r + a - e),
          d = Math.max(0, (l - 1) * o + i - n),
          p = Math.floor(f / 2),
          v = f - p,
          m = Math.floor(d / 2);
      u = {
        top: p,
        bottom: v,
        left: m,
        right: d - m,
        type: "SAME"
      };
    } else {
      if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
      u = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        type: "VALID"
      }, c = Math.ceil((e - a + 1) / r), l = Math.ceil((n - i + 1) / o);
    }

    return {
      padInfo: u,
      outHeight: c,
      outWidth: l
    };
  }(o, l, h, y, x, R, I, a),
      S = k.padInfo,
      T = k.outHeight,
      D = k.outWidth,
      N = i ? m * f : m;

  return "channelsFirst" === s ? d = [c, N, T, D] : "channelsLast" === s && (d = [c, T, D, N]), {
    batchSize: c,
    dataFormat: s,
    inHeight: l,
    inWidth: h,
    inChannels: f,
    outHeight: T,
    outWidth: D,
    outChannels: N,
    padInfo: S,
    strideHeight: y,
    strideWidth: x,
    filterHeight: p,
    filterWidth: v,
    effectiveFilterHeight: R,
    effectiveFilterWidth: I,
    dilationHeight: w,
    dilationWidth: E,
    inShape: t,
    outShape: d,
    filterShape: e
  };
}

function ha(t, e, n, r, o, a, i, s) {
  void 0 === a && (a = !1), void 0 === i && (i = "channelsLast");
  var u = [-1, -1, -1, -1, -1],
      c = u[0],
      l = u[1],
      h = u[2],
      f = u[3],
      d = u[4];
  if ("channelsLast" === i) c = t[0], l = t[1], h = t[2], f = t[3], d = t[4];else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat " + i);
    c = t[0], d = t[1], l = t[2], h = t[3], f = t[4];
  }

  var p,
      v = e[0],
      m = e[1],
      g = e[2],
      y = e[4],
      x = pa(n),
      b = x[0],
      w = x[1],
      E = x[2],
      R = pa(r),
      I = R[0],
      k = R[1],
      S = R[2],
      T = va(v, I),
      D = va(m, k),
      N = va(g, S),
      F = function (t, e, n, r, o, a, i, s, u, c, l) {
    var h, f, d, p;

    if ("number" == typeof t) {
      h = {
        top: t,
        bottom: t,
        left: t,
        right: t,
        front: t,
        back: t,
        type: 0 === t ? "VALID" : "NUMBER"
      };

      var v = function (t, e, n, r, o, a) {
        null == o && (o = fa(t, e, r));
        var i = t[0],
            s = t[1],
            u = t[2],
            c = ma((i - e + 2 * o) / r + 1, a);
        C(A(c), function () {
          return "The output # of depths (" + c + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var l = ma((s - e + 2 * o) / r + 1, a);
        C(A(l), function () {
          return "The output # of rows (" + l + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var h = ma((u - e + 2 * o) / r + 1, a);
        return C(A(h), function () {
          return "The output # of columns (" + h + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [c, l, h, n];
      }([e, n, r, 1], s, 1, o, t, l);

      f = v[0], d = v[1], p = v[2];
    } else if ("same" === t) {
      f = Math.ceil(e / o), d = Math.ceil(n / a), p = Math.ceil(r / i);
      var m = (f - 1) * o + s - e,
          g = (d - 1) * a + u - n,
          y = (p - 1) * i + c - r,
          x = Math.floor(m / 2),
          b = m - x,
          w = Math.floor(g / 2),
          E = g - w,
          R = Math.floor(y / 2);
      h = {
        top: w,
        bottom: E,
        left: R,
        right: y - R,
        front: x,
        back: b,
        type: "SAME"
      };
    } else {
      if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
      h = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        front: 0,
        back: 0,
        type: "VALID"
      }, f = Math.ceil((e - s + 1) / o), d = Math.ceil((n - u + 1) / a), p = Math.ceil((r - c + 1) / i);
    }

    return {
      padInfo: h,
      outDepth: f,
      outHeight: d,
      outWidth: p
    };
  }(o, l, h, f, b, w, E, T, D, N, s),
      _ = F.padInfo,
      O = F.outDepth,
      M = F.outHeight,
      B = F.outWidth,
      P = a ? y * d : y;

  return "channelsFirst" === i ? p = [c, P, O, M, B] : "channelsLast" === i && (p = [c, O, M, B, P]), {
    batchSize: c,
    dataFormat: i,
    inDepth: l,
    inHeight: h,
    inWidth: f,
    inChannels: d,
    outDepth: O,
    outHeight: M,
    outWidth: B,
    outChannels: P,
    padInfo: _,
    strideDepth: b,
    strideHeight: w,
    strideWidth: E,
    filterDepth: v,
    filterHeight: m,
    filterWidth: g,
    effectiveFilterDepth: T,
    effectiveFilterHeight: D,
    effectiveFilterWidth: N,
    dilationDepth: I,
    dilationHeight: k,
    dilationWidth: S,
    inShape: t,
    outShape: p,
    filterShape: e
  };
}

function fa(t, e, n, r) {
  void 0 === r && (r = 1);
  var o = va(e, r);
  return Math.floor((t[0] * (n - 1) - n + o) / 2);
}

function da(t) {
  return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t;
}

function pa(t) {
  return "number" == typeof t ? [t, t, t] : t;
}

function va(t, e) {
  return e <= 1 ? t : t + (t - 1) * (e - 1);
}

function ma(t, e) {
  if (!e) return t;

  switch (e) {
    case "round":
      return Math.round(t);

    case "ceil":
      return Math.ceil(t);

    case "floor":
      return Math.floor(t);

    default:
      throw new Error("Unknown roundingMode " + e);
  }
}

function ga(t) {
  var e = da(t),
      n = e[0],
      r = e[1],
      o = e[2];
  return 1 === n && 1 === r && 1 === o;
}

function ya(t, e) {
  return ga(t) || ga(e);
}

function xa(t) {
  if ("NHWC" === t) return "channelsLast";
  if ("NCHW" === t) return "channelsFirst";
  throw new Error("Unknown dataFormat " + t);
}

function ba(t, e, n) {
  if ("complex64" === e) {
    if ("complex64" === t.dtype) return t.clone();
    var r = Gn(t.shape),
        o = t.toFloat(),
        a = n.complex(o, r);
    return r.dispose(), o.dispose(), a;
  }

  if (!U(t.dtype, e)) return Lt.makeTensorFromDataId(t.dataId, t.shape, e);

  if ("complex64" === t.dtype) {
    var i = n.real(t);
    a = i.cast(e);
    return i.dispose(), a;
  }

  if ("int32" === e) return n.int(t);

  if ("bool" === e) {
    var s = On(0, t.dtype);
    a = n.notEqual(t, s);
    return s.dispose(), a;
  }

  throw new Error("Error in Cast: failed to cast " + t.dtype + " to " + e);
}

function wa(t, e) {
  return Lt.makeTensorFromDataId(t.dataId, e, t.dtype);
}

function Ca(t, e, n) {
  var r = (e - t) / (n - 1),
      o = tt(n, "float32");
  o[0] = t;

  for (var a = 1; a < o.length; a++) o[a] = o[a - 1] + r;

  return Mn(o, "float32");
}

var Ea = Object.freeze({
  castTensor: ba,
  reshapeTensor: wa,
  linspaceImpl: Ca,
  upcastType: Tt,
  axesAreInnerMostDims: yn,
  combineLocations: xn,
  computeOutAndReduceShapes: bn,
  expandShapeToKeepDim: wn,
  assertAxesAreInnerMostDims: Cn,
  getAxesPermutation: En,
  getUndoAxesPermutation: Rn,
  getInnerMostAxes: In,
  getBroadcastDims: Dr,
  getReductionAxes: Nr,
  assertAndGetBroadcastShape: Fr,
  assertParamsConsistent: kn,
  computeOutShape: Sn,
  computePool2DInfo: ua,
  computePool3DInfo: ca,
  computeConv2DInfo: la,
  computeConv3DInfo: ha,
  computeDefaultPad: fa,
  tupleValuesAreOne: ga,
  eitherStridesOrDilationsAreOne: ya,
  convertConv2DDataFormat: xa,
  PARALLELIZE_THRESHOLD: Bo,
  computeOptimalWindowSize: Po
});
exports.backend_util = Ea;

function Ra(t, e) {
  if (t.length !== e.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t.length + ", imag: " + e.length + ".");

  for (var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2) n[r] = t[r / 2], n[r + 1] = e[r / 2];

  return n;
}

function Ia(t, e) {
  return {
    real: t[2 * e],
    imag: t[2 * e + 1]
  };
}

function ka(t, e, n, r) {
  t[2 * r] = e, t[2 * r + 1] = n;
}

function Sa(t, e, n) {
  var r = (n ? 2 : -2) * Math.PI * (t / e);
  return {
    real: Math.cos(r),
    imag: Math.sin(r)
  };
}

function Aa(t, e, n) {
  var r = function (t, e, n) {
    return function (t, e, n) {
      var r = 0,
          o = t.length,
          a = 0,
          i = !1;

      for (; r < o;) {
        var s = n(e, t[a = r + (o - r >>> 1)]);
        s > 0 ? r = a + 1 : (o = a, i = !s);
      }

      return i ? r : -r - 1;
    }(t, e, n || Ta);
  }(t, e, n),
      o = r < 0 ? -(r + 1) : r;

  t.splice(o, 0, e);
}

function Ta(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}

function Da(t, e, n, r, o) {
  return Fa(t, e, n, r, o, 0).selectedIndices;
}

function Na(t, e, n, r, o, a) {
  var i = Fa(t, e, n, r, o, a, !0);
  return i.numValidOutputs.dispose(), {
    selectedIndices: i.selectedIndices,
    selectedScores: i.selectedScores
  };
}

function Fa(t, e, n, r, o, a, i, s) {
  void 0 === i && (i = !1), void 0 === s && (s = !1);

  for (var u = Array.from(e).map(function (t, e) {
    return {
      score: t,
      boxIndex: e,
      suppressBeginIndex: 0
    };
  }).filter(function (t) {
    return t.score > o;
  }).sort(Ma), c = a > 0 ? -.5 / a : 0, l = [], h = []; l.length < n && u.length > 0;) {
    var f = u.pop(),
        d = f.score,
        p = f.boxIndex,
        v = f.suppressBeginIndex;
    if (d < o) break;

    for (var m = !1, g = l.length - 1; g >= v; --g) {
      var y = _a(t, p, l[g]);

      if (y >= r) {
        m = !0;
        break;
      }

      if (f.score = f.score * Oa(r, c, y), f.score <= o) break;
    }

    f.suppressBeginIndex = l.length, m || (f.score === d ? (l.push(p), h.push(f.score)) : f.score > o && Aa(u, f, Ma));
  }

  var x = l.length;
  return s && (l.fill(0, x), h.fill(0, x)), {
    selectedIndices: Mn(l, "int32"),
    selectedScores: Mn(h, "float32"),
    numValidOutputs: On(x, "int32")
  };
}

function _a(t, e, n) {
  var r = t.subarray(4 * e, 4 * e + 4),
      o = t.subarray(4 * n, 4 * n + 4),
      a = Math.min(r[0], r[2]),
      i = Math.min(r[1], r[3]),
      s = Math.max(r[0], r[2]),
      u = Math.max(r[1], r[3]),
      c = Math.min(o[0], o[2]),
      l = Math.min(o[1], o[3]),
      h = Math.max(o[0], o[2]),
      f = Math.max(o[1], o[3]),
      d = (s - a) * (u - i),
      p = (h - c) * (f - l);
  if (d <= 0 || p <= 0) return 0;
  var v = Math.max(a, c),
      m = Math.max(i, l),
      g = Math.min(s, h),
      y = Math.min(u, f),
      x = Math.max(g - v, 0) * Math.max(y - m, 0);
  return x / (d + p - x);
}

function Oa(t, e, n) {
  var r = Math.exp(e * n * n);
  return n <= t ? r : 0;
}

function Ma(t, e) {
  return t.score - e.score || t.score === e.score && e.boxIndex - t.boxIndex;
}

function Ba(t, e, n) {
  var r = new Array(t.rank).fill(0),
      o = t.shape.slice();
  return e.map(function (e) {
    o[n] = e;
    var a = t.slice(r, o);
    return r[n] += e, a;
  });
}

function Pa(t, e) {
  for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[r] * e[r];

  var o = er(n, t.dtype);

  for (r = 0; r < o.values.length; ++r) {
    for (var a = o.indexToLoc(r), i = new Array(t.rank), s = 0; s < i.length; s++) i[s] = a[s] % t.shape[s];

    var u = t.locToIndex(i);
    o.values[r] = t.values[u];
  }

  return o.toTensor();
}

function La(t, e, n, r, o) {
  for (var a = e[e.length - 1], i = [t.length / a, a], s = i[0], u = i[1], c = B(n, s * r), l = B("int32", s * r), h = 0; h < s; h++) {
    for (var f = h * u, d = t.subarray(f, f + u), p = [], v = 0; v < d.length; v++) p.push({
      value: d[v],
      index: v
    });

    p.sort(function (t, e) {
      return e.value - t.value;
    });
    var m = h * r,
        g = c.subarray(m, m + r),
        y = l.subarray(m, m + r);

    for (v = 0; v < r; v++) g[v] = p[v].value, y[v] = p[v].index;
  }

  var x = e.slice();
  return x[x.length - 1] = r, [Fn(c, x, n), Fn(l, x, "int32")];
}

function Wa(t, e) {
  for (var n = [], r = 0; r < e.length; r++) e[r] && n.push(r);

  var o = er(t, "int32"),
      a = er([n.length, t.length], "int32");

  for (r = 0; r < n.length; r++) {
    var i = o.indexToLoc(n[r]),
        s = r * t.length;
    a.values.set(i, s);
  }

  return a.toTensor();
}

var Ua = function (t, e) {
  this.outputShape = [], this.outputShape = t, this.variableNames = e.map(function (t, e) {
    return "T" + e;
  });
  var n = [];
  this.variableNames.forEach(function (t) {
    n.push("float v" + t + " = get" + t + "AtOutCoords();");
  });
  var r = this.variableNames.map(function (t) {
    return "v" + t;
  }).join(" + ");
  this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        float result = " + r + ";\n        setOutput(result);\n      }\n    ";
},
    Va = function (t, e) {
  this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map(function (t, e) {
    return "T" + e;
  });
  var n = [];
  this.variableNames.forEach(function (t) {
    n.push("vec4 v" + t + " = get" + t + "AtOutCoords();");
  });
  var r = this.variableNames.map(function (t) {
    return "v" + t;
  }).join(" + ");
  this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        vec4 result = " + r + ";\n        setOutput(result);\n      }\n    ";
},
    za = function (t, e, n) {
  this.variableNames = ["A"];
  var r = t.windowSize,
      o = t.batchSize,
      a = t.inSize,
      i = Math.ceil(a / r);
  n || this.variableNames.push("bestIndicesA"), this.outputShape = [o, i];
  var s = "max" === e ? ">" : "<",
      u = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
  this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r + "; i++) {\n          int inIdx = " + u + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + s + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
};

function Ga(t, e) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, e).map(function (e) {
    return t + "." + e;
  });
}

function Ha(t, e) {
  return 1 === e ? [t] : Ga(t, e);
}

function qa() {
  var t, e, n, r, o, a, s, u, c, l;
  return 2 === i().getNumber("WEBGL_VERSION") ? (t = "#version 300 es", e = "in", n = "out", r = "in", o = "texture", a = "outputColor", s = "out vec4 outputColor;", u = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", c = "", l = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t = "", e = "attribute", n = "varying", r = "varying", o = "texture2D", a = "gl_FragColor", s = "", u = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", c = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
    version: t,
    attribute: e,
    varyingVs: n,
    varyingFs: r,
    texture2D: o,
    output: a,
    defineOutput: s,
    defineSpecialNaN: u,
    defineSpecialInf: c,
    defineRound: l
  };
}

function Ka(t, e, n) {
  void 0 === n && (n = "index");
  var r = $(e);
  return r.map(function (e, o) {
    return "int " + t[o] + " = " + n + " / " + e + "; " + (o === r.length - 1 ? "int " + t[o + 1] + " = " + n + " - " + t[o] + " * " + e : "index -= " + t[o] + " * " + e) + ";";
  }).join("");
}

function ja(t) {
  var e = $(t).map(function (t) {
    return t.toString();
  });
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e[0] + " + coords.y * " + e[1] + " + coords.z;\n  }\n";
}

var Xa = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";

function Ya(t, e, n, r) {
  var o = [];
  t.forEach(function (t) {
    var e = k(t.shapeInfo.logicalShape);
    t.shapeInfo.isUniform ? o.push("uniform float " + t.name + (e > 1 ? "[" + e + "]" : "") + ";") : (o.push("uniform sampler2D " + t.name + ";"), o.push("uniform int offset" + t.name + ";"));
  });

  var a,
      i,
      s = o.join("\n"),
      u = t.map(function (t) {
    return function (t, e, n) {
      void 0 === n && (n = !1);
      var r = "";
      r += n ? Qa(t) : $a(t);
      var o = t.shapeInfo.logicalShape,
          a = e.logicalShape;
      o.length <= a.length && (r += n ? function (t, e) {
        var n,
            r = t.name,
            o = r.charAt(0).toUpperCase() + r.slice(1),
            a = "get" + o + "AtOutCoords",
            i = t.shapeInfo.logicalShape.length,
            s = e.logicalShape.length,
            u = Dr(t.shapeInfo.logicalShape, e.logicalShape),
            c = oi(s),
            l = s - i,
            h = ["x", "y", "z", "w", "u", "v"];
        n = 0 === i ? "" : s < 2 && u.length >= 1 ? "coords = 0;" : u.map(function (t) {
          return "coords." + h[t + l] + " = 0;";
        }).join("\n");
        var f = "";
        f = s < 2 && i > 0 ? "coords" : t.shapeInfo.logicalShape.map(function (t, e) {
          return "coords." + h[e + l];
        }).join(", ");
        var d = "return outputValue;",
            p = 1 === k(t.shapeInfo.logicalShape),
            v = 1 === k(e.logicalShape);

        if (1 !== i || p || v) {
          if (p && !v) d = 1 === s ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";else if (u.length) {
            var m = i - 2,
                g = i - 1;
            u.indexOf(m) > -1 && u.indexOf(g) > -1 ? d = "return vec4(outputValue.x);" : u.indexOf(m) > -1 ? d = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u.indexOf(g) > -1 && (d = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else d = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";

        return "\n    vec4 " + a + "() {\n      " + c + " coords = getOutputCoords();\n      " + n + "\n      vec4 outputValue = get" + o + "(" + f + ");\n      " + d + "\n    }\n  ";
      }(t, e) : function (t, e) {
        var n = t.name,
            r = n.charAt(0).toUpperCase() + n.slice(1),
            o = "get" + r + "AtOutCoords",
            a = e.texShape,
            i = t.shapeInfo.texShape,
            s = t.shapeInfo.logicalShape.length,
            u = e.logicalShape.length;
        if (!t.shapeInfo.isUniform && s === u && null == t.shapeInfo.flatOffset && S(i, a)) return "\n      float " + o + "() {\n        return sampleTexture(" + n + ", resultUV);\n      }\n    ";
        var c,
            l = oi(u),
            h = Dr(t.shapeInfo.logicalShape, e.logicalShape),
            f = u - s,
            d = ["x", "y", "z", "w", "u", "v"];
        c = 0 === s ? "" : u < 2 && h.length >= 1 ? "coords = 0;" : h.map(function (t) {
          return "coords." + d[t + f] + " = 0;";
        }).join("\n");
        var p = "";
        p = u < 2 && s > 0 ? "coords" : t.shapeInfo.logicalShape.map(function (t, e) {
          return "coords." + d[e + f];
        }).join(", ");
        return "\n    float " + o + "() {\n      " + l + " coords = getOutputCoords();\n      " + c + "\n      return get" + r + "(" + p + ");\n    }\n  ";
      }(t, e));
      return r;
    }(t, e, r);
  }).join("\n"),
      c = e.texShape,
      l = qa(),
      h = function (t) {
    return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t.texture2D + "(textureSampler, uv).r;\n    }\n  ";
  }(l),
      f = function (t) {
    return t.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t.varyingFs + " vec2 resultUV;\n    " + t.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t.defineSpecialNaN + "\n    " + t.defineSpecialInf + "\n    " + t.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + Ja + "\n    " + Za + "\n    " + ti + "\n  ";
  }(l);

  return e.isPacked ? (a = function (t, e) {
    switch (t.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (t, e) {
          var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
          if (1 === n[0]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n[1] + ".0);\n      }\n    ";
          if (1 === n[1]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      return 2 * (resTexRC.x * " + n[1] + " + resTexRC.y);\n    }\n  ";
        }(0, e);

      case 2:
        return function (t, e) {
          var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
          if (S(t, e)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n[0] + ", " + n[1] + "));\n      }\n    ";
          var r = Math.ceil(t[1] / 2);
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
        }(t, e);

      case 3:
        return n = t, r = e, o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], a = Math.ceil(n[2] / 2), i = a * Math.ceil(n[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + o[0] + ", " + o[1] + "));\n      int index = resTexRC.x * " + o[1] + " + resTexRC.y;\n\n      int b = index / " + i + ";\n      index -= b * " + i + ";\n\n      int r = 2 * (index / " + a + ");\n      int c = imod(index, " + a + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";

      default:
        return function (t, e) {
          for (var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)], r = Math.ceil(t[t.length - 1] / 2), o = r * Math.ceil(t[t.length - 2] / 2), a = o, i = "", s = "b, r, c", u = 2; u < t.length - 1; u++) a *= t[t.length - u - 1], i = "\n      int b" + u + " = index / " + a + ";\n      index -= b" + u + " * " + a + ";\n    " + i, s = "b" + u + ", " + s;

          return "\n    ivec" + t.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n\n      " + i + "\n\n      int b = index / " + o + ";\n      index -= b * " + o + ";\n\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec" + t.length + "(" + s + ");\n    }\n  ";
        }(t, e);
    }

    var n, r, o, a, i;
  }(e.logicalShape, c), i = function (t) {
    return "\n    void setOutput(vec4 val) {\n      " + t.output + " = val;\n    }\n  ";
  }(l)) : (a = function (t, e) {
    switch (t.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (t, e) {
          if (1 === e[0]) return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e[1] + ".0);\n      }\n    ";
          if (1 === e[1]) return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      return resTexRC.x * " + e[1] + " + resTexRC.y;\n    }\n  ";
        }(0, e);

      case 2:
        return function (t, e) {
          if (S(t, e)) return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e[0] + ", " + e[1] + "));\n      }\n    ";
          if (1 === t[1]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
          if (1 === t[0]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      int r = index / " + t[1] + ";\n      int c = index - r * " + t[1] + ";\n      return ivec2(r, c);\n    }\n  ";
        }(t, e);

      case 3:
        return n = e, r = Ka(["r", "c", "d"], t), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      " + r + "\n      return ivec3(r, c, d);\n    }\n  ";

      case 4:
        return function (t, e) {
          var n = Ka(["r", "c", "d", "d2"], t);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      " + n + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
        }(t, e);

      case 5:
        return function (t, e) {
          var n = Ka(["r", "c", "d", "d2", "d3"], t);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e[0] + ",\n                             " + e[1] + "));\n\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
        }(t, e);

      case 6:
        return function (t, e) {
          var n = Ka(["r", "c", "d", "d2", "d3", "d4"], t);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
        }(t, e);

      default:
        throw new Error(t.length + "-D output sampling is not yet supported");
    }

    var n, r;
  }(e.logicalShape, c), i = function (t) {
    return "\n    void setOutput(float val) {\n      " + t.output + " = vec4(val, 0, 0, 0);\n    }\n  ";
  }(l)), r && (f += ei), [f, h, i, s, a, u, n].join("\n");
}

function $a(t) {
  var e = t.shapeInfo.logicalShape;

  switch (e.length) {
    case 0:
      return function (t) {
        var e = t.name,
            n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
        if (t.shapeInfo.isUniform) return "float " + n + "() {return " + e + ";}";
        var r = t.shapeInfo.texShape,
            o = r[0],
            a = r[1];
        if (1 === o && 1 === a) return "\n      float " + n + "() {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
        var i = t.shapeInfo.texShape,
            s = i[0],
            u = i[1],
            c = ni(e);
        return "\n    float " + n + "() {\n      vec2 uv = uvFromFlat(" + s + ", " + u + ", " + c + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  ";
      }(t);

    case 1:
      return function (t) {
        var e = t.name,
            n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
        if (t.shapeInfo.isUniform) return "\n      float " + n + "(int index) {\n        " + ri(t) + "\n      }\n    ";
        var r = t.shapeInfo.texShape,
            o = r[0],
            a = r[1];
        if (1 === a && 1 === o) return "\n      float " + n + "(int index) {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
        var i = ni(e);
        if (1 === a) return "\n      float " + n + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + i + ") + 0.5) / " + o + ".0);\n        return sampleTexture(" + e + ", uv);\n      }\n    ";
        if (1 === o) return "\n      float " + n + "(int index) {\n        vec2 uv = vec2((float(index + " + i + ") + 0.5) / " + a + ".0, 0.5);\n        return sampleTexture(" + e + ", uv);\n      }\n    ";
        return "\n    float " + n + "(int index) {\n      vec2 uv = uvFromFlat(" + o + ", " + a + ", index + " + i + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  ";
      }(t);

    case 2:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = t.shapeInfo.texShape;

        if (null != o && S(e, o)) {
          var a = o[0],
              i = o[1];
          return "\n    float " + r + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        }

        var s = M(e),
            u = s.newShape,
            c = s.keptDims,
            l = u;

        if (l.length < e.length) {
          var h = ai(t, l);
          return "\n      " + $a(h) + "\n      float " + r + "(int row, int col) {\n        return " + r + "(" + ii(["row", "col"], c) + ");\n      }\n    ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e[1] + ", 1)));\n        " + ri(t) + "\n      }\n    ";
        var f = o[0],
            d = o[1],
            p = ni(n);
        if (1 === d) return "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        if (1 === f) return "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + d + ".0, 0.5);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        return "\n  float " + r + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e[1] + " + col + " + p + ";\n    vec2 uv = uvFromFlat(" + f + ", " + d + ", index);\n    return sampleTexture(" + n + ", uv);\n  }\n";
      }(t);

    case 3:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = e[1] * e[2],
            a = e[2],
            i = M(e),
            s = i.newShape,
            u = i.keptDims,
            c = s;

        if (c.length < e.length) {
          var l = ai(t, c);
          return "\n        " + $a(l) + "\n        float " + r + "(int row, int col, int depth) {\n          return " + r + "(" + ii(["row", "col", "depth"], u) + ");\n        }\n      ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + o + ", " + a + ", 1)));\n        " + ri(t) + "\n      }\n    ";
        var h = t.shapeInfo.texShape,
            f = h[0],
            d = h[1],
            p = t.shapeInfo.flatOffset;
        if (d === o && null == p) return "\n        float " + r + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + a + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + d + ".0, " + f + ".0);\n          return sampleTexture(" + n + ", uv);\n        }\n      ";
        if (d === a && null == p) return "\n    float " + r + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + d + ".0, " + f + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        var v = ni(n);
        return "\n      float " + r + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + o + " + col * " + a + " + depth + " + v + ";\n        vec2 uv = uvFromFlat(" + f + ", " + d + ", index);\n        return sampleTexture(" + n + ", uv);\n      }\n  ";
      }(t);

    case 4:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = e[3],
            a = e[2] * o,
            i = e[1] * a,
            s = M(e),
            u = s.newShape,
            c = s.keptDims;

        if (u.length < e.length) {
          var l = ai(t, u);
          return "\n      " + $a(l) + "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        return " + r + "(" + ii(["row", "col", "depth", "depth2"], c) + ");\n      }\n    ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + i + ", " + a + ", " + o + ", 1)));\n        " + ri(t) + "\n      }\n    ";
        var h = t.shapeInfo.flatOffset,
            f = t.shapeInfo.texShape,
            d = f[0],
            p = f[1];
        if (p === i && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + a + ", " + o + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + p + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        if (p === o && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e[1] * e[2] + ", " + e[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + p + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        var v = ni(n);
        return "\n    float " + r + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + i + " + col * " + a + " +\n          depth * " + o + " + depth2;\n      vec2 uv = uvFromFlat(" + d + ", " + p + ", index + " + v + ");\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
      }(t);

    case 5:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = e[4],
            a = e[3] * o,
            i = e[2] * a,
            s = e[1] * i,
            u = M(e),
            c = u.newShape,
            l = u.keptDims;

        if (c.length < e.length) {
          var h = ai(t, c);
          return "\n      " + $a(h) + "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r + "(" + ii(["row", "col", "depth", "depth2", "depth3"], l) + ");\n      }\n    ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + s + ", " + i + ", " + a + ", " + o + ")) +\n          depth3;\n        " + ri(t) + "\n      }\n    ";
        var f = t.shapeInfo.flatOffset,
            d = t.shapeInfo.texShape,
            p = d[0],
            v = d[1];
        if (v === s && null == f) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + i + ", " + a + ", " + o + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v + ".0, " + p + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        if (v === o && null == f) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] + ",\n               " + e[2] * e[3] + ", " + e[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v + ".0, " + p + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        var m = ni(n);
        return "\n    float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + s + " + col * " + i + " + depth * " + a + " +\n          depth2 * " + o + " + depth3 + " + m + ";\n      vec2 uv = uvFromFlat(" + p + ", " + v + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
      }(t);

    case 6:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = M(e),
            a = o.newShape,
            i = o.keptDims;

        if (a.length < e.length) {
          var s = ai(t, a);
          return "\n      " + $a(s) + "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r + "(" + ii(["row", "col", "depth", "depth2", "depth3", "depth4"], i) + ");\n      }\n    ";
        }

        var u = e[5],
            c = e[4] * u,
            l = e[3] * c,
            h = e[2] * l,
            f = e[1] * h;
        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f + ", " + h + ", " + l + ", " + c + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + u + ", 1)));\n        " + ri(t) + "\n      }\n    ";
        var d = t.shapeInfo.flatOffset,
            p = t.shapeInfo.texShape,
            v = p[0],
            m = p[1];
        if (m === f && null == d) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h + ", " + l + ", " + c + ", " + u + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        if (m === u && null == d) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] * e[4] + ",\n               " + e[2] * e[3] * e[4] + ",\n               " + e[3] * e[4] + ",\n               " + e[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        var g = ni(n);
        return "\n    float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f + " + col * " + h + " + depth * " + l + " +\n          depth2 * " + c + " + depth3 * " + u + " + depth4 + " + g + ";\n      vec2 uv = uvFromFlat(" + v + ", " + m + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
      }(t);

    default:
      throw new Error(e.length + "-D input sampling is not yet supported");
  }
}

function Qa(t) {
  var e, n, r;

  switch (t.shapeInfo.logicalShape.length) {
    case 0:
      return e = t.name, n = "get" + e.charAt(0).toUpperCase() + e.slice(1), r = qa(), "\n    vec4 " + n + "() {\n      return " + r.texture2D + "(" + e + ", halfCR);\n    }\n  ";

    case 1:
      return function (t) {
        var e = t.name,
            n = "get" + e.charAt(0).toUpperCase() + e.slice(1),
            r = t.shapeInfo.texShape,
            o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],
            a = qa();
        return "\n    vec4 " + n + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + o[0] + ", " + o[1] + ", index);\n      return " + a.texture2D + "(" + e + ", uv);\n    }\n  ";
      }(t);

    case 2:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = t.shapeInfo.texShape,
            a = o[0],
            i = o[1],
            s = qa();
        if (null != o && S(e, o)) return "\n      vec4 " + r + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n\n        return " + s.texture2D + "(" + n + ", uv);\n      }\n    ";
        var u = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],
            c = Math.ceil(e[1] / 2);
        return "\n    vec4 " + r + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c + ", " + u[0] + ", " + u[1] + ", row, col);\n      return " + s.texture2D + "(" + n + ", uv);\n    }\n  ";
      }(t);

    case 3:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = t.shapeInfo.texShape,
            a = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];

        if (1 === e[0]) {
          var i = e.slice(1),
              s = ai(t, i);
          return "\n        " + Qa(s) + "\n        vec4 " + r + "(int b, int row, int col) {\n          return " + r + "(" + ii(["b", "row", "col"], [1, 2]) + ");\n        }\n      ";
        }

        var u = a[0],
            c = a[1],
            l = Math.ceil(e[2] / 2),
            h = l * Math.ceil(e[1] / 2),
            f = qa();
        return "\n    vec4 " + r + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + u + ", " + c + ", " + h + ", " + l + ", b, row, col);\n      return " + f.texture2D + "(" + n + ", uv);\n    }\n  ";
      }(t);

    default:
      return function (t) {
        for (var e = t.shapeInfo.logicalShape, n = e.length, r = t.name, o = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = t.shapeInfo.texShape, i = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)], s = i[0], u = i[1], c = Math.ceil(e[n - 1] / 2), l = c * Math.ceil(e[n - 2] / 2), h = "int b, int row, int col", f = "b * " + l + " + (row / 2) * " + c + " + (col / 2)", d = 2; d < n - 1; d++) h = "int b" + d + ", " + h, l *= e[n - d - 1], f = "b" + d + " * " + l + " + " + f;

        var p = qa();
        return "\n    vec4 " + o + "(" + h + ") {\n      int index = " + f + ";\n      int texR = index / " + u + ";\n      int texC = index - texR * " + u + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + u + ", " + s + ");\n      return " + p.texture2D + "(" + r + ", uv);\n    }\n  ";
      }(t);
  }
}

var Ja = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Za = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    ti = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    ei = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

function ni(t) {
  return "offset" + t;
}

function ri(t) {
  var e = t.name,
      n = k(t.shapeInfo.logicalShape);
  return n < 2 ? "return " + e + ";" : "\n    for (int i = 0; i < " + n + "; i++) {\n      if (i == index) {\n        return " + e + "[i];\n      }\n    }\n  ";
}

function oi(t) {
  if (t <= 1) return "int";
  if (2 === t) return "ivec2";
  if (3 === t) return "ivec3";
  if (4 === t) return "ivec4";
  if (5 === t) return "ivec5";
  if (6 === t) return "ivec6";
  throw Error("GPU for rank " + t + " is not yet supported");
}

function ai(t, e) {
  var n = JSON.parse(JSON.stringify(t));
  return n.shapeInfo.logicalShape = e, n;
}

function ii(t, e) {
  return e.map(function (e) {
    return t[e];
  }).join(", ");
}

var si = function (t, e, n, r) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, C(t.length > 2, function () {
    return "Packed arg" + (n.charAt(0).toUpperCase() + n.slice(1)) + " supports only inputs with rank above 2.";
  });
  var o = t[t.length - 1],
      a = Math.ceil(o / e);
  this.outputShape = t.slice(0, -1), a > 1 && this.outputShape.push(a), r || this.variableNames.push("bestIndicesA");
  var i,
      s,
      u = this.outputShape,
      c = u.length,
      l = oi(c),
      h = Ha("coords", c);

  if (1 === a) {
    var f = oi(s = c + 1);
    i = "\n        " + f + " sourceLocR = " + f + "(" + h.join() + ", 0);\n        ++" + h[c - 1] + ";\n        " + f + " sourceLocG = " + f + "(" + h.join() + ", 0);\n        ++" + h[c - 2] + ";\n        " + f + " sourceLocA = " + f + "(" + h.join() + ", 0);\n        --" + h[c - 1] + ";\n        " + f + " sourceLocB = " + f + "(" + h.join() + ", 0);\n        --" + h[c - 2] + ";";
  } else s = c, i = "\n        " + l + " sourceLocR = coords;\n        ++" + h[c - 1] + ";\n        " + l + " sourceLocG = coords;\n        ++" + h[c - 2] + ";\n        " + l + " sourceLocA = coords;\n        --" + h[c - 1] + ";\n        " + l + " sourceLocB = coords;\n        --" + h[c - 2] + ";";

  var d = ["x", "y", "z", "w", "u", "v"].slice(0, s),
      p = "." + d[s - 1],
      v = d.map(function (t) {
    return "int " + t;
  }),
      m = Ha("sourceLocR", s - 1).concat("inIdx.r"),
      g = Ha("sourceLocG", s - 1).concat("inIdx.g"),
      y = Ha("sourceLocB", s - 1).concat("inIdx.b"),
      x = Ha("sourceLocA", s - 1).concat("inIdx.a"),
      b = "max" === n ? "greaterThan" : "lessThan",
      w = r ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m.join() + "),\n                             getBestIndicesAChannel(" + g.join() + "),\n                             getBestIndicesAChannel(" + y.join() + "),\n                             getBestIndicesAChannel(" + x.join() + ")));",
      E = "vec4(\n            getAChannel(" + m.join() + "),\n            hasNextCol ? getAChannel(" + g.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + y.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + x.join() + ") : 0.)",
      R = r ? "" : "\n      float getBestIndicesAChannel(" + v.join() + ") {\n        return getChannel(getBestIndicesA(" + d.join() + "),\n                                          vec2(" + d.slice(-2).join() + "));\n      }";
  this.userCode = "\n      float getAChannel(" + v.join() + ") {\n        return getChannel(getA(" + d.join() + "),\n                               vec2(" + d.slice(-2).join() + "));\n      }\n      " + R + "\n      void main() {\n        " + l + " coords = getOutputCoords();\n        bool hasNextCol = " + h[c - 1] + " < " + (u[c - 1] - 1) + ";\n        bool hasNextRow = " + h[c - 2] + " < " + (u[c - 2] - 1) + ";\n        " + i + "\n        ivec4 srcIdx = ivec4(sourceLocR" + p + ", sourceLocG" + p + ",\n          sourceLocB" + p + ", sourceLocA" + p + ") * " + e + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + E + ";\n\n        for (int i = 0; i < " + e + "; i++) {\n          inIdx = srcIdx;\n          " + w + "\n          vec4 candidate = " + E + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + b + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
},
    ui = function (t) {
  this.variableNames = ["dy"], this.outputShape = t.inShape;
  var e = t.filterHeight,
      n = t.filterWidth,
      r = t.strideHeight,
      o = t.strideWidth,
      a = t.dilationHeight,
      i = t.dilationWidth,
      s = t.effectiveFilterHeight,
      u = t.effectiveFilterWidth,
      c = s - 1 - t.padInfo.top,
      l = u - 1 - t.padInfo.left,
      h = 1 / (e * n);
  this.userCode = "\n      const ivec2 pads = ivec2(" + c + ", " + l + ");\n      const float avgMultiplier = float(" + h + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + s + ";\n            wR += " + a + ") {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + u + ";\n            wC+= " + i + ") {\n            float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    ci = function (t) {
  this.variableNames = ["dy"], this.outputShape = t.inShape;
  var e = t.filterDepth,
      n = t.filterHeight,
      r = t.filterWidth,
      o = t.strideDepth,
      a = t.strideHeight,
      i = t.strideWidth,
      s = t.dilationDepth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.effectiveFilterDepth,
      h = t.effectiveFilterHeight,
      f = t.effectiveFilterWidth,
      d = l - 1 - t.padInfo.front,
      p = h - 1 - t.padInfo.top,
      v = f - 1 - t.padInfo.left,
      m = 1 / (e * n * r);
  this.userCode = "\n      const ivec3 pads = ivec3(" + d + ", " + p + ", " + v + ");\n      const float avgMultiplier = float(" + m + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + s + ") {\n          float dyD = float(dyDCorner + wD) / " + o + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h + ";\n              wR += " + u + ") {\n            float dyR = float(dyRCorner + wR) / " + a + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + f + ";\n                wC += " + c + ") {\n              float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    li = function (t, e, n, r, o, a) {
  this.outputShape = [], this.variableNames = ["x", "mean", "variance"], Fr(t, e), Fr(t, n);
  var i = "0.0";
  null != r && (Fr(t, r), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
  var s = "1.0";
  null != o && (Fr(t, o), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + i + ";\n        float scale = " + s + ";\n        float inv = scale * inversesqrt(variance + float(" + a + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
},
    hi = function (t, e, n, r, o, a) {
  this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], Fr(t, e), Fr(t, n);
  var i = "vec4(0.0)";
  null != r && (Fr(t, r), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
  var s = "vec4(1.0)";
  null != o && (Fr(t, o), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        vec4 offset = " + i + ";\n        vec4 scale = " + s + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + a + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
},
    fi = "return areal * breal - aimag * bimag;",
    di = "return areal * bimag + aimag * breal;",
    pi = function (t, e, n) {
  this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = Fr(e, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
},
    vi = "return a + b;",
    mi = "return a - b;",
    gi = "return a * b;",
    yi = "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
    xi = "return (a < 0.) ? b * a : a;",
    bi = function (t, e, n) {
  this.variableNames = ["A", "B"], this.outputShape = Fr(e, n), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
},
    wi = "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
    Ci = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    Ei = function (t, e, n, r) {
  void 0 === r && (r = !1), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Fr(e, n);
  var o = this.outputShape.length,
      a = "";
  if (r) if (0 === o || 1 === k(this.outputShape)) a = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if (a = "\n          " + oi(o) + " coords = getOutputCoords();\n        ", 1 === o) a += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else {
    var i = Ha("coords", o);
    a += "\n            bool nextRowOutOfBounds =\n              (" + i[o - 2] + " + 1) >= " + this.outputShape[o - 2] + ";\n            bool nextColOutOfBounds =\n              (" + i[o - 1] + " + 1) >= " + this.outputShape[o - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
  }
  this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + a + "\n\n        setOutput(result);\n      }\n    ";
},
    Ri = function () {
  function t(t) {
    this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t, e) {
    var n = this;
    return function (r, o) {
      null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(o, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);
    };
  }, t;
}(),
    Ii = function () {
  function t(t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t, e) {
    var n = this;
    return function (r, o) {
      null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(o, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);
    };
  }, t;
}(),
    ki = function (t) {
  this.variableNames = ["real", "imag"], this.outputShape = t, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
},
    Si = function (t) {
  this.outputShape = [], this.outputShape = Sn(t, 1), this.variableNames = t.map(function (t, e) {
    return "T" + e;
  });
  var e = new Array(t.length - 1);
  e[0] = t[0][1];

  for (var n = 1; n < e.length; n++) e[n] = e[n - 1] + t[n][1];

  var r = ["if (yC < " + e[0] + ") setOutput(getT0(yR, yC));"];

  for (n = 1; n < e.length; n++) {
    var o = e[n - 1];
    r.push("else if (yC < " + e[n] + ") setOutput(getT" + n + "(yR, yC-" + o + "));");
  }

  var a = e.length,
      i = e[e.length - 1];
  r.push("else setOutput(getT" + a + "(yR, yC-" + i + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r.join("\n        ") + "\n      }\n    ";
},
    Ai = function (t, e) {
  this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = Sn(t, e);
  var n = this.outputShape,
      r = n.length,
      o = oi(r),
      a = Ha("coords", r),
      i = ["x", "y", "z", "w", "u", "v"].slice(0, r);
  this.variableNames = t.map(function (t, e) {
    return "T" + e;
  });
  var s = new Array(t.length - 1);
  s[0] = t[0][e];

  for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + t[u][e];

  var c = i[e],
      l = i.slice(-2),
      h = i.join(),
      f = "if (" + c + " < " + s[0] + ") {\n        return getChannel(\n            getT0(" + h + "), vec2(" + l.join() + "));\n        }";

  for (u = 1; u < s.length; u++) {
    var d = s[u - 1];
    f += "\n        if (" + c + " < " + s[u] + "  && " + c + " >= " + s[u - 1] + ") {\n          return getChannel(\n            getT" + u + "(" + Ti(i, c, d) + "),\n            vec2(" + Ti(l, c, d) + "));\n        }";
  }

  var p = s.length,
      v = s[s.length - 1];
  f += "\n        return getChannel(\n          getT" + p + "(" + Ti(i, c, v) + "),\n          vec2(" + Ti(l, c, v) + "));", this.userCode = "\n      float getValue(" + i.map(function (t) {
    return "int " + t;
  }) + ") {\n        " + f + "\n      }\n\n      void main() {\n        " + o + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + a + "), 0., 0., 0.);\n\n        " + a[r - 1] + " = " + a[r - 1] + " + 1;\n        if (" + a[r - 1] + " < " + n[r - 1] + ") {\n          result.g = getValue(" + a + ");\n        }\n\n        " + a[r - 2] + " = " + a[r - 2] + " + 1;\n        if (" + a[r - 2] + " < " + n[r - 2] + ") {\n          result.a = getValue(" + a + ");\n        }\n\n        " + a[r - 1] + " = " + a[r - 1] + " - 1;\n        if (" + a[r - 2] + " < " + n[r - 2] + " &&\n            " + a[r - 1] + " < " + n[r - 1] + ") {\n          result.b = getValue(" + a + ");\n        }\n        setOutput(result);\n      }\n    ";
};

function Ti(t, e, n) {
  var r = t.indexOf(e);
  return t.map(function (t, e) {
    return e === r ? t + " - " + n : t;
  }).join();
}

var Di = function (t) {
  this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
  var e = t.strideHeight,
      n = t.strideWidth,
      r = t.padInfo.top,
      o = t.padInfo.left,
      a = "channelsLast" === t.dataFormat;
  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + o + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              if (" + a + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Ni = function (t) {
  this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
  var e = t.filterHeight,
      n = t.filterWidth,
      r = t.strideHeight,
      o = t.strideWidth,
      a = "channelsLast" === t.dataFormat,
      i = e - 1 - t.padInfo.top,
      s = n - 1 - t.padInfo.left,
      u = a ? 1 : 2,
      c = a ? 2 : 3,
      l = a ? 3 : 1;
  this.userCode = "\n      const ivec2 pads = ivec2(" + i + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l + "];\n\n        ivec2 dyCorner = ivec2(coords[" + u + "], coords[" + c + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n\n              if (" + a + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Fi = function (t) {
  this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
  var e = t.strideDepth,
      n = t.strideHeight,
      r = t.strideWidth,
      o = t.padInfo.front,
      a = t.padInfo.top,
      i = t.padInfo.left;
  this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t.outDepth + "; yF++) {\n            int xF = wF + yF * " + e + " - " + o + ";\n\n            if (xF < 0 || xF >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n              int xR = wR + yR * " + n + " - " + a + ";\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n                int xC = wC + yC * " + r + " - " + i + ";\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    _i = function (t) {
  this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
  var e = t.filterDepth,
      n = t.filterHeight,
      r = t.filterWidth,
      o = t.strideDepth,
      a = t.strideHeight,
      i = t.strideWidth,
      s = e - 1 - t.padInfo.front,
      u = n - 1 - t.padInfo.top,
      c = r - 1 - t.padInfo.left;
  this.userCode = "\n      const ivec3 pads = ivec3(" + s + ", " + u + ", " + c + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + o + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + a + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Oi = function (t) {
  this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
  var e = t.strideHeight,
      n = t.strideWidth,
      r = t.padInfo.top,
      o = t.padInfo.left,
      a = t.outChannels / t.inChannels;
  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + a + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + o + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Mi = function (t) {
  this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
  var e = t.filterHeight,
      n = t.filterWidth,
      r = t.strideHeight,
      o = t.strideWidth,
      a = e - 1 - t.padInfo.top,
      i = n - 1 - t.padInfo.left,
      s = t.outChannels / t.inChannels;
  this.userCode = "\n      const ivec2 pads = ivec2(" + a + ", " + i + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + s + "; dm++) {\n              int d2 = d1 * " + s + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Bi = function (t, e, n, r) {
  void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
  var o = t.padInfo.top,
      a = t.padInfo.left,
      i = t.strideHeight,
      s = t.strideWidth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.filterHeight,
      h = t.filterWidth,
      f = 4 * Math.floor(t.inChannels / 4),
      d = t.inChannels % 4,
      p = "channelsLast" === t.dataFormat,
      v = p ? 1 : 2,
      m = p ? 2 : 3,
      g = p ? 3 : 1,
      y = "",
      x = "";
  n && (y = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", x = "result = activation(result);");
  var b = e ? "result += getBiasAtOutCoords();" : "";
  e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y + "\n\n      const ivec2 strides = ivec2(" + i + ", " + s + ");\n      const ivec2 pads = ivec2(" + o + ", " + a + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v + "], coords[" + m + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l + "; wR++) {\n          int xR = xRCorner + wR * " + u + ";\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h + "; wC++) {\n            int xC = xCCorner + wC * " + c + ";\n\n            if (xC < 0 || xC >= " + t.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + p + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === d) + ") {\n\n              if (" + p + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f + ") *\n                    getW(wR, wC, " + f + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f + ", xR, xC) *\n                    getW(wR, wC, " + f + ", d2);\n              }\n\n            } else if (" + (2 === d) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f + ", d2),\n                getW(wR, wC, " + f + " + 1, d2)\n              );\n\n              if (" + p + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f + "),\n                  getX(batch, xR, xC, " + f + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f + ", xR, xC),\n                  getX(batch, " + f + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === d) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f + ", d2),\n                getW(wR, wC, " + f + " + 1, d2),\n                getW(wR, wC, " + f + " + 2, d2)\n              );\n\n              if (" + p + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f + "),\n                  getX(batch, xR, xC, " + f + " + 1),\n                  getX(batch, xR, xC, " + f + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f + ", xR, xC),\n                  getX(batch, " + f + " + 1, xR, xC),\n                  getX(batch, " + f + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + b + "\n        " + x + "\n        setOutput(result);\n      }\n    ";
},
    Pi = function (t) {
  this.variableNames = ["x", "W"], this.outputShape = t.outShape;
  var e = t.padInfo.front,
      n = t.padInfo.top,
      r = t.padInfo.left,
      o = t.strideDepth,
      a = t.strideHeight,
      i = t.strideWidth,
      s = t.dilationDepth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.filterDepth,
      h = t.filterHeight,
      f = t.filterWidth,
      d = 4 * Math.floor(t.inChannels / 4),
      p = t.inChannels % 4;
  this.userCode = "\n      const ivec3 strides = ivec3(" + o + ", " + a + ", " + i + ");\n      const ivec3 pads = ivec3(" + e + ", " + n + ", " + r + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l + "; wF++) {\n          int xF = xFCorner + wF * " + s + ";\n\n          if (xF < 0 || xF >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + "; wR++) {\n            int xR = xRCorner + wR * " + u + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + f + "; wC++) {\n              int xC = xCCorner + wC * " + c + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + d + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === p) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + d + ") *\n                  getW(wF, wR, wC, " + d + ", d2);\n              } else if (" + (2 === p) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + d + "),\n                  getX(batch, xF, xR, xC, " + d + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + d + ", d2),\n                  getW(wF, wR, wC, " + d + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === p) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + d + "),\n                  getX(batch, xF, xR, xC, " + d + " + 1),\n                  getX(batch, xF, xR, xC, " + d + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + d + ", d2),\n                  getW(wF, wR, wC, " + d + " + 1, d2),\n                  getW(wF, wR, wC, " + d + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Li = function (t, e, n, r) {
  void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
  var o = t.inHeight,
      a = t.inWidth,
      i = t.padInfo.top,
      s = t.padInfo.left,
      u = t.strideHeight,
      c = t.strideWidth,
      l = t.dilationHeight,
      h = t.dilationWidth,
      f = t.filterHeight,
      d = t.filterWidth,
      p = t.outChannels / t.inChannels,
      v = "",
      m = "";
  n && (v = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", m = "result = activation(result);");
  var g = e ? "result += getBiasAtOutCoords();" : "";
  e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v + "\n\n      const ivec2 strides = ivec2(" + u + ", " + c + ");\n      const ivec2 pads = ivec2(" + i + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + p + ";\n        int q = d2 - d1 * " + p + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f + "; wR++) {\n          int xR = xRCorner + wR * " + l + ";\n\n          if (xR < 0 || xR >= " + o + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + d + "; wC++) {\n            int xC = xCCorner + wC * " + h + ";\n\n            if (xC < 0 || xC >= " + a + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g + "\n        " + m + "\n        setOutput(result);\n      }\n    ";
},
    Wi = function (t, e, n, r) {
  void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.outShape;

  for (var o = t.inHeight, a = t.inWidth, i = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, f = t.filterHeight, d = t.filterWidth, p = d, v = "int xR; int xC; int xCOffset;", m = 0; m < f; m++) for (var g = 0; g < d; g++) v += "\n          vec4 xTexelR" + m + "C" + 2 * g + " = vec4(0.);\n          vec4 wR" + m + "C" + g + " = vec4(0.);\n          vec4 xR" + m + "C" + g + " = vec4(0.);";

  for (m = 0; m < f; m++) for (var y = 0; y < p; y++) {
    if (v += "\n          xR = xRCorner + " + m * l + ";\n          xC = xCCorner + " + (g = 2 * y) * h + ";\n        ", 1 === c) {
      if (g < d && (v += s % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + o + " && xCOffset >= 0 && xCOffset < " + a + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a + ") {\n                    xTexelR" + m + "C" + g + ".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + o + " && xCOffset >= 0 && xCOffset < " + a + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a + ") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR" + m + "C" + g + " = vec4(previous.zw, xTexelR" + m + "C" + g + ".xy);\n                } else {\n                  xR" + m + "C" + g + " = vec4(0, 0, xTexelR" + m + "C" + g + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + o + " && xC >= 0 && xC < " + a + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = xTexelR" + m + "C" + g + ";\n              ", g + 1 < d)) {
        var x = s % 2 == 0 ? b(h) : h;
        h % 2 == 0 && s % 2 == 1 || h % 2 != 0 && s % 2 != 1 ? (v += "\n                  xCOffset = xC + " + s % 2 + " + " + x + ";\n\n                  if(xR >= 0 && xR < " + o + " &&\n                    xCOffset >= 0 && xCOffset < " + a + ") {\n                    xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h > 1 && (v += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + o + " &&\n                      xCOffset >= 0 && xCOffset < " + a + ") {\n                      xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + m + "C" + g + " = vec4(0.);\n                    }\n                  "), v += "\n                  xR" + m + "C" + (g + 1) + " = vec4(\n                    xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".xy);\n                ") : v += "\n                  xCOffset = xC + " + x + ";\n\n                  if(xR >= 0 && xR < " + o + " &&\n                    xCOffset >= 0 && xCOffset < " + a + ") {\n                    xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + m + "C" + (g + 1) + " = xTexelR" + m + "C" + (g + 2) + ";\n                ";
      }
    } else g < d && (v += "\n              if(xR >= 0 && xR < " + o + ") {\n            ", s % 2 == 1 ? (v += "\n                xCOffset = xC + 1 - " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + a + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + a + ") {\n                  xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + m + "C" + (g + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = vec4(\n                  xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".zw);\n              ", g + 1 < d && (v += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c + ";\n                  if(xCOffset >= 0 && xCOffset < " + a + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + m + "C" + (g + 1) + " = vec4(xTexelR" + m + "C" + (g + 2) + ".xy, final.xy);\n                ")) : (v += "\n                if(xC >= 0 && xC < " + a + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + a + ") {\n                  xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + (g + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = vec4(\n                  xTexelR" + m + "C" + g + ".xy, xTexelR" + m + "C" + (g + 2) + ".xy);\n              ", g + 1 < d && (v += "\n                  xR" + m + "C" + (g + 1) + " = vec4(\n                    xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".zw);\n                ")), v += "}");

    g < d && (v += "\n            vec4 wTexelR" + m + "C" + g + " = getW(" + m + ", " + g + ", d1, q);\n            wR" + m + "C" + g + " = vec4(wTexelR" + m + "C" + g + ".xz, wTexelR" + m + "C" + g + ".xz);\n          ", g + 1 < d && (v += "\n              vec4 wTexelR" + m + "C" + (g + 1) + " = getW(" + m + ", " + (g + 1) + ", d1, q);\n              wR" + m + "C" + (g + 1) + " =\n                vec4(wTexelR" + m + "C" + (g + 1) + ".xz, wTexelR" + m + "C" + (g + 1) + ".xz);"));
  }

  for (m = 0; m < f; m++) for (g = 0; g < d; g++) v += "dotProd += xR" + m + "C" + g + " * wR" + m + "C" + g + ";";

  var w = "",
      C = "";
  n && (w = r ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "vec4 activation(vec4 x) {\n          " + n + "\n        }", C = "result = activation(result);");
  var E = e ? "result += getBiasAtOutCoords();" : "";
  e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w + "\n\n      const ivec2 strides = ivec2(" + u + ", " + c + ");\n      const ivec2 pads = ivec2(" + i + ", " + s + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + v + "\n\n        vec4 result = dotProd;\n        " + E + "\n        " + C + "\n        setOutput(result);\n      }\n    ";
},
    Ui = function (t, e, n, r, o) {
  this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
  var a = t[0],
      i = t[1],
      s = t[2],
      u = t[3],
      c = e[0],
      l = n[0],
      h = n[1];
  this.outputShape = [c, l, h, u];
  var f = "bilinear" === r ? 1 : 0,
      d = [i - 1 + ".0", s - 1 + ".0"],
      p = d[0],
      v = d[1],
      m = l > 1 ? ["" + (i - 1) / (l - 1), "(y2-y1) * height_ratio", "y1*" + p + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + p],
      g = m[0],
      y = m[1],
      x = m[2],
      b = h > 1 ? ["" + (s - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*" + v + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + v],
      w = b[0],
      C = b[1],
      E = b[2];
  this.userCode = "\n      const float height_ratio = float(" + g + ");\n      const float width_ratio = float(" + w + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + a + ") {\n          return;\n        }\n\n        float height_scale = " + y + ";\n        float width_scale = " + C + ";\n\n        float in_y = " + x + ";\n        if( in_y < 0.0 || in_y > " + p + " ) {\n          setOutput(float(" + o + "));\n          return;\n        }\n        float in_x = " + E + ";\n        if( in_x < 0.0 || in_x > " + v + " ) {\n          setOutput(float(" + o + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + f + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
},
    Vi = function (t, e, n) {
  this.variableNames = ["x"], this.outputShape = t;
  var r = t.length,
      o = t[t.length - 1],
      a = n ? "<" : ">";

  this.userCode = "\n      int getIndex(int i) {\n        " + (n ? "return " + o + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + oi(r) + " coords = getOutputCoords();\n        int end = " + zi(r, "coords") + ";\n        float val = 0.0;\n        for (int i = " + o + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + a + " end) {\n            continue;\n          }\n          if (idx == end && " + e + ") {\n            continue;\n          }\n          " + zi(r, "coords") + " = idx;\n          val += getX(" + function (t, e) {
    if (1 === t) return "" + e;
    if (2 === t) return e + ".x, " + e + ".y";
    if (3 === t) return e + ".x, " + e + ".y, " + e + ".z";
    if (4 === t) return e + ".x, " + e + ".y, " + e + ".z, " + e + ".w";
    throw Error("Cumulative sum for rank " + t + " is not yet supported");
  }(r, "coords") + ");\n        }\n        setOutput(val);\n      }\n    ";
};

function zi(t, e) {
  if (1 === t) return "" + e;
  if (2 === t) return e + ".y";
  if (3 === t) return e + ".z";
  if (4 === t) return e + ".w";
  throw Error("Cumulative sum for rank " + t + " is not yet supported");
}

var Gi = function (t) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;
  var e = Yt(t),
      n = qa();
  this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + Ka(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n.output + " = result;\n      }\n    ";
},
    Hi = function (t) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;
  var e = Yt(t),
      n = qa();
  this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + Ka(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n.output + " = result;\n      }\n    ";
},
    qi = function () {
  function t(t, e, n) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e + ";\n      int offset_h = imod(h, " + e + ");\n      int in_w = w / " + e + ";\n      int offset_w = imod(w, " + e + ");\n      int offset_d = (offset_h * " + e + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
  }

  return t.prototype.getHeightCoordString = function () {
    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
  }, t.prototype.getWidthCoordString = function () {
    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
  }, t.prototype.getDepthCoordString = function () {
    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
  }, t.prototype.getOutputDepthSize = function () {
    return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
  }, t.prototype.getInputSamplingString = function () {
    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }, t;
}(),
    Ki = function (t) {
  this.variableNames = ["X"], this.outputShape = [t, t], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
},
    ji = function (t) {
  this.variableNames = ["A"], this.outTexUsage = zt.DOWNLOAD;
  var e = qa();
  this.outputShape = t, this.userCode = "\n      " + Xa + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e.output + " = encode_float(x);\n      }\n    ";
},
    Xi = function (t) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = zt.DOWNLOAD;
  var e = qa();
  this.outputShape = t, this.userCode = "\n      " + Xa + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e.output + " = encode_float(x);\n      }\n    ";
},
    Yi = function (t, e, n) {
  void 0 === n && (n = !1), this.variableNames = ["A"];
  var r = qa(),
      o = e[0],
      a = e[1];
  this.outputShape = t;
  var i = "result";
  n && (i = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + ja(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + a + ";\n        int c = imod(flatIndex, " + a + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n        vec4 values = " + r.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r.output + " = vec4(" + i + ", 0., 0., 0.);\n      }\n    ";
},
    $i = function (t, e, n) {
  void 0 === n && (n = !1), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
  var r = qa(),
      o = e[0],
      a = e[1];
  this.outputShape = t;
  var i = "",
      s = "result";
  n && (s = "floor(result * 255. + 0.5)");

  for (var u = 0; u <= 1; u++) for (var c = 0; c <= 1; c++) {
    var l = 2 * u + c;
    i += "\n          localCoords = coords;\n          if(localCoords[2] + " + c + " < " + t[2] + ") {\n            localCoords[2] += " + c + ";\n            if(localCoords[1] + " + u + " < " + t[1] + ") {\n              localCoords[1] += " + u + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + a + ";\n              c = imod(flatIndex, " + a + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n              values = " + r.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l + "] = values[2];\n              } else {\n                result[" + l + "] = values[3];\n              }\n            }\n          }\n        ";
  }

  this.userCode = "\n      " + ja(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + i + "\n\n        " + r.output + " = " + s + ";\n      }\n    ";
},
    Qi = "return real * expR - imag * expI;",
    Ji = "return real * expI + imag * expR;",
    Zi = function (t, e, n) {
  this.variableNames = ["real", "imag"];
  var r = e[1];
  this.outputShape = e;
  var o = n ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI,
      a = n ? r + ".0" : "1.0";
  this.userCode = "\n      const float exponentMultiplier = " + o + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + a + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
},
    ts = function () {
  function t(t, e) {
    this.outputShape = [], this.variableNames = ["x"], this.outputShape = t, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    return function (n, r) {
      null == e.valueLoc && (e.valueLoc = n.getUniformLocationNoThrow(r, "value")), n.gl.uniform1f(e.valueLoc, t);
    };
  }, t;
}(),
    es = function (t, e, n) {
  this.variableNames = ["A", "indices"];
  var r = t.slice();
  r[n] = e, this.outputShape = r, this.rank = r.length;

  var o = oi(this.rank),
      a = function (t, e) {
    var n = t.length;
    if (n > 4) throw Error("Gather for rank " + n + " is not yet supported");
    if (1 === n) return "int(getIndices(resRC))";

    for (var r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o = [], a = 0; a < t.length; a++) a === e ? o.push("int(getIndices(" + r[a] + "))") : o.push("" + r[a]);

    return o.join();
  }(t, n);

  this.userCode = "\n      void main() {\n        " + o + " resRC = getOutputCoords();\n        setOutput(getA(" + a + "));\n      }\n    ";
};

var ns = function (t, e, n) {
  this.sliceDim = t, this.strides = e, this.variableNames = ["x", "indices"], this.outputShape = n;
  var r = oi(e.length),
      o = oi(n.length),
      a = this.sliceDim > 1 ? "strides[j]" : "strides";
  this.userCode = "\n        " + r + " strides = " + r + "(" + this.strides + ");\n         void main() {\n          " + o + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + a + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
};

function rs(t, e) {
  var n = qa();
  return oe(t, e, n.version + "\n    precision highp float;\n    " + n.attribute + " vec3 clipSpacePos;\n    " + n.attribute + " vec2 uv;\n    " + n.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }");
}

function os(t, e) {
  return fe(t, e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
}

function as(t, e) {
  return de(t, e, new Uint16Array([0, 1, 2, 2, 1, 3]));
}

function is(t, e, n, r, o, a, i) {
  ve(n, r);
  var s = pe(t, e),
      u = t.TEXTURE_2D;
  return Jt(t, e, function () {
    return t.bindTexture(u, s);
  }), Jt(t, e, function () {
    return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE);
  }), Jt(t, e, function () {
    return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
  }), Jt(t, e, function () {
    return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST);
  }), Jt(t, e, function () {
    return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST);
  }), Jt(t, e, function () {
    return t.texImage2D(u, 0, o, n, r, 0, a, i, null);
  }), Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, null);
  }), s;
}

function ss(t, e, n, r, o) {
  var a = Xt(n, r);
  return is(t, e, a[0], a[1], o.internalFormatFloat, o.textureFormatFloat, t.FLOAT);
}

function us(t, e, n, r, o) {
  var a = Xt(n, r);
  return is(t, e, a[0], a[1], o.internalFormatHalfFloat, o.textureFormatFloat, o.textureTypeHalfFloat);
}

function cs(t, e, n, r, o) {
  var a = Xt(n, r);
  return is(t, e, a[0], a[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE);
}

function ls(t, e, n, r, o) {
  var a = $t(n, r);
  return is(t, e, a[0], a[1], o.internalFormatPackedFloat, t.RGBA, t.FLOAT);
}

function hs(t, e, n, r, o) {
  var a = $t(n, r);
  return is(t, e, a[0], a[1], o.internalFormatPackedHalfFloat, t.RGBA, o.textureTypeHalfFloat);
}

function fs(t, e, n, r) {
  return Jt(t, e, function () {
    return t.bindBuffer(t.ARRAY_BUFFER, r);
  }), ge(t, e, n, "clipSpacePos", r, 3, 20, 0) && ge(t, e, n, "uv", r, 2, 20, 12);
}

function ds(t, e, n, r, o, a, i) {
  var s, u, c;
  Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, n);
  }), a instanceof Uint8Array ? (s = new Uint8Array(r * o * 4), u = t.UNSIGNED_BYTE, c = t.RGBA) : (s = new Float32Array(r * o * 4), u = t.FLOAT, c = i.internalFormatPackedFloat), s.set(a), Jt(t, e, function () {
    return t.texImage2D(t.TEXTURE_2D, 0, c, r, o, 0, t.RGBA, u, s);
  }), Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, null);
  });
}

function ps(t, e, n, r) {
  Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, n);
  }), r.data instanceof Uint8Array ? Jt(t, e, function () {
    return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data);
  }) : Jt(t, e, function () {
    return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r);
  }), Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, null);
  });
}

function vs(t, e, n, r, o) {
  var a = t.createBuffer();
  Jt(t, e, function () {
    return t.bindBuffer(t.PIXEL_PACK_BUFFER, a);
  });
  var i = 16 * n * r;
  return Jt(t, e, function () {
    return t.bufferData(t.PIXEL_PACK_BUFFER, i, t.STREAM_READ);
  }), Jt(t, e, function () {
    return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0);
  }), Jt(t, e, function () {
    return t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
  }), a;
}

function ms(t, e, n) {
  var r = t,
      o = new Float32Array(n);
  return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, o), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), o;
}

function gs(t, e, n, r, o) {
  var a = Xt(n, r),
      i = a[0],
      s = a[1],
      u = new Uint8Array(n * r * 4);
  return Jt(t, e, function () {
    return t.readPixels(0, 0, i, s, o.downloadTextureFormat, t.UNSIGNED_BYTE, u);
  }), new Float32Array(u.buffer);
}

function ys(t, e, n, r, o, a, i, s) {
  var u = t,
      c = new Float32Array(function (t, e) {
    var n = $t(t, e);
    return n[0] * n[1] * 4;
  }(a, i));
  return u.bindBuffer(u.PIXEL_PACK_BUFFER, e), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), c;
}

function xs(t, e, n, r) {
  var o = new Float32Array(n * r * 4);
  return Jt(t, e, function () {
    return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, o);
  }), o;
}

var bs = Object.freeze({
  createVertexShader: rs,
  createVertexBuffer: os,
  createIndexBuffer: as,
  createFloat32MatrixTexture: ss,
  createFloat16MatrixTexture: us,
  createUnsignedBytesMatrixTexture: cs,
  createPackedMatrixTexture: ls,
  createFloat16PackedMatrixTexture: hs,
  bindVertexProgramAttributeStreams: fs,
  uploadDenseMatrixToTexture: ds,
  uploadPixelDataToTexture: ps,
  createBufferFromOutputTexture: vs,
  downloadFloat32MatrixFromBuffer: ms,
  downloadByteEncodedFloatMatrixFromOutputTexture: gs,
  downloadPackedMatrixFromBuffer: ys,
  downloadMatrixFromPackedOutputTexture: xs
}),
    ws = function () {
  function t(t) {
    this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
    var e = i().getNumber("WEBGL_VERSION");
    null != t ? (this.gl = t, Kt(e, t)) : this.gl = jt(e);
    var n = "WEBGL_color_buffer_float";

    if (1 === i().getNumber("WEBGL_VERSION")) {
      if (this.textureFloatExtension = re(this.gl, this.debug, "OES_texture_float"), Pe(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = re(this.gl, this.debug, "OES_texture_half_float");else if (i().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(n), Pe(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = re(this.gl, this.debug, "EXT_color_buffer_half_float");else if (i().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (n = "EXT_color_buffer_float", Pe(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);else {
      if (!Pe(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
      this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
    }

    this.vertexBuffer = os(this.gl, this.debug), this.indexBuffer = as(this.gl, this.debug), this.framebuffer = me(this.gl, this.debug), this.textureConfig = Qt(this.gl, this.textureHalfFloatExtension);
  }

  return Object.defineProperty(t.prototype, "debug", {
    get: function () {
      return i().getBool("DEBUG");
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.dispose = function () {
    var t = this;

    if (!this.disposed) {
      null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      var e = this.gl;
      Jt(e, this.debug, function () {
        return e.finish();
      }), Jt(e, this.debug, function () {
        return e.bindFramebuffer(e.FRAMEBUFFER, null);
      }), Jt(e, this.debug, function () {
        return e.deleteFramebuffer(t.framebuffer);
      }), Jt(e, this.debug, function () {
        return e.bindBuffer(e.ARRAY_BUFFER, null);
      }), Jt(e, this.debug, function () {
        return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null);
      }), Jt(e, this.debug, function () {
        return e.deleteBuffer(t.indexBuffer);
      }), this.disposed = !0;
    }
  }, t.prototype.createFloat32MatrixTexture = function (t, e) {
    return this.throwIfDisposed(), ss(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.createFloat16MatrixTexture = function (t, e) {
    return this.throwIfDisposed(), us(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.createUnsignedBytesMatrixTexture = function (t, e) {
    return this.throwIfDisposed(), cs(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.uploadPixelDataToTexture = function (t, e) {
    this.throwIfDisposed(), ps(this.gl, this.debug, t, e);
  }, t.prototype.uploadDenseMatrixToTexture = function (t, e, n, r) {
    this.throwIfDisposed(), ds(this.gl, this.debug, t, e, n, r, this.textureConfig);
  }, t.prototype.createFloat16PackedMatrixTexture = function (t, e) {
    return this.throwIfDisposed(), hs(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.createPackedMatrixTexture = function (t, e) {
    return this.throwIfDisposed(), ls(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.deleteMatrixTexture = function (t) {
    var e = this;
    this.throwIfDisposed(), this.outputTexture === t && (Ee(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Jt(this.gl, this.debug, function () {
      return e.gl.deleteTexture(t);
    });
  }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (t, e, n) {
    var r = this;
    return this.downloadMatrixDriver(t, function () {
      return gs(r.gl, r.debug, e, n, r.textureConfig);
    });
  }, t.prototype.downloadPackedMatrixFromBuffer = function (t, e, n, r, o, a) {
    return ys(this.gl, t, 0, 0, 0, o, a, this.textureConfig);
  }, t.prototype.downloadFloat32MatrixFromBuffer = function (t, e) {
    return ms(this.gl, t, e);
  }, t.prototype.createBufferFromTexture = function (t, e, n) {
    this.bindTextureToFrameBuffer(t);
    var r = vs(this.gl, this.debug, e, n, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), r;
  }, t.prototype.createAndWaitForFence = function () {
    var t = this.createFence(this.gl);
    return this.pollFence(t);
  }, t.prototype.createFence = function (t) {
    var e,
        n,
        r = this;

    if (i().getBool("WEBGL_FENCE_API_ENABLED")) {
      var o = t,
          a = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
      t.flush(), n = function () {
        var t = o.clientWaitSync(a, 0, 0);
        return t === o.ALREADY_SIGNALED || t === o.CONDITION_SATISFIED;
      }, e = a;
    } else i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e = this.beginQuery(), this.endQuery(), n = function () {
      return r.isQueryAvailable(e, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }) : n = function () {
      return !0;
    };

    return {
      query: e,
      isFencePassed: n
    };
  }, t.prototype.downloadMatrixFromPackedTexture = function (t, e, n) {
    var r = this;
    return this.downloadMatrixDriver(t, function () {
      return xs(r.gl, r.debug, e, n);
    });
  }, t.prototype.createProgram = function (t) {
    this.throwIfDisposed();
    var e = this.gl,
        n = ae(e, this.debug, t),
        r = rs(e, this.debug),
        o = ce(e, this.debug);
    return Jt(e, this.debug, function () {
      return e.attachShader(o, r);
    }), Jt(e, this.debug, function () {
      return e.attachShader(o, n);
    }), le(e, this.debug, o), this.debug && he(e, this.debug, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = fs(e, this.debug, this.program, this.vertexBuffer)), o;
  }, t.prototype.deleteProgram = function (t) {
    var e = this;
    this.throwIfDisposed(), t === this.program && (this.program = null), null != t && Jt(this.gl, this.debug, function () {
      return e.gl.deleteProgram(t);
    });
  }, t.prototype.setProgram = function (t) {
    var e = this;
    this.throwIfDisposed(), this.program = t, null != this.program && this.debug && he(this.gl, this.debug, this.program), Jt(this.gl, this.debug, function () {
      return e.gl.useProgram(t);
    });
  }, t.prototype.getUniformLocation = function (t, e, n) {
    return void 0 === n && (n = !0), this.throwIfDisposed(), n ? xe(this.gl, this.debug, t, e) : be(this.gl, t, e);
  }, t.prototype.getAttributeLocation = function (t, e) {
    var n = this;
    return this.throwIfDisposed(), Jt(this.gl, this.debug, function () {
      return n.gl.getAttribLocation(t, e);
    });
  }, t.prototype.getUniformLocationNoThrow = function (t, e) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(t, e);
  }, t.prototype.setInputMatrixTexture = function (t, e, n) {
    this.throwIfDisposed(), this.throwIfNoProgram(), we(this.gl, this.debug, this.program, t, e, n);
  }, t.prototype.setOutputMatrixTexture = function (t, e, n) {
    this.setOutputMatrixTextureDriver(t, n, e);
  }, t.prototype.setOutputPackedMatrixTexture = function (t, e, n) {
    this.throwIfDisposed();
    var r = $t(e, n),
        o = r[0],
        a = r[1];
    this.setOutputMatrixTextureDriver(t, o, a);
  }, t.prototype.setOutputMatrixWriteRegion = function (t, e, n, r) {
    this.setOutputMatrixWriteRegionDriver(n, t, r, e);
  }, t.prototype.setOutputPackedMatrixWriteRegion = function (t, e, n, r) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }, t.prototype.debugValidate = function () {
    null != this.program && he(this.gl, this.debug, this.program), Re(this.gl);
  }, t.prototype.executeProgram = function () {
    this.throwIfDisposed(), this.throwIfNoProgram();
    var t = this.gl;
    this.debug && this.debugValidate(), Jt(t, this.debug, function () {
      return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0);
    });
  }, t.prototype.blockUntilAllProgramsCompleted = function () {
    var t = this;
    this.throwIfDisposed(), Jt(this.gl, this.debug, function () {
      return t.gl.finish();
    });
  }, t.prototype.getQueryTimerExtension = function () {
    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = re(this.gl, this.debug, 2 === i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }, t.prototype.getQueryTimerExtensionWebGL2 = function () {
    return this.getQueryTimerExtension();
  }, t.prototype.getQueryTimerExtensionWebGL1 = function () {
    return this.getQueryTimerExtension();
  }, t.prototype.beginQuery = function () {
    if (2 === i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t = this.gl,
          e = this.getQueryTimerExtensionWebGL2(),
          n = t.createQuery();
      return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;
    }

    var r = this.getQueryTimerExtensionWebGL1(),
        o = r.createQueryEXT();
    return r.beginQueryEXT(r.TIME_ELAPSED_EXT, o), o;
  }, t.prototype.endQuery = function () {
    if (2 !== i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t = this.getQueryTimerExtensionWebGL1();
      t.endQueryEXT(t.TIME_ELAPSED_EXT);
    } else {
      var e = this.gl,
          n = this.getQueryTimerExtensionWebGL2();
      e.endQuery(n.TIME_ELAPSED_EXT);
    }
  }, t.prototype.waitForQueryAndGetTime = function (t) {
    return n(this, void 0, void 0, function () {
      var e = this;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, F(function () {
              return e.disposed || e.isQueryAvailable(t, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
            })];

          case 1:
            return n.sent(), [2, this.getQueryTime(t, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];
        }
      });
    });
  }, t.prototype.getQueryTime = function (t, e) {
    if (0 === e) return null;

    if (2 === e) {
      var n = this.gl;
      return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;
    }

    var r = this.getQueryTimerExtensionWebGL1();
    return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6;
  }, t.prototype.isQueryAvailable = function (t, e) {
    if (0 === e) return !0;

    if (2 === e) {
      var n = this.gl,
          r = this.getQueryTimerExtensionWebGL2(),
          o = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);
      return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;
    }

    o = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT);
    return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;
  }, t.prototype.pollFence = function (t) {
    var e = this;
    return new Promise(function (n) {
      e.addItemToPoll(function () {
        return t.isFencePassed();
      }, function () {
        return n();
      });
    });
  }, t.prototype.pollItems = function () {
    for (var t = function (t) {
      for (var e = 0; e < t.length; ++e) {
        if (!t[e]()) break;
      }

      return e - 1;
    }(this.itemsToPoll.map(function (t) {
      return t.isDoneFn;
    })), e = 0; e <= t; ++e) {
      (0, this.itemsToPoll[e].resolveFn)();
    }

    this.itemsToPoll = this.itemsToPoll.slice(t + 1);
  }, t.prototype.addItemToPoll = function (t, e) {
    var n = this;
    this.itemsToPoll.push({
      isDoneFn: t,
      resolveFn: e
    }), this.itemsToPoll.length > 1 || F(function () {
      return n.pollItems(), 0 === n.itemsToPoll.length;
    });
  }, t.prototype.bindTextureToFrameBuffer = function (t) {
    this.throwIfDisposed(), Ce(this.gl, this.debug, t, this.framebuffer), this.debug && Re(this.gl);
  }, t.prototype.unbindTextureToFrameBuffer = function () {
    null != this.outputTexture ? (Ce(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Re(this.gl)) : Ee(this.gl, this.debug, this.framebuffer);
  }, t.prototype.downloadMatrixDriver = function (t, e) {
    this.bindTextureToFrameBuffer(t);
    var n = e();
    return this.unbindTextureToFrameBuffer(), n;
  }, t.prototype.setOutputMatrixTextureDriver = function (t, e, n) {
    this.throwIfDisposed();
    var r = this.gl;
    Ce(r, this.debug, t, this.framebuffer), this.debug && Re(r), this.outputTexture = t, Jt(r, this.debug, function () {
      return r.viewport(0, 0, e, n);
    }), Jt(r, this.debug, function () {
      return r.scissor(0, 0, e, n);
    });
  }, t.prototype.setOutputMatrixWriteRegionDriver = function (t, e, n, r) {
    var o = this;
    this.throwIfDisposed(), Jt(this.gl, this.debug, function () {
      return o.gl.scissor(t, e, n, r);
    });
  }, t.prototype.throwIfDisposed = function () {
    if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
  }, t.prototype.throwIfNoProgram = function () {
    if (null == this.program) throw new Error("No GPU program is currently set.");
  }, t;
}();

function Cs(t, e) {
  if (t.length !== e.length) throw Error("Binary was compiled with " + t.length + " inputs, but was executed with " + e.length + " inputs");
  t.forEach(function (t, n) {
    var r = t.logicalShape,
        o = e[n],
        a = o.shape;
    if (!S(r, a)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r + " and " + a + " must match");

    if (!t.isUniform || !o.isUniform) {
      var i = t.texShape,
          s = o.isUniform ? null : o.texData.texShape;
      if (!S(i, s)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + i + " and " + s + " must match");
    }
  });
}

var Es = function (t, e, n) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;

  for (var r = n.filterWidth, o = n.inChannels, a = n.strideWidth, i = n.strideHeight, s = n.padInfo, u = n.outWidth, c = n.dilationWidth, l = n.dilationHeight, h = n.dataFormat, f = s.left, d = s.top, p = o * r, v = qa(), m = "channelsLast" === h, g = m ? 0 : 1, y = m ? 1 : 2, x = "", b = 0; b <= 1; b++) for (var w = 0; w <= 1; w++) x += "\n          blockIndex = rc.y + " + w + ";\n          pos = rc.x + " + b + ";\n\n          if(blockIndex < " + t[1] + " && pos < " + t[0] + ") {\n            offsetY = int(blockIndex / (" + u + ")) * " + i + " - " + d + ";\n            d0 = offsetY + " + l + " * (pos / " + p + ");\n\n            if(d0 < " + e[g] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + u + ".) * " + a + ". - " + f + ".);\n              d1 = offsetX + " + c + " * (int(mod(float(pos), " + p + ".) / " + o + ".));\n\n              if(d1 < " + e[y] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + o + ".));\n\n                if (" + m + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * b + w) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * b + w) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";

  this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + x + "\n\n        " + v.output + " = result;\n      }\n    ";
},
    Rs = function (t, e, n, r, o) {
  this.variableNames = ["x"], this.outputShape = [];
  var a,
      i = e,
      s = t[3] - 1;
  this.outputShape = t;
  var u = "float(" + n + ") + float(" + r + ") * sum";
  a = .5 === o ? "inversesqrt(" + u + ")" : 1 === o ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + o + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + i + "; j <= " + i + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + s + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + a + ";\n        setOutput(val);\n      }\n    ";
},
    Is = function (t, e, n, r, o) {
  this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = o, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r + ") * norm + float(" + n + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r + ")\n                * float(" + o + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + o + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
},
    ks = function (t, e, n, r, o) {
  this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
  var a,
      i = e,
      s = t[3] - 1;
  this.outputShape = t;
  var u = "float(" + n + ") + float(" + r + ") * sum";
  a = .5 === o ? "inversesqrt(" + u + ")" : 1 === o ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + o + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + i + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + i + "; j <= " + i + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + s + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + a + ";\n        setOutput(result);\n      }\n    ";
},
    Ss = function (t) {
  this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
  var e = t.strideHeight,
      n = t.strideWidth,
      r = t.dilationHeight,
      o = t.effectiveFilterHeight,
      a = t.effectiveFilterWidth,
      i = o - 1 - t.padInfo.top,
      s = a - 1 - t.padInfo.left,
      u = o * a - 1;
  this.userCode = "\n      const ivec2 pads = ivec2(" + i + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + o + ";\n          wR += " + r + ") {\n          float dyR = float(dyRCorner + wR) / " + e + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + a + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + u + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + a + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    As = function (t) {
  this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
  var e = t.strideDepth,
      n = t.strideHeight,
      r = t.strideWidth,
      o = t.dilationDepth,
      a = t.dilationHeight,
      i = t.dilationWidth,
      s = t.effectiveFilterDepth,
      u = t.effectiveFilterHeight,
      c = t.effectiveFilterWidth,
      l = s - 1 - t.padInfo.front,
      h = u - 1 - t.padInfo.top,
      f = c - 1 - t.padInfo.left,
      d = s * u * c - 1;
  this.userCode = "\n      const ivec3 pads = ivec3(" + l + ", " + h + ", " + f + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + s + ";\n           wD += " + o + ") {\n          float dyD = float(dyDCorner + wD) / " + e + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + a + ") {\n            float dyR = float(dyRCorner + wR) / " + n + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + i + ") {\n              float dyC = float(dyCCorner + wC) / " + r + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + d + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + u + " * " + c + " +\n                  wR * " + c + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Ts = function (t, e, n, r, o, a, i) {
  void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === a && (a = null), void 0 === i && (i = !1), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
  var s = n ? t[1] : t[2],
      u = Math.ceil(s / 2),
      c = n ? "i * 2, rc.y" : "rc.y, i * 2",
      l = r ? "rc.z, i * 2" : "i * 2, rc.z",
      h = n ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
      f = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
      d = "",
      p = "";
  a && (d = i ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + a + "\n        }" : "vec4 activation(vec4 x) {\n          " + a + "\n        }", p = "result = activation(result);");
  var v = o ? "result += getBiasAtOutCoords();" : "";
  o && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + d + "\n\n      const float sharedDimension = " + u + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + u + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c + ");\n          vec4 b = getMatrixB(rc.x, " + l + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h[0] + " * " + f[0] + ");\n          result += (" + h[1] + " * " + f[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v + "\n\n        " + p + "\n\n        setOutput(result);\n      }\n    ";
},
    Ds = function () {
  function t(t, e, n) {
    this.variableNames = ["probs"], this.outputShape = [t, n], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e - 1) + "));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    return function (n, r) {
      null == e.seedLoc && (e.seedLoc = n.getUniformLocation(r, "seed")), n.gl.uniform1f(e.seedLoc, t);
    };
  }, t;
}(),
    Ns = function (t, e, n, r) {
  this.variableNames = ["indices"], this.outputShape = [t, e], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r + "), float(" + n + "),\n                      float(index == coords.y)));\n      }\n    ";
},
    Fs = function (t) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t;
  var e = t.length;
  if (0 === e) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else {
    var n = Ha("rc", e),
        r = oi(e),
        o = function (t, e, n) {
      if (1 === t) return "rc > " + e[0];

      for (var r = "", o = t - 2; o < t; o++) r += n[o] + " >= " + e[o], o < t - 1 && (r += "||");

      return r;
    }(e, t, n),
        a = function (t, e, n, r) {
      if (1 === t) return "";
      var o = r.slice(-2);
      return "\n    int r = " + o[0] + ";\n    int c = " + o[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e + ";\n    bool rEdge = rp1 >= " + n + ";\n  ";
    }(e, t[t.length - 1], t[t.length - 2], n),
        i = function (t, e) {
      var n = t.length,
          r = function (t, e) {
        for (var n = [], r = 0; r <= 1; r++) for (var o = 0; o <= 1; o++) {
          for (var a = (0 === r ? "r" : "rp1") + ", " + (0 === o ? "c" : "cp1"), i = 2; i < t; i++) a = e[e.length - 1 - i] + "," + a;

          n.push(a);
        }

        return n;
      }(n, e);

      return 1 === n ? "getA(rc),\n            rc + 1 >= " + t[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r[0] + "),\n          cEdge ? 0. : getA(" + r[1] + "),\n          rEdge ? 0. : getA(" + r[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r[3] + ")";
    }(t, n);

    this.userCode = "\n        void main() {\n          " + r + " rc = getOutputCoords();\n\n          if(" + o + ") {\n            setOutput(vec4(0));\n          } else {\n            " + a + "\n\n            setOutput(vec4(" + i + "));\n          }\n        }\n      ";
  }
};

var _s = function (t, e, n) {
  this.variableNames = ["x"], this.outputShape = e.map(function (e, n) {
    return e[0] + t[n] + e[1];
  });
  var r = t.length,
      o = oi(r),
      a = e.map(function (t) {
    return t[0];
  }).join(","),
      i = e.map(function (e, n) {
    return e[0] + t[n];
  }).join(","),
      s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
  this.userCode = 1 !== r ? "\n      " + o + " start = " + o + "(" + a + ");\n      " + o + " end = " + o + "(" + i + ");\n\n      void main() {\n        " + o + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n + "));\n        } else {\n          " + o + " coords = outC - start;\n          setOutput(getX(" + s + "));\n        }\n      }\n    " : "\n        int start = " + a + ";\n        int end = " + i + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
},
    Os = function (t, e, n) {
  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map(function (e, n) {
    return e[0] + t[n] + e[1];
  });

  for (var r = t.length, o = oi(r), a = e.map(function (t) {
    return t[0];
  }).join(","), i = e.map(function (e, n) {
    return e[0] + t[n];
  }).join(","), s = Ha("rc", r), u = Ha("source", r), c = s[r - 1] + " < " + this.outputShape[r - 1], l = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")", h = [o + " rc = outputLoc;", s[r - 1] + " += 1;\n       if(" + c + ") {\n      ", 1 === r ? "" : "}\n       rc = outputLoc;\n       " + s[r - 2] + " += 1;\n       if(" + s[r - 2] + " < " + this.outputShape[r - 2] + ") {", 1 === r ? "" : "  " + s[r - 1] + " += 1;\n         if(" + c + ") {"], f = 1 === r ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", d = "", p = 0, v = 1 === r ? 2 : 4; p < v; p++) d += "\n        " + h[p] + "\n        if (" + f + ") {\n          result[" + p + "] = float(" + n + ");\n        } else {\n          " + o + " source = rc - start;\n          result[" + p + "] = getChannel(getX(" + u.join() + "), " + l + ");\n        }\n      ";

  d += 1 === r ? "} " : "}}", this.userCode = "\n      const " + o + " start = " + o + "(" + a + ");\n      const " + o + " end = " + o + "(" + i + ");\n\n      void main() {\n        " + o + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + d + "\n        setOutput(result);\n      }\n    ";
},
    Ms = function (t, e, n) {
  if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
  var r = t.filterWidth,
      o = t.strideHeight,
      a = t.strideWidth,
      i = t.dilationHeight,
      s = t.dilationWidth,
      u = t.effectiveFilterHeight,
      c = t.effectiveFilterWidth,
      l = t.padInfo.top,
      h = t.padInfo.left;
  this.outputShape = t.outShape;
  var f = "avg" === e,
      d = "0.0";
  if (f || (d = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec2 strides = ivec2(" + o + ", " + a + ");\n        const ivec2 pads = ivec2(" + l + ", " + h + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + i + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + s + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else {
    var p = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    "avg" === e && (p = "avgValue / count");
    var v = 4 * Math.floor(r / 4),
        m = r % 4,
        g = "\n      if (" + f + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
    this.userCode = "\n      const ivec2 strides = ivec2(" + o + ", " + a + ");\n      const ivec2 pads = ivec2(" + l + ", " + h + ");\n      const float initializationValue = " + d + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + d + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + u + ";\n            wR += " + i + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v + "; wC += 4) {\n            int xC = xCCorner + wC * " + s + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              getValue(batch, xR, xC + 3 * " + s + ", d)\n            );\n\n            " + g + "\n          }\n\n          int xC = xCCorner + " + v + ";\n          if (" + (1 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (2 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (3 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              initializationValue\n            );\n\n            " + g + "\n          }\n        }\n        setOutput(" + p + ");\n      }\n    ";
  }
},
    Bs = function (t, e, n) {
  if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
  var r = t.filterWidth,
      o = t.strideDepth,
      a = t.strideHeight,
      i = t.strideWidth,
      s = t.dilationDepth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.effectiveFilterDepth,
      h = t.effectiveFilterHeight,
      f = t.effectiveFilterWidth,
      d = t.padInfo.front,
      p = t.padInfo.top,
      v = t.padInfo.left;
  this.outputShape = t.outShape;
  var m = "avg" === e,
      g = "0.0";
  if (m || (g = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + o + ", " + a + ", " + i + ");\n        const ivec3 pads = ivec3(" + d + ", " + p + ", " + v + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l + ";\n              wD += " + s + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h + ";\n                wR += " + u + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + f + ";\n                  wC += " + c + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h + " * " + f + " +\n                      wR * " + f + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else {
    var y = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    "avg" === e && (y = "avgValue / count");
    var x = 4 * Math.floor(r / 4),
        b = r % 4,
        w = "\n      if (" + m + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
    this.userCode = "\n      const ivec3 strides =\n        ivec3(" + o + ", " + a + ", " + i + ");\n      const ivec3 pads = ivec3(" + d + ", " + p + ", " + v + ");\n      const float initializationValue = " + g + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + s + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + ";\n            wR += " + u + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + x + "; wC += 4) {\n              int xC = xCCorner + wC * " + c + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c + ", ch)\n              );\n\n              " + w + "\n            }\n\n            int xC = xCCorner + " + x + ";\n            if (" + (1 === b) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (2 === b) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (3 === b) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                initializationValue\n              );\n\n              " + w + "\n            }\n          }\n          setOutput(" + y + ");\n        }\n      }\n    ";
  }
},
    Ps = function (t, e) {
  this.variableNames = ["x"];
  var n = t.windowSize,
      r = t.batchSize,
      o = t.inSize,
      a = Math.ceil(o / n);
  this.outputShape = [r, a];
  var i = "0.0",
      s = "";
  "prod" === e ? i = "1.0" : "min" === e ? (i = "1.0 / 1e-20", s = "min") : "max" === e && (i = "-1.0 / 1e-20", s = "max");
  var u = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
  "sum" === e ? u = "sumValue" : "prod" === e ? u = "prodValue" : "all" === e ? u = "allValue" : "any" === e && (u = "anyValue");
  var c = 4 * Math.floor(n / 4),
      l = n % 4,
      h = "\n      if (" + ("sum" === e) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + s + "(values, minMaxValue);\n      }\n    ",
      f = "vec4";
  "all" === e ? (i = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", f = "bvec4") : "any" === e && (i = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", f = "bvec4");
  var d = "";
  o % n > 0 && (d = "\n        if (inIdx < 0 || inIdx >= " + o + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + i + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + d + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n + ";\n\n        vec4 minMaxValue = vec4(" + i + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h + "\n        }\n\n        int inIdx = inOffset + " + c + ";\n        if (" + (1 === l) + ") {\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (2 === l) + ") {\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (3 === l) + ") {\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h + "\n        }\n        setOutput(" + u + ");\n      }\n    ";
},
    Ls = function (t, e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;

  for (var n = "", r = 0; r < 4; r++) {
    var o = "thisRC = rc;";
    r % 2 == 1 && (o += "thisRC.z += 1;"), r > 1 && (o += "thisRC.y += 1;"), n += "\n        " + o + "\n        " + (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r > 0 ? "}" : "") + "\n      ";
  }

  this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + Ka(["r", "c", "d"], e) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + ja(t) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t[1] + ";\n        int cols = " + t[2] + ";\n\n        " + n + "\n\n        setOutput(result);\n      }\n    ";
};

var Ws = function (t, e, n) {
  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
  var r = e.shape,
      o = r[1],
      a = r[2],
      i = t.shape,
      s = i[1],
      u = i[2],
      c = [n && s > 1 ? o - 1 : o, n && u > 1 ? a - 1 : a],
      l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
      h = c[0] / l[0],
      f = c[1] / l[1],
      d = 1 / h,
      p = 1 / f,
      v = 2 * Math.ceil(d) + 2,
      m = 2 * Math.ceil(p) + 2;
  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + f + ");\n\n        const float invHeightScale = float(" + d + ");\n        const float invWidthScale = float(" + p + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (o - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
},
    Us = function (t, e, n, r) {
  this.variableNames = ["A"], this.outputShape = [];
  var o = t[0],
      a = t[1],
      i = t[2],
      s = t[3];
  this.outputShape = [o, e, n, s];
  var u = [r && e > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],
      c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
  this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + a + ".0, " + i + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
},
    Vs = function (t, e, n, r) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
  var o = t[0],
      a = t[1],
      i = t[2],
      s = t[3];
  this.outputShape = [o, e, n, s];
  var u = [r && e > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],
      c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
  this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ",\n          " + u[1] / c[1] + ");\n      const vec3 inputShapeRC = vec3(" + a + ".0, " + i + ".0,\n                                     " + i + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (s - 1) + ";\n        bool hasNextRow = coords.z < " + (n - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
},
    zs = function (t, e, n) {
  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
  var r = e.shape,
      o = r[1],
      a = r[2],
      i = t.shape,
      s = i[1],
      u = i[2],
      c = [n && s > 1 ? o - 1 : o, n && u > 1 ? a - 1 : a],
      l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
      h = c[0] / l[0],
      f = c[1] / l[1],
      d = 1 / h,
      p = 1 / f,
      v = 2 * Math.ceil(d) + 2,
      m = 2 * Math.ceil(p) + 2;
  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + f + ");\n\n        const float invHeightScale = float(" + d + ");\n        const float invWidthScale = float(" + p + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c[0] + ") *\n                (float(dyR) / float(" + l[0] + "));\n\n            float sourceFracCol =\n                float(" + c[1] + ") *\n                  (float(dyC) / float(" + l[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + o + ") - 1),\n                " + n + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a + ") - 1),\n                " + n + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
},
    Gs = function (t, e, n, r) {
  this.variableNames = ["A"], this.outputShape = [];
  var o = t[0],
      a = t[1],
      i = t[2],
      s = t[3];
  this.outputShape = [o, e, n, s];
  var u = [r && e > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],
      c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],
      l = r ? "0.5" : "0.0";
  this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + a + ".0, " + i + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
},
    Hs = function (t, e) {
  this.variableNames = ["x"];
  var n = t.length;
  if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");

  if (this.outputShape = t, 1 !== n) {
    var r = t.map(function (n, r) {
      return function (n) {
        return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - coords[" + n + "] - 1" : "coords[" + n + "]";
      }(r);
    }).join(","),
        o = oi(n);
    this.userCode = "\n      void main() {\n        " + o + " coords = getOutputCoords();\n        setOutput(getX(" + r + "));\n      }\n    ";
  } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t[0] + " - coord - 1));\n        }\n      ";
},
    qs = function (t, e) {
  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
  var n = t.length;
  if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
  this.outputShape = t;
  var r = Ha("rc", n),
      o = r[n - 1] + " + 1 < " + this.outputShape[n - 1],
      a = r[n - 2] + " + 1 < " + this.outputShape[n - 2],
      i = oi(n);

  function s(n) {
    var r = t.map(function (r, o) {
      return function (n, r) {
        return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - " + r[n] + " - 1" : "" + r[n];
      }(o, n);
    });
    return "getChannel(getX(" + r.join(",") + "), vec2(" + r.slice(-2).join(",") + "))";
  }

  this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t[0] + " - rc - 1),\n            " + t[0] + " - rc - 1);\n          if(" + o + "){\n              result.g = getChannel(getX(" + t[0] + " - (rc  + 1) - 1),\n                " + t[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + i + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + function (t) {
    return s(t);
  }(r.slice()) + ";\n          if(" + o + "){\n            result.g = " + function (t) {
    return t[n - 1] = "(" + t[n - 1] + " + 1)", s(t);
  }(r.slice()) + ";\n          }\n          if(" + a + ") {\n            result.b = " + function (t) {
    return t[n - 2] = "(" + t[n - 2] + " + 1)", s(t);
  }(r.slice()) + ";\n            if(" + o + ") {\n              result.a = " + function (t) {
    return t[n - 1] = "(" + t[n - 1] + " + 1)", t[n - 2] = "(" + t[n - 2] + " + 1)", s(t);
  }(r.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
},
    Ks = function (t, e, n, r, o, a, i) {
  void 0 === i && (i = !0), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a;
  var s = oi(o.length),
      u = oi(a.length),
      c = "";
  1 === n ? c = "i" : 2 === n && (c = "i, j");
  var l = "getIndices(" + c + ")",
      h = "";
  1 === r ? h = "i" : 2 === r && (h = "i, coords[1]");
  var f = "getUpdates(" + h + ")",
      d = e > 1 ? "strides[j]" : "strides";
  this.userCode = "\n        " + s + " strides = " + s + "(" + o + ");\n\n        void main() {\n          " + u + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e + "; j++) {\n              int index = round(" + l + ");\n              flattenedIndex += index * " + d + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + f + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
},
    js = function (t, e) {
  this.variableNames = ["x", "segmentIds"];
  var n = t.windowSize,
      r = t.batchSize,
      o = t.inSize,
      a = t.numSegments,
      i = a * Math.ceil(o / n);
  this.outputShape = [r, i];
  var s = 4 * Math.floor(n / 4),
      u = n % 4,
      c = "\n        sumValue += dot(values, segFilter);\n    ",
      l = "";
  o % n > 0 && (l = "\n        if (inIdx < 0 || inIdx >= " + o + ") {\n          return initializationValue;\n        }\n      ");
  var h = "";
  o % n > 0 && (h = "\n        if (inIdx < 0 || inIdx >= " + o + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + a + ")) * float(" + n + "));\n        int currentSeg = int(mod(float(outIdx), float(" + a + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + s + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c + "\n        }\n\n        int inIdx = inOffset + " + s + ";\n        if (" + (1 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c + "\n        } else if (" + (2 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c + "\n        } else if (" + (3 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c + "\n        }\n        setOutput(sumValue);\n      }\n    ";
},
    Xs = function (t, e, n) {
  var r, o;
  if (this.variableNames = ["c", "a", "b"], this.outputShape = e, n > 4) throw Error("Where for rank " + n + " is not yet supported");
  if (1 === n) o = "resRC", r = "resRC";else {
    for (var a = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i = [], s = [], u = 0; u < e.length; u++) s.push("" + a[u]), u < t && i.push("" + a[u]);

    r = i.join(), o = s.join();
  }
  var c = oi(n);
  this.userCode = "\n      void main() {\n        " + c + " resRC = getOutputCoords();\n        float cVal = getC(" + r + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + o + "));\n        } else {\n          setOutput(getB(" + o + "));\n        }\n      }\n    ";
},
    Ys = function () {
  function t(t) {
    this.variableNames = ["source"], this.outputShape = t, this.rank = t.length;

    var e,
        n = oi(this.rank),
        r = "uniform int start[" + this.rank + "];",
        o = function (t) {
      if (1 === t) return "sourceLoc";
      if (t <= 6) return $s.slice(0, t).map(function (t) {
        return "sourceLoc." + t;
      }).join(",");
      throw Error("Slicing for rank " + t + " is not yet supported");
    }(this.rank);

    e = "\n        " + n + " sourceLoc;\n        " + n + " coords = getOutputCoords();\n        " + t.map(function (t, e) {
      return "sourceLoc." + $s[e] + " = start[" + e + "] + coords." + $s[e] + ";";
    }).join("\n") + "\n      ", this.userCode = "\n      " + r + "\n      void main() {\n        " + e + "\n        setOutput(getSource(" + o + "));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
    return function (n, r) {
      null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);
    };
  }, t;
}(),
    $s = ["x", "y", "z", "w", "u", "v"];

var Qs = function () {
  function t(t) {
    this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length;
    var e = oi(this.rank),
        n = Ha("coords", this.rank),
        r = Ha("sourceLoc", this.rank),
        o = 1 === this.rank ? "sourceLoc" : "vec2(" + r.slice(-2).join() + ")",
        a = "getChannel(getSource(" + r.join() + "), " + o + ")",
        i = "\n      result.x = " + a + ";\n      if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n        ++" + r[this.rank - 1] + ";\n        result.y = " + a + ";\n        --" + r[this.rank - 1] + ";\n      }\n    ",
        s = 1 === this.rank ? "" : "\n      --" + n[this.rank - 1] + ";\n      if (++" + n[this.rank - 2] + " < " + t[this.rank - 2] + ") {\n        ++" + r[this.rank - 2] + ";\n        result.z = " + a + ";\n        if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n          ++" + r[this.rank - 1] + ";\n          result.w = " + a + ";\n        }\n      }\n    ",
        u = this.rank <= 4 ? "sourceLoc = coords +\n            " + e + "(" + t.map(function (t, e) {
      return "start[" + e + "]";
    }).join() + ");" : t.map(function (t, e) {
      return r[e] + " = " + n[e] + " + start[" + e + "];";
    }).join("\n");
    this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e + " coords = getOutputCoords();\n        " + e + " sourceLoc;\n        " + u + "\n        vec4 result = vec4(0.);\n        " + i + "\n        " + s + "\n        setOutput(result);\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
    return function (n, r) {
      null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);
    };
  }, t;
}(),
    Js = function (t, e, n) {
  this.variableNames = ["x"], this.outputShape = n;
  var r = n.length,
      o = oi(n.length),
      a = oi(n.length),
      i = "";
  if (1 === r) i = "coords * strides + begin";else {
    var s = 0;
    i = n.map(function (t, e) {
      return s++, 1 === n.length ? "coords * strides[" + e + "] + begin[" + e + "]" : "coords[" + (s - 1) + "] * strides[" + e + "] + begin[" + e + "]";
    }).join(",");
  }
  this.userCode = "\n      " + o + " begin = " + o + "(" + t + ");\n      " + o + " strides = " + o + "(" + e + ");\n\n      void main() {\n        " + a + " coords = getOutputCoords();\n        setOutput(getX(" + i + "));\n      }\n    ";
},
    Zs = function () {
  function t(t) {
    this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};
  }

  return t.prototype.acquireTexture = function (t, e, n) {
    var r,
        o = tu(e, n),
        a = eu(t, o, n);

    if (a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []), this.freeTextures[a].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this.log();
      var i = this.freeTextures[a].shift();
      return this.usedTextures[a].push(i), i;
    }

    return this.numUsedTextures++, this.log(), o === Gt.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === Gt.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === Gt.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === Gt.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === Gt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[a].push(r), r;
  }, t.prototype.releaseTexture = function (t, e, n, r) {
    if (null != this.freeTextures) {
      var o = eu(e, tu(n, r), r);
      o in this.freeTextures || (this.freeTextures[o] = []), this.freeTextures[o].push(t), this.numFreeTextures++, this.numUsedTextures--;
      var a = this.usedTextures[o],
          i = a.indexOf(t);
      if (i < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      a.splice(i, 1), this.log();
    }
  }, t.prototype.log = function () {
    if (this.logEnabled) {
      var t = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t + ")");
    }
  }, t.prototype.getNumUsedTextures = function () {
    return this.numUsedTextures;
  }, t.prototype.getNumFreeTextures = function () {
    return this.numFreeTextures;
  }, t.prototype.dispose = function () {
    var t = this;

    if (null != this.freeTextures) {
      for (var e in this.freeTextures) this.freeTextures[e].forEach(function (e) {
        t.gpgpu.deleteMatrixTexture(e);
      });

      for (var e in this.usedTextures) this.usedTextures[e].forEach(function (e) {
        t.gpgpu.deleteMatrixTexture(e);
      });

      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
    }
  }, t;
}();

function tu(t, e) {
  if (t === zt.UPLOAD) return Gt.PACKED_2X2_FLOAT32;
  if (t === zt.RENDER || null == t) return function (t) {
    return i().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? Gt.PACKED_2X2_FLOAT32 : Gt.UNPACKED_FLOAT32 : t ? Gt.PACKED_2X2_FLOAT16 : Gt.UNPACKED_FLOAT16;
  }(e);
  if (t === zt.DOWNLOAD || t === zt.PIXELS) return Gt.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type " + t);
}

function eu(t, e, n) {
  return t[0] + "_" + t[1] + "_" + e + "_" + n;
}

var nu = function (t, e) {
  this.variableNames = ["A"];

  for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[r] * e[r];

  this.outputShape = n, this.rank = n.length;

  var o = oi(this.rank),
      a = function (t) {
    var e = t.length;
    if (e > 5) throw Error("Tile for rank " + e + " is not yet supported");
    if (1 === e) return "imod(resRC, " + t[0] + ")";

    for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r = [], o = 0; o < t.length; o++) r.push("imod(" + n[o] + ", " + t[o] + ")");

    return r.join();
  }(t);

  this.userCode = "\n      void main() {\n        " + o + " resRC = getOutputCoords();\n        setOutput(getA(" + a + "));\n      }\n    ";
};

var ru = function (t, e) {
  this.variableNames = ["A"];

  for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];

  this.outputShape = n, this.rank = n.length;

  var o = oi(this.rank),
      a = function (t) {
    var e = t.length;
    if (e > 6) throw Error("Transpose for rank " + e + " is not yet supported");

    for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r = new Array(e), o = 0; o < t.length; o++) r[t[o]] = n[o];

    return r.join();
  }(e);

  this.userCode = "\n    void main() {\n      " + o + " resRC = getOutputCoords();\n      setOutput(getA(" + a + "));\n    }\n    ";
};

var ou = function (t, e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;

  for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];

  if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
  var o = oi(this.rank),
      a = Ga("rc", this.rank),
      i = new Array(this.rank);

  for (r = 0; r < e.length; r++) i[e[r]] = a[r];

  var s = "vec2(" + i.slice(-2).join() + ")",
      u = "++" + a[this.rank - 1] + " < " + n[this.rank - 1],
      c = "getChannel(getA(" + i.join() + "), " + s + ")";
  this.userCode = "\n    void main() {\n      " + o + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c + ";\n      if(" + u + ") {\n        result[1] = " + c + ";\n      }\n      --" + a[this.rank - 1] + ";\n      if(++" + a[this.rank - 2] + " < " + n[this.rank - 2] + ") {\n        result[2] = " + c + ";\n        if(" + u + ") {\n          result[3] = " + c + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
},
    au = 1.7580993408473768,
    iu = 1.0507009873554805,
    su = function (t, e) {
  this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      float unaryOperation(float x) {\n        " + e + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
},
    uu = "if (isnan(x)) return x;",
    cu = "return x;",
    lu = "return abs(x);",
    hu = uu + "\n  return (x < 0.0) ? 0.0 : x;\n",
    fu = uu + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
    du = "return (x >= 0.0) ? x : (exp(x) - 1.0);",
    pu = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + au + ";\n  float scale = " + iu + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";

var vu = "return -x;",
    mu = "return ceil(x);",
    gu = "return floor(x);",
    yu = "return exp(x);",
    xu = "return exp(x) - 1.0;",
    bu = uu + "\n  return sin(x);\n",
    wu = uu + "\n  return cos(x);\n",
    Cu = uu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",
    Eu = uu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",
    Ru = uu + "\n  return atan(x);\n",
    Iu = uu + "return log(x + sqrt(x * x + 1.0));",
    ku = uu + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",
    Su = uu + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",
    Au = "return x;",
    Tu = "return x;",
    Du = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    Nu = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    Fu = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
    _u = function (t, e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
},
    Ou = function (t) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t;

  var e = t.length,
      n = Ha("rc", e),
      r = oi(e),
      o = function (t, e) {
    if (1 === t) return "rc";

    for (var n = "", r = 0; r < t; r++) n += e[r], r < t - 1 && (n += ",");

    return n;
  }(e, n),
      a = n.slice(-2),
      i = e <= 1 ? "rc" : "vec2(" + a.join(",") + ")";

  this.userCode = "\n      void main() {\n        " + r + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + o + ");\n\n        setOutput(getChannel(packedInput, " + i + "));\n      }\n    ";
},
    Mu = {};

function Bu(t, e) {
  if (void 0 === e && (e = !1), "linear" === t) return e ? Tu : cu;
  if ("relu" === t) return e ? Du : hu;
  if ("elu" === t) return e ? Fu : du;
  if ("relu6" === t) return e ? Nu : fu;
  if ("prelu" === t) return e ? Ci : xi;
  throw new Error("Activation " + t + " has not been implemented for the WebGL backend.");
}

var Pu = 600;

var Lu = function (t) {
  function o(e) {
    var n,
        r = t.call(this) || this;
    if (r.pendingRead = new WeakMap(), r.pendingDisposal = new WeakSet(), r.dataRefCount = new WeakMap(), r.numBytesInGPU = 0, r.uploadWaitMs = 0, r.downloadWaitMs = 0, r.warnedAboutMemory = !1, r.pendingDeletes = 0, r.disposed = !1, !i().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");

    if (null == e) {
      var o = jt(i().getNumber("WEBGL_VERSION"));
      r.binaryCache = (n = i().getNumber("WEBGL_VERSION")) in Mu ? Mu[n] : (Mu[n] = {}, Mu[n]), r.gpgpu = new ws(o), r.canvas = o.canvas, r.gpgpuCreatedLocally = !0;
    } else r.gpgpu = e, r.binaryCache = {}, r.gpgpuCreatedLocally = !1, r.canvas = e.gl.canvas;

    return r.textureManager = new Zs(r.gpgpu), r.numMBBeforeWarning = null == i().global.screen ? 1024 : i().global.screen.height * i().global.screen.width * window.devicePixelRatio * Pu / 1024 / 1024, r.texData = new aa(r, Lt), r;
  }

  return e(o, t), o.prototype.numDataIds = function () {
    return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
  }, o.prototype.write = function (t, e, n) {
    if (i().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === n && null != t) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    var r = {};
    return this.texData.set(r, {
      shape: e,
      dtype: n,
      values: t,
      usage: zt.UPLOAD
    }), r;
  }, o.prototype.move = function (t, e, n, r) {
    if (i().getBool("DEBUG") && this.checkNumericalProblems(e), "complex64" === r) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(t, {
      shape: n,
      dtype: r,
      values: e,
      usage: zt.UPLOAD
    });
  }, o.prototype.readSync = function (t) {
    var e = this.texData.get(t),
        n = e.values,
        r = e.dtype,
        o = e.complexTensors,
        a = e.slice,
        i = e.shape,
        s = e.isPacked;

    if (null != a) {
      var u = void 0;
      u = s ? new _u(i, Au) : new su(i, Au);
      var c = this.runWebGLProgram(u, [{
        dataId: t,
        shape: i,
        dtype: r
      }], r),
          l = this.readSync(c.dataId);
      return this.disposeData(c.dataId), l;
    }

    if (null != n) return this.convertAndCacheOnCPU(t);
    if ("string" === r) return n;
    var h,
        f,
        d = null != this.activeTimers;
    (d && (h = et()), "complex64" === r) ? f = Ra(o.real.dataSync(), o.imag.dataSync()) : f = this.getValuesFromTexture(t);
    return d && (this.downloadWaitMs += et() - h), this.convertAndCacheOnCPU(t, f);
  }, o.prototype.read = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, s, u, c, l, h, f, d, p, v, m, g, y, x, b, w, C, E, R;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (this.pendingRead.has(t)) return e = this.pendingRead.get(t), [2, new Promise(function (t) {
              return e.push(t);
            })];
            if (n = this.texData.get(t), o = n.values, a = n.shape, s = n.slice, u = n.dtype, c = n.complexTensors, l = n.isPacked, null != s) return h = void 0, h = l ? new _u(a, Au) : new su(a, Au), f = this.runWebGLProgram(h, [{
              dataId: t,
              shape: a,
              dtype: u
            }], u), d = this.read(f.dataId), this.disposeData(f.dataId), [2, d];
            if (null != o) return [2, this.convertAndCacheOnCPU(t)];
            if (!i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === i().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
            return p = null, "complex64" !== u && i().get("WEBGL_BUFFER_SUPPORTED") && (v = this.decode(t), m = this.texData.get(v.dataId), p = (R = this.gpgpu).createBufferFromTexture.apply(R, [m.texture].concat(Yt(a)))), this.pendingRead.set(t, []), "complex64" === u ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];

          case 1:
            r.sent(), r.label = 2;

          case 2:
            return "complex64" !== u ? [3, 4] : [4, Promise.all([c.real.data(), c.imag.data()])];

          case 3:
            return y = r.sent(), x = y[0], b = y[1], g = Ra(x, b), [3, 5];

          case 4:
            null == p ? g = this.getValuesFromTexture(t) : (w = k(a), g = this.gpgpu.downloadFloat32MatrixFromBuffer(p, w)), r.label = 5;

          case 5:
            return null != v && this.disposeData(v.dataId), C = this.convertAndCacheOnCPU(t, g), E = this.pendingRead.get(t), this.pendingRead.delete(t), E.forEach(function (t) {
              return t(C);
            }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [2, C];
        }
      });
    });
  }, o.prototype.checkNumericalProblems = function (t) {
    if (null != t) for (var e = 0; e < t.length; e++) {
      var n = t[e];

      if (!ee(n)) {
        if (i().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
        throw Error("The value " + n + " cannot be represented on this device.");
      }
    }
  }, o.prototype.getValuesFromTexture = function (t) {
    var e,
        n = this.texData.get(t),
        r = n.shape,
        o = n.dtype,
        a = n.isPacked,
        s = k(r);

    if (i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      var u = this.decode(t),
          c = this.texData.get(u.dataId),
          l = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [c.texture].concat(Yt(r))).subarray(0, s);
      return this.disposeData(u.dataId), l;
    }

    var h = i().getBool("WEBGL_PACK") && !0 === a,
        f = h ? De(r) : r,
        d = h ? new Xi(f) : new ji(f),
        p = this.runWebGLProgram(d, [{
      shape: f,
      dtype: o,
      dataId: t
    }], "float32"),
        v = this.texData.get(p.dataId),
        m = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture, v.texShape[0], v.texShape[1]).subarray(0, s);
    return this.disposeData(p.dataId), m;
  }, o.prototype.time = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, s, u, c;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return e = this.activeTimers, n = [], o = !1, null == this.programTimersStack ? (this.programTimersStack = n, o = !0) : this.activeTimers.push(n), this.activeTimers = n, t(), a = I(this.activeTimers.map(function (t) {
              return t.query;
            })).filter(function (t) {
              return null != t;
            }), s = I(this.activeTimers.map(function (t) {
              return t.name;
            })).filter(function (t) {
              return null != t;
            }), this.activeTimers = e, o && (this.programTimersStack = null), u = {
              uploadWaitMs: this.uploadWaitMs,
              downloadWaitMs: this.downloadWaitMs,
              kernelMs: null,
              wallMs: null
            }, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [4, Promise.all(a)] : [3, 2];

          case 1:
            return c = r.sent(), u.kernelMs = w(c), u.getExtraProfileInfo = function () {
              return c.map(function (t, e) {
                return {
                  name: s[e],
                  ms: t
                };
              }).map(function (t) {
                return t.name + ": " + t.ms;
              }).join(", ");
            }, [3, 3];

          case 2:
            u.kernelMs = {
              error: "WebGL query timers are not supported in this environment."
            }, r.label = 3;

          case 3:
            return this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, u];
        }
      });
    });
  }, o.prototype.memory = function () {
    return {
      unreliable: !1,
      numBytesInGPU: this.numBytesInGPU
    };
  }, o.prototype.startTimer = function () {
    return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
      startMs: et(),
      endMs: null
    };
  }, o.prototype.endTimer = function (t) {
    return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = et(), t);
  }, o.prototype.getQueryTime = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t)] : [2, (e = t).endMs - e.startMs];
      });
    });
  }, o.prototype.disposeData = function (t) {
    if (!this.pendingDisposal.has(t)) {
      if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;

      if (this.texData.has(t)) {
        this.releaseGPUData(t);
        var e = this.texData.get(t).complexTensors;
        null != e && (e.real.dispose(), e.imag.dispose()), this.texData.delete(t);
      }
    }
  }, o.prototype.releaseGPUData = function (t) {
    var e = this.texData.get(t),
        n = e.texture,
        r = e.dtype,
        o = e.texShape,
        a = e.usage,
        i = e.isPacked,
        s = e.slice,
        u = s && s.origDataId || t,
        c = this.dataRefCount.get(u);
    c > 1 ? this.dataRefCount.set(u, c - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(o, r), this.textureManager.releaseTexture(n, o, a, i)));
    var l = this.texData.get(t);
    l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null;
  }, o.prototype.getTexture = function (t) {
    return this.uploadToGPU(t), this.texData.get(t).texture;
  }, o.prototype.getDataInfo = function (t) {
    return this.texData.get(t);
  }, o.prototype.getCPUBackend = function () {
    return i().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Lt.findBackend("cpu")), this.cpuBackend) : null;
  }, o.prototype.shouldExecuteOnCPU = function (t, e) {
    var n = this;
    return void 0 === e && (e = 128), null != this.getCPUBackend() && t.every(function (t) {
      return null == n.texData.get(t.dataId).texture && t.size < e;
    });
  }, o.prototype.getGPGPUContext = function () {
    return this.gpgpu;
  }, o.prototype.complex = function (t, e) {
    var n = this.makeOutput(t.shape, "complex64");
    return this.texData.get(n.dataId).complexTensors = {
      real: Lt.keep(t.clone()),
      imag: Lt.keep(e.clone())
    }, n;
  }, o.prototype.real = function (t) {
    return this.texData.get(t.dataId).complexTensors.real.clone();
  }, o.prototype.imag = function (t) {
    return this.texData.get(t.dataId).complexTensors.imag.clone();
  }, o.prototype.slice = function (t, e, n) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, e, n);
    if (0 === k(n)) return Fn([], n, t.dtype);
    var r = this.texData.get(t.dataId).isPacked,
        o = jo(t.shape, e, n);

    if (r || !o) {
      var a = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Qs(n) : new Ys(n),
          s = a.getCustomSetupFunc(e);
      return this.compileAndRun(a, [t], null, s);
    }

    return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n);
  }, o.prototype.shallowSlice = function (t, e, n) {
    var r = this.texData.get(t.dataId),
        o = this.makeOutput(n, t.dtype),
        a = this.texData.get(o.dataId);
    Object.assign(a, r), a.shape = n, a.dtype = t.dtype;
    var i = Xo(e, t.strides);
    r.slice && (i += r.slice.flatOffset), a.slice = {
      flatOffset: i,
      origDataId: r.slice && r.slice.origDataId || t.dataId
    };
    var s = this.dataRefCount.get(a.slice.origDataId) || 1;
    return this.dataRefCount.set(a.slice.origDataId, s + 1), o;
  }, o.prototype.stridedSlice = function (t, e, n, r) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, e, n, r);
    var o = Ho(e, n, r);
    if (o.some(function (t) {
      return 0 === t;
    })) return Fn([], o);
    var a = new Js(e, r, o);
    return this.compileAndRun(a, [t]);
  }, o.prototype.reverse = function (t, e) {
    var n = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new qs(t.shape, e) : new Hs(t.shape, e);
    return this.compileAndRun(n, [t]);
  }, o.prototype.concat = function (t, e) {
    if ("complex64" === t[0].dtype) {
      var n = t.map(function (t) {
        return Dn(t);
      }),
          r = t.map(function (t) {
        return Nn(t);
      });
      return Tn(this.concat(n, e), this.concat(r, e));
    }

    if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);
    if (1 === t.length) return t[0];

    if (t.length > i().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var o = Math.floor(t.length / 2),
          a = this.concat(t.slice(0, o), e),
          s = this.concat(t.slice(o), e);
      return this.concat([a, s], e);
    }

    if (i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
      var u = new Ai(t.map(function (t) {
        return t.shape;
      }), e);
      return this.compileAndRun(u, t);
    }

    var c = Sn(t.map(function (t) {
      return t.shape;
    }), e),
        l = t.map(function (t) {
      return t.as2D(-1, k(t.shape.slice(e)));
    }),
        h = new Si(l.map(function (t) {
      return t.shape;
    }));
    return this.compileAndRun(h, l).reshape(c);
  }, o.prototype.neg = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, vu, t.dtype);
    var e = new su(t.shape, vu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.batchMatMul = function (t, e, n, r) {
    var o = n ? t.shape[2] : t.shape[1],
        a = r ? e.shape[1] : e.shape[2],
        i = n ? t.shape[1] : t.shape[2],
        s = t.shape[0];

    if ((1 === o || 1 === a) && i > 1e3) {
      n && (t = t.transpose([0, 2, 1])), r && (e = e.transpose([0, 2, 1]));
      var u = 1 === a ? t : t.as3D(s, i, 1),
          c = 1 === a ? 2 : 1,
          l = 1 === a ? e.as3D(s, 1, i) : e;
      return this.multiply(u, l).sum(c, !0);
    }

    var h = Tt(t.dtype, e.dtype),
        f = new Ts(t.shape, [s, o, a], n, r);
    return this.compileAndRun(f, [t, e], h);
  }, o.prototype.fusedBatchMatMul = function (t) {
    var e = t.a,
        n = t.b,
        r = t.transposeA,
        o = t.transposeB,
        a = t.bias,
        i = t.activation,
        s = t.preluActivationWeights,
        u = r ? e.shape[2] : e.shape[1],
        c = o ? n.shape[1] : n.shape[2],
        l = e.shape[0],
        h = Tt(e.dtype, n.dtype),
        f = null != a,
        d = null != s,
        p = i ? Bu(i, !0) : null,
        v = new Ts(e.shape, [l, u, c], r, o, f, p, d),
        m = [e, n];
    return a && m.push(a), s && m.push(s), this.compileAndRun(v, m, h);
  }, o.prototype.multiply = function (t, e) {
    if ("complex64" === t.dtype) {
      var n = this.texData.get(t.dataId),
          r = this.texData.get(e.dataId),
          o = new pi(fi, t.shape, e.shape),
          a = new pi(di, t.shape, e.shape),
          s = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag), this.makeComplexComponentTensorInfo(e, r.complexTensors.real), this.makeComplexComponentTensorInfo(e, r.complexTensors.imag)],
          u = this.compileAndRun(o, s),
          c = this.compileAndRun(a, s),
          l = this.complex(u, c);
      return u.dispose(), c.dispose(), l;
    }

    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.multiply(t, e);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, gi, t.dtype);
    var h = new bi(gi, t.shape, e.shape);
    return this.compileAndRun(h, [t, e], t.dtype);
  }, o.prototype.batchNormalization = function (t, e, n, r, o, a) {
    var s = [t, e, n],
        u = null;
    null != a && (u = a.shape, s.push(a));
    var c = null;

    if (null != o && (c = o.shape, s.push(o)), i().getBool("WEBGL_PACK_NORMALIZATION")) {
      var l = new hi(t.shape, e.shape, n.shape, u, c, r);
      return this.compileAndRun(l, s);
    }

    var h = new li(t.shape, e.shape, n.shape, u, c, r);
    return this.compileAndRun(h, s);
  }, o.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
    var a = i().getBool("WEBGL_PACK_NORMALIZATION") ? new ks(t.shape, e, n, r, o) : new Rs(t.shape, e, n, r, o);
    return this.compileAndRun(a, [t]);
  }, o.prototype.LRNGrad = function (t, e, n, r, o, a, i) {
    var s = new Is(e.shape, r, o, a, i);
    return this.compileAndRun(s, [e, n, t]);
  }, o.prototype.tile = function (t, e) {
    if ("string" === t.dtype) {
      var n = this.readSync(t.dataId).map(function (t) {
        return ot(t);
      });
      return Pa(er(t.shape, t.dtype, n), e);
    }

    var r = new nu(t.shape, e);
    return this.compileAndRun(r, [t]);
  }, o.prototype.pad = function (t, e, n) {
    var r = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Os(t.shape, e, n) : new _s(t.shape, e, n);
    return this.compileAndRun(r, [t]);
  }, o.prototype.transpose = function (t, e) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.transpose(t, e);
    var n = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ou(t.shape, e) : new ru(t.shape, e);
    return this.compileAndRun(n, [t]);
  }, o.prototype.gather = function (t, e, n) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.gather(t, e, n);
    var r = new es(t.shape, e.size, n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.batchToSpaceND = function (t, e, n) {
    C(t.rank <= 4, function () {
      return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = xr(t.shape, e, r),
        a = br(o.length, e.length),
        i = wr(t.shape, e, r),
        s = Cr(n, e.length),
        u = Er(i, n, e.length);
    return t.reshape(o).transpose(a).reshape(i).slice(s, u);
  }, o.prototype.spaceToBatchND = function (t, e, n) {
    C(t.rank <= 4, function () {
      return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = [[0, 0]];
    o.push.apply(o, n);

    for (var a = 1 + e.length; a < t.shape.length; ++a) o.push([0, 0]);

    var i = t.pad(o),
        s = xr(i.shape, e, r, !1),
        u = br(s.length, e.length, !1),
        c = wr(i.shape, e, r, !1);
    return i.reshape(s).transpose(u).reshape(c);
  }, o.prototype.reduce = function (t, e, n) {
    var r = t.shape[0],
        o = t.shape[1],
        a = Po(o),
        i = new Ps({
      windowSize: a,
      inSize: o,
      batchSize: r
    }, e),
        s = this.compileAndRun(i, [t], n);
    return 1 === s.shape[1] ? s : this.reduce(s, e, n);
  }, o.prototype.argReduce = function (t, e, n) {
    void 0 === n && (n = null);
    var r = t.shape[0],
        o = t.shape[1];
    null != n && (r = n.shape[0], o = n.shape[1]);
    var a = Po(o),
        i = new za({
      windowSize: a,
      inSize: o,
      batchSize: r
    }, e, null == n),
        s = [t];
    null != n && s.push(n);
    var u = this.compileAndRun(i, s, "int32");
    return 1 === u.shape[1] ? u : this.argReduce(t, e, u);
  }, o.prototype.argReducePacked = function (t, e, n) {
    void 0 === n && (n = null);
    var r = null != n ? n.shape : t.shape,
        o = Po(r[r.length - 1]),
        a = new si(r, o, e, null == n),
        i = null == n ? [t] : [t, n],
        s = this.compileAndRun(a, i, "int32");
    return s.rank === t.rank ? this.argReducePacked(t, e, s) : s;
  }, o.prototype.sum = function (t, e) {
    Cn("sum", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o),
        i = Dt(t.dtype);
    return this.reduce(a, "sum", i).reshape(r);
  }, o.prototype.prod = function (t, e) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, e);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o),
        i = Dt(t.dtype);
    return this.reduce(a, "prod", i).reshape(r);
  }, o.prototype.unsortedSegmentSum = function (t, e, n) {
    var r = 0,
        o = En([r], t.rank),
        a = t;
    null != o && (a = t.transpose(o), r = In(1, t.rank)[0]);

    var i = function (t, e, n) {
      for (var r = [], o = t.length, a = 0; a < o; a++) a !== e ? r.push(t[a]) : r.push(n);

      return r;
    }(a.shape, r, n),
        s = k([a.shape[r]]),
        u = a.as2D(-1, s),
        c = Dt(t.dtype),
        l = this.segOpCompute(u, "unsortedSegmentSum", e, c, n).reshape(i);

    return null != o && (l = l.transpose(Rn(o))), l;
  }, o.prototype.segOpCompute = function (t, e, n, r, o) {
    var a = t.shape[0],
        i = t.shape[1],
        s = function (t, e) {
      var n,
          r = !1;

      for (t <= Bo ? (n = t, r = !0) : n = Y(t, Math.floor(Math.sqrt(t))); !r;) n > e || n === t ? r = !0 : n = Y(t, n + 1);

      return n;
    }(i, o),
        u = new js({
      windowSize: s,
      inSize: i,
      batchSize: a,
      numSegments: o
    }, e),
        c = this.compileAndRun(u, [t, n], r);

    return c.shape[1] === o ? c : (n = Kn(0, o).tile([i / s]), this.segOpCompute(c, e, n, r, o));
  }, o.prototype.argMinMaxReduce = function (t, e, n) {
    var r = [e];

    if (Cn("arg" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !i().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2) {
      var o = bn(t.shape, r),
          a = o[0],
          s = k(o[1]),
          u = t.as2D(-1, s);
      return this.argReduce(u, n).reshape(a);
    }

    return this.argReducePacked(t, n);
  }, o.prototype.argMin = function (t, e) {
    return this.argMinMaxReduce(t, e, "min");
  }, o.prototype.argMax = function (t, e) {
    return this.argMinMaxReduce(t, e, "max");
  }, o.prototype.cumsum = function (t, e, n, r) {
    if (e !== t.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);
    var o = new Vi(t.shape, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.equal = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(equal(a, b));\n", "bool");
    var n = new bi("return float(a == b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.notEqual = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(notEqual(a, b));\n", "bool");
    var n = new bi("return float(a != b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.less = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.less(t, e);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThan(a, b));\n", "bool");
    var n = new bi("return float(a < b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.lessEqual = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
    var n = new bi("return float(a <= b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.greater = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.greater(t, e);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThan(a, b));\n", "bool");
    var n = new bi("return float(a > b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.greaterEqual = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
    var n = new bi("return float(a >= b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.logicalNot = function (t) {
    var e = new su(t.shape, "return float(!(x >= 1.0));");
    return this.compileAndRun(e, [t]);
  }, o.prototype.logicalAnd = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
    var n = new bi("return float(a >= 1.0 && b >= 1.0);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.logicalOr = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
    var n = new bi("return float(a >= 1.0 || b >= 1.0);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.select = function (t, e, n) {
    var r = new Xs(t.rank, e.shape, e.rank);
    return this.compileAndRun(r, [t, e, n], Tt(e.dtype, n.dtype));
  }, o.prototype.where = function (t) {
    dn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    var e = t.dataSync();
    return Wa(t.shape, e);
  }, o.prototype.topk = function (t, e, n) {
    return La(t.dataSync(), t.shape, t.dtype, e);
  }, o.prototype.min = function (t, e) {
    Cn("min", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "min", a.dtype).reshape(r);
  }, o.prototype.minimum = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.minimum(t, e);
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ei("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new bi("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.mod = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ei("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new bi("if (b == 0.0) return NAN;\n  return mod(a, b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.max = function (t, e) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, e);
    Cn("max", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "max", a.dtype).reshape(r);
  }, o.prototype.maximum = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.maximum(t, e);
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ei("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new bi("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.all = function (t, e) {
    Cn("all", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "all", a.dtype).reshape(r);
  }, o.prototype.any = function (t, e) {
    Cn("any", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "any", a.dtype).reshape(r);
  }, o.prototype.floorDiv = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
    var n = new bi("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "int32");
  }, o.prototype.add = function (t, e) {
    if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, vi);
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.add(t, e);
    var n = Tt(t.dtype, e.dtype);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, vi, n);
    var r = new bi(vi, t.shape, e.shape);
    return this.compileAndRun(r, [t, e], n);
  }, o.prototype.packedUnaryOp = function (t, e, n) {
    var r = new _u(t.shape, e);
    return this.compileAndRun(r, [t], n);
  }, o.prototype.packedBinaryOp = function (t, e, n, r, o) {
    void 0 === o && (o = !1);
    var a = new Ei(n, t.shape, e.shape, o);
    return this.compileAndRun(a, [t, e], r);
  }, o.prototype.complexSeparableBinaryOp = function (t, e, n) {
    var r = this,
        o = this.texData.get(t.dataId),
        a = this.texData.get(e.dataId),
        i = [[o.complexTensors.real, a.complexTensors.real], [o.complexTensors.imag, a.complexTensors.imag]].map(function (o) {
      var a = o[0],
          i = o[1],
          s = r.makeComplexComponentTensorInfo(t, a),
          u = r.makeComplexComponentTensorInfo(e, i),
          c = new bi(n, t.shape, e.shape);
      return r.compileAndRun(c, [s, u], Tt(a.dtype, i.dtype));
    }),
        s = i[0],
        u = i[1],
        c = this.complex(s, u);
    return s.dispose(), u.dispose(), c;
  }, o.prototype.makeComplexComponentTensorInfo = function (t, e) {
    return {
      dataId: e.dataId,
      dtype: e.dtype,
      shape: t.shape
    };
  }, o.prototype.addN = function (t) {
    if (1 === t.length) return t[0];

    if (t.length > i().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var e = Math.floor(t.length / 2),
          n = this.addN(t.slice(0, e)),
          r = this.addN(t.slice(e));
      return this.addN([n, r]);
    }

    var o = t.map(function (t) {
      return t.dtype;
    }).reduce(function (t, e) {
      return Tt(t, e);
    }),
        a = t.map(function (t) {
      return t.shape;
    }),
        s = i().getBool("WEBGL_PACK") ? new Va(t[0].shape, a) : new Ua(t[0].shape, a);
    return this.compileAndRun(s, t, o);
  }, o.prototype.subtract = function (t, e) {
    if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, mi);
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.subtract(t, e);
    var n = Tt(t.dtype, e.dtype);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, mi, t.dtype);
    var r = new bi(mi, t.shape, e.shape);
    return this.compileAndRun(r, [t, e], n);
  }, o.prototype.pow = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ei("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new bi("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t.shape, e.shape),
        r = Tt(t.dtype, e.dtype);
    return this.compileAndRun(n, [t, e], r);
  }, o.prototype.ceil = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, mu, t.dtype);
    var e = new su(t.shape, mu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.floor = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, gu, t.dtype);
    var e = new su(t.shape, gu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.sign = function (t) {
    var e = new su(t.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.isNaN = function (t) {
    var e = new su(t.shape, "return float(isnan(x));");
    return this.compileAndRun(e, [t], "bool");
  }, o.prototype.isInf = function (t) {
    var e = new su(t.shape, "return float(isinf(x));");
    return this.compileAndRun(e, [t], "bool");
  }, o.prototype.isFinite = function (t) {
    var e = new su(t.shape, "return float(!isnan(x) && !isinf(x));");
    return this.compileAndRun(e, [t], "bool");
  }, o.prototype.round = function (t) {
    var e = new su(t.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.exp = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, yu, t.dtype);
    var e = new su(t.shape, yu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.expm1 = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, xu, t.dtype);
    var e = new su(t.shape, xu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.softmax = function (t, e) {
    var n = O([e], t.shape),
        r = this.max(t, n),
        o = wn(r.shape, n),
        a = this.subtract(t, r.reshape(o)),
        i = this.exp(a),
        s = this.sum(i, n).reshape(o);
    return _o(i, s);
  }, o.prototype.log = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t.dtype);
    var e = new su(t.shape, "if (x < 0.0) return NAN;\n  return log(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.log1p = function (t) {
    var e = new su(t.shape, "return log(1.0 + x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.sqrt = function (t) {
    var e = new su(t.shape, "return sqrt(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.rsqrt = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);
    var e = new su(t.shape, "return inversesqrt(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.reciprocal = function (t) {
    var e = new su(t.shape, "return 1.0 / x;");
    return this.compileAndRun(e, [t]);
  }, o.prototype.relu = function (t) {
    var e;
    return e = i().getBool("WEBGL_PACK") ? new _u(t.shape, Du) : new su(t.shape, hu), this.compileAndRun(e, [t]);
  }, o.prototype.relu6 = function (t) {
    var e;
    return e = i().getBool("WEBGL_PACK") ? new _u(t.shape, Nu) : new su(t.shape, fu), this.compileAndRun(e, [t]);
  }, o.prototype.prelu = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ei(Ci, t.shape, e.shape) : new bi(xi, t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.elu = function (t) {
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Fu, t.dtype);
    var e = new su(t.shape, du);
    return this.compileAndRun(e, [t]);
  }, o.prototype.eluDer = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ei("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t.shape, e.shape) : new bi("return (b >= 1.0) ? a : a * (b + 1.0);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.selu = function (t) {
    var e = new su(t.shape, pu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.int = function (t) {
    var e = new su(t.shape, "return float(int(x));");
    return this.compileAndRun(e, [t], "int32");
  }, o.prototype.clip = function (t, e, n) {
    var r,
        o = (r = i().getBool("WEBGL_PACK_CLIP") ? new Ii(t.shape) : new Ri(t.shape)).getCustomSetupFunc(e, n);
    return this.compileAndRun(r, [t], null, o);
  }, o.prototype.abs = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, lu, t.dtype);
    var e = new su(t.shape, lu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.complexAbs = function (t) {
    var e = this.texData.get(t.dataId),
        n = new ki(t.shape),
        r = [this.makeComplexComponentTensorInfo(t, e.complexTensors.real), this.makeComplexComponentTensorInfo(t, e.complexTensors.imag)];
    return this.compileAndRun(n, r);
  }, o.prototype.sigmoid = function (t) {
    var e = new su(t.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
    return this.compileAndRun(e, [t]);
  }, o.prototype.softplus = function (t) {
    var e = new su(t.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.sin = function (t) {
    var e = new su(t.shape, bu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.cos = function (t) {
    var e = new su(t.shape, wu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.tan = function (t) {
    var e = new su(t.shape, "return tan(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.asin = function (t) {
    var e = new su(t.shape, Cu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.acos = function (t) {
    var e = new su(t.shape, Eu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.atan = function (t) {
    var e = new su(t.shape, Ru);
    return this.compileAndRun(e, [t]);
  }, o.prototype.atan2 = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ei("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new bi("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.sinh = function (t) {
    var e = new su(t.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.cosh = function (t) {
    var e = new su(t.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.tanh = function (t) {
    var e = new su(t.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.asinh = function (t) {
    var e = new su(t.shape, Iu);
    return this.compileAndRun(e, [t]);
  }, o.prototype.acosh = function (t) {
    var e = new su(t.shape, ku);
    return this.compileAndRun(e, [t]);
  }, o.prototype.atanh = function (t) {
    var e = new su(t.shape, Su);
    return this.compileAndRun(e, [t]);
  }, o.prototype.erf = function (t) {
    var e = new su(t.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
    return this.compileAndRun(e, [t]);
  }, o.prototype.step = function (t, e) {
    var n = new su(t.shape, function (t) {
      return void 0 === t && (t = 0), uu + "\n    return x > 0.0 ? 1.0 : float(" + t + ");\n  ";
    }(e));
    return this.compileAndRun(n, [t]);
  }, o.prototype.conv2dByMatMul = function (t, e, n, r, o, a) {
    var s = t.shape,
        u = this.texData.get(t.dataId),
        c = n.inChannels,
        l = s[0] * s[1] * s[2],
        h = n.outChannels,
        f = "channelsLast" === n.dataFormat,
        d = (1 === l || 1 === h) && c > 1e3,
        p = s[2] % 2 != 0 && !!u.isPacked;

    if (d || !i().getBool("WEBGL_LAZILY_UNPACK") || !i().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !p) {
      var v = f ? s[0] * s[1] * s[2] : s[0] * s[2] * s[3],
          m = this.reshape(t, [1, v, n.inChannels]),
          g = this.reshape(e, [1, n.inChannels, n.outChannels]);
      return this.reshape(this.fusedBatchMatMul({
        a: m,
        b: g,
        transposeA: !1,
        transposeB: !1,
        bias: r,
        activation: o,
        preluActivationWeights: a
      }), n.outShape);
    }

    var y = f ? s[0] * s[1] * (s[2] + 1) : s[0] * s[2] * (s[3] + 1),
        x = {
      dataId: t.dataId,
      shape: [1, y, n.inChannels],
      dtype: t.dtype
    },
        b = u.shape;
    u.shape = u.shape.slice(), u.shape[u.shape.length - 2]++, C(_e(u.shape, x.shape), function () {
      return "packed reshape " + u.shape + " to " + x.shape + " isn't free";
    });
    var w = this.reshape(e, [1, n.inChannels, n.outChannels]),
        E = this.fusedBatchMatMul({
      a: x,
      b: w,
      transposeA: !1,
      transposeB: !1,
      bias: r,
      activation: o,
      preluActivationWeights: a
    }),
        R = this.texData.get(E.dataId);
    return C(R.isPacked, function () {
      return "batchMatMul result is expected to be packed";
    }), u.shape = b, R.shape = n.outShape, Lt.makeTensorFromDataId(E.dataId, n.outShape, E.dtype);
  }, o.prototype.conv2dWithIm2Row = function (t, e, n, r, o, a) {
    var i = n.filterWidth,
        s = n.filterHeight,
        u = n.inChannels,
        c = n.outWidth,
        l = n.outHeight,
        h = "channelsLast" === n.dataFormat,
        f = i * s * u,
        d = l * c,
        p = [f, d],
        v = t.squeeze([0]),
        m = e.reshape([1, f, -1]),
        g = new Es(p, v.shape, n),
        y = this.compileAndRun(g, [v]).reshape([1, p[0], p[1]]),
        x = null != r,
        b = null != a,
        w = o ? Bu(o, !0) : null,
        C = new Ts(y.shape, [1, d, n.outChannels], !0, !1, x, w, b),
        E = [y, m];
    r && E.push(r), b && E.push(a);
    var R = this.compileAndRun(C, E);
    return h ? R.reshape([1, l, c, n.outChannels]) : R.reshape([1, n.outChannels, l, c]);
  }, o.prototype.fusedConv2d = function (t) {
    var e = t.input,
        n = t.filter,
        r = t.convInfo,
        o = t.bias,
        a = t.activation,
        s = t.preluActivationWeights;
    if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && ("SAME" === r.padInfo.type || "VALID" === r.padInfo.type)) return this.conv2dByMatMul(e, n, r, o, a, s);
    if (i().getBool("WEBGL_CONV_IM2COL") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, o, a, s);
    var u = null != o,
        c = null != s,
        l = a ? Bu(a, !1) : null,
        h = new Bi(r, u, l, c),
        f = [e, n];
    return o && f.push(o), s && f.push(s), this.compileAndRun(h, f);
  }, o.prototype.conv2d = function (t, e, n) {
    if (1 === n.filterHeight && 1 === n.filterWidth && 1 === n.dilationHeight && 1 === n.dilationWidth && 1 === n.strideHeight && 1 === n.strideWidth && ("SAME" === n.padInfo.type || "VALID" === n.padInfo.type)) return this.conv2dByMatMul(t, e, n);
    if (i().getBool("WEBGL_CONV_IM2COL") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n);
    var r = new Bi(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv2dDerInput = function (t, e, n) {
    var r = new Ni(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv2dDerFilter = function (t, e, n) {
    var r = new Di(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.fusedDepthwiseConv2D = function (t) {
    var e,
        n = t.input,
        r = t.filter,
        o = t.convInfo,
        a = t.bias,
        s = t.activation,
        u = t.preluActivationWeights,
        c = i().getBool("WEBGL_PACK_DEPTHWISECONV") && o.strideWidth <= 2 && o.outChannels / o.inChannels == 1,
        l = s ? Bu(s, c) : null,
        h = [n, r],
        f = null != a,
        d = null != u;
    return f && h.push(a), d && h.push(u), c ? (e = new Wi(o, f, l, d), this.compileAndRun(e, h)) : (e = new Li(o, f, l, d), this.compileAndRun(e, h));
  }, o.prototype.depthwiseConv2D = function (t, e, n) {
    var r;
    return i().getBool("WEBGL_PACK_DEPTHWISECONV") && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? (r = new Wi(n), this.compileAndRun(r, [t, e])) : (r = new Li(n), this.compileAndRun(r, [t, e]));
  }, o.prototype.depthwiseConv2DDerInput = function (t, e, n) {
    var r = new Mi(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
    var r = new Oi(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv3d = function (t, e, n) {
    var r = new Pi(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv3dDerInput = function (t, e, n) {
    var r = new _i(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv3dDerFilter = function (t, e, n) {
    var r = new Fi(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.maxPool = function (t, e) {
    var n = new Ms(e, "max", !1);
    return this.compileAndRun(n, [t]);
  }, o.prototype.avgPool = function (t, e) {
    var n = new Ms(e, "avg", !1);
    return this.compileAndRun(n, [t], "float32");
  }, o.prototype.maxPoolBackprop = function (t, e, n, r) {
    var o = new Ms(r, "max", !0),
        a = this.compileAndRun(o, [e]),
        i = new Ss(r),
        s = this.compileAndRun(i, [t, a], e.dtype);
    return a.dispose(), s;
  }, o.prototype.avgPoolBackprop = function (t, e, n) {
    var r = new ui(n);
    return this.compileAndRun(r, [t], e.dtype);
  }, o.prototype.cast = function (t, e) {
    return ba(t, e, this);
  }, o.prototype.unstack = function (t, e) {
    for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++) a !== e && (r[o++] = t.shape[a]);

    var i = new Array(t.rank).fill(0),
        s = t.shape.slice();
    s[e] = 1;
    var u = new Array(n);

    for (a = 0; a < u.length; a++) i[e] = a, u[a] = this.slice(t, i, s).reshape(r);

    return u;
  }, o.prototype.avgPool3d = function (t, e) {
    var n = new Bs(e, "avg", !1);
    return this.compileAndRun(n, [t], "float32");
  }, o.prototype.avgPool3dBackprop = function (t, e, n) {
    var r = new ci(n);
    return this.compileAndRun(r, [t], e.dtype);
  }, o.prototype.maxPool3d = function (t, e) {
    var n = new Bs(e, "max", !1);
    return this.compileAndRun(n, [t], "float32");
  }, o.prototype.maxPool3dBackprop = function (t, e, n, r) {
    var o = new Bs(r, "max", !0),
        a = this.compileAndRun(o, [e]),
        i = new As(r),
        s = this.compileAndRun(i, [t, a], e.dtype);
    return a.dispose(), s;
  }, o.prototype.reshape = function (t, e) {
    var n = this.texData.get(t.dataId);

    if (n.isPacked && !_e(t.shape, e) && (null === n.texture || !_e(n.shape, e))) {
      var r = this.packedReshape(t, e);
      return Lt.makeTensorFromDataId(r.dataId, r.shape, r.dtype);
    }

    return wa(t, e);
  }, o.prototype.resizeBilinear = function (t, e, n, r) {
    var o = i().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new Vs(t.shape, e, n, r) : new Us(t.shape, e, n, r);
    return this.compileAndRun(o, [t], "float32");
  }, o.prototype.resizeBilinearBackprop = function (t, e, n) {
    var r = new Ws(t, e, n);
    return this.compileAndRun(r, [t]);
  }, o.prototype.resizeNearestNeighbor = function (t, e, n, r) {
    var o = new Gs(t.shape, e, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
    var r = new zs(t, e, n);
    return this.compileAndRun(r, [t]);
  }, o.prototype.multinomial = function (t, e, n, r) {
    var o = e ? t : ra(t),
        a = o.shape[0],
        i = o.shape[1],
        s = new Ds(a, i, n),
        u = s.getCustomSetupFunc(r);
    return this.compileAndRun(s, [o], "int32", u);
  }, o.prototype.oneHot = function (t, e, n, r) {
    var o = new Ns(t.size, e, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.diag = function (t) {
    var e = new Ki(t.size);
    return this.compileAndRun(e, [t]);
  }, o.prototype.nonMaxSuppression = function (t, e, n, r, o) {
    return dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), Da(t.dataSync(), e.dataSync(), n, r, o);
  }, o.prototype.cropAndResize = function (t, e, n, r, o, a) {
    var i = new Ui(t.shape, e.shape, r, o, a);
    return this.compileAndRun(i, [t, e, n], "float32");
  }, o.prototype.depthToSpace = function (t, e, n) {
    C(e > 1, function () {
      return "blockSize should be > 1 for depthToSpace, but was: " + e;
    });
    var r = t.shape[0],
        o = "NHWC" === n ? t.shape[1] : t.shape[2],
        a = "NHWC" === n ? t.shape[2] : t.shape[3],
        i = "NHWC" === n ? t.shape[3] : t.shape[1],
        s = o * e,
        u = a * e,
        c = i / (e * e),
        l = new qi("NHWC" === n ? [r, s, u, c] : [r, c, s, u], e, n);
    return this.compileAndRun(l, [t]);
  }, o.prototype.split = function (t, e, n) {
    return Ba(t, e, n);
  }, o.prototype.scatterND = function (t, e, n) {
    var r = Uo(0, t, n),
        o = r.sliceRank,
        a = r.numUpdates,
        i = r.sliceSize,
        s = r.strides,
        u = r.outputSize,
        c = [u / i, i],
        l = t.reshape([a, o]),
        h = e.reshape([a, i]);
    if (0 === u) return wa(Fn([]), n);
    var f = On(0),
        d = new Ks(a, o, l.rank, h.rank, s, c);
    return this.compileAndRun(d, [h, l, f]).reshape(n);
  }, o.prototype.sparseToDense = function (t, e, n, r) {
    var o = Uo(0, t, n),
        a = o.sliceRank,
        i = o.numUpdates,
        s = o.strides,
        u = o.outputSize,
        c = new Ks(i, a, t.rank, e.rank, s, [u, 1], !1);
    return this.compileAndRun(c, [e, t, r]).reshape(n);
  }, o.prototype.fft = function (t) {
    return this.fftImpl(t, !1);
  }, o.prototype.ifft = function (t) {
    return this.fftImpl(t, !0);
  }, o.prototype.fftImpl = function (t, e) {
    var n = this.texData.get(t.dataId),
        r = new Zi(Qi, t.shape, e),
        o = new Zi(Ji, t.shape, e),
        a = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag)],
        i = this.compileAndRun(r, a),
        s = this.compileAndRun(o, a),
        u = this.complex(i, s).as2D(t.shape[0], t.shape[1]);
    return i.dispose(), s.dispose(), u;
  }, o.prototype.gatherND = function (t, e) {
    var n = e.shape,
        r = n[n.length - 1],
        o = Oo(t, e),
        a = o[0],
        i = o[1],
        s = o[2],
        u = o[3],
        c = e.reshape([i, r]),
        l = t.reshape([t.size / s, s]),
        h = new ns(r, u, [i, s]);
    return this.compileAndRun(h, [l, c]).reshape(a);
  }, o.prototype.fill = function (t, e, n) {
    if ("string" === (n = n || j(e))) {
      var r = P(n, k(t));
      return r.fill(e), Lt.makeTensor(r, t, n, this);
    }

    var o = new ts(t, e),
        a = o.getCustomSetupFunc(e);
    return this.compileAndRun(o, [], n, a);
  }, o.prototype.onesLike = function (t) {
    if ("string" === t.dtype) throw new Error("onesLike is not supported under string dtype");
    return this.fill(t.shape, 1, t.dtype);
  }, o.prototype.zerosLike = function (t) {
    return this.fill(t.shape, "string" === t.dtype ? "" : 0, t.dtype);
  }, o.prototype.linspace = function (t, e, n) {
    return Ca(t, e, n);
  }, o.prototype.makeTensorInfo = function (t, e) {
    var n = this.write(null, t, e);
    return this.texData.get(n).usage = null, {
      dataId: n,
      shape: t,
      dtype: e
    };
  }, o.prototype.makeOutput = function (t, e) {
    var n = this.makeTensorInfo(t, e).dataId;
    return Lt.makeTensorFromDataId(n, t, e, this);
  }, o.prototype.unpackTensor = function (t) {
    var e = new Ou(t.shape);
    return this.runWebGLProgram(e, [t], t.dtype);
  }, o.prototype.packTensor = function (t) {
    var e = new Fs(t.shape);
    return this.runWebGLProgram(e, [t], t.dtype, null, !0);
  }, o.prototype.packedReshape = function (t, e) {
    var n = [Ae(t.shape)].concat(Te(t.shape)),
        r = {
      dtype: t.dtype,
      shape: n,
      dataId: t.dataId
    },
        o = [Ae(e)].concat(Te(e)),
        a = new Ls(o, n),
        i = this.runWebGLProgram(a, [r], t.dtype, null, !0);
    return {
      dataId: i.dataId,
      shape: e,
      dtype: i.dtype
    };
  }, o.prototype.decode = function (t) {
    var e,
        n = this.texData.get(t),
        r = n.isPacked,
        o = n.shape,
        a = n.dtype,
        i = De(o);
    e = r ? new Hi(i) : new Gi(i);
    return {
      dtype: a,
      shape: o,
      dataId: this.runWebGLProgram(e, [{
        shape: i,
        dtype: a,
        dataId: t
      }], a, null, !0).dataId
    };
  }, o.prototype.runWebGLProgram = function (t, e, n, r, o) {
    var a = this;
    void 0 === o && (o = !1);
    var s = this.makeTensorInfo(t.outputShape, n),
        u = this.texData.get(s.dataId);

    if (t.packedOutput && (u.isPacked = !0), t.outPackingScheme === Vt.DENSE) {
      var c = Yt(t.outputShape);
      u.texShape = c.map(function (t) {
        return 2 * t;
      });
    }

    if (null != t.outTexUsage && (u.usage = t.outTexUsage), 0 === k(s.shape)) return u.values = B(s.dtype, 0), s;
    var l = [],
        h = e.map(function (e) {
      if ("complex64" === e.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      var n = a.texData.get(e.dataId);

      if (null == n.texture) {
        if (!t.packedInputs && k(e.shape) <= i().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
          shape: e.shape,
          texData: null,
          isUniform: !0,
          uniformValues: n.values
        };
        t.packedInputs && (n.isPacked = !0, n.shape = e.shape);
      } else if (!!n.isPacked != !!t.packedInputs) e = n.isPacked ? a.unpackTensor(e) : a.packTensor(e), l.push(e), n = a.texData.get(e.dataId);else if (n.isPacked && !_e(n.shape, e.shape)) {
        var r = e,
            o = e.shape;
        e.shape = n.shape, e = a.packedReshape(e, o), l.push(e), n = a.texData.get(e.dataId), r.shape = o;
      }

      return a.uploadToGPU(e.dataId), {
        shape: e.shape,
        texData: n,
        isUniform: !1
      };
    });
    this.uploadToGPU(s.dataId);

    var f,
        d = {
      shape: s.shape,
      texData: u,
      isUniform: !1
    },
        p = function (t, e, n) {
      var r = "";
      e.concat(n).forEach(function (t) {
        var e = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0,
            n = t.isUniform ? "uniform" : t.texData.texShape;
        r += t.shape + "_" + n + "_" + e;
      });
      var o = t.userCode,
          a = t.constructor.name;
      return a += "_" + r + "_" + o;
    }(t, h, d),
        v = this.getAndSaveBinary(p, function () {
      return function (t, e, n, r) {
        var o = e.userCode,
            a = n.map(function (t, n) {
          var r = {
            logicalShape: t.shape,
            texShape: t.isUniform ? null : t.texData.texShape,
            isUniform: t.isUniform,
            isPacked: !t.isUniform && t.texData.isPacked,
            flatOffset: null
          };
          return null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0 && (r.flatOffset = t.texData.slice.flatOffset), {
            name: e.variableNames[n],
            shapeInfo: r
          };
        }),
            s = a.map(function (t) {
          return t.shapeInfo;
        }),
            u = {
          logicalShape: r.shape,
          texShape: r.texData.texShape,
          isUniform: !1,
          isPacked: r.texData.isPacked,
          flatOffset: null
        },
            c = Ya(a, u, o, e.packedInputs),
            l = t.createProgram(c),
            h = null,
            f = t.getUniformLocation(l, "NAN", !1);
        1 === i().getNumber("WEBGL_VERSION") && (h = t.getUniformLocation(l, "INFINITY", !1));

        for (var d = {}, p = 0; p < e.variableNames.length; p++) {
          var v = e.variableNames[p];
          d[v] = t.getUniformLocation(l, v, !1), d["offset" + v] = t.getUniformLocation(l, "offset" + v, !1);
        }

        return {
          program: e,
          source: c,
          webGLProgram: l,
          uniformLocations: d,
          inShapeInfos: s,
          outShapeInfo: u,
          infLoc: h,
          nanLoc: f
        };
      }(a.gpgpu, t, h, d);
    }),
        m = null != this.activeTimers;

    if (m && (f = this.startTimer()), function (t, e, n, r, o) {
      Cs(e.inShapeInfos, n), Cs([e.outShapeInfo], [r]);
      var a = r.texData.texture,
          s = r.texData.texShape;
      r.texData.isPacked ? t.setOutputPackedMatrixTexture(a, s[0], s[1]) : t.setOutputMatrixTexture(a, s[0], s[1]), t.setProgram(e.webGLProgram), 1 === i().getNumber("WEBGL_VERSION") && null !== e.infLoc && t.gl.uniform1f(e.infLoc, 1 / 0), null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN), n.forEach(function (n, r) {
        var o = e.program.variableNames[r],
            a = e.uniformLocations[o],
            i = e.uniformLocations["offset" + o];
        if (null != a) if (n.isUniform) {
          if (k(n.shape) < 2) t.gl.uniform1f(a, n.uniformValues[0]);else {
            var s = n.uniformValues;
            s instanceof Float32Array || (s = new Float32Array(s)), t.gl.uniform1fv(a, s);
          }
        } else null != n.texData.slice && null != i && t.gl.uniform1i(i, n.texData.slice.flatOffset), t.setInputMatrixTexture(n.texData.texture, a, r);
      }), null != o && o(t, e.webGLProgram), t.executeProgram();
    }(this.gpgpu, v, h, d, r), l.forEach(function (t) {
      return a.disposeData(t.dataId);
    }), m && (f = this.endTimer(f), this.activeTimers.push({
      name: t.constructor.name,
      query: this.getQueryTime(f)
    })), !i().getBool("WEBGL_LAZILY_UNPACK") && u.isPacked && !1 === o) {
      var g = this.unpackTensor(s);
      return this.disposeData(s.dataId), g;
    }

    return s;
  }, o.prototype.compileAndRun = function (t, e, n, r, o) {
    void 0 === o && (o = !1), n = n || e[0].dtype;
    var a = this.runWebGLProgram(t, e, n, r, o);
    return Lt.makeTensorFromDataId(a.dataId, a.shape, a.dtype);
  }, o.prototype.getAndSaveBinary = function (t, e) {
    return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t];
  }, o.prototype.getTextureManager = function () {
    return this.textureManager;
  }, o.prototype.dispose = function () {
    var t = this;

    if (!this.disposed) {
      if (!i().getBool("IS_TEST")) Object.keys(this.binaryCache).forEach(function (e) {
        t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram), delete t.binaryCache[e];
      });
      this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0;
    }
  }, o.prototype.floatPrecision = function () {
    var t = this;
    return null == this.floatPrecisionValue && (this.floatPrecisionValue = Ze(function () {
      if (!i().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        var e = i().getBool("DEBUG");
        i().set("DEBUG", !1);
        var n = t.abs(On(1e-8)).dataSync()[0];
        if (i().set("DEBUG", e), n > 0) return 32;
      }

      return 16;
    })), this.floatPrecisionValue;
  }, o.prototype.epsilon = function () {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, o.prototype.uploadToGPU = function (t) {
    var e,
        n = this.texData.get(t),
        r = n.shape,
        o = n.dtype,
        a = n.values,
        i = n.texture,
        s = n.usage,
        u = n.isPacked;

    if (null == i) {
      var c,
          l = null != this.activeTimers;
      l && (c = et());
      var h = n.texShape;

      if (null == h && (h = Ne(r, u), n.texShape = h), null != a) {
        var f = De(r),
            d = void 0,
            p = h[1],
            v = h[0],
            m = a instanceof Uint8Array;
        u ? (p = (e = $t(h[0], h[1]))[0], v = e[1], d = new $i(f, [v, p], m)) : d = new Yi(f, [v, p], m);
        var g = this.makeTensorInfo([v, p], o);
        this.texData.get(g.dataId).usage = m ? zt.PIXELS : zt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId), p, v, a);
        var y = this.runWebGLProgram(d, [g], o, null, !0),
            x = this.texData.get(y.dataId);
        n.texture = x.texture, n.texShape = x.texShape, n.isPacked = x.isPacked, n.usage = x.usage, this.disposeData(g.dataId), this.texData.delete(y.dataId), n.values = null, l && (this.uploadWaitMs += et() - c);
      } else {
        var b = this.acquireTexture(h, s, o, u);
        n.texture = b;
      }
    }
  }, o.prototype.convertAndCacheOnCPU = function (t, e) {
    var n = this.texData.get(t),
        r = n.dtype;
    return this.releaseGPUData(t), null != e && (n.values = function (t, e) {
      if ("float32" === e || "complex64" === e) return t;

      if ("int32" === e || "bool" === e) {
        for (var n = "int32" === e ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r) n[r] = Math.round(t[r]);

        return n;
      }

      throw new Error("Unknown dtype " + e);
    }(e, r)), n.values;
  }, o.prototype.acquireTexture = function (t, e, n, r) {
    if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
      var o = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + o + " MB, most likely due to a memory leak");
    }

    return this.textureManager.acquireTexture(t, e, r);
  }, o.prototype.computeBytes = function (t, e) {
    return t[0] * t[1] * z(e);
  }, o;
}(ia);

Wt() && Lt.registerBackend("webgl", function () {
  return new Lu();
}, 2);
"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;

function Wu(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}

var Uu = Wu(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e,
          n = this,
          r = (e = 4022871197, function (t) {
        t = t.toString();

        for (var n = 0; n < t.length; n++) {
          var r = .02519603282416938 * (e += t.charCodeAt(n));
          r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e);
        }

        return 2.3283064365386963e-10 * (e >>> 0);
      });
      n.next = function () {
        var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
        return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t);
      }, n.c = 1, n.s0 = r(" "), n.s1 = r(" "), n.s2 = r(" "), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null;
    }

    function o(t, e) {
      return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = n.next;
      return i.int32 = function () {
        return 4294967296 * n.next() | 0;
      }, i.double = function () {
        return i() + 11102230246251565e-32 * (2097152 * i() | 0);
      }, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.alea = a;
  }(0, t, !1);
}),
    Vu = Wu(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this,
          n = "";
      e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {
        var t = e.x ^ e.x << 11;
        return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;
      }, t === (0 | t) ? e.x = t : n += t;

      for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next();
    }

    function o(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xor128 = a;
  }(0, t, !1);
}),
    zu = Wu(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this,
          n = "";
      e.next = function () {
        var t = e.x ^ e.x >>> 2;
        return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;
      }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;

      for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();
    }

    function o(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xorwow = a;
  }(0, t, !1);
}),
    Gu = Wu(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this;
      e.next = function () {
        var t,
            n,
            r = e.x,
            o = e.i;
        return t = r[o], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[o + 1 & 7]) ^ t >>> 10, n ^= (t = r[o + 3 & 7]) ^ t >>> 3, n ^= (t = r[o + 4 & 7]) ^ t << 7, t = r[o + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[o] = n, e.i = o + 1 & 7, n;
      }, function (t, e) {
        var n,
            r = [];
        if (e === (0 | e)) r[0] = e;else for (e = "" + e, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;

        for (; r.length < 8;) r.push(0);

        for (n = 0; n < 8 && 0 === r[n]; ++n);

        for (8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next();
      }(e, t);
    }

    function o(t, e) {
      return e.x = t.x.slice(), e.i = t.i, e;
    }

    function a(t, e) {
      null == t && (t = +new Date());

      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && (a.x && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xorshift7 = a;
  }(0, t, !1);
}),
    Hu = Wu(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this;
      e.next = function () {
        var t,
            n,
            r = e.w,
            o = e.X,
            a = e.i;
        return e.w = r = r + 1640531527 | 0, n = o[a + 34 & 127], t = o[a = a + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = o[a] = n ^ t, e.i = a, n + (r ^ r >>> 16) | 0;
      }, function (t, e) {
        var n,
            r,
            o,
            a,
            i,
            s = [],
            u = 128;

        for (e === (0 | e) ? (r = e, e = null) : (e += "\0", r = 0, u = Math.max(u, e.length)), o = 0, a = -32; a < u; ++a) e && (r ^= e.charCodeAt((a + 32) % e.length)), 0 === a && (i = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, a >= 0 && (i = i + 1640531527 | 0, o = 0 == (n = s[127 & a] ^= r + i) ? o + 1 : 0);

        for (o >= 128 && (s[127 & (e && e.length || 0)] = -1), o = 127, a = 512; a > 0; --a) r = s[o + 34 & 127], n = s[o = o + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[o] = r ^ n;

        t.w = i, t.X = s, t.i = o;
      }(e, t);
    }

    function o(t, e) {
      return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e;
    }

    function a(t, e) {
      null == t && (t = +new Date());

      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && (a.X && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xor4096 = a;
  }(0, t, !1);
}),
    qu = Wu(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this,
          n = "";
      e.next = function () {
        var t = e.b,
            n = e.c,
            r = e.d,
            o = e.a;
        return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ o, o = o - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ o, e.a = o - t | 0;
      }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;

      for (var r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next();
    }

    function o(t, e) {
      return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.tychei = a;
  }(0, t, !1);
}),
    Ku = Wu(function (t) {
  !function (e, n) {
    var r,
        o = this,
        a = 256,
        i = 6,
        s = "random",
        u = n.pow(a, i),
        c = n.pow(2, 52),
        l = 2 * c,
        h = a - 1;

    function f(t, h, f) {
      var g = [],
          y = v(function t(e, n) {
        var r,
            o = [],
            a = typeof e;
        if (n && "object" == a) for (r in e) try {
          o.push(t(e[r], n - 1));
        } catch (t) {}
        return o.length ? o : "string" == a ? e : e + "\0";
      }((h = 1 == h ? {
        entropy: !0
      } : h || {}).entropy ? [t, m(e)] : null == t ? function () {
        try {
          var t;
          return r && (t = r.randomBytes) ? t = t(a) : (t = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(t)), m(t);
        } catch (t) {
          var n = o.navigator,
              i = n && n.plugins;
          return [+new Date(), o, i, o.screen, m(e)];
        }
      }() : t, 3), g),
          x = new d(g),
          b = function () {
        for (var t = x.g(i), e = u, n = 0; t < c;) t = (t + n) * a, e *= a, n = x.g(1);

        for (; t >= l;) t /= 2, e /= 2, n >>>= 1;

        return (t + n) / e;
      };

      return b.int32 = function () {
        return 0 | x.g(4);
      }, b.quick = function () {
        return x.g(4) / 4294967296;
      }, b.double = b, v(m(x.S), e), (h.pass || f || function (t, e, r, o) {
        return o && (o.S && p(o, x), t.state = function () {
          return p(x, {});
        }), r ? (n[s] = t, e) : t;
      })(b, y, "global" in h ? h.global : this == n, h.state);
    }

    function d(t) {
      var e,
          n = t.length,
          r = this,
          o = 0,
          i = r.i = r.j = 0,
          s = r.S = [];

      for (n || (t = [n++]); o < a;) s[o] = o++;

      for (o = 0; o < a; o++) s[o] = s[i = h & i + t[o % n] + (e = s[o])], s[i] = e;

      (r.g = function (t) {
        for (var e, n = 0, o = r.i, i = r.j, s = r.S; t--;) e = s[o = h & o + 1], n = n * a + s[h & (s[o] = s[i = h & i + e]) + (s[i] = e)];

        return r.i = o, r.j = i, n;
      })(a);
    }

    function p(t, e) {
      return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e;
    }

    function v(t, e) {
      for (var n, r = t + "", o = 0; o < r.length;) e[h & o] = h & (n ^= 19 * e[h & o]) + r.charCodeAt(o++);

      return m(e);
    }

    function m(t) {
      return String.fromCharCode.apply(0, t);
    }

    if (n["seed" + s] = f, v(n.random(), e), t.exports) {
      t.exports = f;

      try {
        r = require("crypto");
      } catch (t) {}
    }
  }([], Math);
});
Ku.alea = Uu, Ku.xor128 = Vu, Ku.xorwow = zu, Ku.xorshift7 = Gu, Ku.xor4096 = Hu, Ku.tychei = qu;
var ju = Ku.alea;
var Xu = An({
  broadcastTo_: function (t, e) {
    var n = mn(t, "broadcastTo", "x"),
        r = n.shape;
    if (e.some(function (t) {
      return !(t > 0) || t % 1 != 0;
    })) throw new Error("broadcastTo(): Invalid broadcast shape [" + e + "].");
    if (e.length < n.rank) throw new Error("broadcastTo(): shape.length=" + e.length + " < input.rank=" + n.rank + ".");

    if (e.length > n.rank) {
      for (var o = n.shape.slice(); o.length < e.length;) o.unshift(1);

      n = n.reshape(o);
    }

    for (var a = n.shape, i = Array.from(e), s = e.length - 1; s >= 0; s--) if (a[s] === e[s]) i[s] = 1;else if (1 !== n.shape[s]) throw new Error("broadcastTo(): [" + r + "] cannot be broadcast to [" + e + "].");

    var u = i.map(function (t, e) {
      return t > 1 ? e : -1;
    }).filter(function (t) {
      return t >= 0;
    });
    if (0 === u.length) return n.clone();
    var c = {
      x: n
    },
        l = {
      shape: e,
      inputShape: a
    };
    return Lt.runKernelFunc(function (t) {
      return t.tile(n, i);
    }, c, function (t) {
      return {
        x: function () {
          return t.sum(u, !0);
        }
      };
    }, kr, l);
  }
});
exports.broadcastTo = Xu;
var Yu = An({
  clone_: function (t) {
    var e = mn(t, "x", "clone", null);
    return Lt.runKernelFunc(function () {
      return Lt.makeTensorFromDataId(e.dataId, e.shape, e.dtype);
    }, {
      x: e
    }, null, Ar);
  }
});
exports.clone = Yu;

var $u = An({
  logicalAnd_: function (t, e) {
    var n = mn(t, "a", "logicalAnd", "bool"),
        r = mn(e, "b", "logicalAnd", "bool");
    return Fr(n.shape, r.shape), Lt.runKernelFunc(function (t) {
      return t.logicalAnd(n, r);
    }, {
      a: n,
      b: r
    }, null, "LogicalAnd");
  }
}),
    Qu = An({
  logicalNot_: function (t) {
    var e = mn(t, "x", "logicalNot", "bool");
    return Lt.runKernelFunc(function (t) {
      return t.logicalNot(e);
    }, {
      $x: e
    });
  }
}),
    Ju = An({
  logicalOr_: function (t, e) {
    var n = mn(t, "a", "logicalOr", "bool"),
        r = mn(e, "b", "logicalOr", "bool");
    return Fr(n.shape, r.shape), Lt.runKernelFunc(function (t) {
      return t.logicalOr(n, r);
    }, {
      $a: n,
      $b: r
    });
  }
}),
    Zu = An({
  logicalXor_: function (t, e) {
    var n = mn(t, "a", "logicalXor", "bool"),
        r = mn(e, "b", "logicalXor", "bool");
    return Fr(n.shape, r.shape), Ju(t, e).logicalAnd($u(t, e).logicalNot());
  }
}),
    tc = An({
  where_: function (t, e, n) {
    var r = mn(e, "a", "where"),
        o = mn(n, "b", "where"),
        a = mn(t, "condition", "where", "bool");
    return E(r.shape, o.shape, "Error in where: "), 1 === a.rank ? C(a.shape[0] === r.shape[0], function () {
      return "The first dimension of `a` must match the size of `condition`.";
    }) : E(a.shape, o.shape, "Error in where: "), Lt.runKernelFunc(function (t, e) {
      var n = t.select(a, r, o);
      return e([a]), n;
    }, {
      $condition: a,
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0];
      return {
        $condition: function () {
          return Xn(n).toFloat();
        },
        $a: function () {
          return t.mul(n.cast(t.dtype));
        },
        $b: function () {
          return t.mul(n.logicalNot().cast(t.dtype));
        }
      };
    });
  }
}),
    ec = function (t) {
  return n(this, void 0, void 0, function () {
    var e, n, o;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return [4, (e = mn(t, "condition", "whereAsync", "bool")).data()];

        case 1:
          return n = r.sent(), o = Wa(e.shape, n), t !== e && e.dispose(), [2, o];
      }
    });
  });
};

exports.whereAsync = ec;
exports.where = tc;
exports.logicalXor = Zu;
exports.logicalOr = Ju;
exports.logicalNot = Qu;
exports.logicalAnd = $u;
var nc = An({
  divNoNan_: function (t, e) {
    var n,
        r = mn(t, "a", "div"),
        o = mn(e, "b", "div");
    r = (n = Nt(r, o))[0], o = n[1];

    var a = _o(r, o),
        i = Xn(a),
        s = o.equal(i);

    return tc(s, i, a);
  }
});
exports.divNoNan = nc;
var rc = An({
  tile_: function (t, e) {
    var n = mn(t, "x", "tile", null);
    C(n.rank === e.length, function () {
      return "Error in transpose: rank of input " + n.rank + " must match length of reps " + e + ".";
    });
    var r = [n],
        o = {
      x: n
    },
        a = {
      reps: e
    };
    return Lt.runKernelFunc(function (t, r) {
      var o = t.tile(n, e);
      return r([n]), o;
    }, o, null, Tr, a, r);
  }
});
exports.tile = rc;
var oc = An({
  eye_: function (t, e, n, r) {
    void 0 === r && (r = "float32"), null == e && (e = t);

    for (var o = er([t, e], r), a = t <= e ? t : e, i = 0; i < a; ++i) o.set(1, i, i);

    var s = o.toTensor().as2D(t, e);
    if (null == n) return s;
    if (1 === n.length) return rc(sr(s, 0), [n[0], 1, 1]);
    if (2 === n.length) return rc(sr(sr(s, 0), 0), [n[0], n[1], 1, 1]);
    if (3 === n.length) return rc(sr(sr(sr(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
    throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n.length + "D.");
  }
});
exports.eye = oc;
var ac = An({
  multinomial_: function (t, e, n, r) {
    void 0 === r && (r = !1);
    var o = mn(t, "logits", "multinomial"),
        a = o.size,
        i = o.rank;
    if (a < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + a + ".");
    if (i > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + i);
    n = n || Math.random();
    var s = 1 === i ? o.as2D(1, -1) : o,
        u = Lt.runKernelFunc(function (t) {
      return t.multinomial(s, r, e, n);
    }, {
      logits2D: s
    });
    return 1 === i ? u.as1D() : u;
  }
});
exports.multinomial = ac;
var ic = An({
  oneHot_: function (t, e, n, r) {
    if (void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e);
    var o = mn(t, "indices", "oneHot", "int32"),
        a = o.shape.concat([e]),
        i = {
      indices: o = o.flatten()
    },
        s = {
      depth: e,
      onValue: n,
      offValue: r
    };
    return Lt.runKernelFunc(function (t, a) {
      return a([o]), t.oneHot(o, e, n, r);
    }, i, null, Sr, s).reshape(a);
  }
});
exports.oneHot = ic;
var sc = An({
  rand_: function (t, e, n) {
    var r = k(t),
        o = null;
    if (null == n || "float32" === n) o = new Float32Array(r);else if ("int32" === n) o = new Int32Array(r);else {
      if ("bool" !== n) throw new Error("Unknown data type " + n);
      o = new Uint8Array(r);
    }

    for (var a = 0; a < r; a++) o[a] = e();

    return Lt.makeTensor(o, t, n);
  }
}),
    uc = .001,
    cc = .1;
exports.rand = sc;

function lc() {
  return 32 === Lt.backend.floatPrecision() ? uc : cc;
}

function hc(t, e, n) {
  var r = !0;

  if ((V(t) || V(e)) && (r = !1), V(t) && V(e) && (r = !0), r) {
    var o = t.constructor.name,
        a = e.constructor.name;
    if (o !== a) throw new Error("Arrays are of different type. Actual: " + o + ". Expected: " + a);
  }

  if (Array.isArray(t) && Array.isArray(e)) {
    var i = pn(t),
        s = pn(e);
    if (!S(i, s)) throw new Error("Arrays have different shapes. Actual: [" + i + "]. Expected: [" + s + "]");
  }

  var u = V(t) ? t : I(t),
      c = V(e) ? e : I(e);
  if (u.length !== c.length) throw new Error("Arrays have different lengths actual: " + u.length + " vs expected: " + c.length + ".\nActual:   " + u + ".\nExpected: " + c + ".");

  for (var l = 0; l < c.length; ++l) {
    var h = u[l],
        f = c[l];
    if (!n(h, f)) throw new Error("Arrays differ: actual[" + l + "] = " + h + ", expected[" + l + "] = " + f + ".\nActual:   " + u + ".\nExpected: " + c + ".");
  }
}

function fc(t, e, n) {
  return !isFinite(t) && !isFinite(e) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n);
}

var dc = Object.freeze({
  TEST_EPSILON_FLOAT16: cc,
  expectArraysClose: function (t, e, n) {
    return null == n && (n = lc()), hc(t, e, function (t, e) {
      return fc(t, e, n);
    });
  },
  testEpsilon: lc,
  expectPromiseToFail: function (t, e) {
    t().then(function () {
      return e.fail();
    }, function () {
      return e();
    });
  },
  expectArraysEqual: function (t, e) {
    var n = "string" == typeof e || "number" == typeof e || "boolean" == typeof e ? [e] : e;
    return H(t) || H(t[0]) || H(e) || H(e[0]) ? hc(t, n, function (t, e) {
      return t == e;
    }) : hc(t, e, function (t, e) {
      return fc(t, e, 0);
    });
  },
  expectNumbersClose: function (t, e, n) {
    if (null == n && (n = lc()), !fc(t, e, n)) throw new Error("Numbers differ: actual === " + t + ", expected === " + e);
  },
  expectValuesInRange: function (t, e, n) {
    for (var r = 0; r < t.length; r++) if (t[r] < e || t[r] > n) throw new Error("Value out of range:" + t[r] + " low: " + e + ", high: " + n);
  },
  expectArrayBuffersEqual: function (t, e) {
    expect(new Float32Array(t)).toEqual(new Float32Array(e));
  }
}),
    pc = function () {
  function t(t, e, n, r, o) {
    this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var a = o || Math.random();
    this.random = ju(a.toString());
  }

  return t.prototype.nextValue = function () {
    if (!isNaN(this.nextVal)) {
      var t = this.nextVal;
      return this.nextVal = NaN, t;
    }

    for (var e, n, r = !1; !r;) {
      var o = void 0,
          a = void 0,
          i = void 0;

      do {
        i = (o = 2 * this.random() - 1) * o + (a = 2 * this.random() - 1) * a;
      } while (i >= 1 || 0 === i);

      var s = Math.sqrt(-2 * Math.log(i) / i);
      e = this.mean + this.stdDev * o * s, n = this.mean + this.stdDev * a * s, this.truncated && !this.isValidTruncated(e) || (r = !0);
    }

    return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e);
  }, t.prototype.convertValue = function (t) {
    return null == this.dtype || "float32" === this.dtype ? t : Math.round(t);
  }, t.prototype.isValidTruncated = function (t) {
    return t <= this.upper && t >= this.lower;
  }, t;
}(),
    vc = function () {
  function t(t, e, n, r) {
    this.alpha = t, this.beta = 1 / e, this.dtype = n;
    var o = r || Math.random();
    this.randu = ju(o.toString()), this.randn = new pc(0, 1, n, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }

  return t.prototype.nextValue = function () {
    for (var t, e, n, r, o, a;;) {
      do {
        r = this.randn.nextValue(), a = 1 + this.c * r;
      } while (a <= 0);

      if (a *= a * a, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - a + Math.log(a)), (o = this.randu()) < e || Math.log(o) < n) break;
    }

    return a = 1 / this.beta * this.d * a, this.alpha < 1 && (a *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a);
  }, t.prototype.convertValue = function (t) {
    return "float32" === this.dtype ? t : Math.round(t);
  }, t;
}(),
    mc = function () {
  function t(t, e, n, r) {
    var o = this;
    if (void 0 === t && (t = 0), void 0 === e && (e = 1), this.canReturnFloat = function () {
      return null == o.dtype || "float32" === o.dtype;
    }, this.min = t, this.range = e - t, this.dtype = n, null == r && (r = Math.random()), "number" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + t + " - " + e + " <= 1 and dtype is not float");
    this.random = ju(r);
  }

  return t.prototype.convertValue = function (t) {
    return this.canReturnFloat() ? t : Math.round(t);
  }, t.prototype.nextValue = function () {
    return this.convertValue(this.min + this.range * this.random());
  }, t;
}();

exports.test_util = dc;
var gc = An({
  randomGamma_: function (t, e, n, r, o) {
    if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), null == n && (n = 1), null == r && (r = "float32"), "float32" !== r && "int32" !== r) throw new Error("Unsupported data type " + r);

    for (var a = new vc(e, n, r, o), i = er(t, r), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();

    return i.toTensor();
  }
});
exports.randomGamma = gc;
var yc = An({
  randomNormal_: function (t, e, n, r, o) {
    if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);

    for (var a = new pc(e, n, r, !1, o), i = er(t, r), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();

    return i.toTensor();
  }
});
exports.randomNormal = yc;
var xc = An({
  randomUniform_: function (t, e, n, r, o) {
    void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = "float32");

    for (var a = er(t, r), i = new mc(e, n, null, o), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue();

    return a.toTensor();
  }
});
exports.randomUniform = xc;
var bc = An({
  square_: function (t) {
    var e = mn(t, "x", "square"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      return n([e]), t.square(e);
    }, {
      x: e
    }, null, "Square", {}, n, []);
  }
});
exports.square = bc;
var wc = An({
  squaredDifference_: function (t, e) {
    var n,
        r = mn(t, "a", "squaredDifference"),
        o = mn(e, "b", "squaredDifference");
    n = Nt(r, o), r = n[0], o = n[1], Fr(r.shape, o.shape);
    var a = {
      a: r,
      b: o
    },
        i = [r, o];
    return Lt.runKernelFunc(function (t, e) {
      var n = t.squaredDifference(r, o);
      return e([r, o]), n;
    }, a, function (t, e) {
      var n = e[0],
          r = e[1],
          o = On(2);
      return {
        a: function () {
          return t.mul(n.sub(r).mul(o));
        },
        b: function () {
          return t.mul(r.sub(n).mul(o));
        }
      };
    }, Ir, {}, i, []);
  }
});
exports.squaredDifference = wc;
var Cc = An({
  truncatedNormal_: function (t, e, n, r, o) {
    if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type $ { dtype }");

    for (var a = new pc(e, n, r, !0, o), i = er(t, r), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();

    return i.toTensor();
  }
});
exports.truncatedNormal = Cc;

function Ec(t, e, n, r, o, a) {
  var i,
      s,
      u = mn(t, "x", "batchNorm"),
      c = mn(e, "mean", "batchNorm"),
      l = mn(n, "variance", "batchNorm");
  return null != o && (i = mn(o, "scale", "batchNorm")), null != r && (s = mn(r, "offset", "batchNorm")), C(2 === u.rank, function () {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + ".";
  }), C(2 === c.rank || 1 === c.rank, function () {
    return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c.rank + ".";
  }), C(2 === l.rank || 1 === l.rank, function () {
    return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l.rank + ".";
  }), null != i && C(2 === i.rank || 1 === i.rank, function () {
    return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i.rank + ".";
  }), null != s && C(2 === s.rank || 1 === s.rank, function () {
    return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s.rank + ".";
  }), kc(u, c, l, s, i, a);
}

function Rc(t, e, n, r, o, a) {
  var i,
      s,
      u = mn(t, "x", "batchNorm"),
      c = mn(e, "mean", "batchNorm"),
      l = mn(n, "variance", "batchNorm");
  return null != o && (i = mn(o, "scale", "batchNorm")), null != r && (s = mn(r, "offset", "batchNorm")), C(3 === u.rank, function () {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + ".";
  }), C(3 === c.rank || 1 === c.rank, function () {
    return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c.rank + ".";
  }), C(3 === l.rank || 1 === l.rank, function () {
    return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l.rank + ".";
  }), null != i && C(3 === i.rank || 1 === i.rank, function () {
    return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i.rank + ".";
  }), null != s && C(3 === s.rank || 1 === s.rank, function () {
    return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s.rank + ".";
  }), kc(u, c, l, s, i, a);
}

function Ic(t, e, n, r, o, a) {
  var i,
      s,
      u = mn(t, "x", "batchNorm"),
      c = mn(e, "mean", "batchNorm"),
      l = mn(n, "variance", "batchNorm");
  return null != o && (i = mn(o, "scale", "batchNorm")), null != r && (s = mn(r, "offset", "batchNorm")), C(4 === u.rank, function () {
    return "Error in batchNorm4D: x must be rank 4 but got rank " + u.rank + ".";
  }), C(4 === c.rank || 1 === c.rank, function () {
    return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c.rank + ".";
  }), C(4 === l.rank || 1 === l.rank, function () {
    return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l.rank + ".";
  }), null != i && C(4 === i.rank || 1 === i.rank, function () {
    return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i.rank + ".";
  }), null != s && C(4 === s.rank || 1 === s.rank, function () {
    return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s.rank + ".";
  }), kc(u, c, l, s, i, a);
}

function kc(t, e, n, r, o, a) {
  null == a && (a = .001);
  var i,
      s,
      u,
      c = mn(t, "x", "batchNorm"),
      l = mn(e, "mean", "batchNorm"),
      h = mn(n, "variance", "batchNorm");
  null != o && (i = mn(o, "scale", "batchNorm")), null != r && (s = mn(r, "offset", "batchNorm")), C(l.rank === h.rank, function () {
    return "Batch normalization gradient requires mean and variance to have equal ranks.";
  }), C(null == s || l.rank === s.rank, function () {
    return "Batch normalization gradient requires mean and offset to have equal ranks.";
  }), C(null == i || l.rank === i.rank, function () {
    return "Batch normalization gradient requires mean and scale to have equal ranks.";
  }), u = 0 === c.rank || 1 === c.rank ? c.as4D(1, 1, 1, c.size) : 2 === c.rank ? c.as4D(1, 1, c.shape[0], c.shape[1]) : 3 === c.rank ? c.as4D(1, c.shape[0], c.shape[1], c.shape[2]) : c;
  var f = [c, l, h, i];
  return Lt.runKernelFunc(function (t, e) {
    var n = t.batchNormalization(u, Sc(l), Sc(h), a, Sc(i), Sc(s));
    return e([c, l, h, i]), n;
  }, {
    x: c,
    mean: l,
    variance: h,
    scale: i,
    offset: s
  }, function (t, e) {
    var n = e,
        r = n[0],
        o = n[1],
        i = n[2],
        s = n[3],
        c = null == s ? On(1) : s,
        l = Nr(o.shape, u.shape),
        h = [];

    if (1 === o.rank) {
      for (var f = 0; f < u.shape.length - 1; ++f) h.push(u.shape[f]);

      h.push(1);
    }

    var d = r.sub(o),
        p = t.mul(c),
        v = to(i.add(On(a))),
        m = v.mul(v).mul(v).mul(On(-.5));
    return {
      x: function () {
        return 1 === o.rank ? t.mul(rc(v.as4D(1, 1, 1, o.shape[0]), h)).mul(c).reshape(r.shape) : t.mul(v).mul(c).reshape(r.shape);
      },
      mean: function () {
        var t = v.mul(On(-1)).mul(p);
        return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);
      },
      variance: function () {
        var t = m.mul(d).mul(p);
        return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);
      },
      scale: function () {
        var e = d.mul(v),
            n = t.mul(e);
        return 1 === o.rank && (n = n.sum(l)), n.reshape(o.shape);
      },
      offset: function () {
        var e = t;
        return 1 === o.rank && (e = e.sum(l)), e.reshape(o.shape);
      }
    };
  }, "BatchNormalization", {
    varianceEpsilon: a
  }, f).reshape(c.shape);
}

function Sc(t) {
  return null == t ? null : 0 === t.rank ? t.as1D() : 1 === t.rank ? t : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t;
}

function Ac() {
  Xe("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}

var Tc = An({
  batchNormalization2d_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), Ac(), Ec(t, e, n, a, o, r);
  }
}),
    Dc = An({
  batchNormalization3d_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), Ac(), Rc(t, e, n, a, o, r);
  }
}),
    Nc = An({
  batchNormalization4d_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), Ac(), Ic(t, e, n, a, o, r);
  }
}),
    Fc = An({
  batchNormalization_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), Ac(), kc(t, e, n, a, o, r);
  }
}),
    _c = An({
  batchNorm_: kc
}),
    Oc = An({
  batchNorm2d_: Ec
}),
    Mc = An({
  batchNorm3d_: Rc
}),
    Bc = An({
  batchNorm4d_: Ic
});

exports.batchNorm4d = Bc;
exports.batchNorm3d = Mc;
exports.batchNorm2d = Oc;
exports.batchNorm = _c;
exports.batchNormalization = Fc;
exports.batchNormalization4d = Nc;
exports.batchNormalization3d = Dc;
exports.batchNormalization2d = Tc;
var Pc = An({
  equal_: function (t, e) {
    var n,
        r = mn(t, "a", "equal"),
        o = mn(e, "b", "equal");
    return n = Nt(r, o), r = n[0], o = n[1], Fr(r.shape, o.shape), Lt.runKernelFunc(function (t) {
      return t.equal(r, o);
    }, {
      $a: r,
      $b: o
    });
  }
}),
    Lc = An({
  equalStrict_: function (t, e) {
    var n = mn(t, "a", "equalStrict"),
        r = mn(e, "b", "equalStrict");
    return E(n.shape, r.shape, "Error in equalStrict: "), n.equal(r);
  }
}),
    Wc = An({
  greater_: function (t, e) {
    var n,
        r = mn(t, "a", "greater"),
        o = mn(e, "b", "greater");
    return n = Nt(r, o), r = n[0], o = n[1], Fr(r.shape, o.shape), Lt.runKernelFunc(function (t) {
      return t.greater(r, o);
    }, {
      a: r,
      b: o
    }, null, "Greater");
  }
}),
    Uc = An({
  greaterEqual_: function (t, e) {
    var n,
        r = mn(t, "a", "greaterEqual"),
        o = mn(e, "b", "greaterEqual");
    return n = Nt(r, o), r = n[0], o = n[1], Fr(r.shape, o.shape), Lt.runKernelFunc(function (t, e) {
      var n = t.greaterEqual(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          return Xn(n);
        },
        b: function () {
          return Xn(r);
        }
      };
    }, "GreaterEqual");
  }
}),
    Vc = An({
  greaterEqualStrict_: function (t, e) {
    var n = mn(t, "a", "greaterEqualStrict"),
        r = mn(e, "b", "greaterEqualStrict");
    return E(n.shape, r.shape, "Error in greaterEqualStrict: "), n.greaterEqual(r);
  }
}),
    zc = An({
  greaterStrict_: function (t, e) {
    var n = mn(t, "a", "greaterStrict"),
        r = mn(e, "b", "greaterStrict");
    return E(n.shape, r.shape, "Error in greaterStrict: "), n.greater(r);
  }
}),
    Gc = An({
  less_: function (t, e) {
    var n,
        r = mn(t, "a", "less"),
        o = mn(e, "b", "less");
    return n = Nt(r, o), r = n[0], o = n[1], Fr(r.shape, o.shape), Lt.runKernelFunc(function (t) {
      return t.less(r, o);
    }, {
      a: r,
      b: o
    }, null, "Less");
  }
}),
    Hc = An({
  lessEqual_: function (t, e) {
    var n,
        r = mn(t, "a", "lessEqual"),
        o = mn(e, "b", "lessEqual");
    return n = Nt(r, o), r = n[0], o = n[1], Fr(r.shape, o.shape), Lt.runKernelFunc(function (t, e) {
      var n = t.lessEqual(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, null, "LessEqual");
  }
}),
    qc = An({
  lessEqualStrict_: function (t, e) {
    var n = mn(t, "a", "lessEqualStrict"),
        r = mn(e, "b", "lessEqualStrict");
    return E(n.shape, r.shape, "Error in lessEqualStrict: "), n.lessEqual(r);
  }
}),
    Kc = An({
  lessStrict_: function (t, e) {
    var n = mn(t, "a", "lessStrict"),
        r = mn(e, "b", "lessStrict");
    return E(n.shape, r.shape, "Error in lessStrict: "), n.less(r);
  }
}),
    jc = An({
  notEqual_: function (t, e) {
    var n,
        r = mn(t, "a", "notEqual"),
        o = mn(e, "b", "notEqual");
    return n = Nt(r, o), r = n[0], o = n[1], Fr(r.shape, o.shape), Lt.runKernelFunc(function (t) {
      return t.notEqual(r, o);
    }, {
      a: r,
      b: o
    }, null, "NotEqual");
  }
}),
    Xc = An({
  notEqualStrict_: function (t, e) {
    var n = mn(t, "a", "notEqualStrict"),
        r = mn(e, "b", "notEqualStrict");
    return E(n.shape, r.shape, "Error in notEqualStrict: "), n.notEqual(r);
  }
});
exports.notEqualStrict = Xc;
exports.notEqual = jc;
exports.lessStrict = Kc;
exports.lessEqualStrict = qc;
exports.lessEqual = Hc;
exports.less = Gc;
exports.greaterStrict = zc;
exports.greaterEqualStrict = Vc;
exports.greaterEqual = Uc;
exports.greater = Wc;
exports.equalStrict = Lc;
exports.equal = Pc;

function Yc(t, e) {
  for (var n = [], r = t; r < e; ++r) n.push(r);

  return n;
}

function $c(t) {
  for (var e = [], n = 0; n < t.length; ++n) for (var r = 0; r < t[n].length; ++r) e.push(t[n][r]);

  return e;
}

var Qc = An({
  gather_: function (t, e, n) {
    void 0 === n && (n = 0);
    var r = mn(t, "x", "gather"),
        o = mn(e, "indices", "gather", "int32");
    n = O(n, r.shape)[0];

    var a = function (t, e, n) {
      for (var r = t.shape[n], o = [], a = 1, i = 1, s = 0; s < n; s++) o.push(t.shape[s]), a *= t.shape[s];

      for (s = 0; s < e.rank; s++) o.push(e.shape[s]);

      for (s = n + 1; s < t.rank; s++) o.push(t.shape[s]), i *= t.shape[s];

      return {
        batchSize: a,
        sliceSize: i,
        dimSize: r,
        outputShape: o
      };
    }(r, o, n);

    return Lt.runKernelFunc(function (t, e) {
      var a = t.gather(r, o.flatten(), n);
      return e([o]), a;
    }, {
      x: r,
      indices: o
    }, function (t, e) {
      var o = e[0];
      return {
        x: function () {
          var e = r.shape,
              a = o.size,
              i = e.slice(0, n),
              s = i.length,
              u = e.slice(n, e.length).slice(1),
              c = u.length,
              l = Yc(0, s),
              h = Yc(s + 1, s + 1 + c),
              f = $c([i, [a], u]),
              d = t.reshape(f),
              p = o.reshape([a]),
              v = $c([[s], l, h]),
              m = d.transpose(v),
              g = Jc(m, p, r.shape[n]),
              y = Rn(v);
          return g = g.transpose(y);
        },
        indices: function () {
          return o;
        }
      };
    }, "Gather", {
      axis: n
    }).reshape(a.outputShape);
  }
}),
    Jc = An({
  unsortedSegmentSum_: function (t, e, n) {
    var r = mn(t, "x", "unsortedSegmentSum"),
        o = mn(e, "segmentIds", "unsortedSegmentSum", "int32");
    return C(A(n), function () {
      return "numSegments must be of dtype int";
    }), Lt.runKernelFunc(function (t, e) {
      var a = t.unsortedSegmentSum(r, o, n);
      return e([o]), a;
    }, {
      $x: r
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return function (t, e) {
            for (var n = bo(e, Xn(e)), r = Qc(t, n), o = Uc(e, On(0, "int32")), a = r.rank - o.rank, i = 0; i < a; ++i) o = sr(o, i + 1);

            o = $u(o, zn(r.shape, "bool"));
            var s = Xn(r);
            return tc(o, r, s);
          }(t, n);
        }
      };
    });
  }
});
exports.unsortedSegmentSum = Jc;
exports.gather = Qc;

var Zc = function (t, e, o) {
  return n(this, void 0, void 0, function () {
    var n, a, i, s, u, c, l, h, f, d, p, v, m;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          for (n = mn(t, "tensor", "boolMask"), a = mn(e, "mask", "boolMask", "bool"), i = null == o ? 0 : o, s = a.rank, u = n.shape, C(s > 0, function () {
            return "mask cannot be scalar";
          }), E(u.slice(i, i + s), a.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c = 1, l = i; l < i + s; l++) c *= u[l];

          return h = u.slice(0, i).concat([c], u.slice(i + s)), f = n.reshape(h), d = a.reshape([-1]), [4, ec(d)];

        case 1:
          return p = r.sent(), v = p.squeeze([1]), m = Qc(f, v, i), t !== n && n.dispose(), e !== a && a.dispose(), v.dispose(), f.dispose(), d.dispose(), p.dispose(), [2, m];
      }
    });
  });
};

exports.booleanMaskAsync = Zc;

function tl(t, e, n, r, o, a, i) {
  void 0 === a && (a = "NHWC"), C(t.length === e.rank, function () {
    return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match";
  });
  var s = t,
      u = e,
      c = !1;
  3 === e.rank && (c = !0, u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), s = [1, t[0], t[1], t[2]]), C(4 === s.length, function () {
    return "Error in conv2dDerInput: inShape must be length 4, but got length " + s.length + ".";
  }), C(4 === u.rank, function () {
    return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u.rank;
  }), C(4 === n.rank, function () {
    return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n.rank;
  });
  var l = "NHWC" === a ? s[3] : s[1],
      h = "NHWC" === a ? u.shape[3] : u.shape[1];
  C(l === n.shape[2], function () {
    return "Error in conv2dDerInput: depth of input (" + l + ") must match input depth for filter " + n.shape[2] + ".";
  }), C(h === n.shape[3], function () {
    return "Error in conv2dDerInput: depth of output (" + h + ") must match output depth for filter " + n.shape[3] + ".";
  }), null != i && C(A(o), function () {
    return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + o + ".";
  });
  var f = xa(a),
      d = la(s, n.shape, r, 1, o, i, !1, f),
      p = Lt.runKernelFunc(function (t, e) {
    var r = t.conv2dDerInput(u, n, d);
    return e([n, u]), r;
  }, {
    dy4D: u,
    filter: n
  }, function (t, e) {
    var n = e[0],
        s = e[1];
    return {
      dy4D: function () {
        return ol(t, n, r, o, a, 1, i);
      },
      filter: function () {
        return il(t, s, n.shape, r, o, a, i);
      }
    };
  });
  return c ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;
}

function el(t) {
  var e = function (t) {
    return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t;
  }(t),
      n = e[0],
      r = e[1],
      o = e[2];

  return 1 === n && 1 === r && 1 === o;
}

function nl(t, e, n, r, o) {
  C(t.length === e.rank, function () {
    return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match";
  });
  var a = t,
      i = e,
      s = !1;
  4 === e.rank && (s = !0, i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), a = [1, t[0], t[1], t[2], t[3]]);
  var u = a[4],
      c = i.shape[4];
  C(5 === a.length, function () {
    return "Error in conv3dDerInput: inShape must be length 5, but got length " + a.length + ".";
  }), C(5 === i.rank, function () {
    return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i.rank;
  }), C(5 === n.rank, function () {
    return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n.rank;
  }), C(u === n.shape[3], function () {
    return "Error in conv3dDerInput: depth of input (" + u + ") must match input depth for filter " + n.shape[3] + ".";
  }), C(c === n.shape[4], function () {
    return "Error in conv3dDerInput: depth of output (" + c + ") must match output depth for filter " + n.shape[4] + ".";
  });
  var l = ha(a, n.shape, r, 1, o),
      h = Lt.runKernelFunc(function (t) {
    return t.conv3dDerInput(i, n, l);
  }, {
    dy5D: i
  });
  return s ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
}

var rl = An({
  conv1d_: function (t, e, n, r, o, a, i) {
    void 0 === o && (o = "NWC"), void 0 === a && (a = 1);
    var s = mn(t, "x", "conv1d"),
        u = mn(e, "filter", "conv1d"),
        c = s,
        l = !1;
    2 === s.rank && (l = !0, c = s.as3D(1, s.shape[0], s.shape[1])), C(3 === c.rank, function () {
      return "Error in conv1d: input must be rank 3, but got rank " + c.rank + ".";
    }), C(3 === u.rank, function () {
      return "Error in conv1d: filter must be rank 3, but got rank " + u.rank + ".";
    }), null != i && C(A(r), function () {
      return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
    }), C(c.shape[2] === u.shape[1], function () {
      return "Error in conv1d: depth of input (" + c.shape[2] + ") must match input depth for filter " + u.shape[1] + ".";
    }), C(ya(n, a), function () {
      return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n + " and dilation '" + a + "'";
    }), C("NWC" === o, function () {
      return "Error in conv1d: got dataFormat of " + o + " but only NWC is currently supported.";
    });
    var h = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]),
        f = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]),
        d = ol(f, h, [1, n], r, "NHWC", [1, a], i);
    return l ? d.as2D(d.shape[2], d.shape[3]) : d.as3D(d.shape[0], d.shape[2], d.shape[3]);
  }
}),
    ol = An({
  conv2d_: function (t, e, n, r, o, a, i) {
    void 0 === o && (o = "NHWC"), void 0 === a && (a = [1, 1]);
    var s = mn(t, "x", "conv2d"),
        u = mn(e, "filter", "conv2d"),
        c = s,
        l = !1;
    3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), C(4 === c.rank, function () {
      return "Error in conv2d: input must be rank 4, but got rank " + c.rank + ".";
    }), C(4 === u.rank, function () {
      return "Error in conv2d: filter must be rank 4, but got rank " + u.rank + ".";
    }), null != i && C(A(r), function () {
      return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
    });
    var h = "NHWC" === o ? c.shape[3] : c.shape[1];
    C(h === u.shape[2], function () {
      return "Error in conv2d: depth of input (" + h + ") must match input depth for filter " + u.shape[2] + ".";
    }), C(ya(n, a), function () {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'";
    });
    var f = xa(o),
        d = la(c.shape, u.shape, n, a, r, i, !1, f),
        p = [u, c],
        v = Lt.runKernelFunc(function (t, e) {
      var n = t.conv2d(c, u, d);
      return e([u, c]), n;
    }, {
      x: c,
      filter: u
    }, function (t, e) {
      var i = e,
          s = i[0],
          u = i[1];
      return C(ga(a), function () {
        return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a + "'";
      }), {
        x: function () {
          return sl(u.shape, t, s, n, r, o);
        },
        filter: function () {
          return il(u, t, s.shape, n, r, o);
        }
      };
    }, "Conv2D", d, p);
    return l ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;
  }
}),
    al = An({
  conv3d_: function (t, e, n, r, o, a) {
    void 0 === o && (o = "NDHWC"), void 0 === a && (a = [1, 1, 1]);
    var i = mn(t, "x", "conv3d"),
        s = mn(e, "filter", "conv3d"),
        u = i,
        c = !1;
    4 === i.rank && (c = !0, u = i.as5D(1, i.shape[0], i.shape[1], i.shape[2], i.shape[3])), C(5 === u.rank, function () {
      return "Error in conv3d: input must be rank 5, but got rank " + u.rank + ".";
    }), C(5 === s.rank, function () {
      return "Error in conv3d: filter must be rank 5, but got rank " + s.rank + ".";
    }), C(u.shape[4] === s.shape[3], function () {
      return "Error in conv3d: depth of input (" + u.shape[4] + ") must match input depth for filter " + s.shape[3] + ".";
    }), C(function (t, e) {
      return el(t) || el(e);
    }(n, a), function () {
      return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'";
    }), C("NDHWC" === o, function () {
      return "Error in conv3d: got dataFormat of " + o + " but only NDHWC is currently supported.";
    });
    var l = ha(u.shape, s.shape, n, a, r),
        h = Lt.runKernelFunc(function (t, e) {
      var n = t.conv3d(u, s, l);
      return e([u, s]), n;
    }, {
      x: u,
      $filter: s
    }, function (t, e) {
      C(el(a), function () {
        return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a + "'";
      });
      var o = e[0],
          i = e[1];
      return {
        x: function () {
          return nl(o.shape, t, i, n, r);
        },
        $filter: function () {
          return function (t, e, n, r, o) {
            var a = t;
            4 === t.rank && (a = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]));
            var i = e;
            4 === i.rank && (i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]));
            C(5 === a.rank, function () {
              return "Error in conv3dDerFilter: input must be rank 5, but got shape " + a.shape + ".";
            }), C(5 === i.rank, function () {
              return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + i.shape + ".";
            }), C(5 === n.length, function () {
              return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n + ".";
            }), C(a.shape[4] === n[3], function () {
              return "Error in conv3dDerFilter: depth of input " + a.shape[4] + ") must match input depth in filter (" + n[3] + ".";
            }), C(i.shape[4] === n[4], function () {
              return "Error in conv3dDerFilter: depth of dy (" + i.shape[4] + ") must match output depth for filter (" + n[4] + ").";
            });
            var s = ha(a.shape, n, r, 1, o);
            return Lt.runKernelFunc(function (t) {
              return t.conv3dDerFilter(a, i, s);
            }, {
              x5D: a,
              dy5D: i
            });
          }(o, t, i.shape, n, r);
        }
      };
    });
    return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
}),
    il = An({
  conv2dDerFilter_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = "NHWC");
    var s = t;
    3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
    var u = e;
    3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), C(4 === s.rank, function () {
      return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s.shape + ".";
    }), C(4 === u.rank, function () {
      return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u.shape + ".";
    }), C(4 === n.length, function () {
      return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n + ".";
    });
    var c = "NHWC" === a ? s.shape[3] : s.shape[1],
        l = "NHWC" === a ? u.shape[3] : u.shape[1];
    C(c === n[2], function () {
      return "Error in conv2dDerFilter: depth of input " + c + ") must match input depth in filter (" + n[2] + ".";
    }), C(l === n[3], function () {
      return "Error in conv2dDerFilter: depth of dy (" + l + ") must match output depth for filter (" + n[3] + ").";
    }), null != i && C(A(o), function () {
      return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + o + ".";
    });
    var h = xa(a),
        f = la(s.shape, n, r, 1, o, i, !1, h);
    return Lt.runKernelFunc(function (t) {
      return t.conv2dDerFilter(s, u, f);
    }, {
      x4D: s,
      dy4D: u
    });
  }
}),
    sl = An({
  conv2dDerInput_: tl
}),
    ul = An({
  depthwiseConv2d_: function (t, e, n, r, o, a, i) {
    void 0 === o && (o = "NHWC"), void 0 === a && (a = [1, 1]);
    var s = mn(t, "x", "depthwiseConv2d"),
        u = mn(e, "filter", "depthwiseConv2d"),
        c = s,
        l = !1;
    3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), C(4 === c.rank, function () {
      return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c.rank + ".";
    }), C(4 === u.rank, function () {
      return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u.rank + ".";
    }), C(c.shape[3] === u.shape[2], function () {
      return "Error in depthwiseConv2d: number of input channels (" + c.shape[3] + ") must match the inChannels dimension in filter " + u.shape[2] + ".";
    }), null == a && (a = [1, 1]), C(ya(n, a), function () {
      return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'";
    }), null != i && C(A(r), function () {
      return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
    });
    var h = la(c.shape, u.shape, n, a, r, i, !0),
        f = [c, u],
        d = Lt.runKernelFunc(function (t, e) {
      var n = t.depthwiseConv2D(c, u, h);
      return e([c, u]), n;
    }, {
      x: c,
      filter: u
    }, function (t, e) {
      C(ga(a), function () {
        return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + a + "'";
      });
      var n = e[0],
          r = e[1];
      return {
        x: function () {
          return cl(n.shape, t, r, h);
        },
        filter: function () {
          return ll(n, t, r.shape, h);
        }
      };
    }, "DepthwiseConv2dNative", h, f);
    return l ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;
  }
}),
    cl = An({
  depthwiseConv2dDerInput_: function (t, e, n, r) {
    var o = e,
        a = !1;
    3 === e.rank && (a = !0, o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));
    var i = Lt.runKernelFunc(function (t) {
      return t.depthwiseConv2DDerInput(o, n, r);
    }, {
      dy4D: o
    });
    return a ? i.as3D(i.shape[1], i.shape[2], i.shape[3]) : i;
  }
}),
    ll = An({
  depthwiseConv2dDerFilter_: function (t, e, n, r) {
    var o = t;
    3 === t.rank && (o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
    var a = e;
    return 3 === a.rank && (a = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), Lt.runKernelFunc(function (t) {
      return t.depthwiseConv2DDerFilter(o, a, r);
    }, {
      x4D: o,
      dy4D: a
    });
  }
}),
    hl = An({
  separableConv2d_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = [1, 1]), void 0 === i && (i = "NHWC");
    var s = mn(t, "x", "separableConv2d"),
        u = mn(e, "depthwiseFilter", "separableConv2d"),
        c = mn(n, "pointwiseFilter", "separableConv2d"),
        l = s,
        h = !1;
    if (3 === s.rank && (h = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), "NCHW" === i) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    C(4 === l.rank, function () {
      return "Error in separableConv2d: input must be rank 4, but got rank " + l.rank + ".";
    }), C(4 === u.rank, function () {
      return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u.rank + ".";
    }), C(4 === c.rank, function () {
      return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u.rank + ".";
    }), C(1 === c.shape[0], function () {
      return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c.shape[0] + ".";
    }), C(1 === c.shape[1], function () {
      return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c.shape[1] + ".";
    });
    var f = u.shape[2],
        d = u.shape[3];
    C(c.shape[2] === f * d, function () {
      return "Error in separableConv2d: the third dimension of pointwise filter must be " + f * d + ", but got " + c.shape[2] + ".";
    });
    var p = ul(l, u, r, o, i, a),
        v = ol(p, c, 1, "valid", i);
    return h ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;
  }
}),
    fl = An({
  conv2dTranspose_: function (t, e, n, r, o, a) {
    return tl(n, mn(t, "x", "conv2dTranspose"), mn(e, "filter", "conv2dTranspose"), r, o, "NHWC", a);
  }
}),
    dl = An({
  conv3dTranspose_: function (t, e, n, r, o) {
    return nl(n, mn(t, "x", "conv3dTranspose"), mn(e, "filter", "conv3dTranspose"), r, o);
  }
});
exports.conv3dTranspose = dl;
exports.conv2dTranspose = fl;
exports.separableConv2d = hl;
exports.depthwiseConv2d = ul;
exports.conv3d = al;
exports.conv2d = ol;
exports.conv1d = rl;
var pl = An({
  matMul_: function (t, e, n, r) {
    var o;
    void 0 === n && (n = !1), void 0 === r && (r = !1);
    var a = mn(t, "a", "matMul"),
        i = mn(e, "b", "matMul");
    o = Nt(a, i), a = o[0], i = o[1];
    var s = n ? a.shape[a.rank - 2] : a.shape[a.rank - 1],
        u = r ? i.shape[i.rank - 1] : i.shape[i.rank - 2],
        c = n ? a.shape[a.rank - 1] : a.shape[a.rank - 2],
        l = r ? i.shape[i.rank - 2] : i.shape[i.rank - 1],
        h = a.shape.slice(0, -2),
        f = i.shape.slice(0, -2),
        d = k(h),
        p = k(f);
    C(a.rank >= 2 && i.rank >= 2 && a.rank === i.rank, function () {
      return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + a.rank + " and " + i.rank + ".";
    }), C(S(h, f), function () {
      return "Error in matMul: outer dimensions (" + h + ") and (" + f + ") of Tensors with shapes " + a.shape + " and " + i.shape + " must match.";
    }), C(s === u, function () {
      return "Error in matMul: inner shapes (" + s + ") and (" + u + ") of Tensors with shapes " + a.shape + " and " + i.shape + " and transposeA=" + n + " and transposeB=" + r + " must match.";
    });
    var v = a.shape.slice(0, -2).concat([c, l]),
        m = n ? a.as3D(d, s, c) : a.as3D(d, c, s),
        g = r ? i.as3D(p, l, u) : i.as3D(p, u, l),
        y = {
      transposeA: n,
      transposeB: r
    };
    return Lt.runKernelFunc(function (t, e) {
      var o = t.batchMatMul(m, g, n, r);
      return e([m, g]), o;
    }, {
      a: m,
      b: g
    }, function (t, e) {
      var o = e,
          a = o[0],
          i = o[1];
      return n || r ? !n && r ? {
        a: function () {
          return t.matMul(i, !1, !1);
        },
        b: function () {
          return t.matMul(a, !0, !1);
        }
      } : n && !r ? {
        a: function () {
          return i.matMul(t, !1, !0);
        },
        b: function () {
          return a.matMul(t, !1, !1);
        }
      } : {
        a: function () {
          return i.matMul(t, !0, !0);
        },
        b: function () {
          return t.matMul(a, !0, !0);
        }
      } : {
        a: function () {
          return t.matMul(i, !1, !0);
        },
        b: function () {
          return a.matMul(t, !0, !1);
        }
      };
    }, "BatchMatMul", y).reshape(v);
  }
}),
    vl = An({
  dot_: function (t, e) {
    var n = mn(t, "t1", "dot"),
        r = mn(e, "t2", "dot");
    C(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), function () {
      return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n.rank + " and " + r.rank + ".";
    });
    var o = 1 === n.rank ? n.size : n.shape[1],
        a = 1 === r.rank ? r.size : r.shape[0];
    return C(o === a, function () {
      return "Error in dot: inner dimensions of inputs must match, but got " + o + " and " + a + ".";
    }), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]));
  }
}),
    ml = An({
  outerProduct_: function (t, e) {
    var n = mn(t, "v1", "outerProduct"),
        r = mn(e, "v2", "outerProduct");
    return C(1 === n.rank && 1 === r.rank, function () {
      return "Error in outerProduct: inputs must be rank 1, but got ranks " + n.rank + " and " + r.rank + ".";
    }), n.as2D(-1, 1).matMul(r.as2D(1, -1));
  }
});
exports.outerProduct = ml;
exports.dot = vl;
exports.matMul = pl;
var gl = An({
  reverse_: function (t, e) {
    var n = mn(t, "x", "reverse");
    if (0 === n.rank) return n.clone();
    var r = O(e, n.shape);
    return Lt.runKernelFunc(function (t) {
      return t.reverse(n, r);
    }, {
      $x: n
    }, function (t) {
      return {
        $x: function () {
          return t.reverse(r);
        }
      };
    }).reshapeAs(n);
  }
}),
    yl = An({
  reverse1d_: function (t) {
    var e = mn(t, "x", "reverse");
    return C(1 === e.rank, function () {
      return "Error in reverse1D: x must be rank 1 but got rank " + e.rank + ".";
    }), gl(e, 0);
  }
}),
    xl = An({
  reverse2d_: function (t, e) {
    var n = mn(t, "x", "reverse");
    return C(2 === n.rank, function () {
      return "Error in reverse2D: x must be rank 2 but got rank " + n.rank + ".";
    }), gl(n, e);
  }
}),
    bl = An({
  reverse3d_: function (t, e) {
    var n = mn(t, "x", "reverse");
    return C(3 === n.rank, function () {
      return "Error in reverse3D: x must be rank 3 but got rank " + n.rank + ".";
    }), gl(n, e);
  }
}),
    wl = An({
  reverse4d_: function (t, e) {
    var n = mn(t, "x", "reverse");
    return C(4 === n.rank, function () {
      return "Error in reverse4D: x must be rank 4 but got rank " + n.rank + ".";
    }), gl(n, e);
  }
});
exports.reverse4d = wl;
exports.reverse3d = bl;
exports.reverse2d = xl;
exports.reverse1d = yl;
exports.reverse = gl;

function Cl(t, e, n, r, o, a) {
  var i = mn(t, "x", "maxPool"),
      s = i,
      u = !1;
  3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), null == r && (r = [1, 1]), C(4 === s.rank, function () {
    return "Error in maxPool: input must be rank 4 but got rank " + s.rank + ".";
  }), C(ya(n, r), function () {
    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'";
  }), null != a && C(A(o), function () {
    return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + ".";
  });
  var c = ua(s.shape, e, n, r, o, a);
  if (1 === c.filterWidth && 1 === c.filterHeight && S(c.inShape, c.outShape)) return i.clone();
  var l = [s],
      h = Lt.runKernelFunc(function (t, e) {
    var n = t.maxPool(s, c);
    return e([s, n]), n;
  }, {
    x: s
  }, function (t, a) {
    var i = a[0],
        s = a[1];
    return {
      x: function () {
        return function (t, e, n, r, o, a, i, s) {
          var u = mn(t, "dy", "maxPoolBackprop"),
              c = mn(e, "input", "maxPoolBackprop"),
              l = mn(n, "output", "maxPoolBackprop");
          C(c.rank === u.rank, function () {
            return "Rank of input (" + c.rank + ") does not match rank of dy (" + u.rank + ")";
          }), null == a && (a = [1, 1]);
          C(ya(o, a), function () {
            return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + a + "'";
          }), C(4 === u.rank, function () {
            return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + u.rank + ".";
          }), C(4 === c.rank, function () {
            return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c.rank + ".";
          }), null != s && C(A(i), function () {
            return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + s + " but got pad " + i + ".";
          });
          var h = ua(c.shape, r, o, a, i, s);
          return Lt.runKernelFunc(function (t) {
            return t.maxPoolBackprop(u, c, l, h);
          }, {
            $dy: u,
            $input: c
          });
        }(t, i, s, e, n, r, o);
      }
    };
  }, "MaxPool", c, l);
  return u ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h;
}

function El(t, e, n, r, o, a) {
  var i = mn(t, "x", "avgPool", "float32");
  null == r && (r = [1, 1]), C(ya(n, r), function () {
    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'";
  });
  var s = i,
      u = !1;
  3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), C(4 === s.rank, function () {
    return "Error in avgPool: x must be rank 4 but got rank " + s.rank + ".";
  }), null != a && C(A(o), function () {
    return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + ".";
  });
  var c = ua(s.shape, e, n, r, o, a);
  if (1 === c.filterWidth && 1 === c.filterHeight && S(c.inShape, c.outShape)) return i.clone();
  var l = Lt.runKernelFunc(function (t) {
    return t.avgPool(s, c);
  }, {
    x: s
  }, function (t) {
    return {
      x: function () {
        return function (t, e, n, r, o, a) {
          var i = mn(t, "dy", "avgPoolBackprop"),
              s = mn(e, "input", "avgPoolBackprop");
          C(s.rank === i.rank, function () {
            return "Rank of input (" + s.rank + ") does not match rank of dy (" + i.rank + ")";
          }), null == o && (o = [1, 1]);
          C(ya(r, o), function () {
            return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + o + "'";
          });
          var u = s,
              c = i,
              l = !1;
          3 === s.rank && (l = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), c = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]));
          C(4 === c.rank, function () {
            return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c.rank + ".";
          }), C(4 === u.rank, function () {
            return "Error in avgPoolBackprop: input must be rank 4 but got rank " + u.rank + ".";
          });
          var h = ua(u.shape, n, r, o, a),
              f = Lt.runKernelFunc(function (t) {
            return t.avgPoolBackprop(c, u, h);
          }, {
            dy4D: c,
            input4D: u
          });
          if (l) return f.as3D(f.shape[1], f.shape[2], f.shape[3]);
          return f;
        }(t, s, e, n, r, o);
      }
    };
  }, "AvgPool", c);
  return l = l.cast(i.dtype), u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;
}

var Rl = An({
  maxPool_: function (t, e, n, r, o) {
    return Cl(t, e, n, 1, r, o);
  }
}),
    Il = An({
  avgPool_: function (t, e, n, r, o) {
    return El(t, e, n, 1, r, o);
  }
}),
    kl = An({
  pool_: function (t, e, n, r, o, a) {
    null == o && (o = [1, 1]), null == a && (a = 1), 0 === r && (r = "valid");
    var i = mn(t, "x", "maxPool"),
        s = i,
        u = !1;
    3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), C(ya(a, o), function () {
      return "Error in pool: Either strides or dilations must be 1. Got strides " + a + " and dilations '" + o + "'";
    });
    var c,
        l = ua(s.shape, e, a, o, r),
        h = [l.dilationHeight, l.dilationWidth];
    c = "same" === r ? function (t, e) {
      var n = t.map(function (t, n) {
        return t + (t - 1) * (e[n] - 1);
      }).map(function (t) {
        return t - 1;
      }),
          r = n.map(function (t) {
        return Math.floor(t / 2);
      }),
          o = n.map(function (t, e) {
        return t - r[e];
      });
      return n.map(function (t, e) {
        return [r[e], o[e]];
      });
    }([l.filterHeight, l.filterWidth], h) : [[0, 0], [0, 0]];

    var f = 1 === h[0] && 1 === h[1],
        d = function (t, e, n) {
      var r = n.map(function (t) {
        return t[0];
      }),
          o = n.map(function (t) {
        return t[1];
      }),
          a = t.concat(r, o),
          i = e.map(function (t, e) {
        return (t - a[e] % t) % t;
      }),
          s = o.map(function (t, e) {
        return t + i[e];
      }),
          u = e.map(function (t, e) {
        return [r[e], s[e]];
      }),
          c = e.map(function (t, e) {
        return [0, i[e]];
      });
      return [u, c];
    }([l.inHeight, l.inWidth], h, c),
        p = d[0],
        v = d[1],
        m = f ? r : "valid",
        g = f ? s : pr(s, h, p),
        y = ("avg" === n ? function () {
      return El(g, e, a, 1, m);
    } : function () {
      return Cl(g, e, a, 1, m);
    })(),
        x = f ? y : rr(y, h, v);

    return u ? x.as3D(x.shape[1], x.shape[2], x.shape[3]) : x;
  }
}),
    Sl = An({
  maxPool3d_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = "NDHWC");
    var s = mn(t, "x", "maxPool3d"),
        u = s,
        c = !1;
    4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == i && (i = [1, 1, 1]), C(5 === u.rank, function () {
      return "Error in maxPool3d: x must be rank 5 but got rank " + u.rank + ".";
    }), C("NDHWC" === a, function () {
      return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + a;
    }), C(ya(n, i), function () {
      return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'";
    }), null != o && C(A(r), function () {
      return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + ".";
    });
    var l = ca(u.shape, e, n, i, r, o, a),
        h = Lt.runKernelFunc(function (t, e) {
      var n = t.maxPool3d(u, l);
      return e([u, n]), n;
    }, {
      x: u
    }, function (t, a) {
      var s = a[0],
          u = a[1];
      return {
        x: function () {
          return function (t, e, n, r, o, a, i, s) {
            var u = mn(t, "dy", "maxPool3dBackprop"),
                c = mn(e, "input", "maxPool3dBackprop"),
                l = mn(n, "output", "maxPool3dBackprop"),
                h = u,
                f = c,
                d = l,
                p = !1;
            4 === c.rank && (p = !0, h = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]), f = c.as5D(1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]), d = l.as5D(1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]));
            C(5 === h.rank, function () {
              return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h.rank + ".";
            }), C(5 === f.rank, function () {
              return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + f.rank + ".";
            }), C(5 === d.rank, function () {
              return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + d.rank + ".";
            }), null == a && (a = [1, 1, 1]);
            C(ya(o, a), function () {
              return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + a + "'";
            }), null != s && C(A(i), function () {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + s + " but got pad " + i + ".";
            });
            var v = ca(f.shape, r, o, a, i, s),
                m = Lt.runKernelFunc(function (t) {
              return t.maxPool3dBackprop(h, f, d, v);
            }, {
              dy5D: h,
              input5D: f
            });
            if (p) return m.as4D(m.shape[1], m.shape[2], m.shape[3], m.shape[4]);
            return m;
          }(t, s, u, e, n, i, r, o);
        }
      };
    });
    return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
}),
    Al = An({
  avgPool3d_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = "NDHWC");
    var s = mn(t, "x", "avgPool3d", "float32"),
        u = s,
        c = !1;
    4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == i && (i = [1, 1, 1]), C(5 === u.rank, function () {
      return "Error in avgPool3d: x must be rank 5 but got rank " + u.rank + ".";
    }), C("NDHWC" === a, function () {
      return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + a;
    }), C(ya(n, i), function () {
      return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'";
    }), null != o && C(A(r), function () {
      return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + ".";
    });
    var l = ca(u.shape, e, n, i, r, o, a),
        h = Lt.runKernelFunc(function (t) {
      return t.avgPool3d(u, l);
    }, {
      x: u
    }, function (t) {
      return {
        x: function () {
          return function (t, e, n, r, o, a, i) {
            var s = mn(t, "dy", "avgPool3dBackprop"),
                u = mn(e, "input", "avgPool3dBackprop"),
                c = s,
                l = u,
                h = !1;
            4 === u.rank && (h = !0, c = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]), l = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]));
            C(5 === c.rank, function () {
              return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c.rank + ".";
            }), C(5 === l.rank, function () {
              return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l.rank + ".";
            }), null == o && (o = [1, 1, 1]);
            C(ya(r, o), function () {
              return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + o + "'";
            }), null != i && C(A(a), function () {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + a + ".";
            });
            var f = ca(l.shape, n, r, o, a, i),
                d = Lt.runKernelFunc(function (t) {
              return t.avgPool3dBackprop(c, l, f);
            }, {
              dy5D: c,
              input5D: l
            });
            if (h) return d.as4D(d.shape[1], d.shape[2], d.shape[3], d.shape[4]);
            return d;
          }(t, u, e, n, i, r, o);
        }
      };
    });
    return h = h.cast(u.dtype), c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
});
exports.avgPool3d = Al;
exports.maxPool3d = Sl;
exports.pool = kl;
exports.avgPool = Il;
exports.maxPool = Rl;

var Tl = An({
  slice_: function (t, e, n) {
    var r,
        o,
        a = mn(t, "x", "slice");
    if (0 === a.rank) throw new Error("Slicing scalar is not possible");
    (r = "number" == typeof e ? [e].concat(new Array(a.rank - 1).fill(0)) : e.length < a.rank ? e.concat(new Array(a.rank - e.length).fill(0)) : e.slice()).forEach(function (t) {
      C(-1 !== t, function () {
        return "slice() does not support negative begin indexing.";
      });
    }), o = (o = null == n ? new Array(a.rank).fill(-1) : "number" == typeof n ? [n].concat(new Array(a.rank - 1).fill(-1)) : n.length < a.rank ? n.concat(new Array(a.rank - n.length).fill(-1)) : n).map(function (t, e) {
      return t >= 0 ? t : (C(-1 === t, function () {
        return "Negative size values should be exactly -1 but got " + t + " for the slice() size at index " + e + ".";
      }), a.shape[e] - r[e]);
    }), zo(a, r, o);
    var i = a.shape,
        s = {
      begin: r,
      size: o
    };
    return Lt.runKernelFunc(function (t) {
      return t.slice(a, r, o);
    }, {
      x: a
    }, function (t) {
      for (var e = [], n = 0; n < t.rank; n++) e.push([r[n], i[n] - r[n] - o[n]]);

      return {
        x: function () {
          return t.pad(e);
        }
      };
    }, "Slice", s);
  }
}),
    Dl = An({
  slice1d_: function (t, e, n) {
    var r = mn(t, "x", "slice1d");
    return C(1 === r.rank, function () {
      return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor";
    }), Tl(r, [e], [n]);
  }
}),
    Nl = An({
  slice2d_: function (t, e, n) {
    var r = mn(t, "x", "slice2d");
    return C(2 === r.rank, function () {
      return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor";
    }), Tl(r, e, n);
  }
}),
    Fl = An({
  slice3d_: function (t, e, n) {
    var r = mn(t, "x", "slice3d");
    return C(3 === r.rank, function () {
      return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor";
    }), Tl(r, e, n);
  }
}),
    _l = An({
  slice4d_: function (t, e, n) {
    var r = mn(t, "x", "slice4d");
    return C(4 === r.rank, function () {
      return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor";
    }), Tl(r, e, n);
  }
});

exports.slice4d = _l;
exports.slice3d = Fl;
exports.slice2d = Nl;
exports.slice1d = Dl;
exports.slice = Tl;

function Ol(t, e, n, r, o) {
  return e.rank < n.rank && (e = e.reshape(wn(e.shape, r))), t.rank < n.rank && (t = t.reshape(wn(t.shape, r))), {
    x: function () {
      var r = t.mul(n.equal(e).cast(t.dtype));
      return null == o ? r : r.transpose(o);
    }
  };
}

var Ml = An({
  all_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "all", "bool"),
        o = O(e, r.shape),
        a = o,
        i = En(a, r.rank);
    null != i && (r = r.transpose(i), a = In(a.length, r.rank));
    var s = Lt.runKernelFunc(function (t) {
      return t.all(r, a);
    }, {
      $x: r
    });

    if (n) {
      var u = wn(s.shape, o);
      return s.reshape(u);
    }

    return s;
  }
}),
    Bl = An({
  any_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "any", "bool"),
        o = O(e, r.shape),
        a = o,
        i = En(a, r.rank);
    null != i && (r = r.transpose(i), a = In(a.length, r.rank));
    var s = Lt.runKernelFunc(function (t) {
      return t.any(r, a);
    }, {
      $x: r
    });

    if (n) {
      var u = wn(s.shape, o);
      return s.reshape(u);
    }

    return s;
  }
}),
    Pl = An({
  argMax_: function (t, e) {
    void 0 === e && (e = 0);
    var n = mn(t, "x", "argMax");
    null == e && (e = 0);
    var r = O(e, n.shape),
        o = En(r, n.rank);
    null != o && (n = n.transpose(o), r = In(r.length, n.rank));
    var a = {
      axis: r[0]
    },
        i = [n];
    return Lt.runKernelFunc(function (t, e) {
      var o = t.argMax(n, r[0]);
      return e([n]), o;
    }, {
      x: n
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return Xn(n);
        }
      };
    }, "ArgMax", a, i);
  }
}),
    Ll = An({
  argMin_: function (t, e) {
    void 0 === e && (e = 0);
    var n = mn(t, "x", "argMin");
    null == e && (e = 0);
    var r = O(e, n.shape),
        o = En(r, n.rank);
    return null != o && (n = n.transpose(o), r = In(r.length, n.rank)), Lt.runKernelFunc(function (t, e) {
      var o = t.argMin(n, r[0]);
      return e([n]), o;
    }, {
      $x: n
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return Xn(n);
        }
      };
    });
  }
}),
    Wl = An({
  logSumExp_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "logSumExp"),
        o = O(e, r.shape),
        a = r.max(o, !0),
        i = r.sub(a).exp().sum(o).log(),
        s = a.reshape(i.shape).add(i);

    if (n) {
      var u = wn(s.shape, o);
      return s.reshape(u);
    }

    return s;
  }
}),
    Ul = An({
  max_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "max"),
        o = r,
        a = O(e, r.shape),
        i = a,
        s = En(i, r.rank);
    null != s && (r = r.transpose(s), i = In(i.length, r.rank));
    var u = [r],
        c = Lt.runKernelFunc(function (t, e) {
      var n = t.max(r, i);
      return e([o, n]), n;
    }, {
      x: r
    }, function (t, e) {
      return Ol(t, e[1], e[0], a, s);
    }, "Max", {
      axes: i
    }, u, [!0]);

    if (n) {
      var l = wn(c.shape, a);
      c = c.reshape(l);
    }

    return c;
  }
}),
    Vl = An({
  mean_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "mean"),
        o = O(e, r.shape),
        a = k(bn(r.shape, o)[1]);
    return ea(function (t) {
      var r = On(a);
      return {
        value: (r.dtype === t.dtype ? t : t.cast(r.dtype)).div(r).sum(e, n),
        gradFunc: function (e) {
          var n = t.shape.slice();
          return o.forEach(function (t) {
            n[t] = 1;
          }), e.reshape(n).mul(zn(t.shape, "float32")).div(a);
        }
      };
    })(r);
  }
}),
    zl = An({
  min_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "min"),
        o = r,
        a = O(e, r.shape),
        i = a,
        s = En(i, r.rank);
    null != s && (r = r.transpose(s), i = In(i.length, r.rank));
    var u = [r],
        c = Lt.runKernelFunc(function (t, e) {
      var n = t.min(r, i);
      return e([o, n]), n;
    }, {
      x: r
    }, function (t, e) {
      return Ol(t, e[1], e[0], a, s);
    }, "Min", {
      axes: i
    }, u, [!0]);

    if (n) {
      var l = wn(c.shape, a);
      c = c.reshape(l);
    }

    return c;
  }
}),
    Gl = An({
  moments_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = O(e, (t = mn(t, "x", "moments")).shape),
        o = t.mean(r, n),
        a = o.shape;
    n || (a = wn(o.shape, r));
    var i = t.toFloat().sub(o.reshape(a)).square();
    return {
      mean: o,
      variance: i.mean(r, n)
    };
  }
}),
    Hl = An({
  sum_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "sum");
    "bool" === r.dtype && (r = r.toInt());
    var o = O(e, r.shape);
    return ea(function (t) {
      var e = En(o, t.rank),
          r = o,
          a = t;
      null != e && (a = t.transpose(e), r = In(r.length, t.rank));

      var i = function (e) {
        var n = t.shape.slice();
        return o.forEach(function (t) {
          n[t] = 1;
        }), e.reshape(n).mul(zn(t.shape, "float32"));
      },
          s = {
        axes: r
      },
          u = Lt.runKernelFunc(function (t) {
        return t.sum(a, r);
      }, {
        x: a
      }, function (t) {
        return {
          x: function () {
            return i(t);
          }
        };
      }, "Sum", s);

      if (n) {
        var c = wn(u.shape, o);
        u = u.reshape(c);
      }

      return {
        value: u,
        gradFunc: i
      };
    })(r);
  }
}),
    ql = An({
  prod_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "prod");
    "bool" === r.dtype && (r = r.toInt());
    var o = O(e, r.shape),
        a = En(o, r.rank),
        i = o,
        s = r;
    null != a && (s = r.transpose(a), i = In(i.length, r.rank));
    var u = Lt.runKernelFunc(function (t) {
      return t.prod(s, i);
    }, {
      permutedX: s
    });

    if (n) {
      var c = wn(u.shape, o);
      u = u.reshape(c);
    }

    return u;
  }
});
exports.prod = ql;
exports.sum = Hl;
exports.moments = Gl;
exports.min = zl;
exports.mean = Vl;
exports.max = Ul;
exports.logSumExp = Wl;
exports.argMin = Ll;
exports.argMax = Pl;
exports.any = Bl;
exports.all = Ml;
var Kl = An({
  elu_: function (t) {
    var e = mn(t, "x", "elu");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.elu(e);
      return n([r]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return Lt.runKernelFunc(function (e) {
            return e.eluDer(t, n);
          }, {
            dy: t,
            y: n
          });
        }
      };
    });
  }
}),
    jl = An({
  leakyRelu_: function (t, e) {
    void 0 === e && (e = .2);
    var n = mn(t, "x", "leakyRelu");
    return bo(On(e).mul(n), n);
  }
}),
    Xl = An({
  prelu_: function (t, e) {
    var n = mn(t, "x", "prelu"),
        r = mn(e, "alpha", "prelu");
    return Lt.runKernelFunc(function (t, e) {
      var o = t.prelu(n, r);
      return e([n, r]), o;
    }, {
      x: n,
      alpha: r
    }, function (t, e) {
      var n = e[0],
          r = e[1],
          o = n.greater(0);
      return {
        x: function () {
          return tc(o, t, t.mul(r));
        },
        alpha: function () {
          var e = tc(o, Xn(t), t.mul(n)),
              a = Nr(r.shape, t.shape);
          return a.length > 0 && (e = e.sum(a)), e.reshape(r.shape);
        }
      };
    }, "Prelu");
  }
}),
    Yl = An({
  relu_: function (t) {
    var e = mn(t, "x", "relu");
    return "bool" === e.dtype ? e.toInt() : Lt.runKernelFunc(function (t, n) {
      var r = t.relu(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mulStrict(n.step().toFloat());
        }
      };
    }, "Relu");
  }
}),
    $l = An({
  relu6_: function (t) {
    var e = mn(t, "x", "relu6");
    return "bool" === e.dtype ? e.toInt() : Lt.runKernelFunc(function (t, n) {
      var r = t.relu6(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0],
          r = n.lessEqual(6).mul(n.step());
      return {
        x: function () {
          return t.mulStrict(r.toFloat());
        }
      };
    }, "Relu6");
  }
}),
    Ql = An({
  selu_: function (t) {
    var e = mn(t, "x", "selu");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.selu(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          var e = n.greater(On(0)),
              r = On(au),
              o = On(iu),
              a = t.mul(o),
              i = t.mul(r).mul(n.toFloat().exp());
          return tc(e, a, i);
        }
      };
    });
  }
});
exports.selu = Ql;
exports.relu6 = $l;
exports.relu = Yl;
exports.prelu = Xl;
exports.leakyRelu = jl;
exports.elu = Kl;
var Jl = An({
  transpose_: function (t, e) {
    var n = mn(t, "x", "transpose");
    if (null == e && (e = n.shape.map(function (t, e) {
      return e;
    }).reverse()), C(n.rank === e.length, function () {
      return "Error in transpose: rank of input " + n.rank + " must match length of perm " + e + ".";
    }), e.forEach(function (t) {
      C(t >= 0 && t < n.rank, function () {
        return "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got " + e;
      });
    }), n.rank <= 1) return n.clone();
    var r = {
      perm: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.transpose(n, e);
    }, {
      x: n
    }, function (t) {
      var n = Rn(e);
      return {
        x: function () {
          return t.transpose(n);
        }
      };
    }, "Transpose", r);
  }
});
exports.transpose = Jl;
var Zl = An({
  localResponseNormalization_: function (t, e, n, r, o) {
    void 0 === e && (e = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === o && (o = .5);
    var a = mn(t, "x", "localResponseNormalization");
    C(4 === a.rank || 3 === a.rank, function () {
      return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + a.rank + ".";
    }), C(A(e), function () {
      return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e + ".";
    });
    var i = a,
        s = !1;
    3 === a.rank && (s = !0, i = a.as4D(1, a.shape[0], a.shape[1], a.shape[2]));
    var u = Lt.runKernelFunc(function (t, a) {
      var s = t.localResponseNormalization4D(i, e, n, r, o);
      return a([i, s]), s;
    }, {
      x4D: i
    }, function (t, a) {
      var i = a[0],
          s = a[1];
      return {
        x4D: function () {
          return Lt.runKernelFunc(function (a) {
            return a.LRNGrad(t, i, s, e, n, r, o);
          }, {});
        }
      };
    });
    return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
  }
});
exports.localResponseNormalization = Zl;
var th = An({
  norm_: function (t, e, n, r) {
    void 0 === e && (e = "euclidean"), void 0 === n && (n = null), void 0 === r && (r = !1);

    var o = function t(e, n, r) {
      void 0 === r && (r = null);
      if (0 === e.rank) return e.abs();
      if (1 !== e.rank && null === r) return t(e.reshape([-1]), n, r);

      if (1 === e.rank || "number" == typeof r || Array.isArray(r) && 1 === r.length) {
        if (1 === n) return e.abs().sum(r);
        if (n === 1 / 0) return e.abs().max(r);
        if (n === -1 / 0) return e.abs().min(r);
        if ("euclidean" === n || 2 === n) return e.abs().pow(On(2, "int32")).sum(r).sqrt();
        throw new Error("Error in norm: invalid ord value: " + n);
      }

      if (Array.isArray(r) && 2 === r.length) {
        if (1 === n) return e.abs().sum(r[0]).max(r[1] - 1);
        if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);
        if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);
        if ("fro" === n || "euclidean" === n) return e.square().sum(r).sqrt();
        throw new Error("Error in norm: invalid ord value: " + n);
      }

      throw new Error("Error in norm: invalid axis: " + r);
    }(t = mn(t, "x", "norm"), e, n),
        a = o.shape;

    if (r) {
      var i = O(n, t.shape);
      a = wn(o.shape, i);
    }

    return o.reshape(a);
  }
});
exports.norm = th;
var eh = An({
  basicLSTMCell_: function (t, e, n, r, o, a) {
    var i = mn(t, "forgetBias", "basicLSTMCell"),
        s = mn(e, "lstmKernel", "basicLSTMCell"),
        u = mn(n, "lstmBias", "basicLSTMCell"),
        c = mn(r, "data", "basicLSTMCell"),
        l = mn(o, "c", "basicLSTMCell"),
        h = mn(a, "h", "basicLSTMCell"),
        f = c.concat(h, 1).matMul(s).add(u),
        d = f.shape[0],
        p = f.shape[1] / 4,
        v = [d, p],
        m = f.slice([0, 0], v),
        g = f.slice([0, p], v),
        y = f.slice([0, 2 * p], v),
        x = f.slice([0, 3 * p], v),
        b = m.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(i.add(y).sigmoid())),
        w = b.tanh().mulStrict(x.sigmoid());
    return [b, w];
  }
}),
    nh = An({
  multiRNNCell_: function (t, e, n, r) {
    for (var o = mn(e, "data", "multiRNNCell"), a = gn(n, "c", "multiRNNCell"), i = gn(r, "h", "multiRNNCell"), s = o, u = [], c = 0; c < t.length; c++) {
      var l = t[c](s, a[c], i[c]);
      u.push(l[0]), u.push(l[1]), s = l[1];
    }

    var h = [],
        f = [];

    for (c = 0; c < u.length; c += 2) h.push(u[c]), f.push(u[c + 1]);

    return [h, f];
  }
});
exports.multiRNNCell = nh;
exports.basicLSTMCell = eh;
var rh = An({
  movingAverage_: function (t, e, n, r, o) {
    void 0 === o && (o = !0);
    var a = mn(t, "v", "movingAverage"),
        i = mn(e, "x", "movingAverage"),
        s = mn(n, "decay", "movingAverage");
    Ft(a, i), C(S(a.shape, i.shape), function () {
      return "Shape mismatch in v and x";
    });
    var u = On(1),
        c = u.sub(s),
        l = i.sub(a).mul(c);

    if (o) {
      C(null != r, function () {
        return "When using zeroDebias: true, step is required.";
      });
      var h = mn(r, "step", "movingAverage");
      l = l.div(u.sub(Ao(s, h)));
    }

    return a.add(l);
  }
});
exports.movingAverage = rh;
var oh = An({
  stridedSlice_: function (t, e, n, r, o, a, i, s, u) {
    if (void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), null == r && (r = new Array(e.length)), 0 !== i) throw new Error("ellipsis mask is not yet supported");
    var c = mn(t, "x", "stridedSlice"),
        l = Go(s),
        h = c.shape.slice();
    l.forEach(function (t) {
      e[t] = 0, n[t] = 1, h.splice(t, 0, 1);
    }), c = c.reshape(h);

    for (var f = 0; f < c.rank; f++) e[f] = qo(o, e, r, c.shape, f), n[f] = Ko(a, n, r, c.shape, f), r[f] = r[f] || 1;

    var d = Go(u);
    d.forEach(function (t) {
      n[t] = e[t] + 1, r[t] = 1;
    });
    var p = Ho(e, n, r),
        v = p.filter(function (t, e) {
      return -1 === d.indexOf(e);
    });
    return r.every(function (t) {
      return 1 === t;
    }) ? Tl(c, e, p).reshape(v) : Lt.runKernelFunc(function (t) {
      return t.stridedSlice(c, e, n, r);
    }, {
      $x: c
    }).reshape(v);
  }
});
exports.stridedSlice = oh;
var ah = An({
  topk_: function (t, e, n) {
    void 0 === e && (e = 1), void 0 === n && (n = !0);
    var r = mn(t, "x", "topk");
    if (0 === r.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
    var o = r.shape[r.shape.length - 1];
    if (e > o) throw new Error("'k' passed to topk() must be <= the last dimension (" + o + ") but got " + e);
    var a = Lt.runKernelFunc(function (t) {
      return t.topk(r, e, n);
    }, {
      $x: r
    });
    return {
      values: a[0],
      indices: a[1]
    };
  }
});
exports.topk = ah;
var ih = An({
  scatterND_: function (t, e, n) {
    var r = mn(t, "indices", "scatterND", "int32"),
        o = mn(e, "updates", "scatterND");
    return Wo(o, r, n), Lt.runKernelFunc(function (t) {
      return t.scatterND(r, o, n);
    }, {
      indices: r,
      updates: o
    }, null, "ScatterNd", {
      shape: n
    });
  }
});
exports.scatterND = ih;
var sh = An({
  fft_: function (t) {
    C("complex64" === t.dtype, function () {
      return "The dtype for tf.spectral.fft() must be complex64 but got " + t.dtype + ".";
    });
    var e = t.shape[t.shape.length - 1],
        n = t.size / e,
        r = t.as2D(n, e);
    return Lt.runKernelFunc(function (t) {
      return t.fft(r);
    }, {
      input: t
    }).reshape(t.shape);
  }
}),
    uh = An({
  ifft_: function (t) {
    C("complex64" === t.dtype, function () {
      return "The dtype for tf.spectral.ifft() must be complex64 but got " + t.dtype + ".";
    });
    var e = t.shape[t.shape.length - 1],
        n = t.size / e,
        r = t.as2D(n, e);
    return Lt.runKernelFunc(function (t) {
      return t.ifft(r);
    }, {
      input: t
    }).reshape(t.shape);
  }
}),
    ch = An({
  rfft_: function (t, e) {
    C("float32" === t.dtype, function () {
      return "The dtype for rfft() must be real value but got " + t.dtype;
    });
    var n,
        r = t.shape[t.shape.length - 1],
        o = t.size / r;

    if (null != e && e < r) {
      var a = t.shape.map(function (t) {
        return 0;
      }),
          i = t.shape.map(function (t) {
        return t;
      });
      i[t.shape.length - 1] = e, n = t.slice(a, i), r = e;
    } else if (null != e && e > r) {
      var s = t.shape.map(function (t) {
        return t;
      });
      s[t.shape.length - 1] = e - r, n = t.concat(Gn(s), t.shape.length - 1), r = e;
    } else n = t;

    var u = n.zerosLike(),
        c = Tn(n, u).as2D(o, r),
        l = sh(c),
        h = Math.floor(r / 2) + 1,
        f = Dn(l),
        d = Nn(l),
        p = f.split([h, r - h], f.shape.length - 1),
        v = d.split([h, r - h], d.shape.length - 1),
        m = n.shape.slice();
    return m[n.shape.length - 1] = h, Tn(p[0], v[0]).reshape(m);
  }
}),
    lh = An({
  irfft_: function (t) {
    var e = t.shape[t.shape.length - 1],
        n = t.size / e;

    if (e <= 2) {
      var r = t.as2D(n, e),
          o = uh(r);
      return Dn(o);
    }

    var a = [n, 2 * (e - 1)],
        i = Dn(t).as2D(n, e),
        s = Nn(t).as2D(n, e),
        u = i.slice([0, 1], [n, e - 2]).reverse(1),
        c = s.slice([0, 1], [n, e - 2]).reverse(1).mul(On(-1)),
        l = i.concat(u, 1),
        h = s.concat(c, 1);
    return r = Tn(l, h).as2D(a[0], a[1]), o = uh(r), Dn(o);
  }
}),
    hh = Object.freeze({
  fft: sh,
  ifft: uh,
  rfft: ch,
  irfft: lh
});
exports.spectral = hh;
exports.irfft = lh;
exports.rfft = ch;
exports.ifft = uh;
exports.fft = sh;
var fh = An({
  sparseToDense_: function (t, e, n, r) {
    void 0 === r && (r = 0);
    var o = mn(t, "sparseIndices", "sparseToDense", "int32"),
        a = mn(e, "sparseValues", "sparseToDense"),
        i = mn(r, "defaultValue", "sparseToDense", a.dtype);
    return function (t, e, n, r) {
      if ("int32" !== t.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t.dtype + ".");
      if (t.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t.shape + ".");
      var o = t.rank > 0 ? t.shape[0] : 1,
          a = t.rank > 1 ? t.shape[1] : 1;
      if (n.length !== a) throw new Error("outputShape has incorrect number of elements:, " + n.length + ", should be: " + a + ".");
      var i = e.size;
      if (0 !== e.rank && (1 !== e.rank || i !== o)) throw new Error("sparseValues has incorrect shape " + e.shape + ", should be [] or [" + o + "]");
      if (e.dtype !== r.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
    }(o, a, n, i), Lt.runKernelFunc(function (t) {
      return t.sparseToDense(o, a, n, i);
    }, {
      $sparseIndices: o,
      $sparseValues: a,
      $defaultValue: i
    });
  }
});
exports.sparseToDense = fh;
var dh = An({
  gatherND_: function (t, e) {
    var n = mn(e, "indices", "gatherND", "int32"),
        r = mn(t, "x", "gatherND");
    return Lt.runKernelFunc(function (t) {
      return t.gatherND(r, n);
    }, {
      x: r,
      indices: n
    }, null, "GatherNd");
  }
});
exports.gatherND = dh;
var ph = An({
  diag_: function (t) {
    var e = mn(t, "x", "diag").flatten(),
        n = t.shape.concat(t.shape);
    return Lt.runKernelFunc(function (t) {
      return t.diag(e);
    }, {
      $x: e
    }).reshape(n);
  }
});
exports.diag = ph;
var vh = An({
  dropout_: function (t, e, n, r) {
    var o = mn(t, "x", "dropout");
    if (C("float32" === o.dtype, function () {
      return "x has to be a floating point tensor since it's going to be scaled, but got a " + o.dtype + " tensor instead.";
    }), C(e >= 0 && e < 1, function () {
      return "rate must be a float in the range [0, 1), but got " + e + ".";
    }), 0 === e) return t instanceof wt ? o.clone() : o;

    var a = function (t, e) {
      if (null == e) return t.shape.slice();
      if (S(t.shape, e)) return e;

      if (t.shape.length === e.length) {
        for (var n = [], r = 0; r < t.shape.length; r++) null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r]);

        return n;
      }

      return e;
    }(o, n),
        i = 1 - e,
        s = xc(a, 0, 1, "float32", r).add(i).floor().div(i);

    return o.mul(s);
  }
});
exports.dropout = vh;

function mh(t, e, n) {
  for (var r = 1 - t % 2, o = new Float32Array(t), a = 0; a < t; ++a) {
    var i = 2 * Math.PI * a / (t + r - 1);
    o[a] = e - n * Math.cos(i);
  }

  return Mn(o, "float32");
}

var gh = An({
  hannWindow_: function (t) {
    return mh(t, .5, .5);
  }
}),
    yh = An({
  hammingWindow_: function (t) {
    return mh(t, .54, .46);
  }
}),
    xh = An({
  frame_: function (t, e, n, r, o) {
    void 0 === r && (r = !1), void 0 === o && (o = 0);

    for (var a = 0, i = []; a + e <= t.size;) i.push(Tl(t, a, e)), a += n;

    if (r) for (; a < t.size;) {
      var s = a + e - t.size,
          u = Yn([Tl(t, a, e - s), Hn([s], o)]);
      i.push(u), a += n;
    }
    return 0 === i.length ? Bn([], [0, e]) : Yn(i).as2D(i.length, e);
  }
}),
    bh = An({
  stft_: function (t, e, n, r, o) {
    var a;
    void 0 === o && (o = gh), null == r && (a = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(a) / Math.log(2)))));

    for (var i = xh(t, e, n), s = ko(i, o(e)), u = [], c = 0; c < i.shape[0]; c++) u.push(ch(s.slice([c, 0], [1, e]), r));

    return Yn(u);
  }
}),
    wh = Object.freeze({
  hannWindow: gh,
  hammingWindow: yh,
  frame: xh,
  stft: bh
});
exports.signal = wh;
exports.stft = bh;
exports.frame = xh;
exports.hammingWindow = yh;
exports.hannWindow = gh;

var Ch,
    Eh = function (t, e, o) {
  return void 0 === o && (o = 1), n(this, void 0, void 0, function () {
    var n, a, i, s, u, c, l, h, f, d, p, v, m, g;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = mn(t, "predictions", "inTopK"), a = mn(e, "targets", "inTopK"), C(n.rank > 1, function () {
            return "inTopK() expects the predictions to be of rank 2 or higher, but got " + n.rank;
          }), C(n.rank - 1 === a.rank, function () {
            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + n.rank + " and targets rank " + a.rank;
          }), E(n.shape.slice(0, n.shape.length - 1), a.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i = n.shape[n.shape.length - 1], C(o > 0 && o <= i, function () {
            return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i + "), but got " + o;
          }), [4, n.data()];

        case 1:
          return s = r.sent(), [4, a.data()];

        case 2:
          for (u = r.sent(), c = [s.length / i, i], h = c[1], f = B("bool", l = c[0]), d = 0; d < l; d++) {
            for (p = d * h, v = s.subarray(p, p + h), m = [], g = 0; g < v.length; g++) m.push({
              value: v[g],
              index: g
            });

            for (m.sort(function (t, e) {
              return e.value - t.value;
            }), f[d] = 0, g = 0; g < o; g++) if (m[g].index === u[d]) {
              f[d] = 1;
              break;
            }
          }

          return t !== n && n.dispose(), e !== a && a.dispose(), [2, Fn(f, a.shape, "bool")];
      }
    });
  });
};

exports.inTopKAsync = Eh;
exports.Reduction = Ch;
!function (t) {
  t[t.NONE = 0] = "NONE", t[t.MEAN = 1] = "MEAN", t[t.SUM = 2] = "SUM", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(Ch || (exports.Reduction = Ch = {}));

var Rh = An({
  absoluteDifference_: function (t, e, n, r) {
    void 0 === r && (r = Ch.SUM_BY_NONZERO_WEIGHTS);
    var o = mn(t, "labels", "absoluteDifference"),
        a = mn(e, "predictions", "absoluteDifference"),
        i = null;
    null != n && (i = mn(n, "weights", "absoluteDifference")), E(o.shape, a.shape, "Error in absoluteDifference: ");
    var s = o.sub(a).abs();
    return Ih(s, i, r);
  }
}),
    Ih = An({
  computeWeightedLoss_: function (t, e, n) {
    void 0 === n && (n = Ch.SUM_BY_NONZERO_WEIGHTS);
    var r = mn(t, "losses", "computeWeightedLoss"),
        o = null;
    null != e && (o = mn(e, "weights", "computeWeightedLoss"));
    var a = null == o ? r : r.mul(o);
    if (n === Ch.NONE) return a;
    if (n === Ch.SUM) return a.sum();

    if (n === Ch.MEAN) {
      if (null == o) return a.mean();
      var i = r.size / o.size,
          s = a.sum().div(o.sum());
      return i > 1 ? s.div(On(i)) : s;
    }

    if (n === Ch.SUM_BY_NONZERO_WEIGHTS) {
      if (null == o) return a.sum().div(On(r.size));
      var u = o.mul(zn(r.shape)).notEqual(On(0)).sum().toFloat();
      return a.sum().div(u);
    }

    throw Error("Unknown reduction: " + n);
  }
}),
    kh = An({
  cosineDistance_: function (t, e, n, r, o) {
    void 0 === o && (o = Ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "labels", "cosineDistance"),
        i = mn(e, "predictions", "cosineDistance"),
        s = null;
    null != r && (s = mn(r, "weights", "cosineDistance")), E(a.shape, i.shape, "Error in cosineDistance: ");
    var u = On(1).sub(a.mul(i).sum(n, !0));
    return Ih(u, s, o);
  }
}),
    Sh = An({
  hingeLoss_: function (t, e, n, r) {
    void 0 === r && (r = Ch.SUM_BY_NONZERO_WEIGHTS);
    var o = mn(t, "labels", "hingeLoss"),
        a = mn(e, "predictions", "hingeLoss"),
        i = null;
    null != n && (i = mn(n, "weights", "hingeLoss")), E(o.shape, a.shape, "Error in hingeLoss: ");
    var s = On(1);
    o = On(2).mul(o).sub(s);
    var u = s.sub(o.mul(a)).relu();
    return Ih(u, i, r);
  }
}),
    Ah = An({
  huberLoss_: function (t, e, n, r, o) {
    void 0 === r && (r = 1), void 0 === o && (o = Ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "labels", "huberLoss"),
        i = mn(e, "predictions", "huberLoss"),
        s = null;
    null != n && (s = mn(n, "weights", "huberLoss")), E(a.shape, i.shape, "Error in huberLoss: ");
    var u = On(r),
        c = i.sub(a).abs(),
        l = Co(c, u),
        h = c.sub(l),
        f = On(.5).mul(l.square()).add(u.mul(h));
    return Ih(f, s, o);
  }
}),
    Th = An({
  logLoss_: function (t, e, n, r, o) {
    void 0 === r && (r = 1e-7), void 0 === o && (o = Ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "labels", "logLoss"),
        i = mn(e, "predictions", "logLoss"),
        s = null;
    null != n && (s = mn(n, "weights", "logLoss")), E(a.shape, i.shape, "Error in logLoss: ");
    var u = On(1),
        c = On(r),
        l = a.mul(i.add(c).log()).neg().sub(u.sub(a).mul(u.sub(i).add(c).log()));
    return Ih(l, s, o);
  }
}),
    Dh = An({
  meanSquaredError_: function (t, e, n, r) {
    void 0 === r && (r = Ch.SUM_BY_NONZERO_WEIGHTS);
    var o = mn(t, "labels", "meanSquaredError"),
        a = mn(e, "predictions", "meanSquaredError"),
        i = null;
    null != n && (i = mn(n, "weights", "meanSquaredError")), E(o.shape, a.shape, "Error in meanSquaredError: ");
    var s = o.squaredDifference(a);
    return Ih(s, i, r);
  }
}),
    Nh = An({
  sigmoidCrossEntropy_: function (t, e, n, r, o) {
    void 0 === r && (r = 0), void 0 === o && (o = Ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "multiClassLabels", "sigmoidCrossEntropy"),
        i = mn(e, "logits", "sigmoidCrossEntropy"),
        s = null;

    if (null != n && (s = mn(n, "weights", "sigmoidCrossEntropy")), E(a.shape, i.shape, "Error in sigmoidCrossEntropy: "), r > 0) {
      var u = On(r),
          c = On(1),
          l = On(.5);
      a = a.mul(c.sub(u)).add(l.mul(u));
    }

    var h = function (t, e) {
      var n = mn(t, "labels", "sigmoidCrossEntropyWithLogits"),
          r = mn(e, "logits", "sigmoidCrossEntropyWithLogits");
      E(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
      var o = r.relu(),
          a = r.mul(n),
          i = r.abs().neg().exp().log1p();
      return o.sub(a).add(i);
    }(a, i);

    return Ih(h, s, o);
  }
}),
    Fh = An({
  softmaxCrossEntropy_: function (t, e, n, r, o) {
    void 0 === r && (r = 0), void 0 === o && (o = Ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "onehotLabels", "softmaxCrossEntropy"),
        i = mn(e, "logits", "softmaxCrossEntropy"),
        s = null;

    if (null != n && (s = mn(n, "weights", "softmaxCrossEntropy")), E(a.shape, i.shape, "Error in softmaxCrossEntropy: "), r > 0) {
      var u = On(r),
          c = On(1),
          l = On(a.shape[1]);
      a = a.mul(c.sub(u)).add(u.div(l));
    }

    var h = function (t, e, n) {
      if (void 0 === n && (n = -1), -1 === n && (n = e.rank - 1), n !== e.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e.rank + " and dim was " + n);
      return ea(function (t, e, r) {
        var o = e.logSumExp([n], !0),
            a = e.toFloat().sub(o);
        r([t, a]);
        return {
          value: a.mul(t).neg().sum([n]),
          gradFunc: function (t, e) {
            var r = e[0],
                o = e[1],
                a = wn(t.shape, [n]);
            return [t.reshape(a).mul(r.toFloat().sub(o.exp())), t.reshape(a).mul(o.exp().sub(r.toFloat()))];
          }
        };
      })(t, e);
    }(a, i);

    return Ih(h, s, o);
  }
}),
    _h = Object.freeze({
  get Reduction() {
    return Ch;
  },

  absoluteDifference: Rh,
  computeWeightedLoss: Ih,
  cosineDistance: kh,
  hingeLoss: Sh,
  huberLoss: Ah,
  logLoss: Th,
  meanSquaredError: Dh,
  sigmoidCrossEntropy: Nh,
  softmaxCrossEntropy: Fh
});

exports.losses = _h;

function Oh(t, e) {
  return void 0 === e && (e = !1), Lt.tidy(function () {
    if (2 !== t.shape.length) throw new Error("qr2d() requires a 2D Tensor, but got a " + t.shape.length + "D Tensor.");

    for (var n = t.shape[0], r = t.shape[1], o = oc(n), a = t.clone(), i = Bn([[1]], [1, 1]), s = i.clone(), u = n >= r ? r : n, c = function (t) {
      var e,
          u = a,
          c = s,
          l = o;
      e = Lt.tidy(function () {
        var e = a.slice([t, t], [n - t, 1]),
            u = e.norm(),
            c = a.slice([t, t], [1, 1]),
            l = Bn([[-1]]).where(c.greater(0), Bn([[1]])),
            h = c.sub(l.mul(u)),
            f = e.div(h);
        s = 1 === f.shape[0] ? i.clone() : i.concat(f.slice([1, 0], [f.shape[0] - 1, f.shape[1]]), 0);
        var d = l.matMul(h).div(u).neg(),
            p = a.slice([t, 0], [n - t, r]),
            v = d.mul(s);
        if (0 === t) a = p.sub(v.matMul(s.transpose().matMul(p)));else {
          var m = p.sub(v.matMul(s.transpose().matMul(p)));
          a = a.slice([0, 0], [t, r]).concat(m, 0);
        }
        var g = o.slice([0, t], [n, o.shape[1] - t]);
        if (0 === t) o = g.sub(g.matMul(s).matMul(v.transpose()));else {
          var y = g.sub(g.matMul(s).matMul(v.transpose()));
          o = o.slice([0, 0], [n, t]).concat(y, 1);
        }
        return [s, a, o];
      }), s = e[0], a = e[1], o = e[2], tn([u, c, l]);
    }, l = 0; l < u; ++l) c(l);

    return !e && n > r && (o = o.slice([0, 0], [n, r]), a = a.slice([0, 0], [r, r])), [o, a];
  });
}

var Mh = An({
  bandPart_: function (t, e, n) {
    if (e % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + e + ".");
    if (n % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + n + ".");
    var r = mn(t, "a", "bandPart");
    if (r.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r.rank + ".");
    var o = r.shape,
        a = r.shape.slice(-2),
        i = a[0],
        s = a[1];
    if (!(e <= i)) throw new Error("bandPart(): numLower (" + e + ") must not be greater than the number of rows (" + i + ").");
    if (!(n <= s)) throw new Error("bandPart(): numUpper (" + n + ") must not be greater than the number of columns (" + s + ").");
    e < 0 && (e = i), n < 0 && (n = s);
    var u = Kn(0, i, 1, "int32").reshape([-1, 1]),
        c = Kn(0, s, 1, "int32"),
        l = No(u, c),
        h = $u(l.lessEqual(On(+e, "int32")), l.greaterEqual(On(-n, "int32"))),
        f = Gn([i, s], r.dtype);
    return mr(gr(r.reshape([-1, i, s])).map(function (t) {
      return tc(h, t, f);
    })).reshape(o);
  }
}),
    Bh = An({
  gramSchmidt_: function (t) {
    var e;

    if (Array.isArray(t)) {
      e = !1, C(null != t && t.length > 0, function () {
        return "Gram-Schmidt process: input must not be null, undefined, or empty";
      });

      for (var n = t[0].shape[0], r = function (e) {
        C(t[e].shape[0] === n, function () {
          return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t[e].shape[0] + " vs. " + n + ")";
        });
      }, o = 1; o < t.length; ++o) r(o);
    } else e = !0, t = tr(t, t.shape[0], 0).map(function (t) {
      return vr(t, [0]);
    });

    C(t.length <= t[0].shape[0], function () {
      return "Gram-Schmidt: Number of vectors (" + t.length + ") exceeds number of dimensions (" + t[0].shape[0] + ").";
    });

    var a = [],
        i = t,
        s = function (t) {
      a.push(Lt.tidy(function () {
        var e = i[t];
        if (t > 0) for (var n = 0; n < t; ++n) {
          var r = Hl(a[n].mulStrict(e)).mul(a[n]);
          e = e.sub(r);
        }
        return e.div(th(e, "euclidean"));
      }));
    };

    for (o = 0; o < t.length; ++o) s(o);

    return e ? mr(a, 0) : a;
  }
}),
    Ph = An({
  qr_: function (t, e) {
    if (void 0 === e && (e = !1), t.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t.rank);
    if (2 === t.rank) return Oh(t, e);
    var n = t.shape.slice(0, t.shape.length - 2).reduce(function (t, e) {
      return t * e;
    }),
        r = gr(t.reshape([n, t.shape[t.shape.length - 2], t.shape[t.shape.length - 1]]), 0),
        o = [],
        a = [];
    return r.forEach(function (t) {
      var n = Oh(t, e),
          r = n[0],
          i = n[1];
      o.push(r), a.push(i);
    }), [mr(o, 0).reshape(t.shape), mr(a, 0).reshape(t.shape)];
  }
}),
    Lh = Object.freeze({
  bandPart: Mh,
  gramSchmidt: Bh,
  qr: Ph
});
exports.linalg = Lh;

function Wh(t, e, n, r, o, a) {
  null == r && (r = .5), null == o && (o = Number.NEGATIVE_INFINITY), null == a && (a = 0);
  var i = t.shape[0];
  return n = Math.min(n, i), C(0 <= r && r <= 1, function () {
    return "iouThreshold must be in [0, 1], but was '" + r + "'";
  }), C(2 === t.rank, function () {
    return "boxes must be a 2D tensor, but was of rank '" + t.rank + "'";
  }), C(4 === t.shape[1], function () {
    return "boxes must have 4 columns, but 2nd dimension was " + t.shape[1];
  }), C(1 === e.rank, function () {
    return "scores must be a 1D tensor";
  }), C(e.shape[0] === i, function () {
    return "scores has incompatible shape with boxes. Expected " + i + ", but was " + e.shape[0];
  }), C(0 <= a && a <= 1, function () {
    return "softNmsSigma must be in [0, 1], but was '" + a + "'";
  }), {
    maxOutputSize: n,
    iouThreshold: r,
    scoreThreshold: o,
    softNmsSigma: a
  };
}

var Uh = An({
  resizeBilinear_: function (t, e, n) {
    void 0 === n && (n = !1);
    var r = mn(t, "images", "resizeBilinear");
    C(3 === r.rank || 4 === r.rank, function () {
      return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r.rank + ".";
    }), C(2 === e.length, function () {
      return "Error in resizeBilinear: new shape must 2D, but got shape " + e + ".";
    });
    var o = r,
        a = !1;
    3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
    var i = e[0],
        s = e[1],
        u = Lt.runKernelFunc(function (t, e) {
      return e([o]), t.resizeBilinear(o, i, s, n);
    }, {
      x: o
    }, function (t, e) {
      return {
        x: function () {
          return Lt.runKernelFunc(function (r) {
            return r.resizeBilinearBackprop(t, e[0], n);
          }, {});
        }
      };
    }, "ResizeBilinear", {
      alignCorners: n,
      newHeight: i,
      newWidth: s
    });
    return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
  }
}),
    Vh = An({
  resizeNearestNeighbor_: function (t, e, n) {
    void 0 === n && (n = !1);
    var r = mn(t, "images", "resizeNearestNeighbor");
    C(3 === r.rank || 4 === r.rank, function () {
      return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r.rank + ".";
    }), C(2 === e.length, function () {
      return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e + ".";
    }), C("float32" === r.dtype || "int32" === r.dtype, function () {
      return "`images` must have `int32` or `float32` as dtype";
    });
    var o = r,
        a = !1;
    3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
    var i = e[0],
        s = e[1],
        u = Lt.runKernelFunc(function (t, e) {
      return e([o]), t.resizeNearestNeighbor(o, i, s, n);
    }, {
      batchImages: o
    }, function (t, e) {
      return {
        batchImages: function () {
          return Lt.runKernelFunc(function (r) {
            return r.resizeNearestNeighborBackprop(t, e[0], n);
          }, {});
        }
      };
    });
    return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
  }
}),
    zh = An({
  nonMaxSuppression_: function (t, e, n, r, o) {
    void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY);
    var a = mn(t, "boxes", "nonMaxSuppression"),
        i = mn(e, "scores", "nonMaxSuppression"),
        s = Wh(a, i, n, r, o);
    n = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold;
    var u = {
      maxOutputSize: n,
      iouThreshold: r,
      scoreThreshold: o
    };
    return Lt.runKernelFunc(function (t) {
      return t.nonMaxSuppression(a, i, n, r, o);
    }, {
      boxes: a,
      scores: i
    }, null, "NonMaxSuppressionV3", u);
  }
}),
    Gh = function (t, e, o, a, i) {
  return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function () {
    var n, s, u, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = mn(t, "boxes", "nonMaxSuppressionAsync"), s = mn(e, "scores", "nonMaxSuppressionAsync"), u = Wh(n, s, o, a, i), o = u.maxOutputSize, a = u.iouThreshold, i = u.scoreThreshold, [4, Promise.all([n.data(), s.data()])];

        case 1:
          return c = r.sent(), l = c[0], h = c[1], f = Da(l, h, o, a, i), n !== t && n.dispose(), s !== e && s.dispose(), [2, f];
      }
    });
  });
},
    Hh = An({
  nonMaxSuppressionWithScore_: function (t, e, n, r, o, a) {
    void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY), void 0 === a && (a = 0);
    var i = mn(t, "boxes", "nonMaxSuppression"),
        s = mn(e, "scores", "nonMaxSuppression"),
        u = Wh(i, s, n, r, o, a),
        c = {
      maxOutputSize: n = u.maxOutputSize,
      iouThreshold: r = u.iouThreshold,
      scoreThreshold: o = u.scoreThreshold,
      softNmsSigma: a = u.softNmsSigma
    },
        l = Lt.runKernel("NonMaxSuppressionV5", {
      boxes: i,
      scores: s
    }, c);
    return {
      selectedIndices: l[0],
      selectedScores: l[1]
    };
  }
}),
    qh = function (t, e, o, a, i, s) {
  return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === s && (s = 0), n(this, void 0, void 0, function () {
    var n, u, c, l, h, f, d;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = mn(t, "boxes", "nonMaxSuppressionAsync"), u = mn(e, "scores", "nonMaxSuppressionAsync"), c = Wh(n, u, o, a, i, s), o = c.maxOutputSize, a = c.iouThreshold, i = c.scoreThreshold, s = c.softNmsSigma, [4, Promise.all([n.data(), u.data()])];

        case 1:
          return l = r.sent(), h = l[0], f = l[1], d = Na(h, f, o, a, i, s), n !== t && n.dispose(), u !== e && u.dispose(), [2, d];
      }
    });
  });
},
    Kh = An({
  cropAndResize_: function (t, e, n, r, o, a) {
    var i = mn(t, "image", "cropAndResize"),
        s = mn(e, "boxes", "cropAndResize", "float32"),
        u = mn(n, "boxInd", "cropAndResize", "int32");
    o = o || "bilinear", a = a || 0;
    var c = s.shape[0];
    return C(4 === i.rank, function () {
      return "Error in cropAndResize: image must be rank 4,but got rank " + i.rank + ".";
    }), C(2 === s.rank && 4 === s.shape[1], function () {
      return "Error in cropAndResize: boxes must be have size [" + c + ",4] but had shape " + s.shape + ".";
    }), C(1 === u.rank && u.shape[0] === c, function () {
      return "Error in cropAndResize: boxInd must be have size [" + c + "] but had shape " + s.shape + ".";
    }), C(2 === r.length, function () {
      return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + ".";
    }), C(r[0] >= 1 && r[1] >= 1, function () {
      return "cropSize must be atleast [1,1], but was " + r;
    }), C("bilinear" === o || "nearest" === o, function () {
      return "method must be bilinear or nearest, but was " + o;
    }), Lt.runKernelFunc(function (t, e) {
      return t.cropAndResize(i, s, u, r, o, a);
    }, {
      images: i,
      boxes: s,
      boxInd: u
    }, null, "CropAndResize", {
      method: o,
      extrapolationValue: a,
      cropSize: r
    });
  }
}),
    jh = Object.freeze({
  resizeBilinear: Uh,
  resizeNearestNeighbor: Vh,
  nonMaxSuppression: zh,
  nonMaxSuppressionAsync: Gh,
  nonMaxSuppressionWithScore: Hh,
  nonMaxSuppressionWithScoreAsync: qh,
  cropAndResize: Kh
}),
    Xh = function (t, e) {
  return !(t > 0) || "linear" === e;
},
    Yh = function (t, e, n) {
  if (null == n || "linear" === n) return t;
  if ("relu" === n) return t.mul(e.step());
  throw new Error("Gradient for activation " + n + " has not been implemented yet.");
},
    $h = function (t, e) {
  var n = e,
      r = Nr(t.shape, e.shape);
  return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape);
},
    Qh = function (t, e, n) {
  if ("linear" === e) return t;
  if ("relu" === e) return Yl(t);
  if ("elu" === e) return Kl(t);
  if ("relu6" === e) return $l(t);
  if ("prelu" === e) return Xl(t, n);
  throw new Error("Unknown fused activation " + e + ".");
};

exports.image = jh;
var Jh = An({
  fusedMatMul_: function (t) {
    var e,
        n = t.a,
        r = t.b,
        o = t.transposeA,
        a = void 0 !== o && o,
        i = t.transposeB,
        s = void 0 !== i && i,
        u = t.bias,
        c = t.activation,
        l = void 0 === c ? "linear" : c,
        h = t.preluActivationWeights;

    if (!1 === Xh(Lt.state.gradientDepth, l)) {
      var f = pl(n, r, a, s);
      return null != u && (f = po(f, u)), Qh(f, l, h);
    }

    var d = mn(n, "a", "fused matMul"),
        p = mn(r, "b", "fused matMul");
    e = Nt(d, p), d = e[0], p = e[1];
    var v = a ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
        m = s ? p.shape[p.rank - 1] : p.shape[p.rank - 2],
        g = a ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
        y = s ? p.shape[p.rank - 2] : p.shape[p.rank - 1],
        x = d.shape.slice(0, -2),
        b = p.shape.slice(0, -2),
        w = k(x),
        E = k(b);
    C(d.rank >= 2 && p.rank >= 2 && d.rank === p.rank, function () {
      return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + d.rank + " and " + p.rank + ".";
    }), C(S(x, b), function () {
      return "Error in fused matMul: outer dimensions (" + x + ") and (" + b + ") of Tensors with shapes " + d.shape + " and " + p.shape + " must match.";
    }), C(v === m, function () {
      return "Error in fused matMul: inner shapes (" + v + ") and (" + m + ") of Tensors with shapes " + d.shape + " and " + p.shape + " and transposeA=" + a + " and transposeB=" + s + " must match.";
    });
    var R,
        I,
        A = d.shape.slice(0, -2).concat([g, y]),
        T = a ? d.as3D(w, v, g) : d.as3D(w, g, v),
        D = s ? p.as3D(E, y, m) : p.as3D(E, m, y);
    null != u && Fr(A, (R = Nt(R = mn(u, "bias", "fused matMul"), d)[0]).shape), null != h && (I = mn(h, "prelu weights", "fused matMul"));
    var N = {
      a: T,
      b: D
    };
    null != u && (N.bias = R), null != h && (N.preluActivationWeights = I);
    var F = [T, D];
    return Lt.runKernelFunc(function (t, e) {
      var n = t.fusedBatchMatMul({
        a: T,
        b: D,
        transposeA: a,
        transposeB: s,
        bias: R,
        activation: l,
        preluActivationWeights: I
      });
      return e([T, D, n]), n;
    }, N, function (t, e) {
      var n = e[0],
          r = e[1],
          o = e[2],
          i = Yh(t, o, l),
          c = {};
      return null != u && (c = {
        bias: function () {
          return $h(R, i);
        }
      }), a || s ? !a && s ? Object.assign({
        a: function () {
          return i.matMul(r, !1, !1);
        },
        b: function () {
          return i.matMul(n, !0, !1);
        }
      }, c) : a && !s ? Object.assign({
        a: function () {
          return r.matMul(i, !1, !0);
        },
        b: function () {
          return n.matMul(i, !1, !1);
        }
      }, c) : Object.assign({
        a: function () {
          return r.matMul(i, !0, !0);
        },
        b: function () {
          return i.matMul(n, !0, !0);
        }
      }, c) : Object.assign({
        a: function () {
          return i.matMul(r, !1, !0);
        },
        b: function () {
          return n.matMul(i, !0, !1);
        }
      }, c);
    }, "_FusedMatMul", {
      transposeA: a,
      transposeB: s,
      activation: l
    }, F, [!0]).reshape(A);
  }
}),
    Zh = An({
  fusedConv2d_: function (t) {
    var e = t.x,
        n = t.filter,
        r = t.strides,
        o = t.pad,
        a = t.dataFormat,
        i = void 0 === a ? "NHWC" : a,
        s = t.dilations,
        u = void 0 === s ? [1, 1] : s,
        c = t.dimRoundingMode,
        l = t.bias,
        h = t.activation,
        f = void 0 === h ? "linear" : h,
        d = t.preluActivationWeights;

    if (f = f || "linear", !1 === Xh(Lt.state.gradientDepth, f)) {
      var p = ol(e, n, r, o, i, u, c);
      return null != l && (p = po(p, l)), Qh(p, f, d);
    }

    var v = mn(e, "x", "conv2d"),
        m = mn(n, "filter", "conv2d"),
        g = v,
        y = !1;
    3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === g.rank, function () {
      return "Error in fused conv2d: input must be rank 4, but got rank " + g.rank + ".";
    }), C(4 === m.rank, function () {
      return "Error in fused conv2d: filter must be rank 4, but got rank " + m.rank + ".";
    }), null != c && C(A(o), function () {
      return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c + " but got pad " + o + ".";
    }), C(g.shape[3] === m.shape[2], function () {
      return "Error in conv2d: depth of input (" + g.shape[3] + ") must match input depth for filter " + m.shape[2] + ".";
    }), C(ya(r, u), function () {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'";
    }), C("NHWC" === i, function () {
      return "Error in conv2d: got dataFormat of " + i + " but only NHWC is currently supported.";
    });
    var x,
        b,
        w = la(g.shape, m.shape, r, u, o, c);
    null != l && (x = Nt(x = mn(l, "bias", "fused conv2d"), v)[0], Fr(w.outShape, x.shape)), null != d && (b = mn(d, "prelu weights", "fused conv2d"));
    var E = {
      x: g,
      filter: m
    };
    null != l && (E.bias = x), null != d && (E.preluActivationWeights = b);
    var R = [m, g],
        I = Lt.runKernelFunc(function (t, e) {
      var n = t.fusedConv2d({
        input: g,
        filter: m,
        convInfo: w,
        bias: x,
        activation: f,
        preluActivationWeights: b
      });
      return e([m, g, n]), n;
    }, E, function (t, e) {
      var n = e,
          a = n[0],
          i = n[1],
          s = n[2],
          c = Yh(t, s, f);
      C(ga(u), function () {
        return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u + "'";
      });
      var h = {};
      return null != l && (h = {
        bias: function () {
          return $h(x, c);
        }
      }), Object.assign({
        x: function () {
          return sl(i.shape, c, a, r, o);
        },
        filter: function () {
          return il(i, c, a.shape, r, o);
        }
      }, h);
    }, "FusedConv2D", {
      convInfo: w,
      activation: f
    }, R, [!0]);
    return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;
  }
}),
    tf = An({
  fusedDepthwiseConv2d_: function (t) {
    var e = t.x,
        n = t.filter,
        r = t.strides,
        o = t.pad,
        a = t.dataFormat,
        i = void 0 === a ? "NHWC" : a,
        s = t.dilations,
        u = void 0 === s ? [1, 1] : s,
        c = t.dimRoundingMode,
        l = t.bias,
        h = t.activation,
        f = void 0 === h ? "linear" : h,
        d = t.preluActivationWeights;

    if (!1 === Xh(Lt.state.gradientDepth, f)) {
      var p = ul(e, n, r, o, i, u, c);
      return null != l && (p = po(p, l)), Qh(p, f, d);
    }

    var v = mn(e, "x", "depthwiseConv2d"),
        m = mn(n, "filter", "depthwiseConv2d"),
        g = v,
        y = !1;
    3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === g.rank, function () {
      return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + g.rank + ".";
    }), C(4 === m.rank, function () {
      return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m.rank + ".";
    }), C(g.shape[3] === m.shape[2], function () {
      return "Error in fused depthwiseConv2d: number of input channels (" + g.shape[3] + ") must match the inChannels dimension in filter " + m.shape[2] + ".";
    }), null == u && (u = [1, 1]), C(ya(r, u), function () {
      return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'";
    }), null != c && C(A(o), function () {
      return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c + " but got pad " + o + ".";
    });
    var x,
        b,
        w = la(g.shape, m.shape, r, u, o, c, !0);
    null != l && (x = Nt(x = mn(l, "bias", "fused conv2d"), v)[0], Fr(w.outShape, x.shape)), null != d && (b = mn(d, "prelu weights", "fused depthwiseConv2d"));
    var E = {
      x: g,
      filter: m
    };
    null != l && (E.bias = x), null != d && (E.preluActivationWeights = b);
    var R = [m, g],
        I = Lt.runKernelFunc(function (t, e) {
      var n = t.fusedDepthwiseConv2D({
        input: g,
        filter: m,
        convInfo: w,
        bias: x,
        activation: f,
        preluActivationWeights: b
      });
      return e([m, g, n]), n;
    }, E, function (t, e) {
      C(ga(u), function () {
        return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u + "'";
      });
      var n = e[0],
          r = e[1],
          o = e[2],
          a = Yh(t, o, f),
          i = {};
      return null != l && (i = {
        bias: function () {
          return $h(x, a);
        }
      }), Object.assign({
        x: function () {
          return cl(r.shape, a, n, w);
        },
        filter: function () {
          return ll(r, a, n.shape, w);
        }
      }, i);
    }, "FusedDepthwiseConv2D", {
      convInfo: w,
      activation: f
    }, R, [!0]);
    return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;
  }
}),
    ef = Object.freeze({
  matMul: Jh,
  conv2d: Zh,
  depthwiseConv2d: tf
}),
    nf = Object.freeze({
  image: jh,
  linalg: Lh,
  losses: _h,
  spectral: hh,
  fused: ef,
  signal: wh,
  broadcastTo: Xu,
  clone: Yu,
  div: _o,
  divNoNan: nc,
  eye: oc,
  multinomial: ac,
  oneHot: ic,
  rand: sc,
  randomGamma: gc,
  randomNormal: yc,
  randomUniform: xc,
  square: bc,
  squaredDifference: wc,
  tile: rc,
  truncatedNormal: Cc,
  conv1d: rl,
  conv2d: ol,
  conv3d: al,
  depthwiseConv2d: ul,
  separableConv2d: hl,
  conv2dTranspose: fl,
  conv3dTranspose: dl,
  op: An,
  batchNormalization2d: Tc,
  batchNormalization3d: Dc,
  batchNormalization4d: Nc,
  batchNormalization: Fc,
  batchNorm: _c,
  batchNorm2d: Oc,
  batchNorm3d: Mc,
  batchNorm4d: Bc,
  booleanMaskAsync: Zc,
  complex: Tn,
  real: Dn,
  imag: Nn,
  concat: Yn,
  concat1d: $n,
  concat2d: Qn,
  concat3d: Jn,
  concat4d: Zn,
  split: tr,
  matMul: pl,
  dot: vl,
  outerProduct: ml,
  reverse: gl,
  reverse1d: yl,
  reverse2d: xl,
  reverse3d: bl,
  reverse4d: wl,
  maxPool: Rl,
  avgPool: Il,
  pool: kl,
  maxPool3d: Sl,
  avgPool3d: Al,
  slice: Tl,
  slice1d: Dl,
  slice2d: Nl,
  slice3d: Fl,
  slice4d: _l,
  abs: _r,
  acos: Or,
  acosh: Mr,
  asin: Br,
  asinh: Pr,
  atan: Lr,
  atanh: Wr,
  ceil: Ur,
  clipByValue: Vr,
  cos: zr,
  cosh: Gr,
  erf: Hr,
  exp: qr,
  expm1: Kr,
  floor: jr,
  log: Xr,
  log1p: Yr,
  logSigmoid: $r,
  neg: Qr,
  reciprocal: Jr,
  round: Zr,
  rsqrt: to,
  sigmoid: eo,
  sign: no,
  isNaN: ro,
  isInf: oo,
  isFinite: ao,
  sin: io,
  sinh: so,
  softplus: uo,
  sqrt: co,
  step: lo,
  tan: ho,
  tanh: fo,
  all: Ml,
  any: Bl,
  argMax: Pl,
  argMin: Ll,
  logSumExp: Wl,
  max: Ul,
  mean: Vl,
  min: zl,
  moments: Gl,
  sum: Hl,
  prod: ql,
  equal: Pc,
  equalStrict: Lc,
  greater: Wc,
  greaterEqual: Uc,
  greaterEqualStrict: Vc,
  greaterStrict: zc,
  less: Gc,
  lessEqual: Hc,
  lessEqualStrict: qc,
  lessStrict: Kc,
  notEqual: jc,
  notEqualStrict: Xc,
  add: po,
  addN: vo,
  addStrict: mo,
  atan2: go,
  divStrict: yo,
  floorDiv: xo,
  maximum: bo,
  maximumStrict: wo,
  minimum: Co,
  minimumStrict: Eo,
  mod: Ro,
  modStrict: Io,
  mul: ko,
  mulStrict: So,
  pow: Ao,
  powStrict: To,
  squaredDifferenceStrict: Do,
  sub: No,
  subStrict: Fo,
  elu: Kl,
  leakyRelu: jl,
  prelu: Xl,
  relu: Yl,
  relu6: $l,
  selu: Ql,
  logicalAnd: $u,
  logicalNot: Qu,
  logicalOr: Ju,
  logicalXor: Zu,
  where: tc,
  whereAsync: ec,
  buffer: er,
  print: nr,
  batchToSpaceND: rr,
  cast: or,
  cumsum: ar,
  depthToSpace: ir,
  expandDims: sr,
  pad: ur,
  pad1d: cr,
  pad2d: lr,
  pad3d: hr,
  pad4d: fr,
  reshape: dr,
  spaceToBatchND: pr,
  squeeze: vr,
  stack: mr,
  unstack: gr,
  setdiff1dAsync: yr,
  fill: Hn,
  linspace: qn,
  ones: zn,
  range: Kn,
  scalar: On,
  tensor: Fn,
  tensor1d: Mn,
  tensor2d: Bn,
  tensor3d: Pn,
  tensor4d: Ln,
  tensor5d: Wn,
  tensor6d: Un,
  variable: Vn,
  zeros: Gn,
  onesLike: jn,
  zerosLike: Xn,
  transpose: Jl,
  softmax: ra,
  logSoftmax: oa,
  localResponseNormalization: Zl,
  norm: th,
  gather: Qc,
  unsortedSegmentSum: Jc,
  basicLSTMCell: eh,
  multiRNNCell: nh,
  movingAverage: rh,
  stridedSlice: oh,
  topk: ah,
  scatterND: ih,
  fft: sh,
  ifft: uh,
  rfft: ch,
  irfft: lh,
  sparseToDense: fh,
  gatherND: dh,
  diag: ph,
  dropout: vh,
  hannWindow: gh,
  hammingWindow: yh,
  frame: xh,
  stft: bh,
  inTopKAsync: Eh
});
exports.fused = ef;

function rf(t, e) {
  Array.isArray(t) || (t = [t]), t.forEach(function (t) {
    null != t && C("complex64" !== t.dtype, function () {
      return e + " does not support complex64 tensors.";
    });
  });
}

function of(t, e, n, r) {
  if ("linear" === n) return t.linear(e);
  if ("relu" === n) return t.relu(e);
  if ("elu" === n) return t.elu(e);
  if ("relu6" === n) return t.relu6(e);
  if ("prelu" === n) return t.prelu(e, r);
  throw new Error("Activation " + n + " has not been implemented for the CPU backend.");
}

var af = function (t) {
  function o() {
    var e = t.call(this) || this;
    return e.blockSize = 48, e.firstUse = !0, e.data = new aa(e, Lt), e;
  }

  return e(o, t), o.prototype.write = function (t, e, n) {
    this.firstUse && (this.firstUse = !1, i().get("IS_NODE") && dn("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
    var r = {};
    return this.data.set(r, {
      values: t,
      dtype: n
    }), r;
  }, o.prototype.move = function (t, e, n, r) {
    this.data.set(t, {
      values: e,
      dtype: r
    });
  }, o.prototype.numDataIds = function () {
    return this.data.numDataIds();
  }, o.prototype.read = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        return [2, this.readSync(t)];
      });
    });
  }, o.prototype.readSync = function (t) {
    var e = this.data.get(t),
        n = e.dtype,
        r = e.complexTensors;
    return "complex64" === n ? Ra(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(t).values;
  }, o.prototype.bufferSync = function (t) {
    var e = this.readSync(t.dataId),
        n = e;
    if ("string" === t.dtype) try {
      n = e.map(function (t) {
        return ot(t);
      });
    } catch (t) {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return er(t.shape, t.dtype, n);
  }, o.prototype.makeOutput = function (t, e, n) {
    var r = this.write(t, e, n);
    return Lt.makeTensorFromDataId(r, e, n, this);
  }, o.prototype.disposeData = function (t) {
    if (this.data.has(t)) {
      var e = this.data.get(t).complexTensors;
      null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t);
    }
  }, o.prototype.time = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        return e = et(), t(), [2, {
          kernelMs: et() - e
        }];
      });
    });
  }, o.prototype.memory = function () {
    return {
      unreliable: !0,
      reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
    };
  }, o.prototype.complex = function (t, e) {
    var n = this.makeOutput(null, t.shape, "complex64");
    return this.data.get(n.dataId).complexTensors = {
      real: Lt.keep(t.clone()),
      imag: Lt.keep(e.clone())
    }, n;
  }, o.prototype.real = function (t) {
    return this.data.get(t.dataId).complexTensors.real.clone();
  }, o.prototype.imag = function (t) {
    return this.data.get(t.dataId).complexTensors.imag.clone();
  }, o.prototype.slice = function (t, e, n) {
    if (rf(t, "slice"), jo(t.shape, e, n)) {
      var r = Xo(e, t.strides),
          o = k(n);
      return Fn(this.readSync(t.dataId).subarray(r, r + o), n, t.dtype);
    }

    for (var a = er(n, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; ++s) {
      var u = a.indexToLoc(s).map(function (t, n) {
        return t + e[n];
      });
      a.values[s] = i.get.apply(i, u);
    }

    return a.toTensor();
  }, o.prototype.stridedSlice = function (t, e, n, r) {
    rf(t, "stridedSlice");
    var o = Ho(e, n, r);
    if (o.some(function (t) {
      return 0 === t;
    })) return Fn([], o);

    for (var a = er(o, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; s++) {
      for (var u = a.indexToLoc(s), c = new Array(u.length), l = 0; l < c.length; l++) c[l] = u[l] * r[l] + e[l];

      a.set.apply(a, [i.get.apply(i, c)].concat(u));
    }

    return a.toTensor();
  }, o.prototype.diag = function (t) {
    for (var e = this.readSync(t.dataId), n = er([t.size, t.size], t.dtype), r = n.values, o = 0; o < e.length; o++) r[o * t.size + o] = e[o];

    return n.toTensor();
  }, o.prototype.unstack = function (t, e) {
    for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++) a !== e && (r[o++] = t.shape[a]);

    var i = new Array(t.rank).fill(0),
        s = t.shape.slice();
    s[e] = 1;
    var u = new Array(n);

    for (a = 0; a < u.length; a++) i[e] = a, u[a] = this.slice(t, i, s).reshape(r);

    return u;
  }, o.prototype.reverse = function (t, e) {
    rf(t, "reverse");

    for (var n = er(t.shape, t.dtype), r = this.bufferSync(t), o = function (o) {
      var a = n.indexToLoc(o),
          i = a.slice();
      e.forEach(function (e) {
        return i[e] = t.shape[e] - 1 - i[e];
      }), n.set.apply(n, [r.get.apply(r, i)].concat(a));
    }, a = 0; a < n.size; a++) o(a);

    return n.toTensor();
  }, o.prototype.concat = function (t, e) {
    var n = this;

    if ("complex64" === t[0].dtype) {
      var r = t.map(function (t) {
        return Dn(t);
      }),
          o = t.map(function (t) {
        return Nn(t);
      });
      return Tn(this.concat(r, e), this.concat(o, e));
    }

    var a = t.map(function (t) {
      var n = k(t.shape.slice(e));
      return t.as2D(-1, n);
    }),
        i = Sn(a.map(function (t) {
      return t.shape;
    }), 1),
        s = er(i, t[0].dtype).values;

    if (1 === a[0].shape[0]) {
      var u = 0;
      a.forEach(function (t) {
        s.set(n.readSync(t.dataId), u), u += t.size;
      });
    } else {
      var c = 0;
      a.forEach(function (t) {
        for (var e = n.readSync(t.dataId), r = 0, o = 0; o < t.shape[0]; ++o) for (var a = o * i[1] + c, u = 0; u < t.shape[1]; ++u) s[a + u] = e[r++];

        c += t.shape[1];
      });
    }

    var l = Sn(t.map(function (t) {
      return t.shape;
    }), e);
    return Fn(s, l, t[0].dtype);
  }, o.prototype.neg = function (t) {
    return rf(t, "neg"), this.multiply(On(-1), t);
  }, o.prototype.add = function (t, e) {
    return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
      return {
        real: t + n,
        imag: e + r
      };
    }) : this.broadcastedBinaryOp(t, e, Tt(t.dtype, e.dtype), function (t, e) {
      return t + e;
    });
  }, o.prototype.addN = function (t) {
    var e = this;
    rf(t, "addN");

    for (var n = t.map(function (t) {
      return e.readSync(t.dataId);
    }), r = er(t[0].shape, t[0].dtype), o = r.values, a = 0; a < t.length; a++) for (var i = n[a], s = 0; s < o.length; s++) o[s] += i[s];

    return r.toTensor();
  }, o.prototype.softmax = function (t, e) {
    var n = O([e], t.shape),
        r = this.max(t, n),
        o = wn(r.shape, n),
        a = this.subtract(t, r.reshape(o)),
        i = this.exp(a),
        s = this.sum(i, n).reshape(o);
    return _o(i, s);
  }, o.prototype.subtract = function (t, e) {
    return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
      return {
        real: t - n,
        imag: e - r
      };
    }) : this.broadcastedBinaryOp(t, e, Tt(t.dtype, e.dtype), function (t, e) {
      return t - e;
    });
  }, o.prototype.pow = function (t, e) {
    return rf([t, e], "pow"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.pow(t, e);
    });
  }, o.prototype.batchMatMul = function (t, e, n, r) {
    rf([t, e], "matMul");

    for (var o = n ? t.shape[1] : t.shape[2], a = n ? t.shape[2] : t.shape[1], i = r ? e.shape[1] : e.shape[2], s = t.shape[0], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = n ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], h = l[0], f = l[1], d = l[2], p = r ? [1, e.strides[1], e.strides[0]] : [e.strides[1], 1, e.strides[0]], v = p[0], m = p[1], g = p[2], y = a * i, x = er([s, a, i], t.dtype), b = x.values, w = this.blockSize, C = 0; C < s; C++) for (var E = 0; E < a; E += w) for (var R = 0; R < i; R += w) for (var I = 0; I < o; I += w) for (var k = Math.min(E + w, a), S = Math.min(R + w, i), A = Math.min(I + w, o), T = E; T < k; T++) for (var D = R; D < S; D++) {
      for (var N = 0, F = I; F < A; F++) N += u[C * h + T * f + F * d] * c[F * v + D * m + C * g];

      b[C * y + (T * i + D)] += N;
    }

    return x.toTensor();
  }, o.prototype.fusedBatchMatMul = function (t) {
    var e = t.a,
        n = t.b,
        r = t.transposeA,
        o = t.transposeB,
        a = t.bias,
        i = t.activation,
        s = t.preluActivationWeights,
        u = this.batchMatMul(e, n, r, o);
    return a && (u = this.add(u, a)), i && (u = of(this, u, i, s)), u;
  }, o.prototype.multiply = function (t, e) {
    return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
      return {
        real: t * n - e * r,
        imag: t * r + e * n
      };
    }) : this.broadcastedBinaryOp(t, e, Tt(t.dtype, e.dtype), function (t, e) {
      return t * e;
    });
  }, o.prototype.floorDiv = function (t, e) {
    rf([t, e], "floorDiv");
    return this.broadcastedBinaryOp(t, e, "int32", function (t, e) {
      return Math.floor(t / e);
    });
  }, o.prototype.sum = function (t, e) {
    rf(t, "sum"), Cn("sum", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, Tt(t.dtype, "int32")), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = 0, f = 0; f < i; ++f) h += u[l + f];

      s[c] = h;
    }

    return a;
  }, o.prototype.prod = function (t, e) {
    rf(t, "sum");

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, Tt(t.dtype, "int32")), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = 1, f = 0; f < i; ++f) h *= u[l + f];

      s[c] = h;
    }

    return a;
  }, o.prototype.unsortedSegmentSum = function (t, e, n) {
    rf(t, "unsortedSegmentSum");

    for (var r = [], o = t.rank - e.rank, a = 0; a < o; ++a) e = e.expandDims(a + 1);

    for (a = 0; a < n; ++a) {
      var i = On(a, "int32"),
          s = Pc(i, e).asType("float32").mul(t).sum(0);
      r.push(s);
    }

    return mr(r);
  }, o.prototype.argMin = function (t, e) {
    rf(t, "argMin");
    var n = [e];
    Cn("argMin", n, t.rank);

    for (var r = bn(t.shape, n), o = r[0], a = r[1], i = Gn(o, "int32"), s = k(a), u = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {
      for (var h = l * s, f = c[h], d = 0, p = 0; p < s; ++p) {
        var v = c[h + p];
        v < f && (f = v, d = p);
      }

      u[l] = d;
    }

    return i;
  }, o.prototype.argMax = function (t, e) {
    rf(t, "argMax");
    var n = [e];
    Cn("argMax", n, t.rank);

    for (var r = bn(t.shape, n), o = r[0], a = r[1], i = Gn(o, "int32"), s = k(a), u = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {
      for (var h = l * s, f = c[h], d = 0, p = 0; p < s; ++p) {
        var v = c[h + p];
        v > f && (f = v, d = p);
      }

      u[l] = d;
    }

    return i;
  }, o.prototype.cumsum = function (t, e, n, r) {
    if (rf(t, "cumsum"), e !== t.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);

    for (var o = Tt(t.dtype, "int32"), a = Gn(t.shape, o), i = this.readSync(a.dataId), s = this.readSync(t.dataId), u = t.shape[t.rank - 1], c = r ? function (t, e) {
      return t + u - e - 1;
    } : function (t, e) {
      return t + e;
    }, l = 0; l < s.length; l += u) for (var h = 0; h < u; h++) {
      var f = c(l, h);
      if (0 === h) i[f] = n ? 0 : s[f];else {
        var d = c(l, h - 1);
        i[f] = n ? s[d] + i[d] : s[f] + i[d];
      }
    }

    return a;
  }, o.prototype.equal = function (t, e) {
    return rf([t, e], "equal"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t === e ? 1 : 0;
    });
  }, o.prototype.notEqual = function (t, e) {
    return rf([t, e], "notEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t !== e ? 1 : 0;
    });
  }, o.prototype.less = function (t, e) {
    return rf([t, e], "less"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t < e ? 1 : 0;
    });
  }, o.prototype.lessEqual = function (t, e) {
    return rf([t, e], "lessEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t <= e ? 1 : 0;
    });
  }, o.prototype.greater = function (t, e) {
    return rf([t, e], "greater"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t > e ? 1 : 0;
    });
  }, o.prototype.greaterEqual = function (t, e) {
    return rf([t, e], "greaterEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t >= e ? 1 : 0;
    });
  }, o.prototype.logicalNot = function (t) {
    rf(t, "logicalNot");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e[r] ? 0 : 1;

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.logicalAnd = function (t, e) {
    return rf([t, e], "logicalAnd"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t && e;
    });
  }, o.prototype.logicalOr = function (t, e) {
    return rf([t, e], "logicalOr"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t || e;
    });
  }, o.prototype.select = function (t, e, n) {
    rf([t, e, n], "select");

    for (var r = this.readSync(t.dataId), o = this.readSync(e.dataId), a = this.readSync(n.dataId), i = Gn(e.shape, Tt(e.dtype, n.dtype)), s = this.readSync(i.dataId), u = 0, c = 0 === t.rank || t.rank > 1 || 1 === e.rank ? 1 : k(e.shape.slice(1)), l = 0; l < r.length; l++) for (var h = 0; h < c; h++) 1 === r[l] ? s[u++] = o[l] : s[u++] = a[l];

    return i;
  }, o.prototype.where = function (t) {
    rf([t], "where");
    var e = this.readSync(t.dataId);
    return Wa(t.shape, e);
  }, o.prototype.topk = function (t, e, n) {
    return rf(t, "topk"), La(this.readSync(t.dataId), t.shape, t.dtype, e);
  }, o.prototype.min = function (t, e) {
    rf(t, "min"), Cn("min", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = u[l], f = 0; f < i; ++f) {
        var d = u[l + f];
        d < h && (h = d);
      }

      s[c] = h;
    }

    return a;
  }, o.prototype.minimum = function (t, e) {
    return rf([t, e], "minimum"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.min(t, e);
    });
  }, o.prototype.mod = function (t, e) {
    return rf([t, e], "mod"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      var n = t % e;
      return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e;
    });
  }, o.prototype.max = function (t, e) {
    rf(t, "max"), Cn("max", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = u[l], f = 0; f < i; ++f) {
        var d = u[l + f];
        d > h && (h = d);
      }

      s[c] = h;
    }

    return a;
  }, o.prototype.maximum = function (t, e) {
    return rf([t, e], "maximum"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.max(t, e);
    });
  }, o.prototype.all = function (t, e) {
    rf(t, "all"), Cn("all", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = u[l], f = 0; f < i; ++f) {
        var d = u[l + f];
        h = h && d;
      }

      s[c] = h;
    }

    return a;
  }, o.prototype.any = function (t, e) {
    rf(t, "any"), Cn("any", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = u[l], f = 0; f < i; ++f) {
        var d = u[l + f];
        h = h || d;
      }

      s[c] = h;
    }

    return a;
  }, o.prototype.squaredDifference = function (t, e) {
    return rf([t, e], "squaredDifference"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      var n = t - e;
      return n * n;
    });
  }, o.prototype.ceil = function (t) {
    rf(t, "ceil");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.ceil(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.floor = function (t) {
    rf(t, "floor");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.floor(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.sign = function (t) {
    rf(t, "x");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.isNaN = function (t) {
    rf(t, "x");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isNaN(e[r]) && (n[r] = 1);

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.isInf = function (t) {
    rf(t, "x");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Math.abs(e[r]) === 1 / 0 && (n[r] = 1);

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.isFinite = function (t) {
    rf(t, "x");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isFinite(e[r]) && (n[r] = 1);

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.round = function (t) {
    rf(t, "round");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = Math.floor(e[r]);
      e[r] - o < .5 ? n[r] = Math.floor(e[r]) : e[r] - o > .5 ? n[r] = Math.ceil(e[r]) : n[r] = o % 2 == 0 ? o : o + 1;
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.exp = function (t) {
    rf(t, "exp");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.exp(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.expm1 = function (t) {
    rf(t, "expm1");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.expm1(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.log = function (t) {
    rf(t, "log");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = Math.log(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.log1p = function (t) {
    rf(t, "log1p");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = Math.log1p(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.sqrt = function (t) {
    rf(t, "sqrt");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = Math.sqrt(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.rsqrt = function (t) {
    rf(t, "rsqrt");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = 1 / Math.sqrt(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.reciprocal = function (t) {
    rf(t, "reciprocal");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = 1 / e[r];

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.linear = function (t) {
    return t;
  }, o.prototype.relu = function (t) {
    rf(t, "relu");

    for (var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) n[o] = Math.max(0, r[o]);

    return e;
  }, o.prototype.relu6 = function (t) {
    rf(t, "relu");

    for (var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) n[o] = Math.min(Math.max(0, r[o]), 6);

    return e;
  }, o.prototype.prelu = function (t, e) {
    return rf([t, e], "prelu"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return t < 0 ? e * t : t;
    });
  }, o.prototype.elu = function (t) {
    rf(t, "elu");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
      var o = n[r];
      e[r] = o >= 0 ? o : Math.exp(o) - 1;
    }

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.eluDer = function (t, e) {
    rf([t, e], "eluDer");

    for (var n = new Float32Array(e.size), r = this.readSync(e.dataId), o = this.readSync(t.dataId), a = 0; a < r.length; ++a) {
      var i = r[a];
      n[a] = i >= 1 ? o[a] : o[a] * (i + 1);
    }

    return this.makeOutput(n, e.shape, "float32");
  }, o.prototype.selu = function (t) {
    rf(t, "selu");

    for (var e = au, n = iu, r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a) {
      var i = o[a];
      r[a] = i >= 0 ? n * i : e * (Math.exp(i) - 1);
    }

    return this.makeOutput(r, t.shape, "float32");
  }, o.prototype.clip = function (t, e, n) {
    rf(t, "clip");

    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a) {
      var i = o[a];
      r[a] = i > n ? n : i < e ? e : i;
    }

    return this.makeOutput(r, t.shape, "float32");
  }, o.prototype.abs = function (t) {
    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.abs(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.complexAbs = function (t) {
    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r) {
      var o = n[2 * r],
          a = n[2 * r + 1];
      e[r] = Math.hypot(o, a);
    }

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.int = function (t) {
    rf(t, "int");

    for (var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = n[r];

    return this.makeOutput(e, t.shape, "int32");
  }, o.prototype.sigmoid = function (t) {
    rf(t, "sigmoid");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = 1 / (1 + Math.exp(-n[r]));

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.softplus = function (t) {
    rf(t, "softplus");

    for (var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) {
      var a = r[o] > -e,
          i = r[o] < e,
          s = Math.exp(r[o]),
          u = void 0;
      u = i ? s : a ? r[o] : Math.log(1 + s), n[o] = u;
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.sin = function (t) {
    rf(t, "sin");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sin(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.cos = function (t) {
    rf(t, "cos");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cos(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.tan = function (t) {
    rf(t, "tan");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.tan(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.asin = function (t) {
    rf(t, "asin");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asin(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.acos = function (t) {
    rf(t, "acos");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acos(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.atan = function (t) {
    rf(t, "atan");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atan(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.atan2 = function (t, e) {
    return rf([t, e], "atan2"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.atan2(t, e);
    });
  }, o.prototype.sinh = function (t) {
    rf(t, "sinh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sinh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.cosh = function (t) {
    rf(t, "cosh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cosh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.tanh = function (t) {
    rf(t, "tanh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = T(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.asinh = function (t) {
    rf(t, "asinh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asinh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.acosh = function (t) {
    rf(t, "acosh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acosh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.atanh = function (t) {
    rf(t, "atanh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atanh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.erf = function (t) {
    rf(t, "erf");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
      var o = Math.sign(n[r]),
          a = Math.abs(n[r]),
          i = 1 / (1 + .3275911 * a);
      e[r] = o * (1 - ((((1.061405429 * i - 1.453152027) * i + 1.421413741) * i - .284496736) * i + .254829592) * i * Math.exp(-a * a));
    }

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.step = function (t, e) {
    void 0 === e && (e = 0), rf(t, "step");

    for (var n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) {
      var a = r[o];
      isNaN(a) ? n[o] = NaN : n[o] = a > 0 ? 1 : e;
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.fusedConv2d = function (t) {
    var e = t.input,
        n = t.filter,
        r = t.convInfo,
        o = t.bias,
        a = t.activation,
        i = t.preluActivationWeights,
        s = this.conv2d(e, n, r);
    return o && (s = this.add(s, o)), a && (s = of(this, s, a, i)), s;
  }, o.prototype.conv2d = function (t, e, n) {
    rf([t, e], "conv2d");

    for (var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = "channelsLast" === n.dataFormat, l = er(n.outShape, t.dtype), h = t.strides[0], f = c ? t.strides[1] : t.strides[2], d = c ? t.strides[2] : 1, p = c ? 1 : t.strides[1], v = l.strides[0], m = c ? l.strides[1] : l.strides[2], g = c ? l.strides[2] : 1, y = c ? 1 : l.strides[1], x = this.readSync(t.dataId), b = this.readSync(e.dataId), w = l.values, C = 0; C < n.batchSize; ++C) for (var E = C * h, R = C * v, I = 0; I < n.outHeight; ++I) for (var k = R + I * m, S = I * n.strideHeight - u, A = 0; A < r; A++) {
      var T = S + A * a;
      if (!(T < 0 || T >= n.inHeight)) for (var D = A * e.strides[0], N = E + T * f, F = 0; F < n.outWidth; ++F) for (var _ = k + F * g, O = F * n.strideWidth - s, M = 0; M < o; M++) {
        var B = O + M * i;
        if (!(B < 0 || B >= n.inWidth)) for (var P = N + B * d, L = D + M * e.strides[1], W = 0; W < n.inChannels; ++W) {
          for (var U = x[P + W * p], V = 0; V < n.outChannels; ++V) w[_ + V * y] += U * b[L + V];

          L += n.outChannels;
        }
      }
    }

    return l.toTensor();
  }, o.prototype.conv3d = function (t, e, n) {
    for (var r = n.filterDepth, o = n.filterHeight, a = n.filterWidth, i = n.dilationDepth, s = n.dilationHeight, u = n.dilationWidth, c = n.padInfo.front, l = n.padInfo.left, h = n.padInfo.top, f = er(n.outShape, t.dtype), d = this.readSync(t.dataId), p = this.readSync(e.dataId), v = f.values, m = 0; m < n.batchSize; ++m) for (var g = m * t.strides[0], y = m * f.strides[0], x = 0; x < n.outDepth; ++x) for (var b = y + x * f.strides[1], w = x * n.strideDepth - c, C = 0; C < r; C++) {
      var E = w + C * i;
      if (!(E < 0 || E >= n.inDepth)) for (var R = C * e.strides[0], I = g + E * t.strides[1], k = 0; k < n.outHeight; ++k) for (var S = b + k * f.strides[2], A = k * n.strideHeight - h, T = 0; T < o; T++) {
        var D = A + T * s;
        if (!(D < 0 || D >= n.inHeight)) for (var N = R + T * e.strides[1], F = I + D * t.strides[2], _ = 0; _ < n.outWidth; ++_) for (var O = S + _ * n.outChannels, M = _ * n.strideWidth - l, B = 0; B < a; B++) {
          var P = M + B * u;
          if (!(P < 0 || P >= n.inWidth)) for (var L = N + B * e.strides[2], W = F + P * n.inChannels, U = L, V = 0; V < n.inChannels; ++V) {
            for (var z = d[W + V], G = 0; G < n.outChannels; ++G) v[O + G] += z * p[U + G];

            U += n.outChannels;
          }
        }
      }
    }

    return f.toTensor();
  }, o.prototype.conv2dDerInput = function (t, e, n) {
    rf([t, e], "conv2dDerInput");

    for (var r = er(n.inShape, "float32"), o = r.values, a = this.readSync(t.dataId), i = this.readSync(e.dataId), s = e.strides, u = s[0], c = s[1], l = s[2], h = n.batchSize, f = n.filterHeight, d = n.filterWidth, p = n.inChannels, v = n.inHeight, m = n.inWidth, g = n.outChannels, y = n.outHeight, x = n.outWidth, b = n.strideHeight, w = n.strideWidth, C = n.dataFormat, E = f - 1 - n.padInfo.top, R = d - 1 - n.padInfo.left, I = "channelsLast" === C, k = r.strides[0], S = I ? r.strides[1] : r.strides[2], A = I ? r.strides[2] : 1, T = I ? 1 : r.strides[1], D = t.strides[0], N = I ? t.strides[1] : t.strides[2], F = I ? t.strides[2] : 1, _ = I ? 1 : t.strides[1], O = 0; O < h; ++O) for (var M = 0; M < p; ++M) for (var B = 0; B < v; ++B) for (var P = B - E, L = Math.max(0, Math.ceil(P / b)), W = Math.min(y, (f + P) / b), U = 0; U < m; ++U) {
      for (var V = U - R, z = Math.max(0, Math.ceil(V / w)), G = Math.min(x, (d + V) / w), H = 0, q = L; q < W; ++q) for (var K = q * b - P, j = z; j < G; ++j) for (var X = D * O + N * q + F * j, Y = u * (f - 1 - K) + c * (d - 1 - (j * w - V)) + l * M, $ = 0; $ < g; ++$) {
        H += a[X + _ * $] * i[Y + $];
      }

      o[k * O + S * B + A * U + T * M] = H;
    }

    return r.toTensor();
  }, o.prototype.conv3dDerInput = function (t, e, n) {
    for (var r = er(n.inShape, "float32"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], c = a[3], l = this.readSync(t.dataId), h = t.strides, f = h[0], d = h[1], p = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], x = g[1], b = g[2], w = g[3], C = n.batchSize, E = n.filterDepth, R = n.filterHeight, I = n.filterWidth, k = n.inChannels, S = n.inDepth, A = n.inHeight, T = n.inWidth, D = n.outChannels, N = n.outDepth, F = n.outHeight, _ = n.outWidth, O = n.strideDepth, M = n.strideHeight, B = n.strideWidth, P = E - 1 - n.padInfo.front, L = R - 1 - n.padInfo.top, W = I - 1 - n.padInfo.left, U = 0; U < C; ++U) for (var V = 0; V < k; ++V) for (var z = 0; z < S; ++z) for (var G = z - P, H = Math.max(0, Math.ceil(G / O)), q = Math.min(N, (E + G) / O), K = 0; K < A; ++K) for (var j = K - L, X = Math.max(0, Math.ceil(j / M)), Y = Math.min(F, (R + j) / M), $ = 0; $ < T; ++$) {
      for (var Q = $ - W, J = Math.max(0, Math.ceil(Q / B)), Z = Math.min(_, (I + Q) / B), tt = 0, et = H; et < q; ++et) for (var nt = et * O - G, rt = X; rt < Y; ++rt) for (var ot = rt * M - j, at = J; at < Z; ++at) for (var it = f * U + d * et + p * rt + v * at, st = y * (E - 1 - nt) + x * (R - 1 - ot) + b * (I - 1 - (at * B - Q)) + w * V, ut = 0; ut < D; ++ut) {
        tt += l[it + ut] * m[st + ut];
      }

      o[i * U + s * z + u * K + c * $ + V] = tt;
    }

    return r.toTensor();
  }, o.prototype.conv2dDerFilter = function (t, e, n) {
    rf([t, e], "conv2dDerFilter");

    for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = "channelsLast" === n.dataFormat, u = er(n.filterShape, "float32"), c = n.padInfo.left, l = n.padInfo.top, h = this.bufferSync(t), f = this.bufferSync(e), d = 0; d < a; ++d) for (var p = Math.max(0, Math.ceil((l - d) / r)), v = Math.min(n.outHeight, (n.inHeight + l - d) / r), m = 0; m < i; ++m) for (var g = Math.max(0, Math.ceil((c - m) / o)), y = Math.min(n.outWidth, (n.inWidth + c - m) / o), x = 0; x < n.inChannels; ++x) for (var b = 0; b < n.outChannels; ++b) {
      for (var w = 0, C = 0; C < n.batchSize; ++C) for (var E = p; E < v; ++E) for (var R = d + E * r - l, I = g; I < y; ++I) {
        var k = m + I * o - c;
        w += s ? h.get(C, R, k, x) * f.get(C, E, I, b) : h.get(C, x, R, k) * f.get(C, b, E, I);
      }

      u.set(w, d, m, x, b);
    }

    return u.toTensor();
  }, o.prototype.conv3dDerFilter = function (t, e, n) {
    for (var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = er(n.filterShape, "float32"), l = c.values, h = c.strides, f = h[0], d = h[1], p = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], x = g[1], b = g[2], w = g[3], C = this.readSync(t.dataId), E = t.strides, R = E[0], I = E[1], k = E[2], S = E[3], A = n.padInfo.front, T = n.padInfo.left, D = n.padInfo.top, N = 0; N < i; ++N) for (var F = Math.max(0, Math.ceil((A - N) / r)), _ = Math.min(n.outDepth, (n.inDepth + A - N) / r), O = N * f, M = 0; M < s; ++M) for (var B = Math.max(0, Math.ceil((D - M) / o)), P = Math.min(n.outHeight, (n.inHeight + D - M) / o), L = M * d + O, W = 0; W < u; ++W) for (var U = Math.max(0, Math.ceil((T - W) / a)), V = Math.min(n.outWidth, (n.inWidth + T - W) / a), z = W * p + L, G = 0; G < n.inChannels; ++G) for (var H = G * v + z, q = 0; q < n.outChannels; ++q) {
      for (var K = 0, j = 0; j < n.batchSize; ++j) for (var X = j * R, Y = j * y, $ = F; $ < _; ++$) for (var Q = (N + $ * r - A) * I + X, J = $ * x + Y, Z = B; Z < P; ++Z) for (var tt = (M + Z * o - D) * k + Q, et = Z * b + J, nt = U; nt < V; ++nt) {
        var rt = nt * w + et;
        K += C[(W + nt * a - T) * S + tt + G] * m[rt + q];
      }

      l[H + q] = K;
    }

    return c.toTensor();
  }, o.prototype.fusedDepthwiseConv2D = function (t) {
    var e = t.input,
        n = t.filter,
        r = t.convInfo,
        o = t.bias,
        a = t.activation,
        i = t.preluActivationWeights,
        s = this.depthwiseConv2D(e, n, r);
    return o && (s = this.add(s, o)), a && (s = of(this, s, a, i)), s;
  }, o.prototype.depthwiseConv2D = function (t, e, n) {
    rf([t, e], "depthwiseConv2D");

    for (var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = n.outChannels / n.inChannels, l = er(n.outShape, t.dtype), h = this.readSync(t.dataId), f = this.readSync(e.dataId), d = l.values, p = 0; p < n.batchSize; ++p) for (var v = p * t.strides[0], m = p * l.strides[0], g = 0; g < n.outHeight; ++g) for (var y = m + g * l.strides[1], x = g * n.strideHeight - s, b = 0; b < r; ++b) {
      var w = x + b * a;
      if (!(w < 0 || w >= n.inHeight)) for (var C = b * e.strides[0], E = v + w * t.strides[1], R = 0; R < n.outWidth; ++R) for (var I = y + R * l.strides[2], k = R * n.strideWidth - u, S = 0; S < o; ++S) {
        var A = k + S * i;
        if (!(A < 0 || A >= n.inWidth)) for (var T = C + S * e.strides[1], D = E + A * n.inChannels, N = I, F = T, _ = 0; _ < n.inChannels; ++_) {
          for (var O = h[D + _], M = 0; M < c; ++M) d[N + M] += O * f[F + M];

          N += c, F += c;
        }
      }
    }

    return l.toTensor();
  }, o.prototype.depthwiseConv2DDerInput = function (t, e, n) {
    rf([t, e], "depthwiseConv2DDerInput");

    for (var r = er(n.inShape, "float32"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], c = this.readSync(t.dataId), l = t.strides, h = l[0], f = l[1], d = l[2], p = this.readSync(e.dataId), v = e.strides, m = v[0], g = v[1], y = v[2], x = n.batchSize, b = n.filterHeight, w = n.filterWidth, C = n.inChannels, E = n.inHeight, R = n.inWidth, I = n.outChannels, k = n.outHeight, S = n.outWidth, A = n.strideHeight, T = n.strideWidth, D = b - 1 - n.padInfo.top, N = w - 1 - n.padInfo.left, F = I / C, _ = 0; _ < x; ++_) for (var O = 0; O < C; ++O) for (var M = 0; M < E; ++M) for (var B = M - D, P = Math.max(0, Math.ceil(B / A)), L = Math.min(k, (b + B) / A), W = 0; W < R; ++W) {
      for (var U = W - N, V = Math.max(0, Math.ceil(U / T)), z = Math.min(S, (w + U) / T), G = 0, H = P; H < L; ++H) for (var q = H * A - B, K = V; K < z; ++K) for (var j = h * _ + f * H + d * K, X = m * (b - 1 - q) + g * (w - 1 - (K * T - U)) + y * O, Y = 0; Y < F; ++Y) {
        G += c[j + (O * F + Y)] * p[X + Y];
      }

      o[i * _ + s * M + u * W + O] = G;
    }

    return r.toTensor();
  }, o.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
    rf([t, e], "depthwiseConv2DDerFilter");

    for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = er(n.filterShape, "float32"), u = n.padInfo.left, c = n.padInfo.top, l = n.outChannels / n.inChannels, h = this.bufferSync(t), f = this.bufferSync(e), d = 0; d < a; ++d) for (var p = Math.max(0, Math.ceil((c - d) / r)), v = Math.min(n.outHeight, (n.inHeight + c - d) / r), m = 0; m < i; ++m) for (var g = Math.max(0, Math.ceil((u - m) / o)), y = Math.min(n.outWidth, (n.inWidth + u - m) / o), x = 0; x < n.outChannels; ++x) {
      for (var b = Math.trunc(x / l), w = x % l, C = 0, E = 0; E < n.batchSize; ++E) for (var R = p; R < v; ++R) for (var I = d + R * r - c, k = g; k < y; ++k) {
        var S = m + k * o - u;
        C += h.get(E, I, S, b) * f.get(E, R, k, x);
      }

      s.set(C, d, m, b, w);
    }

    return s.toTensor();
  }, o.prototype.tile = function (t, e) {
    return rf(t, "tile"), Pa(this.bufferSync(t), e);
  }, o.prototype.pad = function (t, e, n) {
    rf(t, "pad");
    var r = e.map(function (e, n) {
      return e[0] + t.shape[n] + e[1];
    }),
        o = e.map(function (t) {
      return t[0];
    }),
        a = this.bufferSync(t),
        i = er(r, t.dtype);
    0 !== n && i.values.fill(n);

    for (var s = 0; s < t.size; s++) {
      var u = a.indexToLoc(s),
          c = u.map(function (t, e) {
        return t + o[e];
      });
      i.set.apply(i, [a.get.apply(a, u)].concat(c));
    }

    return i.toTensor();
  }, o.prototype.transpose = function (t, e) {
    rf(t, "transpose");

    for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[e[r]];

    var o = this.readSync(t.dataId),
        a = er(n, t.dtype),
        i = this.bufferSync(t);

    for (r = 0; r < t.size; ++r) {
      for (var s = i.indexToLoc(r), u = new Array(s.length), c = 0; c < u.length; c++) u[c] = s[e[c]];

      var l = a.locToIndex(u);
      a.values[l] = o[r];
    }

    return a.toTensor();
  }, o.prototype.gather = function (t, e, n) {
    rf([t, e], "gather");
    var r = t.shape.slice(),
        o = this.readSync(e.dataId);
    r[n] = o.length;

    for (var a = er(r, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; ++s) {
      var u = a.indexToLoc(s),
          c = u.slice();
      c[n] = o[u[n]];
      var l = i.locToIndex(c);
      a.values[s] = i.values[l];
    }

    return a.toTensor();
  }, o.prototype.batchToSpaceND = function (t, e, n) {
    rf([t], "batchToSpaceND");
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = xr(t.shape, e, r),
        a = br(o.length, e.length),
        i = wr(t.shape, e, r),
        s = Cr(n, e.length),
        u = Er(i, n, e.length);
    return t.reshape(o).transpose(a).reshape(i).slice(s, u);
  }, o.prototype.spaceToBatchND = function (t, e, n) {
    rf([t], "spaceToBatchND");
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = [[0, 0]];
    o.push.apply(o, n);

    for (var a = 1 + e.length; a < t.shape.length; ++a) o.push([0, 0]);

    var i = t.pad(o),
        s = xr(i.shape, e, r, !1),
        u = br(s.length, e.length, !1),
        c = wr(i.shape, e, r, !1);
    return i.reshape(s).transpose(u).reshape(c);
  }, o.prototype.pool = function (t, e, n) {
    rf(t, "pool");

    for (var r = e.strideHeight, o = e.strideWidth, a = e.dilationHeight, i = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f = this.readSync(t.dataId), d = er(e.outShape, t.dtype), p = d.values, v = e.outShape[1] * e.outShape[2] * e.outShape[3], m = e.outShape[2] * e.outShape[3], g = e.outShape[3], y = 0; y < e.batchSize; ++y) for (var x = y * v, b = y * t.strides[0], w = 0; w < e.inChannels; ++w) for (var C = 0; C < e.outHeight; ++C) for (var E = C * r - c, R = Math.max(0, E), I = Math.min(e.inHeight, s + E), k = x + C * m, S = 0; S < e.outWidth; ++S) {
      for (var A = S * o - l, T = Math.max(0, A), D = Math.min(e.inWidth, u + A), N = h, F = 0, _ = 0, O = R; O < I; O += a) {
        for (var M = b + O * t.strides[1], B = T; B < D; B += i) {
          var P = f[M + B * t.strides[2] + w];
          "max" === n && P > N ? N = P : "avg" === n && (F += P, _++);
        }

        if (isNaN(N)) break;
      }

      p[k + S * g + w] = "avg" === n ? F / _ : N;
    }

    return d.toTensor();
  }, o.prototype.maxPool = function (t, e) {
    return this.pool(t, e, "max");
  }, o.prototype.maxPoolPositions = function (t, e) {
    for (var n = er(e.outShape, "int32"), r = e.strideHeight, o = e.strideWidth, a = e.dilationHeight, i = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = this.bufferSync(t), f = 0; f < e.batchSize; ++f) for (var d = 0; d < e.inChannels; ++d) for (var p = 0; p < e.outHeight; ++p) {
      for (var v = p * r - c, m = v; m < 0;) m += a;

      for (var g = Math.min(e.inHeight, s + v), y = 0; y < e.outWidth; ++y) {
        for (var x = y * o - l, b = x; b < 0;) b += i;

        for (var w = Math.min(e.inWidth, u + x), C = Number.NEGATIVE_INFINITY, E = -1, R = m; R < g; R += a) for (var I = R - v, k = b; k < w; k += i) {
          var S = k - x,
              A = h.get(f, R, k, d);
          A > C && (C = A, E = I * u + S);
        }

        n.set(E, f, p, y, d);
      }
    }

    return n.toTensor();
  }, o.prototype.maxPoolBackprop = function (t, e, n, r) {
    rf([e, n], "maxPoolBackprop");

    for (var o = this.maxPoolPositions(e, r), a = r.strideHeight, i = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, c = r.effectiveFilterHeight, l = r.effectiveFilterWidth, h = l - 1 - r.padInfo.left, f = c - 1 - r.padInfo.top, d = er(e.shape, "float32"), p = this.bufferSync(o), v = this.bufferSync(t), m = 0; m < r.batchSize; ++m) for (var g = 0; g < r.inChannels; ++g) for (var y = 0; y < r.inHeight; ++y) for (var x = 0; x < r.inWidth; ++x) {
      for (var b = y - f, w = x - h, C = 0, E = 0; E < c; E += s) {
        var R = (b + E) / a;
        if (!(R < 0 || R >= r.outHeight || Math.floor(R) !== R)) for (var I = 0; I < l; I += u) {
          var k = (w + I) / i;

          if (!(k < 0 || k >= r.outWidth || Math.floor(k) !== k)) {
            var S = c * l - 1 - p.get(m, R, k, g) === E * l + I ? 1 : 0;
            if (0 !== S) C += v.get(m, R, k, g) * S;
          }
        }
      }

      d.set(C, m, y, x, g);
    }

    return d.toTensor();
  }, o.prototype.avgPoolBackprop = function (t, e, n) {
    rf([t, e], "avgPoolBackprop");

    for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = n.dilationHeight, u = n.dilationWidth, c = n.effectiveFilterHeight, l = n.effectiveFilterWidth, h = l - 1 - n.padInfo.left, f = c - 1 - n.padInfo.top, d = er(e.shape, "float32"), p = 1 / (a * i), v = this.bufferSync(t), m = 0; m < n.batchSize; ++m) for (var g = 0; g < n.inChannels; ++g) for (var y = 0; y < n.inHeight; ++y) for (var x = 0; x < n.inWidth; ++x) {
      for (var b = y - f, w = x - h, C = 0, E = 0; E < c; E += s) {
        var R = (b + E) / r;
        if (!(R < 0 || R >= n.outHeight || Math.floor(R) !== R)) for (var I = 0; I < l; I += u) {
          var k = (w + I) / o;
          if (!(k < 0 || k >= n.outWidth || Math.floor(k) !== k)) C += v.get(m, R, k, g);
        }
      }

      d.set(C * p, m, y, x, g);
    }

    return d.toTensor();
  }, o.prototype.pool3d = function (t, e, n) {
    rf(t, "pool3d");

    for (var r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, d = e.padInfo.top, p = e.padInfo.left, v = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = this.readSync(t.dataId), g = er(e.outShape, t.dtype), y = g.values, x = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4], b = e.outShape[2] * e.outShape[3] * e.outShape[4], w = e.outShape[3] * e.outShape[4], C = e.outShape[4], E = 0; E < e.batchSize; ++E) for (var R = E * x, I = E * t.strides[0], k = 0; k < e.inChannels; ++k) for (var S = 0; S < e.outDepth; ++S) {
      for (var A = S * r - f, T = A; T < 0;) T += i;

      for (var D = Math.min(e.inDepth, c + A), N = R + S * b, F = 0; F < e.outHeight; ++F) {
        for (var _ = F * o - d, O = _; O < 0;) O += s;

        for (var M = Math.min(e.inHeight, l + _), B = N + F * w, P = 0; P < e.outWidth; ++P) {
          for (var L = P * a - p, W = L; W < 0;) W += u;

          for (var U = Math.min(e.inWidth, h + L), V = B + P * C, z = v, G = 0, H = 0, q = T; q < D; q += i) {
            for (var K = I + q * t.strides[1], j = O; j < M; j += s) {
              for (var X = K + j * t.strides[2], Y = W; Y < U; Y += u) {
                var $ = m[X + Y * t.strides[3] + k];
                if ("max" === n && $ > z ? z = $ : "avg" === n && (G += $, H++), isNaN(z)) break;
              }

              if (isNaN(z)) break;
            }

            if (isNaN(z)) break;
          }

          y[V + k] = "avg" === n ? G / H : z;
        }
      }
    }

    return g.toTensor();
  }, o.prototype.avgPool3d = function (t, e) {
    return rf(t, "avgPool3d"), this.pool3d(t, e, "avg").toFloat();
  }, o.prototype.avgPool3dBackprop = function (t, e, n) {
    rf([t, e], "avgPool3dBackprop");

    for (var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = n.dilationDepth, l = n.dilationHeight, h = n.dilationWidth, f = n.effectiveFilterDepth, d = n.effectiveFilterHeight, p = n.effectiveFilterWidth, v = f - 1 - n.padInfo.front, m = p - 1 - n.padInfo.left, g = d - 1 - n.padInfo.top, y = er(e.shape, "float32"), x = 1 / (i * s * u), b = this.bufferSync(t), w = 0; w < n.batchSize; ++w) for (var C = 0; C < n.inChannels; ++C) for (var E = 0; E < n.inDepth; ++E) for (var R = 0; R < n.inHeight; ++R) for (var I = 0; I < n.inWidth; ++I) {
      for (var k = E - v, S = R - g, A = I - m, T = 0, D = 0; D < f; D += c) {
        var N = (k + D) / r;
        if (!(N < 0 || N >= n.outDepth || Math.floor(N) !== N)) for (var F = 0; F < d; F += l) {
          var _ = (S + F) / o;

          if (!(_ < 0 || _ >= n.outHeight || Math.floor(_) !== _)) for (var O = 0; O < p; O += h) {
            var M = (A + O) / a;
            if (!(M < 0 || M >= n.outWidth || Math.floor(M) !== M)) T += b.get(w, N, _, M, C);
          }
        }
      }

      y.set(T * x, w, E, R, I, C);
    }

    return y.toTensor();
  }, o.prototype.maxPool3d = function (t, e) {
    return rf(t, "maxPool3d"), this.pool3d(t, e, "max").toFloat();
  }, o.prototype.maxPool3dPositions = function (t, e) {
    for (var n = er(e.outShape, "int32"), r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, d = e.padInfo.top, p = e.padInfo.left, v = this.bufferSync(t), m = 0; m < e.batchSize; ++m) for (var g = 0; g < e.inChannels; ++g) for (var y = 0; y < e.outDepth; ++y) {
      for (var x = y * r - f, b = x; b < 0;) b += i;

      for (var w = Math.min(e.inDepth, c + x), C = 0; C < e.outHeight; ++C) {
        for (var E = C * o - d, R = E; R < 0;) R += s;

        for (var I = Math.min(e.inHeight, l + E), k = 0; k < e.outWidth; ++k) {
          for (var S = k * a - p, A = S; A < 0;) A += u;

          for (var T = Math.min(e.inWidth, h + S), D = Number.NEGATIVE_INFINITY, N = -1, F = b; F < w; F += i) for (var _ = F - x, O = R; O < I; O += s) for (var M = O - E, B = A; B < T; B += u) {
            var P = B - S,
                L = v.get(m, F, O, B, g);
            L >= D && (D = L, N = _ * l * h + M * l + P);
          }

          n.set(N, m, y, C, k, g);
        }
      }
    }

    return n.toTensor();
  }, o.prototype.maxPool3dBackprop = function (t, e, n, r) {
    rf([e, n], "maxPool3dBackprop");

    for (var o = this.maxPool3dPositions(e, r), a = r.strideDepth, i = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterDepth, f = r.effectiveFilterHeight, d = r.effectiveFilterWidth, p = h - 1 - r.padInfo.front, v = d - 1 - r.padInfo.left, m = f - 1 - r.padInfo.top, g = er(e.shape, "float32"), y = this.bufferSync(o), x = this.bufferSync(t), b = 0; b < r.batchSize; ++b) for (var w = 0; w < r.inChannels; ++w) for (var C = 0; C < r.inDepth; ++C) for (var E = 0; E < r.inHeight; ++E) for (var R = 0; R < r.inWidth; ++R) {
      for (var I = C - p, k = E - m, S = R - v, A = 0, T = 0; T < h; T += u) {
        var D = (I + T) / a;
        if (!(D < 0 || D >= r.outDepth || Math.floor(D) !== D)) for (var N = 0; N < f; N += c) {
          var F = (k + N) / i;
          if (!(F < 0 || F >= r.outHeight || Math.floor(F) !== F)) for (var _ = 0; _ < d; _ += l) {
            var O = (S + _) / s;

            if (!(O < 0 || O >= r.outWidth || Math.floor(O) !== O)) {
              var M = h * f * d - 1 - y.get(b, D, F, O, w) === T * f * d + N * d + _ ? 1 : 0;
              if (0 !== M) A += x.get(b, D, F, O, w) * M;
            }
          }
        }
      }

      g.set(A, b, C, E, R, w);
    }

    return g.toTensor();
  }, o.prototype.cast = function (t, e) {
    return ba(t, e, this);
  }, o.prototype.reshape = function (t, e) {
    return wa(t, e);
  }, o.prototype.avgPool = function (t, e) {
    return rf(t, "avgPool"), this.pool(t, e, "avg").toFloat();
  }, o.prototype.resizeBilinear = function (t, e, n, r) {
    rf(t, "resizeBilinear");

    for (var o = t.shape, a = o[0], i = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(k([a, e, n, u])), h = [r && e > 1 ? i - 1 : i, r && n > 1 ? s - 1 : s], f = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], d = 0, p = h[0] / f[0], v = h[1] / f[1], m = 0; m < a; m++) for (var g = 0; g < e; g++) for (var y = p * g, x = Math.floor(y), b = y - x, w = Math.min(i - 1, Math.ceil(y)), C = m * t.strides[0] + x * t.strides[1], E = m * t.strides[0] + w * t.strides[1], R = 0; R < n; R++) for (var I = v * R, S = Math.floor(I), A = I - S, T = Math.min(s - 1, Math.ceil(I)), D = C + S * t.strides[2], N = E + S * t.strides[2], F = C + T * t.strides[2], _ = E + T * t.strides[2], O = 0; O < u; O++) {
      var M = c[D + O],
          B = c[N + O],
          P = M + (c[F + O] - M) * A,
          L = P + (B + (c[_ + O] - B) * A - P) * b;
      l[d++] = L;
    }

    return Fn(l, [a, e, n, u]);
  }, o.prototype.resizeBilinearBackprop = function (t, e, n) {
    rf([t, e], "resizeBilinearBackprop");

    for (var r = e.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * a * i * s), f = [n && c > 1 ? a - 1 : a, n && l > 1 ? i - 1 : i], d = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], p = f[0] / d[0], v = f[1] / d[1], m = this.readSync(t.dataId), g = 0, y = 0; y < o; y++) for (var x = y * e.strides[0], b = 0; b < c; b++) for (var w = b * p, C = Math.floor(w), E = Math.min(Math.ceil(w), a - 1), R = x + C * e.strides[1], I = x + E * e.strides[1], k = w - C, S = 1 - k, A = 0; A < l; A++) for (var T = A * v, D = Math.floor(T), N = Math.min(Math.ceil(T), i - 1), F = T - D, _ = 1 - F, O = R + D * e.strides[2], M = R + N * e.strides[2], B = I + D * e.strides[2], P = I + N * e.strides[2], L = S * _, W = S * F, U = k * _, V = k * F, z = 0; z < s; z++) {
      var G = m[g++];
      h[O + z] += G * L, h[M + z] += G * W, h[B + z] += G * U, h[P + z] += G * V;
    }

    return Ln(h, [o, i, a, s], e.dtype);
  }, o.prototype.resizeNearestNeighbor = function (t, e, n, r) {
    rf(t, "resizeNearestNeighbor");

    for (var o = t.shape, a = o[0], i = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(a * e * n * u), h = [r && e > 1 ? i - 1 : i, r && n > 1 ? s - 1 : s], f = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], d = h[0] / f[0], p = h[1] / f[1], v = 0, m = 0; m < a; m++) for (var g = m * t.strides[0], y = 0; y < e; y++) for (var x = d * y, b = g + Math.min(i - 1, r ? Math.round(x) : Math.floor(x)) * t.strides[1], w = 0; w < n; w++) for (var C = p * w, E = b + Math.min(s - 1, r ? Math.round(C) : Math.floor(C)) * t.strides[2], R = 0; R < u; R++) {
      var I = c[E + R];
      l[v++] = I;
    }

    return Fn(l, [a, e, n, u], t.dtype);
  }, o.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
    rf([t, e], "resizeNearestNeighborBackprop");

    for (var r = e.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * a * i * s), f = this.readSync(t.dataId), d = [n && c > 1 ? a - 1 : a, n && l > 1 ? i - 1 : i], p = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], v = d[0] / p[0], m = d[1] / p[1], g = 1 / v, y = 1 / m, x = 2 * Math.ceil(g) + 2, b = 2 * Math.ceil(y) + 2, w = 0; w < o; w++) for (var C = w * e.strides[0], E = 0; E < a; E++) for (var R = C + E * e.strides[1], I = Math.floor(E * g), k = Math.floor(I - x / 2), S = 0; S < i; S++) for (var A = R + S * e.strides[2], T = Math.floor(S * y), D = Math.floor(T - b / 2), N = 0; N < s; N++) {
      for (var F = 0, _ = 0; _ < x; _++) {
        var O = _ + k;

        if (!(O < 0 || O >= c)) {
          var M = C + O * t.strides[1],
              B = O * v;
          if (E === Math.min(a - 1, n ? Math.round(B) : Math.floor(B))) for (var P = 0; P < b; P++) {
            var L = P + D;

            if (!(L < 0 || L >= l)) {
              var W = M + L * t.strides[2],
                  U = L * m;
              S === Math.min(i - 1, n ? Math.round(U) : Math.floor(U)) && (F += f[W + N]);
            }
          }
        }
      }

      h[A + N] = F;
    }

    return Ln(h, e.shape, e.dtype);
  }, o.prototype.batchNormalization = function (t, e, n, r, o, a) {
    rf([t, e, n, o, a], "batchNorm");

    for (var i = this.readSync(t.dataId), s = this.readSync(e.dataId), u = this.readSync(n.dataId), c = o ? this.readSync(o.dataId) : new Float32Array([1]), l = a ? this.readSync(a.dataId) : new Float32Array([0]), h = new Float32Array(i.length), f = l.length, d = c.length, p = u.length, v = s.length, m = 0, g = 0, y = 0, x = 0, b = 0; b < i.length; ++b) h[b] = l[m++] + (i[b] - s[g++]) * c[y++] / Math.sqrt(u[x++] + r), m >= f && (m = 0), g >= v && (g = 0), y >= d && (y = 0), x >= p && (x = 0);

    return Ln(h, t.shape);
  }, o.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
    rf(t, "localResponseNormalization4D");
    var a = t.shape[3],
        i = a - 1,
        s = this.readSync(t.dataId),
        u = t.size,
        c = new Float32Array(u);

    function l(t) {
      for (var n = t % a, r = t - n + Math.max(0, n - e), o = t - n + Math.min(n + e, i), u = 0; r <= o; r++) {
        var c = s[r];
        u += c * c;
      }

      return u;
    }

    for (var h = 0; h < u; h++) {
      var f = l(h),
          d = s[h] * Math.pow(n + r * f, -o);
      c[h] = d;
    }

    return Ln(c, t.shape);
  }, o.prototype.LRNGrad = function (t, e, n, r, o, a, i) {
    rf(t, "LRNGrad");

    for (var s = t.shape[3], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = this.readSync(n.dataId), h = new Float32Array(t.size), f = t.size, d = 0; d < f; d++) {
      for (var p = d % s, v = d - p + Math.max(0, p - r), m = d - p + Math.min(s, p + r + 1), g = 0, y = v; y < m; y++) g += Math.pow(c[y], 2);

      g = a * g + o;

      for (y = v; y < m; y++) {
        var x = -2 * a * i * c[y] * l[d] / g;
        d === y && (x += Math.pow(g, -i)), x *= u[d], h[y] += x;
      }
    }

    return Ln(h, t.shape);
  }, o.prototype.multinomial = function (t, e, n, r) {
    rf(t, "multinomial");

    for (var o = e ? t : ra(t), a = o.shape[0], i = o.shape[1], s = Gn([a, n], "int32"), u = this.readSync(s.dataId), c = this.readSync(o.dataId), l = 0; l < a; ++l) {
      var h = l * i,
          f = new Float32Array(i - 1);
      f[0] = c[h];

      for (var d = 1; d < f.length; ++d) f[d] = f[d - 1] + c[h + d];

      for (var p = ju(r.toString()), v = l * n, m = 0; m < n; ++m) {
        var g = p();
        u[v + m] = f.length;

        for (var y = 0; y < f.length; y++) if (g < f[y]) {
          u[v + m] = y;
          break;
        }
      }
    }

    return s;
  }, o.prototype.oneHot = function (t, e, n, r) {
    rf(t, "oneHot");
    var o = new Float32Array(t.size * e);
    o.fill(r);

    for (var a = this.readSync(t.dataId), i = 0; i < t.size; ++i) a[i] >= 0 && a[i] < e && (o[i * e + a[i]] = n);

    return Bn(o, [t.size, e], "int32");
  }, o.prototype.nonMaxSuppression = function (t, e, n, r, o) {
    return rf(t, "nonMaxSuppression"), Da(this.readSync(t.dataId), this.readSync(e.dataId), n, r, o);
  }, o.prototype.fft = function (t) {
    return this.fftBatch(t, !1);
  }, o.prototype.ifft = function (t) {
    return this.fftBatch(t, !0);
  }, o.prototype.fftBatch = function (t, e) {
    for (var n = t.shape[0], r = t.shape[1], o = er(t.shape, "float32"), a = er(t.shape, "float32"), i = Dn(t).as2D(n, r), s = Nn(t).as2D(n, r), u = 0; u < n; u++) for (var c = i.slice([u, 0], [1, r]), l = s.slice([u, 0], [1, r]), h = Tn(c, l), f = this.readSync(this.fftImpl(h, e).dataId), d = 0; d < r; d++) {
      var p = Ia(f, d);
      o.values[u * r + d] = p.real, a.values[u * r + d] = p.imag;
    }

    return Tn(o.toTensor(), a.toTensor()).as2D(n, r);
  }, o.prototype.fftImpl = function (t, e) {
    var n = t.as1D(),
        r = n.size;

    if (this.isExponentOf2(r)) {
      var o = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);
      return e && (o = Tn(Dn(o).div(On(r)), Nn(o).div(On(r)))), o;
    }

    var a = this.readSync(t.dataId),
        i = function (t) {
      for (var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2) e[r / 2] = t[r], n[r / 2] = t[r + 1];

      return {
        real: e,
        imag: n
      };
    }(this.fourierTransformByMatmul(a, r, e));

    return Tn(i.real, i.imag).as2D(t.shape[0], t.shape[1]);
  }, o.prototype.isExponentOf2 = function (t) {
    return 0 == (t & t - 1);
  }, o.prototype.fftRadix2 = function (t, e, n) {
    if (1 === e) return t;

    var r = this.readSync(t.dataId),
        o = e / 2,
        a = function (t) {
      for (var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 0; o < t.length; o += 4) n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];

      return {
        real: n,
        imag: r
      };
    }(r),
        i = Tn(a.real, a.imag).as1D(),
        s = function (t) {
      for (var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 2; o < t.length; o += 4) n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];

      return {
        real: n,
        imag: r
      };
    }(r),
        u = Tn(s.real, s.imag).as1D();

    i = this.fftRadix2(i, o, n), u = this.fftRadix2(u, o, n);

    var c = function (t, e) {
      for (var n = new Float32Array(t / 2), r = new Float32Array(t / 2), o = 0; o < Math.ceil(t / 2); o++) {
        var a = (e ? 2 : -2) * Math.PI * (o / t);
        n[o] = Math.cos(a), r[o] = Math.sin(a);
      }

      return {
        real: n,
        imag: r
      };
    }(e, n),
        l = Tn(c.real, c.imag).mul(u),
        h = i.add(l),
        f = i.sub(l),
        d = Dn(h).concat(Dn(f)),
        p = Nn(h).concat(Nn(f));

    return Tn(d, p).as1D();
  }, o.prototype.fourierTransformByMatmul = function (t, e, n) {
    for (var r = new Float32Array(2 * e), o = 0; o < e; o++) {
      for (var a = 0, i = 0, s = 0; s < e; s++) {
        var u = Sa(o * s, e, n),
            c = Ia(t, s);
        a += c.real * u.real - c.imag * u.imag, i += c.real * u.imag + c.imag * u.real;
      }

      n && (a /= e, i /= e), ka(r, a, i, o);
    }

    return r;
  }, o.prototype.depthToSpace = function (t, e, n) {
    C("NHWC" === n, function () {
      return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n;
    }), C(e > 1, function () {
      return "blockSize should be > 1 for depthToSpace, but was: " + e;
    });

    for (var r = t.shape[0], o = t.shape[1], a = t.shape[2], i = t.shape[3], s = o * e, u = a * e, c = i / (e * e), l = this.readSync(t.dataId), h = new Float32Array(r * s * u * c), f = 0, d = 0; d < r; ++d) for (var p = 0; p < s; ++p) for (var v = Math.floor(p / e), m = p % e, g = 0; g < u; ++g) for (var y = Math.floor(g / e), x = (m * e + g % e) * c, b = 0; b < c; ++b) {
      var w = b + x + i * (y + a * (v + o * d));
      h[f++] = l[w];
    }

    return Ln(h, [r, s, u, c]);
  }, o.prototype.broadcastedBinaryOp = function (t, e, n, r) {
    var o = Fr(t.shape, e.shape),
        a = er(o, n),
        i = this.readSync(t.dataId),
        s = this.readSync(e.dataId),
        u = Dr(t.shape, o),
        c = Dr(e.shape, o),
        l = a.values;
    if (u.length + c.length === 0) for (var h = 0; h < l.length; ++h) l[h] = r(i[h % i.length], s[h % s.length]);else {
      var f = this.bufferSync(t),
          d = this.bufferSync(e),
          p = function (n) {
        var o = a.indexToLoc(n),
            h = o.slice(-t.rank);
        u.forEach(function (t) {
          return h[t] = 0;
        });
        var p = f.locToIndex(h),
            v = o.slice(-e.rank);
        c.forEach(function (t) {
          return v[t] = 0;
        });
        var m = d.locToIndex(v);
        l[n] = r(i[p], s[m]);
      };

      for (h = 0; h < l.length; ++h) p(h);
    }
    return a.toTensor();
  }, o.prototype.broadcastedBinaryComplexOp = function (t, e, n) {
    var r = Fr(t.shape, e.shape),
        o = er(r, "float32"),
        a = er(r, "float32"),
        i = this.readSync(t.dataId),
        s = this.readSync(e.dataId),
        u = Dr(t.shape, r),
        c = Dr(e.shape, r),
        l = o.values,
        h = a.values;
    if (u.length + c.length === 0) for (var f = 0; f < l.length; f++) {
      var d = f % i.length,
          p = f % s.length,
          v = n(i[2 * d], i[2 * d + 1], s[2 * p], s[2 * p + 1]);
      l[f] = v.real, h[f] = v.imag;
    } else {
      var m = this.bufferSync(this.data.get(t.dataId).complexTensors.real),
          g = this.bufferSync(this.data.get(e.dataId).complexTensors.real),
          y = function (r) {
        var a = o.indexToLoc(r),
            f = a.slice(-t.rank);
        u.forEach(function (t) {
          return f[t] = 0;
        });
        var d = m.locToIndex(f),
            p = a.slice(-e.rank);
        c.forEach(function (t) {
          return p[t] = 0;
        });
        var v = g.locToIndex(p),
            y = n(i[2 * d], i[2 * d + 1], s[2 * v], s[2 * v + 1]);
        l[r] = y.real, h[r] = y.imag;
      };

      for (f = 0; f < l.length; f++) y(f);
    }
    return this.complex(o.toTensor(), a.toTensor());
  }, o.prototype.split = function (t, e, n) {
    return Ba(t, e, n);
  }, o.prototype.dispose = function () {}, o.prototype.floatPrecision = function () {
    return 32;
  }, o.prototype.epsilon = function () {
    return 1e-7;
  }, o.prototype.cropAndResize = function (t, e, n, r, o, a) {
    for (var i = t.shape, s = i[0], u = i[1], c = i[2], l = i[3], h = e.shape[0], f = r[0], d = r[1], p = er([h, f, d, l], "float32"), v = this.readSync(e.dataId), m = this.readSync(n.dataId), g = this.readSync(t.dataId), y = t.strides, x = p.strides, b = 0; b < h; b++) {
      var w = 4 * b,
          C = v[w],
          E = v[w + 1],
          R = v[w + 2],
          I = v[w + 3],
          k = m[b];
      if (!(k >= s)) for (var S = f > 1 ? (R - C) * (u - 1) / (f - 1) : 0, A = d > 1 ? (I - E) * (c - 1) / (d - 1) : 0, T = 0; T < f; T++) {
        var D = f > 1 ? C * (u - 1) + T * S : .5 * (C + R) * (u - 1);
        if (D < 0 || D > u - 1) for (var N = 0; N < d; N++) for (var F = 0; F < l; F++) {
          var _ = F + N * x[2] + T * x[1] + b * x[0];

          p.values[_] = a;
        } else if ("bilinear" === o) {
          var O = Math.floor(D),
              M = Math.ceil(D),
              B = D - O;

          for (N = 0; N < d; N++) {
            if ((q = d > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for (F = 0; F < l; F++) {
              _ = F + N * x[2] + T * x[1] + b * x[0];
              p.values[_] = a;
            } else {
              var P = Math.floor(q),
                  L = Math.ceil(q),
                  W = q - P;

              for (F = 0; F < l; F++) {
                var U = g[_ = F + P * y[2] + O * y[1] + k * y[0]],
                    V = g[_ = F + L * y[2] + O * y[1] + k * y[0]],
                    z = g[_ = F + P * y[2] + M * y[1] + k * y[0]],
                    G = U + (V - U) * W,
                    H = z + (g[_ = F + L * y[2] + M * y[1] + k * y[0]] - z) * W;
                _ = F + N * x[2] + T * x[1] + b * x[0], p.values[_] = G + (H - G) * B;
              }
            }
          }
        } else for (N = 0; N < d; ++N) {
          var q;
          if ((q = d > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for (F = 0; F < l; F++) {
            _ = F + N * x[2] + T * x[1] + b * x[0];
            p.values[_] = a;
          } else {
            var K = Math.round(q),
                j = Math.round(D);

            for (F = 0; F < l; F++) {
              var X = F + K * y[2] + j * y[1] + k * y[0],
                  Y = F + N * x[2] + T * x[1] + b * x[0];
              p.values[Y] = g[X];
            }
          }
        }
      }
    }

    return p.toTensor();
  }, o.prototype.sparseToDense = function (t, e, n, r) {
    var o = Uo(0, t, n),
        a = o.sliceRank,
        i = o.numUpdates,
        s = o.sliceSize,
        u = o.strides,
        c = o.outputSize;
    return this.scatter(t, e, n, c, s, i, a, u, r, !1);
  }, o.prototype.gatherND = function (t, e) {
    var n = e.shape,
        r = n[n.length - 1],
        o = Oo(t, e),
        a = o[0],
        i = o[1],
        s = o[2],
        u = o[3];
    if (0 === i) return Fn([], a, t.dtype);

    for (var c = new gt([i, s], t.dtype), l = this.readSync(e.dataId), h = this.readSync(t.dataId), f = 0; f < i; f++) {
      for (var d = [], p = 0, v = 0; v < r; v++) {
        var m = l[f * r + v];
        p += m * u[v], d.push(m);
      }

      if (p < 0 || p >= t.size / s) throw new Error("Invalid indices: " + d + " does not index into " + t.shape);

      for (var g = 0; g < s; g++) c.values[f * s + g] = h[p * s + g];
    }

    return c.toTensor().reshape(a);
  }, o.prototype.scatterND = function (t, e, n) {
    var r = Uo(0, t, n),
        o = r.sliceRank,
        a = r.numUpdates,
        i = r.sliceSize,
        s = r.strides,
        u = r.outputSize,
        c = On(0);
    return this.scatter(t, e, n, u, i, a, o, s, c, !0);
  }, o.prototype.fill = function (t, e, n) {
    var r = P(n = n || j(e), k(t));
    return r.fill(e), Lt.makeTensor(r, t, n, this);
  }, o.prototype.onesLike = function (t) {
    if ("string" === t.dtype) throw new Error("onesLike is not supported for string tensors");
    return this.fill(t.shape, 1, t.dtype);
  }, o.prototype.zerosLike = function (t) {
    var e = P(t.dtype, k(t.shape));
    return this.makeOutput(e, t.shape, t.dtype);
  }, o.prototype.linspace = function (t, e, n) {
    return Ca(t, e, n);
  }, o.prototype.scatter = function (t, e, n, r, o, a, i, s, u, c) {
    var l = [r / o, o],
        h = this.readSync(t.dataId),
        f = this.readSync(e.dataId);
    if (0 === r) return Fn([], n, e.dtype);
    var d = new gt(l, e.dtype);
    d.values.fill(this.readSync(u.dataId)[0]);

    for (var p = 0; p < a; p++) {
      for (var v = [], m = 0, g = 0; g < i; g++) {
        var y = h[p * i + g];
        v.push(y), m += y * s[g];
      }

      if (m < 0 || m >= r / o) throw new Error("Invalid indices: " + v + " does not index into " + n);

      for (var x = 0; x < o; x++) c ? d.values[m * o + x] += f[p * o + x] : d.values[m * o + x] = 0 === e.rank ? f[0] : f[p * o + x];
    }

    return d.toTensor().reshape(n);
  }, o;
}(ia);

function sf(t, e) {
  return {
    kernelName: t,
    backendName: "cpu",
    kernelFunc: function (n) {
      var r = n.inputs,
          o = n.backend,
          a = r,
          i = a.a,
          s = a.b,
          u = o;
      rf([i, s], t);
      var c = u.data.get(i.dataId).values,
          l = u.data.get(s.dataId).values,
          h = e(i.shape, s.shape, c, l, i.dtype),
          f = h[0],
          d = h[1];
      return {
        dataId: u.write(f, d, i.dtype),
        shape: d,
        dtype: i.dtype
      };
    }
  };
}

function uf(t) {
  return function (e, n, r, o, a) {
    var i = Fr(e, n),
        s = i.length,
        u = $(i),
        c = B(a, k(i)),
        l = e.length,
        h = n.length,
        f = $(e),
        d = $(n),
        p = Dr(e, i),
        v = Dr(n, i);
    if (p.length + v.length === 0) for (var m = 0; m < c.length; ++m) c[m] = t(r[m % r.length], o[m % o.length]);else {
      var g = function (e) {
        var n = it(e, s, u),
            a = n.slice(-l);
        p.forEach(function (t) {
          return a[t] = 0;
        });
        var i = at(a, l, f),
            m = n.slice(-h);
        v.forEach(function (t) {
          return m[t] = 0;
        });
        var g = at(m, h, d);
        c[e] = t(r[i], o[g]);
      };

      for (m = 0; m < c.length; ++m) g(m);
    }
    return [c, i];
  };
}

Lt.registerBackend("cpu", function () {
  return new af();
}, 1);

for (var cf = uf(function (t, e) {
  return t / e;
}), lf = sf(Rr, cf), hf = {
  kernelName: "NonMaxSuppressionV5",
  backendName: "cpu",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = t.attrs,
        o = e,
        a = o.boxes,
        i = o.scores,
        s = r,
        u = s.maxOutputSize,
        c = s.iouThreshold,
        l = s.scoreThreshold,
        h = s.softNmsSigma,
        f = n;
    rf(a, "NonMaxSuppressionWithScore");
    var d = Na(f.data.get(a.dataId).values, f.data.get(i.dataId).values, u, c, l, h);
    return [d.selectedIndices, d.selectedScores];
  }
}, ff = {
  kernelName: "Square",
  backendName: "cpu",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e.x,
        o = n;
    rf(r, "square");

    for (var a = o.data.get(r.dataId).values, i = new Float32Array(a.length), s = 0; s < a.length; ++s) {
      var u = a[s];
      i[s] = u * u;
    }

    return {
      dataId: o.write(i, r.shape, r.dtype),
      shape: r.shape,
      dtype: r.dtype
    };
  }
}, df = uf(function (t, e) {
  var n = t - e;
  return n * n;
}), pf = 0, vf = [hf, ff, sf(Ir, df), lf]; pf < vf.length; pf++) {
  d(vf[pf]);
}

var mf,
    gf = function (t) {
  this.variableNames = ["A"];
  var e = qa(),
      n = t[0],
      r = t[1];
  this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r + ".0, " + n + ".0);\n\n        vec4 values = " + e.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
},
    yf = function (t) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
  var e = qa(),
      n = t[0],
      r = t[1];
  this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r + ".0, " + n + ".0);\n            vec4 values = " + e.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e.output + " = result;\n      }\n    ";
};

for (var xf = 0, bf = [{
  kernelName: "FromPixels",
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = t.attrs,
        o = e.pixels,
        a = r.numChannels,
        s = "undefined" != typeof HTMLVideoElement && o instanceof HTMLVideoElement,
        u = "undefined" != typeof HTMLImageElement && o instanceof HTMLImageElement,
        c = s ? [o.videoWidth, o.videoHeight] : [o.width, o.height],
        l = c[0],
        h = c[1],
        f = [h, l],
        d = [h, l, a];
    (u || s) && (null == mf && (mf = document.createElement("canvas").getContext("2d")), mf.canvas.width = l, mf.canvas.height = h, mf.drawImage(o, 0, 0, l, h), o = mf.canvas);
    var p = n.makeTensorInfo(f, "int32");
    n.texData.get(p.dataId).usage = zt.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId), o);
    var v = i().getBool("WEBGL_PACK") ? new yf(d) : new gf(d),
        m = n.runWebGLProgram(v, [p], "int32");
    return n.disposeData(p.dataId), m;
  }
}, {
  kernelName: Rr,
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e;
    return function (t, e, n) {
      var r = new bi(yi, t.shape, e.shape);
      return i().getBool("WEBGL_PACK_BINARY_OPERATIONS") && (r = new Ei(wi, t.shape, e.shape, !0)), n.runWebGLProgram(r, [t, e], "float32");
    }(r.a, r.b, n);
  }
}, {
  kernelName: "NonMaxSuppressionV5",
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = t.attrs;
    dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    var o = e,
        a = o.boxes,
        i = o.scores,
        s = r,
        u = s.maxOutputSize,
        c = s.iouThreshold,
        l = s.scoreThreshold,
        h = s.softNmsSigma,
        f = n,
        d = Na(f.readSync(a.dataId), f.readSync(i.dataId), u, c, l, h);
    return [d.selectedIndices, d.selectedScores];
  }
}, {
  kernelName: "Square",
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e.x,
        o = n,
        a = new su(r.shape, "return x * x;");
    return o.runWebGLProgram(a, [r], r.dtype);
  }
}, {
  kernelName: Ir,
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e,
        o = r.a,
        a = r.b,
        s = n,
        u = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ei("return (a - b) * (a - b);", o.shape, a.shape) : new bi("return (a - b) * (a - b);", o.shape, a.shape);
    return s.compileAndRun(u, [o, a]);
  }
}]; xf < bf.length; xf++) {
  d(bf[xf]);
}

for (var wf = 0, Cf = [{
  kernelName: Rr,
  inputsToSave: ["a", "b"],
  gradFunc: function (t, e) {
    var n = e[0],
        r = e[1],
        o = Fr(n.shape, r.shape);
    return {
      a: function () {
        var e = _o(t, r.toFloat()),
            a = Nr(n.shape, o);

        return a.length > 0 ? Hl(e, a).reshape(n.shape) : e;
      },
      b: function () {
        var e = t.mul(n.toFloat()),
            a = Nr(r.shape, o);
        a.length > 0 && (e = Hl(e, a).reshape(r.shape));
        var i = bc(r);
        return Qr(_o(e, i.toFloat()));
      }
    };
  }
}, {
  kernelName: "Square",
  inputsToSave: ["x"],
  gradFunc: function (t, e) {
    var n = e[0];
    return {
      x: function () {
        return t.mul(n.toFloat().mul(2));
      }
    };
  }
}, {
  kernelName: Ir,
  inputsToSave: ["a", "b"],
  gradFunc: function (t, e) {
    var n = e[0],
        r = e[1],
        o = On(2);
    return {
      a: function () {
        return ko(t, ko(o, No(n, r)));
      },
      b: function () {
        return ko(t, ko(o, No(r, n)));
      }
    };
  }
}, {
  kernelName: kr,
  gradFunc: function (t, e, n) {
    for (var r = n, o = r.inputShape, a = r.shape, i = Array.from(a), s = o.length - 1; s >= 0; s--) if (o[s] === a[s]) i[s] = 1;else if (1 !== o[s]) throw new Error("broadcastTo(): [" + o + "] cannot be broadcast to [" + a + "].");

    var u = [];

    for (s = 0; s < i.length; s++) i[s] > 1 && u.push(s);

    return {
      x: function () {
        return t.sum(u, !0);
      }
    };
  }
}, {
  kernelName: Ar,
  gradFunc: function (t) {
    return {
      x: function () {
        return t.toFloat();
      }
    };
  }
}, {
  kernelName: Tr,
  inputsToSave: ["x"],
  gradFunc: function (t, e, n) {
    var r = e[0],
        o = n.reps;
    return {
      x: function () {
        var e = Xn(r);
        if (1 === r.rank) for (var n = 0; n < o[0]; ++n) e = e.add(t.slice([n * r.shape[0]], [r.shape[0]]));else if (2 === r.rank) for (n = 0; n < o[0]; ++n) for (var a = 0; a < o[1]; ++a) e = e.add(t.slice([n * r.shape[0], a * r.shape[1]], [r.shape[0], r.shape[1]]));else if (3 === r.rank) for (n = 0; n < o[0]; ++n) for (a = 0; a < o[1]; ++a) for (var i = 0; i < o[2]; ++i) e = e.add(t.slice([n * r.shape[0], a * r.shape[1], i * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));else {
          if (4 !== r.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r.rank + " tensors yet.");

          for (n = 0; n < o[0]; ++n) for (a = 0; a < o[1]; ++a) for (i = 0; i < o[2]; ++i) for (var s = 0; s < o[3]; ++s) e = e.add(t.slice([n * r.shape[0], a * r.shape[1], i * r.shape[2], s * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]));
        }
        return e;
      }
    };
  }
}, {
  kernelName: Sr,
  inputsToSave: ["indices"],
  gradFunc: function (t, e) {
    var n = e[0];
    return {
      indices: function () {
        return Gn(n.shape, "float32");
      }
    };
  }
}]; wf < Cf.length; wf++) {
  p(Cf[wf]);
}

var Ef = function () {
  function t() {}

  return t.prototype.fetch = function (t, e) {
    return fetch(t, e);
  }, t.prototype.now = function () {
    return performance.now();
  }, t.prototype.encode = function (t, e) {
    if ("utf-8" !== e && "utf8" !== e) throw new Error("Browser's encoder only supports utf-8, but got " + e);
    return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t);
  }, t.prototype.decode = function (t, e) {
    return new TextDecoder(e).decode(t);
  }, t;
}();

i().get("IS_BROWSER") && i().setPlatform("browser", new Ef());

var Rf,
    If = function () {
  return require("node-fetch");
},
    kf = function () {
  function t() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }

  return t.prototype.fetch = function (t, e) {
    return null != i().global.fetch ? i().global.fetch(t, e) : (null == Rf && (Rf = If()), Rf(t, e));
  }, t.prototype.now = function () {
    var t = process.hrtime();
    return 1e3 * t[0] + t[1] / 1e6;
  }, t.prototype.encode = function (t, e) {
    if ("utf-8" !== e && "utf8" !== e) throw new Error("Node built-in encoder only supports utf-8, but got " + e);
    return this.textEncoder.encode(t);
  }, t.prototype.decode = function (t, e) {
    return 0 === t.length ? "" : new this.util.TextDecoder(e).decode(t);
  }, t;
}();

i().get("IS_NODE") && i().setPlatform("node", new kf());
var Sf = {
  float32: 4,
  int32: 4,
  uint16: 2,
  uint8: 1,
  bool: 1
},
    Af = 4;

function Tf(t, e) {
  for (var n = {}, r = 0, o = function (e) {
    var o = e.name,
        a = e.dtype,
        i = e.shape,
        s = k(i),
        u = void 0;

    if (("quantization" in e)) {
      var c = e.quantization;
      if ("uint8" !== c.dtype && "uint16" !== c.dtype) throw new Error("Weight " + e.name + " has unknown quantization dtype " + c.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
      var l = Sf[c.dtype],
          h = t.slice(r, r + s * l),
          f = "uint8" === c.dtype ? new Uint8Array(h) : new Uint16Array(h);
      if ("float32" === a) u = Float32Array.from(f, function (t) {
        return t * c.scale + c.min;
      });else {
        if ("int32" !== a) throw new Error("Unsupported dtype in weight '" + o + "': " + a);
        u = Int32Array.from(f, function (t) {
          return Math.round(t * c.scale + c.min);
        });
      }
      r += s * l;
    } else if ("string" === a) {
      var d = k(e.shape);
      u = [];

      for (var p = 0; p < d; p++) {
        var v = new Uint32Array(t.slice(r, r + Af))[0];
        r += Af;
        var m = new Uint8Array(t.slice(r, r + v));
        u.push(m), r += v;
      }
    } else {
      var g = Sf[a];
      h = t.slice(r, r + s * g);
      if ("float32" === a) u = new Float32Array(h);else if ("int32" === a) u = new Int32Array(h);else {
        if ("bool" !== a) throw new Error("Unsupported dtype in weight '" + o + "': " + a);
        u = new Uint8Array(h);
      }
      r += s * g;
    }

    n[o] = Fn(u, i, a);
  }, a = 0, i = e; a < i.length; a++) {
    o(i[a]);
  }

  return n;
}

function Df(t) {
  if (null === t) throw new Error("Invalid input value: " + JSON.stringify(t));
  var e = 0,
      n = [];
  t.forEach(function (t) {
    if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + t.constructor.name);
  });
  var r = new Uint8Array(e),
      o = 0;
  return n.forEach(function (t) {
    r.set(new Uint8Array(t.buffer), o), o += t.byteLength;
  }), r.buffer;
}

var Nf = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

function Ff(t) {
  return Nf ? Buffer.byteLength(t) : new Blob([t]).size;
}

function _f(t) {
  var e = 0;
  t.forEach(function (t) {
    e += t.byteLength;
  });
  var n = new Uint8Array(e),
      r = 0;
  return t.forEach(function (t) {
    n.set(new Uint8Array(t), r), r += t.byteLength;
  }), n.buffer;
}

function Of(t) {
  for (t = t.trim(); t.endsWith("/");) t = t.slice(0, t.length - 1);

  var e = t.split("/");
  return e[e.length - 1];
}

function Mf(t) {
  if (t.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {
    dateSaved: new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: null == t.modelTopology ? 0 : Ff(JSON.stringify(t.modelTopology)),
    weightSpecsBytes: null == t.weightSpecs ? 0 : Ff(JSON.stringify(t.weightSpecs)),
    weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength
  };
}

var Bf = function () {
  function t() {
    this.saveRouters = [], this.loadRouters = [];
  }

  return t.getInstance = function () {
    return null == t.instance && (t.instance = new t()), t.instance;
  }, t.registerSaveRouter = function (e) {
    t.getInstance().saveRouters.push(e);
  }, t.registerLoadRouter = function (e) {
    t.getInstance().loadRouters.push(e);
  }, t.getSaveHandlers = function (e) {
    return t.getHandlers(e, "save");
  }, t.getLoadHandlers = function (e, n) {
    return t.getHandlers(e, "load", n);
  }, t.getHandlers = function (e, n, r) {
    var o = [];
    return ("load" === n ? t.getInstance().loadRouters : t.getInstance().saveRouters).forEach(function (t) {
      var n = t(e, r);
      null !== n && o.push(n);
    }), o;
  }, t;
}(),
    Pf = "://",
    Lf = function () {
  function t() {
    this.managers = {};
  }

  return t.getInstance = function () {
    return null == t.instance && (t.instance = new t()), t.instance;
  }, t.registerManager = function (e, n) {
    C(null != e, function () {
      return "scheme must not be undefined or null.";
    }), e.endsWith(Pf) && (e = e.slice(0, e.indexOf(Pf))), C(e.length > 0, function () {
      return "scheme must not be an empty string.";
    });
    var r = t.getInstance();
    C(null == r.managers[e], function () {
      return "A model store manager is already registered for scheme '" + e + "'.";
    }), r.managers[e] = n;
  }, t.getManager = function (t) {
    var e = this.getInstance().managers[t];
    if (null == e) throw new Error("Cannot find model manager for scheme '" + t + "'");
    return e;
  }, t.getSchemes = function () {
    return Object.keys(this.getInstance().managers);
  }, t;
}();

function Wf(t) {
  if (-1 === t.indexOf(Pf)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Lf.getSchemes().join(","));
  return {
    scheme: t.split(Pf)[0],
    path: t.split(Pf)[1]
  };
}

function Uf(t, e, o) {
  return void 0 === o && (o = !1), n(this, void 0, void 0, function () {
    var n, a, i, s, u, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return C(t !== e, function () {
            return "Old path and new path are the same: '" + t + "'";
          }), C((n = Bf.getLoadHandlers(t)).length > 0, function () {
            return "Copying failed because no load handler is found for source URL " + t + ".";
          }), C(n.length < 2, function () {
            return "Copying failed because more than one (" + n.length + ") load handlers for source URL " + t + ".";
          }), a = n[0], C((i = Bf.getSaveHandlers(e)).length > 0, function () {
            return "Copying failed because no save handler is found for destination URL " + e + ".";
          }), C(i.length < 2, function () {
            return "Copying failed because more than one (" + n.length + ") save handlers for destination URL " + e + ".";
          }), s = i[0], u = Wf(t).scheme, c = Wf(t).path, l = u === Wf(t).scheme, [4, a.load()];

        case 1:
          return h = r.sent(), o && l ? [4, Lf.getManager(u).removeModel(c)] : [3, 3];

        case 2:
          r.sent(), r.label = 3;

        case 3:
          return [4, s.save(h)];

        case 4:
          return f = r.sent(), !o || l ? [3, 6] : [4, Lf.getManager(u).removeModel(c)];

        case 5:
          r.sent(), r.label = 6;

        case 6:
          return [2, f.modelArtifactsInfo];
      }
    });
  });
}

var Vf = "models_store",
    zf = "model_info_store";

function Gf() {
  if (!i().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var t = window || self,
      e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;
  if (null == e) throw new Error("The current browser does not appear to support IndexedDB.");
  return e;
}

function Hf(t) {
  var e = t.result;
  e.createObjectStore(Vf, {
    keyPath: "modelPath"
  }), e.createObjectStore(zf, {
    keyPath: "modelPath"
  });
}

var qf = function () {
  function t(t) {
    if (this.indexedDB = Gf(), null == t || !t) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = t;
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        return [2, this.databaseAction(this.modelPath, t)];
      });
    });
  }, t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        return [2, this.databaseAction(this.modelPath)];
      });
    });
  }, t.prototype.databaseAction = function (t, e) {
    var n = this;
    return new Promise(function (t, r) {
      var o = n.indexedDB.open("tensorflowjs", 1);
      o.onupgradeneeded = function () {
        return Hf(o);
      }, o.onsuccess = function () {
        var a = o.result;

        if (null == e) {
          var i = a.transaction(Vf, "readonly"),
              s = i.objectStore(Vf).get(n.modelPath);
          s.onsuccess = function () {
            if (null == s.result) return a.close(), r(new Error("Cannot find model with path '" + n.modelPath + "' in IndexedDB."));
            t(s.result.modelArtifacts);
          }, s.onerror = function (t) {
            return a.close(), r(s.error);
          }, i.oncomplete = function () {
            return a.close();
          };
        } else {
          var u,
              c = Mf(e),
              l = a.transaction(zf, "readwrite"),
              h = l.objectStore(zf),
              f = h.put({
            modelPath: n.modelPath,
            modelArtifactsInfo: c
          });
          f.onsuccess = function () {
            var o = (u = a.transaction(Vf, "readwrite")).objectStore(Vf).put({
              modelPath: n.modelPath,
              modelArtifacts: e,
              modelArtifactsInfo: c
            });
            o.onsuccess = function () {
              return t({
                modelArtifactsInfo: c
              });
            }, o.onerror = function (t) {
              var e = (h = l.objectStore(zf)).delete(n.modelPath);
              e.onsuccess = function () {
                return a.close(), r(o.error);
              }, e.onerror = function (t) {
                return a.close(), r(o.error);
              };
            };
          }, f.onerror = function (t) {
            return a.close(), r(f.error);
          }, l.oncomplete = function () {
            null == u ? a.close() : u.oncomplete = function () {
              return a.close();
            };
          };
        }
      }, o.onerror = function (t) {
        return r(o.error);
      };
    });
  }, t.URL_SCHEME = "indexeddb://", t;
}(),
    Kf = function (t) {
  return i().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(qf.URL_SCHEME) ? (e = t.slice(qf.URL_SCHEME.length), new qf(e)) : null;
  var e;
};

Bf.registerSaveRouter(Kf), Bf.registerLoadRouter(Kf);

var jf = function () {
  function t() {
    this.indexedDB = Gf();
  }

  return t.prototype.listModels = function () {
    return n(this, void 0, void 0, function () {
      var t = this;
      return r(this, function (e) {
        return [2, new Promise(function (e, n) {
          var r = t.indexedDB.open("tensorflowjs", 1);
          r.onupgradeneeded = function () {
            return Hf(r);
          }, r.onsuccess = function () {
            var t = r.result,
                o = t.transaction(zf, "readonly"),
                a = o.objectStore(zf).getAll();
            a.onsuccess = function () {
              for (var t = {}, n = 0, r = a.result; n < r.length; n++) {
                var o = r[n];
                t[o.modelPath] = o.modelArtifactsInfo;
              }

              e(t);
            }, a.onerror = function (e) {
              return t.close(), n(a.error);
            }, o.oncomplete = function () {
              return t.close();
            };
          }, r.onerror = function (t) {
            return n(r.error);
          };
        })];
      });
    });
  }, t.prototype.removeModel = function (t) {
    return n(this, void 0, void 0, function () {
      var e = this;
      return r(this, function (n) {
        var r;
        return t = (r = t).startsWith(qf.URL_SCHEME) ? r.slice(qf.URL_SCHEME.length) : r, [2, new Promise(function (n, r) {
          var o = e.indexedDB.open("tensorflowjs", 1);
          o.onupgradeneeded = function () {
            return Hf(o);
          }, o.onsuccess = function () {
            var e,
                a = o.result,
                i = a.transaction(zf, "readwrite"),
                s = i.objectStore(zf),
                u = s.get(t);
            u.onsuccess = function () {
              if (null == u.result) return a.close(), r(new Error("Cannot find model with path '" + t + "' in IndexedDB."));

              var o = s.delete(t),
                  i = function () {
                var o = (e = a.transaction(Vf, "readwrite")).objectStore(Vf).delete(t);
                o.onsuccess = function () {
                  return n(u.result.modelArtifactsInfo);
                }, o.onerror = function (t) {
                  return r(u.error);
                };
              };

              o.onsuccess = i, o.onerror = function (t) {
                return i(), a.close(), r(u.error);
              };
            }, u.onerror = function (t) {
              return a.close(), r(u.error);
            }, i.oncomplete = function () {
              null == e ? a.close() : e.oncomplete = function () {
                return a.close();
              };
            };
          }, o.onerror = function (t) {
            return r(o.error);
          };
        })];
      });
    });
  }, t;
}();

if (i().getBool("IS_BROWSER")) try {
  Lf.registerManager(qf.URL_SCHEME, new jf());
} catch (t) {}
var Xf = "/",
    Yf = "tensorflowjs_models",
    $f = "info",
    Qf = "model_topology",
    Jf = "weight_specs",
    Zf = "weight_data",
    td = "model_metadata";

function ed(t) {
  return {
    info: [Yf, t, $f].join(Xf),
    topology: [Yf, t, Qf].join(Xf),
    weightSpecs: [Yf, t, Jf].join(Xf),
    weightData: [Yf, t, Zf].join(Xf),
    modelMetadata: [Yf, t, td].join(Xf)
  };
}

function nd(t) {
  var e = t.split(Xf);
  if (e.length < 3) throw new Error("Invalid key format: " + t);
  return e.slice(1, e.length - 1).join(Xf);
}

var rd = function () {
  function t(t) {
    if (!i().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, null == t || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = t, this.keys = ed(this.modelPath);
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o;
      return r(this, function (r) {
        if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        e = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), o = Mf(t);

        try {
          return this.LS.setItem(this.keys.info, JSON.stringify(o)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, function (t) {
            if (Nf) return Buffer.from(t).toString("base64");

            for (var e = new Uint8Array(t), n = "", r = 0, o = e.length; r < o; r++) n += String.fromCharCode(e[r]);

            return btoa(n);
          }(t.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
            format: t.format,
            generatedBy: t.generatedBy,
            convertedBy: t.convertedBy,
            userDefinedMetadata: t.userDefinedMetadata
          })), [2, {
            modelArtifactsInfo: o
          }];
        } catch (t) {
          throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o.modelTopologyBytes + ", weightSpecsBytes=" + o.weightSpecsBytes + ", weightDataBytes=" + o.weightDataBytes + ".");
        }

        return [2];
      });
    });
  }, t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i, s;
      return r(this, function (r) {
        if (null == (t = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
        if ("JSON" !== t.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        if (e = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
        if (e.modelTopology = n, null == (o = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
        if (e.weightSpecs = o, null != (a = this.LS.getItem(this.keys.modelMetadata)) && (i = JSON.parse(a), e.format = i.format, e.generatedBy = i.generatedBy, e.convertedBy = i.convertedBy, e.userDefinedMetadata = i.userDefinedMetadata), null == (s = this.LS.getItem(this.keys.weightData))) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
        return e.weightData = function (t) {
          if (Nf) {
            var e = Buffer.from(t, "base64");
            return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
          }

          for (var n = atob(t), r = new Uint8Array(n.length), o = 0; o < n.length; ++o) r.set([n.charCodeAt(o)], o);

          return r.buffer;
        }(s), [2, e];
      });
    });
  }, t.URL_SCHEME = "localstorage://", t;
}(),
    od = function (t) {
  return i().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(rd.URL_SCHEME) ? (e = t.slice(rd.URL_SCHEME.length), new rd(e)) : null;
  var e;
};

Bf.registerSaveRouter(od), Bf.registerLoadRouter(od);

var ad = function () {
  function t() {
    C(i().getBool("IS_BROWSER"), function () {
      return "Current environment is not a web browser";
    }), C("undefined" == typeof window || void 0 !== window.localStorage, function () {
      return "Current browser does not appear to support localStorage";
    }), this.LS = window.localStorage;
  }

  return t.prototype.listModels = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i;
      return r(this, function (r) {
        for (t = {}, e = Yf + Xf, n = Xf + $f, o = 0; o < this.LS.length; ++o) (a = this.LS.key(o)).startsWith(e) && a.endsWith(n) && (i = nd(a), t[i] = JSON.parse(this.LS.getItem(a)));

        return [2, t];
      });
    });
  }, t.prototype.removeModel = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n;
      return r(this, function (r) {
        var o;
        if (t = (o = t).startsWith(rd.URL_SCHEME) ? o.slice(rd.URL_SCHEME.length) : o, e = ed(t), null == this.LS.getItem(e.info)) throw new Error("Cannot find model at path '" + t + "'");
        return n = JSON.parse(this.LS.getItem(e.info)), this.LS.removeItem(e.info), this.LS.removeItem(e.topology), this.LS.removeItem(e.weightSpecs), this.LS.removeItem(e.weightData), [2, n];
      });
    });
  }, t;
}();

if (i().getBool("IS_BROWSER")) try {
  Lf.registerManager(rd.URL_SCHEME, new ad());
} catch (t) {}
var id = "model",
    sd = ".json",
    ud = ".weights.bin";

function cd(t) {
  return new Promise(function (t) {
    return setTimeout(t);
  }).then(t);
}

var ld = function () {
  function t(e) {
    if (!i().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)), null != e && 0 !== e.length || (e = id), this.modelTopologyFileName = e + sd, this.weightDataFileName = e + ud;
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, i, s;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
            if (e = window.URL.createObjectURL(new Blob([t.weightData], {
              type: "application/octet-stream"
            })), !(t.modelTopology instanceof ArrayBuffer)) return [3, 1];
            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");

          case 1:
            return n = [{
              paths: ["./" + this.weightDataFileName],
              weights: t.weightSpecs
            }], o = {
              modelTopology: t.modelTopology,
              format: t.format,
              generatedBy: t.generatedBy,
              convertedBy: t.convertedBy,
              weightsManifest: n
            }, a = window.URL.createObjectURL(new Blob([JSON.stringify(o)], {
              type: "application/json"
            })), (i = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i.href = a, [4, cd(function () {
              return i.dispatchEvent(new MouseEvent("click"));
            })];

          case 2:
            return r.sent(), null == t.weightData ? [3, 4] : ((s = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, s.href = e, [4, cd(function () {
              return s.dispatchEvent(new MouseEvent("click"));
            })]);

          case 3:
            r.sent(), r.label = 4;

          case 4:
            return [2, {
              modelArtifactsInfo: Mf(t)
            }];
        }
      });
    });
  }, t.URL_SCHEME = "downloads://", t;
}(),
    hd = function () {
  function t(t) {
    if (null == t || t.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + t);
    this.files = t;
  }

  return t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      var t,
          e,
          n = this;
      return r(this, function (r) {
        return t = this.files[0], e = this.files.slice(1), [2, new Promise(function (r, o) {
          var a = new FileReader();
          a.onload = function (a) {
            var i = JSON.parse(a.target.result),
                s = i.modelTopology;

            if (null != s) {
              0 === e.length && r({
                modelTopology: s
              });
              var u = i.weightsManifest;

              if (null != u) {
                var c;

                try {
                  c = n.checkManifestAndWeightFiles(u, e);
                } catch (t) {
                  return void o(t);
                }

                var l = [],
                    h = [],
                    f = [];
                u.forEach(function (t) {
                  t.paths.forEach(function (t) {
                    h.push(t), f.push(null);
                  }), l.push.apply(l, t.weights);
                }), u.forEach(function (t) {
                  t.paths.forEach(function (t) {
                    var e = new FileReader();
                    e.onload = function (e) {
                      var n = e.target.result,
                          o = h.indexOf(t);
                      f[o] = n, -1 === f.indexOf(null) && r({
                        modelTopology: s,
                        weightSpecs: l,
                        weightData: _f(f),
                        format: i.format,
                        generatedBy: i.generatedBy,
                        convertedBy: i.convertedBy,
                        userDefinedMetadata: i.userDefinedMetadata
                      });
                    }, e.onerror = function (e) {
                      return o("Failed to weights data from file of path '" + t + "'.");
                    }, e.readAsArrayBuffer(c[t]);
                  });
                });
              } else o(new Error("weightManifest field is missing from file " + t.name));
            } else o(new Error("modelTopology field is missing from file " + t.name));
          }, a.onerror = function (e) {
            return o("Failed to read model topology and weights manifest JSON from file '" + t.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
          }, a.readAsText(t);
        })];
      });
    });
  }, t.prototype.checkManifestAndWeightFiles = function (t, e) {
    for (var n = [], r = e.map(function (t) {
      return Of(t.name);
    }), o = {}, a = 0, i = t; a < i.length; a++) {
      i[a].paths.forEach(function (t) {
        var a = Of(t);
        if (-1 !== n.indexOf(a)) throw new Error("Duplicate file basename found in weights manifest: '" + a + "'");
        if (n.push(a), -1 === r.indexOf(a)) throw new Error("Weight file with basename '" + a + "' is not provided.");
        o[t] = e[r.indexOf(a)];
      });
    }

    if (n.length !== e.length) throw new Error("Mismatch in the number of files in weights manifest (" + n.length + ") and the number of weight files provided (" + e.length + ").");
    return o;
  }, t;
}();

function fd(t, e, n, r) {
  !function (t) {
    C(null != t && Array.isArray(t) && t.length > 0, function () {
      return "promises must be a none empty array";
    });
  }(t), function (t, e) {
    C(t >= 0 && t <= 1, function () {
      return "Progress fraction must be in range [0, 1], but got startFraction " + t;
    }), C(e >= 0 && e <= 1, function () {
      return "Progress fraction must be in range [0, 1], but got endFraction " + e;
    }), C(e >= t, function () {
      return "startFraction must be no more than endFraction, but got startFraction " + t + " and endFraction " + e;
    });
  }(n = null == n ? 0 : n, r = null == r ? 1 : r);
  var o = 0;
  return Promise.all(t.map(function (a) {
    return a.then(function (a) {
      var i = n + ++o / t.length * (r - n);
      return e(i), a;
    }), a;
  }));
}

function dd(t, e) {
  return n(this, void 0, void 0, function () {
    var n, o, a, s, u, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return null == e && (e = {}), n = null == e.fetchFunc ? i().platform.fetch : e.fetchFunc, o = t.map(function (t) {
            return n(t, e.requestInit, {
              isBinary: !0
            });
          }), a = 0, s = .5, null != e.onProgress ? [3, 2] : [4, Promise.all(o)];

        case 1:
          return u = r.sent(), [3, 4];

        case 2:
          return [4, fd(o, e.onProgress, a, s)];

        case 3:
          u = r.sent(), r.label = 4;

        case 4:
          return c = u.map(function (t) {
            return t.arrayBuffer();
          }), l = .5, h = 1, null != e.onProgress ? [3, 6] : [4, Promise.all(c)];

        case 5:
          return f = r.sent(), [3, 8];

        case 6:
          return [4, fd(c, e.onProgress, l, h)];

        case 7:
          f = r.sent(), r.label = 8;

        case 8:
          return [2, f];
      }
    });
  });
}

function pd(t) {
  var e = this;
  return function (o, a, i) {
    return void 0 === a && (a = ""), n(e, void 0, void 0, function () {
      var e, n, s, u, c, l, h, f, d, p;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (e = o.map(function () {
              return !1;
            }), n = {}, s = null != i ? i.map(function () {
              return !1;
            }) : [], u = [], o.forEach(function (t, r) {
              var o = 0;
              t.weights.forEach(function (t) {
                var a = "quantization" in t ? t.quantization.dtype : t.dtype,
                    c = Sf[a] * k(t.shape),
                    l = function () {
                  e[r] = !0, null == n[r] && (n[r] = []), n[r].push({
                    manifestEntry: t,
                    groupOffset: o,
                    sizeBytes: c
                  });
                };

                null != i ? i.forEach(function (e, n) {
                  e === t.name && (l(), s[n] = !0);
                }) : l(), u.push(t.name), o += c;
              });
            }), !s.every(function (t) {
              return t;
            })) throw c = i.filter(function (t, e) {
              return !s[e];
            }), new Error("Could not find weights in manifest with names: " + c.join(", ") + ". \nManifest JSON has weights with names: " + u.join(", ") + ".");
            return l = e.reduce(function (t, e, n) {
              return e && t.push(n), t;
            }, []), h = [], l.forEach(function (t) {
              o[t].paths.forEach(function (t) {
                var e = a + (a.endsWith("/") ? "" : "/") + t;
                h.push(e);
              });
            }), [4, t(h)];

          case 1:
            return f = r.sent(), d = {}, p = 0, l.forEach(function (t) {
              for (var e = o[t].paths.length, r = 0, a = 0; a < e; a++) r += f[p + a].byteLength;

              for (var i = new ArrayBuffer(r), s = new Uint8Array(i), u = 0, c = 0; c < e; c++) {
                var l = new Uint8Array(f[p + c]);
                s.set(l, u), u += l.byteLength;
              }

              n[t].forEach(function (t) {
                var e = Tf(i.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [t.manifestEntry]);

                for (var n in e) d[n] = e[n];
              }), p += e;
            }), [2, d];
        }
      });
    });
  };
}

Bf.registerSaveRouter(function (t) {
  return i().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(ld.URL_SCHEME) ? function (t) {
    void 0 === t && (t = "model");
    return new ld(t);
  }(t.slice(ld.URL_SCHEME.length)) : null;
});

var vd = function () {
  function t(t, e) {
    if (this.DEFAULT_METHOD = "POST", null == e && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, null != e.fetchFunc ? (C("function" == typeof e.fetchFunc, function () {
      return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
    }), this.fetch = e.fetchFunc) : this.fetch = i().platform.fetch, C(null != t && t.length > 0, function () {
      return "URL path for http must not be null, undefined or empty.";
    }), Array.isArray(t) && C(2 === t.length, function () {
      return "URL paths for http must have a length of 2, (actual length is " + t.length + ").";
    }), this.path = t, null != e.requestInit && null != e.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = e.requestInit || {};
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
            return (e = Object.assign({
              method: this.DEFAULT_METHOD
            }, this.requestInit)).body = new FormData(), n = [{
              paths: ["./model.weights.bin"],
              weights: t.weightSpecs
            }], o = {
              modelTopology: t.modelTopology,
              format: t.format,
              generatedBy: t.generatedBy,
              convertedBy: t.convertedBy,
              userDefinedMetadata: t.userDefinedMetadata,
              weightsManifest: n
            }, e.body.append("model.json", new Blob([JSON.stringify(o)], {
              type: "application/json"
            }), "model.json"), null != t.weightData && e.body.append("model.weights.bin", new Blob([t.weightData], {
              type: "application/octet-stream"
            }), "model.weights.bin"), [4, this.fetch(this.path, e)];

          case 1:
            if ((a = r.sent()).ok) return [2, {
              modelArtifactsInfo: Mf(t),
              responses: [a]
            }];
            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + a.status + ".");
        }
      });
    });
  }, t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i, s, u, c, l, h, f;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, this.fetch(this.path, this.requestInit)];

          case 1:
            if (!(t = r.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + t.status + ". Please verify this URL points to the model JSON of the model to load.");
            r.label = 2;

          case 2:
            return r.trys.push([2, 4,, 5]), [4, t.json()];

          case 3:
            return e = r.sent(), [3, 5];

          case 4:
            throw r.sent(), n = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n += " Please make sure the server is serving valid JSON for this request.", new Error(n);

          case 5:
            if (o = e.modelTopology, a = e.weightsManifest, i = e.generatedBy, s = e.convertedBy, u = e.format, c = e.userDefinedMetadata, null == o && null == a) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
            return null == a ? [3, 7] : [4, this.loadWeights(a)];

          case 6:
            f = r.sent(), l = f[0], h = f[1], r.label = 7;

          case 7:
            return [2, {
              modelTopology: o,
              weightSpecs: l,
              weightData: h,
              userDefinedMetadata: c,
              generatedBy: i,
              convertedBy: s,
              format: u
            }];
        }
      });
    });
  }, t.prototype.loadWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, i, s, u, c, l, h, f;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            for (e = Array.isArray(this.path) ? this.path[1] : this.path, n = function (t) {
              var e = t.lastIndexOf("/"),
                  n = t.lastIndexOf("?"),
                  r = t.substring(0, e),
                  o = n > e ? t.substring(n) : "";
              return [r + "/", o];
            }(e), o = n[0], a = n[1], i = this.weightPathPrefix || o, s = [], u = 0, c = t; u < c.length; u++) l = c[u], s.push.apply(s, l.weights);

            return h = [], t.forEach(function (t) {
              t.paths.forEach(function (t) {
                h.push(i + t + a);
              });
            }), [4, dd(h, {
              requestInit: this.requestInit,
              fetchFunc: this.fetch,
              onProgress: this.onProgress
            })];

          case 1:
            return f = r.sent(), [2, [s, _f(f)]];
        }
      });
    });
  }, t.URL_SCHEME_REGEX = /^https?:\/\//, t;
}();

function md(t) {
  return null != t.match(vd.URL_SCHEME_REGEX);
}

var gd = function (t, e) {
  if ("undefined" == typeof fetch) return null;
  return (Array.isArray(t) ? t.every(function (t) {
    return md(t);
  }) : md(t)) ? yd(t, {
    onProgress: e
  }) : null;
};

function yd(t, e) {
  return new vd(t, e);
}

Bf.registerSaveRouter(gd), Bf.registerLoadRouter(gd);

var xd = function () {
  function t(t) {
    this.modelArtifacts = t;
  }

  return t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        return [2, this.modelArtifacts];
      });
    });
  }, t;
}(),
    bd = function () {
  function t(t) {
    this.saveHandler = t;
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        return [2, this.saveHandler(t)];
      });
    });
  }, t;
}();

var wd = Object.freeze({
  browserFiles: function (t) {
    return new hd(t);
  },
  browserHTTPRequest: function (t, e) {
    return yd(t, e);
  },
  concatenateArrayBuffers: _f,
  decodeWeights: Tf,
  encodeWeights: function (t, e) {
    return n(this, void 0, void 0, function () {
      var o,
          a,
          i,
          s,
          u,
          c = this;
      return r(this, function (l) {
        switch (l.label) {
          case 0:
            for (o = [], a = [], i = Array.isArray(t) ? t.map(function (t) {
              return t.name;
            }) : Object.keys(t), s = function (s) {
              var u = i[s],
                  l = Array.isArray(t) ? t[s].tensor : t[u];
              if ("float32" !== l.dtype && "int32" !== l.dtype && "bool" !== l.dtype && "string" !== l.dtype) throw new Error("Unsupported dtype in weight '" + u + "': " + l.dtype);
              var h = {
                name: u,
                shape: l.shape,
                dtype: l.dtype
              };

              if ("string" === l.dtype) {
                var f = new Promise(function (t) {
                  return n(c, void 0, void 0, function () {
                    var e, n, o, a, i, s, u;
                    return r(this, function (r) {
                      switch (r.label) {
                        case 0:
                          return [4, l.bytes()];

                        case 1:
                          for (e = r.sent(), n = e.reduce(function (t, e) {
                            return t + e.length;
                          }, 0) + Af * e.length, o = new Uint8Array(n), a = 0, i = 0; i < e.length; i++) s = e[i], u = new Uint8Array(new Uint32Array([s.length]).buffer), o.set(u, a), a += Af, o.set(s, a), a += s.length;

                          return t(o), [2];
                      }
                    });
                  });
                });
                a.push(f);
              } else a.push(l.data());

              null != e && (h.group = e), o.push(h);
            }, u = 0; u < i.length; ++u) s(u);

            return [4, Promise.all(a)];

          case 1:
            return [2, {
              data: Df(l.sent()),
              specs: o
            }];
        }
      });
    });
  },
  fromMemory: function (t, e, n, r) {
    return 1 === arguments.length ? null != t.modelTopology || null != t.weightSpecs ? new xd(t) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new xd({
      modelTopology: t
    })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new xd({
      modelTopology: t,
      weightSpecs: e,
      weightData: n,
      trainingConfig: r
    }));
  },
  getLoadHandlers: function (t, e) {
    return Bf.getLoadHandlers(t, e);
  },
  getModelArtifactsInfoForJSON: Mf,
  getSaveHandlers: function (t) {
    return Bf.getSaveHandlers(t);
  },
  http: yd,
  isHTTPScheme: md,
  loadWeights: function (t, e, o, a) {
    return void 0 === e && (e = ""), n(this, void 0, void 0, function () {
      return r(this, function (n) {
        return [2, pd(function (t) {
          return dd(t, {
            requestInit: a
          });
        })(t, e, o)];
      });
    });
  },
  registerLoadRouter: function (t) {
    return Bf.registerLoadRouter(t);
  },
  registerSaveRouter: function (t) {
    return Bf.registerSaveRouter(t);
  },
  weightsLoaderFactory: pd,
  withSaveHandler: function (t) {
    return new bd(t);
  },
  copyModel: function (t, e) {
    return n(this, void 0, void 0, function () {
      return r(this, function (n) {
        return !1, [2, Uf(t, e, !1)];
      });
    });
  },
  listModels: function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i, s;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            t = Lf.getSchemes(), e = {}, n = 0, o = t, r.label = 1;

          case 1:
            return n < o.length ? (a = o[n], [4, Lf.getManager(a).listModels()]) : [3, 4];

          case 2:
            for (s in i = r.sent()) e[a + Pf + s] = i[s];

            r.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2, e];
        }
      });
    });
  },
  moveModel: function (t, e) {
    return n(this, void 0, void 0, function () {
      return r(this, function (n) {
        return !0, [2, Uf(t, e, !0)];
      });
    });
  },
  removeModel: function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        return e = Wf(t), [2, Lf.getManager(e.scheme).removeModel(e.path)];
      });
    });
  }
});
exports.io = wd;
var Cd,
    Ed = An({
  confusionMatrix_: function (t, e, n) {
    var r = mn(t, "labels", "confusionMatrix"),
        o = mn(e, "predictions", "confusionMatrix");
    C(null == n || n > 0 && Number.isInteger(n), function () {
      return "If provided, numClasses must be a positive integer, but got " + n;
    }), C(1 === r.rank, function () {
      return "Expected the rank of labels to be 1, but got " + r.rank;
    }), C(1 === o.rank, function () {
      return "Expected the rank of predictions to be 1, but got " + o.rank;
    }), C(r.shape[0] === o.shape[0], function () {
      return "Mismatch in the number of examples: " + r.shape[0] + " vs. " + o.shape[0] + ". Labels and predictions should have the same number of elements.";
    }), C(n > 0 && Number.isInteger(n), function () {
      return "numClasses is required to be a positive integer, but got " + n;
    });
    var a = ic(r.asType("int32"), n),
        i = ic(o.asType("int32"), n);
    return a.transpose().matMul(i).asType("int32");
  }
}),
    Rd = Object.freeze({
  confusionMatrix: Ed
});
exports.math = Rd;

var Id = An({
  fromPixels_: function (t, e) {
    if (void 0 === e && (e = 3), e > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
    if (null == t) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    var n = !1,
        r = !1,
        o = !1,
        a = !1,
        i = !1;
    if (t.data instanceof Uint8Array) n = !0;else if ("undefined" != typeof ImageData && t instanceof ImageData) r = !0;else if ("undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement) o = !0;else if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) a = !0;else {
      if (null == t.getContext) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t.constructor.name);
      i = !0;
    }

    if (o) {
      if (o && t.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
    }

    if (null != l("FromPixels", Lt.backendName)) return Lt.runKernel("FromPixels", {
      pixels: t
    }, {
      numChannels: e
    });
    var s,
        u,
        c = o ? [t.videoWidth, t.videoHeight] : [t.width, t.height],
        h = c[0],
        f = c[1];
    if (i ? s = t.getContext("2d").getImageData(0, 0, h, f).data : r || n ? s = t.data : (a || o) && (null == Cd && (Cd = document.createElement("canvas").getContext("2d")), Cd.canvas.width = h, Cd.canvas.height = f, Cd.drawImage(t, 0, 0, h, f), s = Cd.getImageData(0, 0, h, f).data), 4 === e) u = new Int32Array(s);else {
      var d = h * f;
      u = new Int32Array(d * e);

      for (var p = 0; p < d; p++) for (var v = 0; v < e; ++v) u[p * e + v] = s[4 * p + v];
    }
    return Pn(u, [f, h, e], "int32");
  }
}),
    kd = Object.freeze({
  toPixels: function (t, e) {
    return n(this, void 0, void 0, function () {
      var n, o, a, i, s, u, c, l, h, f, d, p, v, m, g, y, x, b, w, C, E, R, I;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (n = mn(t, "img", "toPixels"), t instanceof wt || (n = n.toInt()), 2 !== n.rank && 3 !== n.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n.rank + ".");
            if (o = n.shape.slice(0, 2), a = o[0], i = o[1], (s = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === s) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + s);
            return [4, n.data()];

          case 1:
            return u = r.sent(), c = n.min(), l = n.max(), [4, Promise.all([c.data(), l.data()])];

          case 2:
            if (h = r.sent(), f = h[0], d = h[1], p = f[0], v = d[0], c.dispose(), l.dispose(), "float32" === n.dtype) {
              if (p < 0 || v > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + p + " - " + v + "].");
            } else {
              if ("int32" !== n.dtype) throw new Error("Unsupported type for toPixels: " + n.dtype + ". Please use float32 or int32 tensors.");
              if (p < 0 || v > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + p + " - " + v + "].");
            }

            for (m = "float32" === n.dtype ? 255 : 1, g = new Uint8ClampedArray(i * a * 4), y = 0; y < a * i; ++y) x = void 0, b = void 0, w = void 0, C = void 0, 1 === s ? (x = u[y] * m, b = u[y] * m, w = u[y] * m, C = 255) : 3 === s ? (x = u[3 * y] * m, b = u[3 * y + 1] * m, w = u[3 * y + 2] * m, C = 255) : 4 === s && (x = u[4 * y] * m, b = u[4 * y + 1] * m, w = u[4 * y + 2] * m, C = u[4 * y + 3] * m), g[(E = 4 * y) + 0] = Math.round(x), g[E + 1] = Math.round(b), g[E + 2] = Math.round(w), g[E + 3] = Math.round(C);

            return null != e && (e.width = i, e.height = a, R = e.getContext("2d"), I = new ImageData(g, i, a), R.putImageData(I, 0, 0)), n !== t && n.dispose(), [2, g];
        }
      });
    });
  },
  fromPixels: Id
}),
    Sd = function () {
  function t() {}

  return t.prototype.getClassName = function () {
    return this.constructor.className;
  }, t.fromConfig = function (t, e) {
    return new t(e);
  }, t;
}(),
    Ad = function () {
  function t() {
    this.classNameMap = {};
  }

  return t.getMap = function () {
    return null == t.instance && (t.instance = new t()), t.instance;
  }, t.register = function (e) {
    t.getMap().classNameMap[e.className] = [e, e.fromConfig];
  }, t;
}();

exports.browser = kd;

function Td(t) {
  C(null != t.className, function () {
    return "Class being registered does not have the static className property defined.";
  }), C("string" == typeof t.className, function () {
    return "className is required to be a string, but got type " + typeof t.className;
  }), C(t.className.length > 0, function () {
    return "Class being registered has an empty-string as its className, which is disallowed.";
  }), Ad.register(t);
}

var Dd = Object.freeze({
  Serializable: Sd,
  SerializationMap: Ad,
  registerClass: Td
}),
    Nd = "1.7.1";
exports.version_core = Nd;
exports.serialization = Dd;

var Fd = Object.freeze({
  gpgpu_util: bs,
  webgl_util: Ge,
  forceHalfFloat: function () {
    i().set("WEBGL_FORCE_F16_TEXTURES", !0);
  },
  MathBackendWebGL: Lu,
  setWebGLContext: Kt,
  GPGPUContext: ws
}),
    _d = function (t) {
  function o() {
    return null !== t && t.apply(this, arguments) || this;
  }

  return e(o, t), o.prototype.minimize = function (t, e, n) {
    void 0 === e && (e = !1);
    var r = this.computeGradients(t, n),
        o = r.value,
        a = r.grads;

    if (null != n) {
      var i = n.map(function (t) {
        return {
          name: t.name,
          tensor: a[t.name]
        };
      });
      this.applyGradients(i);
    } else this.applyGradients(a);

    return tn(a), e ? o : (o.dispose(), null);
  }, Object.defineProperty(o.prototype, "iterations", {
    get: function () {
      return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
    },
    enumerable: !0,
    configurable: !0
  }), o.prototype.incrementIterations = function () {
    this.iterations_ = this.iterations + 1;
  }, o.prototype.computeGradients = function (t, e) {
    return ta(t, e);
  }, o.prototype.dispose = function () {
    null != this.iterations_ && tn(this.iterations_);
  }, o.prototype.saveIterations = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        return null == this.iterations_ && (this.iterations_ = 0), [2, {
          name: "iter",
          tensor: On(this.iterations_, "int32")
        }];
      });
    });
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("getWeights() is not implemented for this optimizer yet.");
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
      });
    });
  }, o.prototype.extractIterations = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return e = this, [4, t[0].tensor.data()];

          case 1:
            return e.iterations_ = n.sent()[0], [2, t.slice(1)];
        }
      });
    });
  }, o;
}(Sd);

exports.Optimizer = _d;
exports.webgl = Fd;
Object.defineProperty(_d, Symbol.hasInstance, {
  value: function (t) {
    return null != t.minimize && null != t.computeGradients && null != t.applyGradients;
  }
});

var Od = function (t) {
  function o(e, n, r) {
    void 0 === r && (r = null);
    var o = t.call(this) || this;
    return o.learningRate = e, o.rho = n, o.epsilon = r, o.accumulatedGrads = [], o.accumulatedUpdates = [], null == r && (o.epsilon = Lt.backend.epsilon()), o;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Lt.registeredVariables[n];
      null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {
        originalName: n + "/accum_grad",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      }), null == e.accumulatedUpdates[r] && (e.accumulatedUpdates[r] = {
        originalName: n + "/accum_var",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      });
      var a = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != a) {
        var i = e.accumulatedGrads[r].variable,
            s = e.accumulatedUpdates[r].variable;
        Ze(function () {
          var t = i.mul(e.rho).add(a.square().mul(1 - e.rho)),
              n = s.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a),
              r = s.mul(e.rho).add(n.square().mul(1 - e.rho));
          i.assign(t), s.assign(r);
          var u = n.mul(-e.learningRate).add(o);
          o.assign(u);
        });
      }
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    null != this.accumulatedUpdates && (tn(this.accumulatedGrads.map(function (t) {
      return t.variable;
    })), tn(this.accumulatedUpdates.map(function (t) {
      return t.variable;
    })));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];

          case 1:
            return [2, [e.sent()].concat(t.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = n.sent(), e = t.length / 2, !1, this.accumulatedGrads = t.slice(0, e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.accumulatedUpdates = t.slice(e, 2 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      rho: this.rho,
      epsilon: this.epsilon
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.rho, e.epsilon);
  }, o.className = "Adadelta", o;
}(_d);

exports.AdadeltaOptimizer = Od;
Td(Od);

var Md = function (t) {
  function o(e, n) {
    void 0 === n && (n = .1);
    var r = t.call(this) || this;
    return r.learningRate = e, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Lt.registeredVariables[n];

      if (null == e.accumulatedGrads[r]) {
        e.accumulatedGrads[r] = {
          originalName: n + "/accumulator",
          variable: Ze(function () {
            return Hn(o.shape, e.initialAccumulatorValue).variable(!1);
          })
        };
      }

      var a = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != a) {
        var i = e.accumulatedGrads[r].variable;
        Ze(function () {
          var t = i.add(a.square());
          i.assign(t);
          var n = a.div(t.add(Lt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);
          o.assign(n);
        });
      }
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    null != this.accumulatedGrads && tn(this.accumulatedGrads.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];

          case 1:
            return [2, [t.sent()].concat(this.accumulatedGrads.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = e.sent(), !1, this.accumulatedGrads = t.map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      initialAccumulatorValue: this.initialAccumulatorValue
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.initialAccumulatorValue);
  }, o.className = "Adagrad", o;
}(_d);

exports.AdagradOptimizer = Md;
Td(Md);

var Bd = function (t) {
  function o(e, n, r, o) {
    void 0 === o && (o = null);
    var a = t.call(this) || this;
    return a.learningRate = e, a.beta1 = n, a.beta2 = r, a.epsilon = o, a.accumulatedFirstMoment = [], a.accumulatedSecondMoment = [], Ze(function () {
      a.accBeta1 = On(n).variable(), a.accBeta2 = On(r).variable();
    }), null == o && (a.epsilon = Lt.backend.epsilon()), a;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this,
        n = Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t);
    Ze(function () {
      var r = No(1, e.accBeta1),
          o = No(1, e.accBeta2);
      n.forEach(function (n, a) {
        var i = Lt.registeredVariables[n];
        null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {
          originalName: n + "/m",
          variable: Ze(function () {
            return Xn(i).variable(!1);
          })
        }), null == e.accumulatedSecondMoment[a] && (e.accumulatedSecondMoment[a] = {
          originalName: n + "/v",
          variable: Ze(function () {
            return Xn(i).variable(!1);
          })
        });
        var s = Array.isArray(t) ? t[a].tensor : t[n];

        if (null != s) {
          var u = e.accumulatedFirstMoment[a].variable,
              c = e.accumulatedSecondMoment[a].variable,
              l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
              h = c.mul(e.beta2).add(s.square().mul(1 - e.beta2)),
              f = l.div(r),
              d = h.div(o);
          u.assign(l), c.assign(h);
          var p = f.div(d.sqrt().add(e.epsilon)).mul(-e.learningRate).add(i);
          i.assign(p);
        }
      }), e.accBeta1.assign(e.accBeta1.mul(e.beta1)), e.accBeta2.assign(e.accBeta2.mul(e.beta2));
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function (t) {
      return t.variable;
    })), null != this.accumulatedSecondMoment && tn(this.accumulatedSecondMoment.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];

          case 1:
            return [2, [e.sent()].concat(t.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e,
          n = this;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = r.sent(), Ze(function () {
              n.accBeta1.assign(Ao(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(Ao(n.beta2, n.iterations_ + 1));
            }), e = t.length / 2, !1, this.accumulatedFirstMoment = t.slice(0, e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.accumulatedSecondMoment = t.slice(e, 2 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.beta1, e.beta2, e.epsilon);
  }, o.className = "Adam", o;
}(_d);

exports.AdamOptimizer = Bd;
Td(Bd);

var Pd = function (t) {
  function o(e, n, r, o, a) {
    void 0 === o && (o = null), void 0 === a && (a = 0);
    var i = t.call(this) || this;
    return i.learningRate = e, i.beta1 = n, i.beta2 = r, i.epsilon = o, i.decay = a, i.accumulatedFirstMoment = [], i.accumulatedWeightedInfNorm = [], Ze(function () {
      i.iteration = On(0).variable(), i.accBeta1 = On(n).variable();
    }), null == o && (i.epsilon = Lt.backend.epsilon()), i;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this,
        n = Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t);
    Ze(function () {
      var r = No(1, e.accBeta1),
          o = _o(-e.learningRate, e.iteration.mul(e.decay).add(1));

      n.forEach(function (n, a) {
        var i = Lt.registeredVariables[n];
        null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {
          originalName: n + "/m",
          variable: Xn(i).variable(!1)
        }), null == e.accumulatedWeightedInfNorm[a] && (e.accumulatedWeightedInfNorm[a] = {
          originalName: n + "/v",
          variable: Xn(i).variable(!1)
        });
        var s = Array.isArray(t) ? t[a].tensor : t[n];

        if (null != s) {
          var u = e.accumulatedFirstMoment[a].variable,
              c = e.accumulatedWeightedInfNorm[a].variable,
              l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
              h = c.mul(e.beta2),
              f = s.abs(),
              d = h.maximum(f);
          u.assign(l), c.assign(d);
          var p = o.div(r).mul(l.div(d.add(e.epsilon))).add(i);
          i.assign(p);
        }
      }), e.iteration.assign(e.iteration.add(1)), e.accBeta1.assign(e.accBeta1.mul(e.beta1));
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function (t) {
      return t.variable;
    })), null != this.accumulatedWeightedInfNorm && tn(this.accumulatedWeightedInfNorm.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("getWeights() is not implemented for Adamax yet.");
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("setWeights() is not implemented for Adamax yet.");
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon,
      decay: this.decay
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay);
  }, o.className = "Adamax", o;
}(_d);

exports.AdamaxOptimizer = Pd;
Td(Pd);

var Ld = function (t) {
  function o(e) {
    var n = t.call(this) || this;
    return n.learningRate = e, n.setLearningRate(e), n;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != o) {
        var a = Lt.registeredVariables[n];
        Ze(function () {
          var t = e.c.mul(o).add(a);
          a.assign(t);
        });
      }
    }), this.incrementIterations();
  }, o.prototype.setLearningRate = function (t) {
    this.learningRate = t, null != this.c && this.c.dispose(), this.c = en(On(-t));
  }, o.prototype.dispose = function () {
    this.c.dispose();
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];

          case 1:
            return [2, [t.sent()]];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            if (0 !== (t = e.sent()).length) throw new Error("SGD optimizer does not have settable weights.");
            return [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate);
  }, o.className = "SGD", o;
}(_d);

exports.SGDOptimizer = Ld;
Td(Ld);

var Wd = function (t) {
  function o(e, n, r) {
    void 0 === r && (r = !1);
    var o = t.call(this, e) || this;
    return o.learningRate = e, o.momentum = n, o.useNesterov = r, o.accumulations = [], o.m = On(o.momentum), o;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Lt.registeredVariables[n];

      if (null == e.accumulations[r]) {
        e.accumulations[r] = {
          originalName: n + "/momentum",
          variable: Ze(function () {
            return Xn(o).variable(!1);
          })
        };
      }

      var a = e.accumulations[r].variable,
          i = Array.isArray(t) ? t[r].tensor : t[n];
      null != i && Ze(function () {
        var t,
            n = e.m.mul(a).add(i);
        t = e.useNesterov ? e.c.mul(i.add(n.mul(e.m))).add(o) : e.c.mul(n).add(o), a.assign(n), o.assign(t);
      });
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    this.m.dispose(), null != this.accumulations && tn(this.accumulations.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.setMomentum = function (t) {
    this.momentum = t;
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];

          case 1:
            return [2, [t.sent()].concat(this.accumulations.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = e.sent(), !1, this.accumulations = t.map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      momentum: this.momentum,
      useNesterov: this.useNesterov
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.momentum, e.useNesterov);
  }, o.className = "Momentum", o;
}(Ld);

exports.MomentumOptimizer = Wd;
Td(Wd);

var Ud = function (t) {
  function o(e, n, r, o, a) {
    void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === o && (o = null), void 0 === a && (a = !1);
    var i = t.call(this) || this;
    if (i.learningRate = e, i.decay = n, i.momentum = r, i.epsilon = o, i.accumulatedMeanSquares = [], i.accumulatedMoments = [], i.accumulatedMeanGrads = [], i.centered = a, null == o && (i.epsilon = Lt.backend.epsilon()), null == e) throw new Error("learningRate for RMSPropOptimizer must be defined.");
    return i;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Lt.registeredVariables[n];
      null == e.accumulatedMeanSquares[r] && (e.accumulatedMeanSquares[r] = {
        originalName: n + "/rms",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      }), null == e.accumulatedMoments[r] && (e.accumulatedMoments[r] = {
        originalName: n + "/momentum",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      }), null == e.accumulatedMeanGrads[r] && e.centered && (e.accumulatedMeanGrads[r] = {
        originalName: n + "/mg",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      });
      var a = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != a) {
        var i = e.accumulatedMeanSquares[r].variable,
            s = e.accumulatedMoments[r].variable;
        Ze(function () {
          var t = i.mul(e.decay).add(a.square().mul(1 - e.decay));

          if (e.centered) {
            var n = e.accumulatedMeanGrads[r].variable,
                u = n.mul(e.decay).add(a.mul(1 - e.decay)),
                c = s.mul(e.momentum).add(a.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));
            i.assign(t), n.assign(u), s.assign(c);
            var l = o.sub(c);
            o.assign(l);
          } else {
            var h = i.mul(e.decay).add(a.square().mul(1 - e.decay));
            c = s.mul(e.momentum).add(a.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));
            i.assign(h), s.assign(c);
            l = o.sub(c);
            o.assign(l);
          }
        });
      }
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    null != this.accumulatedMeanSquares && tn(this.accumulatedMeanSquares.map(function (t) {
      return t.variable;
    })), null != this.accumulatedMeanGrads && this.centered && tn(this.accumulatedMeanGrads.map(function (t) {
      return t.variable;
    })), null != this.accumulatedMoments && tn(this.accumulatedMoments.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [4, this.saveIterations()];

          case 1:
            return [2, [e.sent()].concat(t.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = n.sent(), e = this.centered ? t.length / 3 : t.length / 2, !1, this.accumulatedMeanSquares = t.slice(0, e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.accumulatedMoments = t.slice(e, 2 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            })), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      decay: this.decay,
      momentum: this.momentum,
      epsilon: this.epsilon,
      centered: this.centered
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered);
  }, o.className = "RMSProp", o;
}(_d);

exports.RMSPropOptimizer = Ud;
Td(Ud);

var Vd = function () {
  function t() {}

  return t.sgd = function (t) {
    return new Ld(t);
  }, t.momentum = function (t, e, n) {
    return void 0 === n && (n = !1), new Wd(t, e, n);
  }, t.rmsprop = function (t, e, n, r, o) {
    return void 0 === e && (e = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1), new Ud(t, e, n, r, o);
  }, t.adam = function (t, e, n, r) {
    return void 0 === t && (t = .001), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new Bd(t, e, n, r);
  }, t.adadelta = function (t, e, n) {
    return void 0 === t && (t = .001), void 0 === e && (e = .95), void 0 === n && (n = null), new Od(t, e, n);
  }, t.adamax = function (t, e, n, r, o) {
    return void 0 === t && (t = .002), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === o && (o = 0), new Pd(t, e, n, r, o);
  }, t.adagrad = function (t, e) {
    return void 0 === e && (e = .1), new Md(t, e);
  }, t;
}(),
    zd = {
  sgd: Vd.sgd,
  momentum: Vd.momentum,
  adadelta: Vd.adadelta,
  adagrad: Vd.adagrad,
  rmsprop: Vd.rmsprop,
  adamax: Vd.adamax,
  adam: Vd.adam
},
    Gd = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function (t) {
  return t();
};

exports.train = zd;

function Hd() {
  return new Promise(function (t) {
    return Gd(function () {
      return t();
    });
  });
}

wt.prototype.broadcastTo = function (t) {
  return Xu(this, t);
}, wt.prototype.div = function (t) {
  return _o(this, t);
}, wt.prototype.divNoNan = function (t) {
  return nc(this, t);
}, wt.prototype.squaredDifference = function (t) {
  return wc(this, t);
}, wt.prototype.tile = function (t) {
  return rc(this, t);
}, wt.prototype.oneHot = function (t, e, n) {
  return void 0 === e && (e = 1), void 0 === n && (n = 0), ic(this, t, e, n);
}, xt = nf;
},{"crypto":"node_modules/parcel-bundler/src/builtins/_empty.js","node-fetch":"node_modules/parcel-bundler/src/builtins/_empty.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js","process":"node_modules/process/browser.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadGraphModel = loadGraphModel;
exports.deregisterOp = deregisterOp;
exports.registerOp = registerOp;
exports.version_converter = exports.GraphModel = void 0;

var _tfjsCore = require("@tensorflow/tfjs-core");

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var DataType,
    SaverDef,
    __assign = function () {
  return (__assign = Object.assign || function (e) {
    for (var t, a = 1, r = arguments.length; a < r; a++) for (var n in t = arguments[a]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);

    return e;
  }).apply(this, arguments);
};

function __awaiter(e, t, a, r) {
  return new (a || (a = Promise))(function (n, s) {
    function o(e) {
      try {
        u(r.next(e));
      } catch (e) {
        s(e);
      }
    }

    function p(e) {
      try {
        u(r.throw(e));
      } catch (e) {
        s(e);
      }
    }

    function u(e) {
      e.done ? n(e.value) : new a(function (t) {
        t(e.value);
      }).then(o, p);
    }

    u((r = r.apply(e, t || [])).next());
  });
}

function __generator(e, t) {
  var a,
      r,
      n,
      s,
      o = {
    label: 0,
    sent: function () {
      if (1 & n[0]) throw n[1];
      return n[1];
    },
    trys: [],
    ops: []
  };
  return s = {
    next: p(0),
    throw: p(1),
    return: p(2)
  }, "function" == typeof Symbol && (s[Symbol.iterator] = function () {
    return this;
  }), s;

  function p(s) {
    return function (p) {
      return function (s) {
        if (a) throw new TypeError("Generator is already executing.");

        for (; o;) try {
          if (a = 1, r && (n = 2 & s[0] ? r.return : s[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, s[1])).done) return n;

          switch (r = 0, n && (s = [2 & s[0], n.value]), s[0]) {
            case 0:
            case 1:
              n = s;
              break;

            case 4:
              return o.label++, {
                value: s[1],
                done: !1
              };

            case 5:
              o.label++, r = s[1], s = [0];
              continue;

            case 7:
              s = o.ops.pop(), o.trys.pop();
              continue;

            default:
              if (!(n = (n = o.trys).length > 0 && n[n.length - 1]) && (6 === s[0] || 2 === s[0])) {
                o = 0;
                continue;
              }

              if (3 === s[0] && (!n || s[1] > n[0] && s[1] < n[3])) {
                o.label = s[1];
                break;
              }

              if (6 === s[0] && o.label < n[1]) {
                o.label = n[1], n = s;
                break;
              }

              if (n && o.label < n[2]) {
                o.label = n[2], o.ops.push(s);
                break;
              }

              n[2] && o.ops.pop(), o.trys.pop();
              continue;
          }

          s = t.call(e, o);
        } catch (e) {
          s = [6, e], r = 0;
        } finally {
          a = n = 0;
        }

        if (5 & s[0]) throw s[1];
        return {
          value: s[0] ? s[1] : void 0,
          done: !0
        };
      }([s, p]);
    };
  }
}

!function (e) {
  e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
}(DataType || (DataType = {})), function (e) {
  !function (e) {
    e[e.LEGACY = 0] = "LEGACY", e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2";
  }(e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}));
}(SaverDef || (SaverDef = {}));
var CUSTOM_OPS = {};

function registerOp(e, t) {
  var a = {
    tfOpName: e,
    category: "custom",
    inputs: [],
    attrs: [],
    customExecutor: t
  };
  CUSTOM_OPS[e] = a;
}

function getRegisteredOp(e) {
  return CUSTOM_OPS[e];
}

function deregisterOp(e) {
  delete CUSTOM_OPS[e];
}

function getParamValue(e, t, a, r) {
  var n = t.inputParams[e];

  if (n && void 0 !== n.inputIndexStart) {
    var s = n.inputIndexStart,
        o = 0 === n.inputIndexEnd ? void 0 : void 0 === n.inputIndexEnd ? s + 1 : n.inputIndexEnd;
    if ("tensor" === n.type) return getTensor(t.inputNames[n.inputIndexStart], a, r);
    if ("tensors" === n.type) return t.inputNames.slice(s, o).map(function (e) {
      return getTensor(e, a, r);
    });
    var p = Array.prototype.slice.call(getTensor(t.inputNames.slice(s)[0], a, r).dataSync());
    return "number" === n.type ? p[0] : p;
  }

  var u = t.attrParams[e];
  return u && u.value;
}

function getTensor(e, t, a) {
  var r = parseNodeName(e),
      n = r[0],
      s = r[1],
      o = a.currentContextIds.find(function (e) {
    return !!t[getNodeNameWithContextId(n, e)];
  });
  return void 0 !== o ? t[getNodeNameWithContextId(n, o)][s] : void 0;
}

function getTensorsForCurrentContenxt(e, t, a) {
  return t[getNodeNameWithContextId(e, a.currentContextId)];
}

function getNodeNameAndIndex(e, t) {
  var a = parseNodeName(e),
      r = a[0],
      n = a[1];
  return [getNodeNameWithContextId(r, t && t.currentContextId), n];
}

function getNodeNameWithContextId(e, t) {
  return t ? e + "-" + t : e;
}

function parseNodeName(e) {
  var t = e.lastIndexOf(":");
  return -1 === t ? [e, 0] : [e.substring(0, t), Number(e.substring(t + 1))];
}

function split$1(e, t) {
  for (var a = [], r = 0; r < e.length; r += t) a.push(e.slice(r, r + t));

  return a;
}

var json = [{
  tfOpName: "Add",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "AddV2",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "AddN",
  category: "arithmetic",
  inputs: [{
    start: 0,
    end: 0,
    name: "tensors",
    type: "tensors"
  }]
}, {
  tfOpName: "BiasAdd",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sub",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "RealDiv",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Div",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "DivNoNan",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "FloorDiv",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Mul",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Maximum",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }]
}, {
  tfOpName: "Minimum",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }]
}, {
  tfOpName: "Pow",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "SquaredDifference",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Mod",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "FloorMod",
  category: "arithmetic",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    arithmetic = Object.freeze({
  json: json
}),
    json$1 = [{
  tfOpName: "Abs",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Acos",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Asin",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Atan",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Atan2",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "y",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Ceil",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "ClipByValue",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "clip_value_min",
    name: "clipValueMin",
    type: "number"
  }, {
    tfName: "clip_value_max",
    name: "clipValueMax",
    type: "number"
  }]
}, {
  tfOpName: "Complex",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "real",
    type: "tensor"
  }, {
    start: 1,
    name: "imag",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "ComplexAbs",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Cos",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Cosh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Elu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Exp",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Floor",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Log",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Imag",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "Tout",
    name: "outputType",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Neg",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Real",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "Tout",
    name: "outputType",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Prelu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "alpha",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Relu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Relu6",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "clipValueMin",
    name: "clipValueMin",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "clipValueMax",
    name: "clipValueMax",
    type: "number",
    defaultValue: 6
  }]
}, {
  tfOpName: "Selu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sigmoid",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sin",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sinh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sqrt",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Rsqrt",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Square",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Tan",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Tanh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Sign",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Round",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Expm1",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Log1p",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Reciprocal",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Softplus",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Asinh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Acosh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Atanh",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Erf",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Prod",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axes",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool",
    notSupported: !0
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LeakyRelu",
  category: "basic_math",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "alpha",
    name: "alpha",
    type: "number",
    defaultValue: .2
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    basicMath = Object.freeze({
  json: json$1
}),
    json$2 = [{
  tfOpName: "LoopCond",
  category: "control",
  inputs: [{
    start: 0,
    name: "pred",
    type: "tensor"
  }]
}, {
  tfOpName: "Switch",
  category: "control",
  inputs: [{
    start: 0,
    name: "data",
    type: "tensor"
  }, {
    start: 1,
    name: "pred",
    type: "tensor"
  }]
}, {
  tfOpName: "Merge",
  category: "control",
  inputs: [{
    start: 0,
    end: 0,
    name: "tensors",
    type: "tensors"
  }]
}, {
  tfOpName: "Enter",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensor",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "frame_name",
    name: "frameName",
    type: "string"
  }, {
    tfName: "is_constant",
    name: "isConstant",
    type: "bool"
  }]
}, {
  tfOpName: "Exit",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensor",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "NextIteration",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensor",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "TensorArrayV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "size",
    type: "number"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "element_shape",
    name: "elementShape",
    type: "shape"
  }, {
    tfName: "dynamic_size",
    name: "dynamicSize",
    type: "bool"
  }, {
    tfName: "clear_after_read",
    name: "clearAfterRead",
    type: "bool"
  }, {
    tfName: "identical_element_shapes",
    name: "identicalElementShapes",
    type: "bool"
  }, {
    tfName: "tensor_array_name",
    name: "name",
    type: "string"
  }]
}, {
  tfOpName: "TensorArrayWriteV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "index",
    type: "number"
  }, {
    start: 2,
    name: "tensor",
    type: "tensor"
  }, {
    start: 3,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "TensorArrayReadV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "index",
    type: "number"
  }, {
    start: 2,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "TensorArrayGatherV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "indices",
    type: "number[]"
  }, {
    start: 2,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "element_shape",
    name: "elementShape",
    type: "shape"
  }]
}, {
  tfOpName: "TensorArrayScatterV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "indices",
    type: "number[]"
  }, {
    start: 2,
    name: "tensor",
    type: "tensor"
  }, {
    start: 3,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "TensorArrayConcatV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "element_shape_except0",
    name: "elementShapeExcept0",
    type: "shape",
    notSupported: !0
  }]
}, {
  tfOpName: "TensorArraySplitV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "tensor",
    type: "tensor"
  }, {
    start: 2,
    name: "lengths",
    type: "number[]"
  }, {
    start: 3,
    name: "flowIn",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "TensorArraySizeV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }, {
    start: 1,
    name: "flowIn",
    type: "number"
  }]
}, {
  tfOpName: "TensorArrayCloseV3",
  category: "control",
  inputs: [{
    start: 0,
    name: "tensorArrayId",
    type: "number"
  }]
}],
    control = Object.freeze({
  json: json$2
}),
    json$3 = [{
  tfOpName: "AvgPool",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }, {
    tfName: "ksize",
    name: "kernelSize",
    type: "number[]"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "MaxPool",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }, {
    tfName: "ksize",
    name: "kernelSize",
    type: "number[]"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "AvgPool3D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }, {
    tfName: "ksize",
    name: "kernelSize",
    type: "number[]"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "MaxPool3D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }, {
    tfName: "ksize",
    name: "kernelSize",
    type: "number[]"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Conv1D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "stride",
    name: "stride",
    type: "number"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NWC"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "dilation",
    name: "dilation",
    type: "number",
    defaultValue: 1
  }]
}, {
  tfOpName: "Conv2D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "useCudnnOnGpu",
    name: "useCudnnOnGpu",
    type: "bool"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]"
  }]
}, {
  tfOpName: "_FusedConv2D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }, {
    start: 2,
    end: 0,
    name: "args",
    type: "tensors"
  }],
  attrs: [{
    tfName: "num_args",
    name: "numArgs",
    type: "number"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "explicit_paddings",
    name: "explicitPaddings",
    type: "number[]",
    defaultValue: []
  }, {
    tfName: "use_cudnn_on_gpu",
    name: "useCudnnOnGpu",
    type: "bool",
    defaultValue: !0
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]",
    defaultValue: [1, 1, 1, 1]
  }, {
    tfName: "fused_ops",
    name: "fusedOps",
    type: "string[]",
    defaultValue: []
  }, {
    tfName: "epsilon",
    name: "epsilon",
    type: "number",
    defaultValue: 1e-4
  }]
}, {
  tfOpName: "Conv2DBackpropInput",
  category: "convolution",
  inputs: [{
    start: 2,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }, {
    start: 0,
    name: "outputShape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }]
}, {
  tfOpName: "DepthwiseConv2d",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "input",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]"
  }]
}, {
  tfOpName: "DepthwiseConv2dNative",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "input",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]"
  }]
}, {
  tfOpName: "FusedDepthwiseConv2dNative",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }, {
    start: 2,
    end: 0,
    name: "args",
    type: "tensors"
  }],
  attrs: [{
    tfName: "num_args",
    name: "numArgs",
    type: "number"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]",
    defaultValue: [1, 1, 1, 1]
  }, {
    tfName: "fused_ops",
    name: "fusedOps",
    type: "string[]",
    defaultValue: []
  }]
}, {
  tfOpName: "Conv3D",
  category: "convolution",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "filter",
    type: "tensor"
  }],
  attrs: [{
    tfName: "strides",
    name: "strides",
    type: "number[]"
  }, {
    tfName: "padding",
    name: "pad",
    type: "string"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    defaultValue: "NHWC"
  }, {
    tfName: "dilations",
    name: "dilations",
    type: "number[]"
  }]
}],
    convolution = Object.freeze({
  json: json$3
}),
    json$4 = [{
  tfOpName: "Fill",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }, {
    start: 1,
    name: "value",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "LinSpace",
  category: "creation",
  inputs: [{
    start: 0,
    name: "start",
    type: "number"
  }, {
    start: 1,
    name: "stop",
    type: "number"
  }, {
    start: 2,
    name: "num",
    type: "number"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "OneHot",
  category: "creation",
  inputs: [{
    start: 0,
    name: "indices",
    type: "tensor"
  }, {
    start: 1,
    name: "depth",
    type: "number"
  }, {
    start: 2,
    name: "onValue",
    type: "number",
    defaultValue: 1
  }, {
    start: 3,
    name: "offValue",
    type: "number",
    defaultValue: 0
  }],
  attrs: [{
    tfName: "axis",
    name: "axis",
    type: "number",
    notSupported: !0
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Ones",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "OnesLike",
  category: "creation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "RandomUniform",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "minval",
    name: "minval",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "maxval",
    name: "maxval",
    type: "number",
    defaultValue: 1
  }, {
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "seed",
    name: "seed",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "seed2",
    name: "seed2",
    type: "number",
    defaultValue: 0,
    notSupported: !0
  }, {
    tfName: "T",
    name: "T",
    type: "number",
    notSupported: !0
  }]
}, {
  tfOpName: "Range",
  category: "creation",
  inputs: [{
    start: 0,
    name: "start",
    type: "number"
  }, {
    start: 1,
    name: "stop",
    type: "number"
  }, {
    start: 2,
    name: "step",
    type: "number",
    defaultValue: 0
  }],
  attrs: [{
    tfName: "Tidx",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "TruncatedNormal",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "means",
    name: "mean",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "stddev",
    name: "stdDev",
    type: "number",
    defaultValue: 1
  }, {
    tfName: "seed",
    name: "seed",
    type: "number"
  }, {
    tfName: "seed2",
    name: "seed2",
    type: "number",
    defaultValue: 0,
    notSupported: !0
  }, {
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "T",
    name: "T",
    type: "number",
    notSupported: !0
  }]
}, {
  tfOpName: "Zeros",
  category: "creation",
  inputs: [{
    start: 0,
    name: "shape",
    type: "number[]"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "ZerosLike",
  category: "creation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "Multinomial",
  category: "creation",
  inputs: [{
    start: 0,
    name: "logits",
    type: "tensor"
  }, {
    start: 1,
    name: "numSamples",
    type: "number"
  }],
  attrs: [{
    tfName: "seed",
    name: "seed",
    type: "number"
  }, {
    tfName: "seed2",
    name: "seed2",
    type: "number"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype"
  }, {
    tfName: "output_dtype",
    name: "output_dtype",
    type: "dtype"
  }]
}],
    creation = Object.freeze({
  json: json$4
}),
    json$5 = [{
  tfOpName: "NonMaxSuppressionV2",
  category: "dynamic",
  inputs: [{
    start: 0,
    name: "boxes",
    type: "tensor"
  }, {
    start: 1,
    name: "scores",
    type: "tensor"
  }, {
    start: 2,
    name: "maxOutputSize",
    type: "number"
  }, {
    start: 3,
    name: "iouThreshold",
    type: "number"
  }]
}, {
  tfOpName: "NonMaxSuppressionV3",
  category: "dynamic",
  inputs: [{
    start: 0,
    name: "boxes",
    type: "tensor"
  }, {
    start: 1,
    name: "scores",
    type: "tensor"
  }, {
    start: 2,
    name: "maxOutputSize",
    type: "number"
  }, {
    start: 3,
    name: "iouThreshold",
    type: "number"
  }, {
    start: 4,
    name: "scoreThreshold",
    type: "number"
  }]
}, {
  tfOpName: "NonMaxSuppressionV5",
  category: "dynamic",
  inputs: [{
    start: 0,
    name: "boxes",
    type: "tensor"
  }, {
    start: 1,
    name: "scores",
    type: "tensor"
  }, {
    start: 2,
    name: "maxOutputSize",
    type: "number"
  }, {
    start: 3,
    name: "iouThreshold",
    type: "number"
  }, {
    start: 4,
    name: "scoreThreshold",
    type: "number"
  }, {
    start: 5,
    name: "softNmsSigma",
    type: "number"
  }]
}, {
  tfOpName: "Where",
  category: "dynamic",
  inputs: [{
    start: 0,
    name: "condition",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "ListDiff",
  category: "dynamic",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "y",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    dynamic = Object.freeze({
  json: json$5
}),
    json$6 = [{
  tfOpName: "TopKV2",
  category: "evaluation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "k",
    type: "number"
  }],
  attrs: [{
    tfName: "sorted",
    name: "sorted",
    type: "bool"
  }]
}],
    evaluation = Object.freeze({
  json: json$6
}),
    json$7 = [{
  tfOpName: "PlaceholderWithDefault",
  category: "graph",
  inputs: [{
    start: 0,
    name: "default",
    type: "tensor"
  }],
  attrs: [{
    tfName: "shape",
    name: "shape",
    type: "shape"
  }, {
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "Placeholder",
  category: "graph",
  attrs: [{
    tfName: "shape",
    name: "shape",
    type: "shape"
  }, {
    tfName: "dtype",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "Const",
  category: "graph"
}, {
  tfOpName: "Identity",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "IdentityN",
  category: "graph",
  inputs: [{
    start: 0,
    end: 0,
    name: "x",
    type: "tensors"
  }]
}, {
  tfOpName: "Snapshot",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "Rank",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "Size",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "Shape",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "ShapeN",
  category: "graph",
  inputs: [{
    start: 0,
    end: 0,
    name: "x",
    type: "tensors"
  }]
}, {
  tfOpName: "Print",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "data",
    type: "tensors"
  }],
  attrs: [{
    tfName: "message",
    name: "message",
    type: "string"
  }, {
    tfName: "first_n",
    name: "firstN",
    type: "number",
    notSupported: !0
  }, {
    tfName: "summarize",
    name: "summarize",
    type: "number",
    defaultValue: 3
  }]
}, {
  tfOpName: "NoOp",
  category: "graph",
  inputs: []
}, {
  tfOpName: "StopGradient",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "FakeQuantWithMinMaxVars",
  category: "graph",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "min",
    name: "min",
    type: "number"
  }, {
    tfName: "max",
    name: "max",
    type: "number"
  }]
}],
    graph = Object.freeze({
  json: json$7
}),
    json$8 = [{
  tfOpName: "ResizeBilinear",
  category: "image",
  inputs: [{
    start: 0,
    name: "images",
    type: "tensor"
  }, {
    start: 1,
    name: "size",
    type: "number[]"
  }],
  attrs: [{
    tfName: "align_corners",
    name: "alignCorners",
    type: "bool"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "ResizeNearestNeighbor",
  category: "image",
  inputs: [{
    start: 0,
    name: "images",
    type: "tensor"
  }, {
    start: 1,
    name: "size",
    type: "number[]"
  }],
  attrs: [{
    tfName: "align_corners",
    name: "alignCorners",
    type: "bool"
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "CropAndResize",
  category: "image",
  inputs: [{
    start: 0,
    name: "image",
    type: "tensor"
  }, {
    start: 1,
    name: "boxes",
    type: "tensor"
  }, {
    start: 2,
    name: "boxInd",
    type: "tensor"
  }, {
    start: 3,
    name: "cropSize",
    type: "number[]"
  }],
  attrs: [{
    tfName: "method",
    name: "method",
    type: "string"
  }, {
    tfName: "extrapolation_value",
    name: "extrapolationValue",
    type: "number"
  }]
}],
    image$1 = Object.freeze({
  json: json$8
}),
    json$9 = [{
  tfOpName: "Equal",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "NotEqual",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Greater",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "GreaterEqual",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Less",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LessEqual",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LogicalAnd",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LogicalNot",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "LogicalOr",
  category: "logical",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Select",
  category: "logical",
  inputs: [{
    start: 0,
    name: "condition",
    type: "tensor"
  }, {
    start: 1,
    name: "a",
    type: "tensor"
  }, {
    start: 2,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    logical = Object.freeze({
  json: json$9
}),
    json$10 = [{
  tfOpName: "_FusedMatMul",
  category: "matrices",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }, {
    start: 2,
    end: 0,
    name: "args",
    type: "tensors"
  }],
  attrs: [{
    tfName: "num_args",
    name: "numArgs",
    type: "number"
  }, {
    tfName: "fused_ops",
    name: "fusedOps",
    type: "string[]",
    defaultValue: []
  }, {
    tfName: "epsilon",
    name: "epsilon",
    type: "number",
    defaultValue: 1e-4
  }, {
    tfName: "transpose_a",
    name: "transposeA",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "transpose_b",
    name: "transposeB",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "MatMul",
  category: "matrices",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "transpose_a",
    name: "transposeA",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "transpose_b",
    name: "transposeB",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "BatchMatMul",
  category: "matrices",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "adj_x",
    name: "transposeA",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "adj_y",
    name: "transposeB",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "BatchMatMulV2",
  category: "matrices",
  inputs: [{
    start: 0,
    name: "a",
    type: "tensor"
  }, {
    start: 1,
    name: "b",
    type: "tensor"
  }],
  attrs: [{
    tfName: "adj_x",
    name: "transposeA",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "adj_y",
    name: "transposeB",
    type: "bool",
    defaultValue: !1
  }, {
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}, {
  tfOpName: "Transpose",
  category: "matrices",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "perm",
    type: "number[]"
  }],
  attrs: [{
    tfName: "T",
    name: "dtype",
    type: "dtype",
    notSupported: !0
  }]
}],
    matrices = Object.freeze({
  json: json$10
}),
    json$11 = [{
  tfOpName: "FusedBatchNorm",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "scale",
    type: "tensor"
  }, {
    start: 2,
    name: "offset",
    type: "tensor"
  }, {
    start: 3,
    name: "mean",
    type: "tensor"
  }, {
    start: 4,
    name: "variance",
    type: "tensor"
  }],
  attrs: [{
    tfName: "epsilon",
    name: "epsilon",
    type: "number",
    defaultValue: .001
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }]
}, {
  tfOpName: "FusedBatchNormV2",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "scale",
    type: "tensor"
  }, {
    start: 2,
    name: "offset",
    type: "tensor"
  }, {
    start: 3,
    name: "mean",
    type: "tensor"
  }, {
    start: 4,
    name: "variance",
    type: "tensor"
  }],
  attrs: [{
    tfName: "epsilon",
    name: "epsilon",
    type: "number",
    defaultValue: .001
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }]
}, {
  tfOpName: "FusedBatchNormV3",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "scale",
    type: "tensor"
  }, {
    start: 2,
    name: "offset",
    type: "tensor"
  }, {
    start: 3,
    name: "mean",
    type: "tensor"
  }, {
    start: 4,
    name: "variance",
    type: "tensor"
  }],
  attrs: [{
    tfName: "epsilon",
    name: "epsilon",
    type: "number",
    defaultValue: .001
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string",
    notSupported: !0
  }]
}, {
  tfOpName: "LRN",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "depth_radius",
    name: "radius",
    type: "number",
    defaultValue: 5
  }, {
    tfName: "bias",
    name: "bias",
    type: "number",
    defaultValue: 1
  }, {
    tfName: "alpha",
    name: "alpha",
    type: "number",
    defaultValue: 1
  }, {
    tfName: "beta",
    name: "beta",
    type: "number",
    defaultValue: .5
  }]
}, {
  tfOpName: "Softmax",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "LogSoftmax",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "SparseToDense",
  category: "normalization",
  inputs: [{
    start: 0,
    name: "sparseIndices",
    type: "tensor"
  }, {
    start: 1,
    name: "outputShape",
    type: "number[]"
  }, {
    start: 2,
    name: "sparseValues",
    type: "tensor"
  }, {
    start: 3,
    name: "defaultValue",
    type: "tensor"
  }],
  attrs: [{
    tfName: "validate_indices",
    name: "validateIndices",
    type: "bool",
    defaultValue: !0,
    notSupported: !0
  }]
}],
    normalization = Object.freeze({
  json: json$11
}),
    json$12 = [{
  tfOpName: "Max",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "Mean",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "Min",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "Sum",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "All",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "Any",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}, {
  tfOpName: "ArgMax",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number"
  }]
}, {
  tfOpName: "ArgMin",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number"
  }]
}, {
  tfOpName: "Prod",
  category: "reduction",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }],
  attrs: [{
    tfName: "keep_dims",
    name: "keepDims",
    type: "bool"
  }]
}],
    reduction = Object.freeze({
  json: json$12
}),
    json$13 = [{
  tfOpName: "ConcatV2",
  category: "slice_join",
  inputs: [{
    start: 0,
    end: -1,
    name: "tensors",
    type: "tensors"
  }, {
    start: -1,
    name: "axis",
    type: "number"
  }],
  attrs: [{
    tfName: "N",
    name: "n",
    type: "number",
    defaultValue: 2
  }]
}, {
  tfOpName: "Concat",
  category: "slice_join",
  inputs: [{
    start: 1,
    end: 0,
    name: "tensors",
    type: "tensors"
  }, {
    start: 0,
    name: "axis",
    type: "number"
  }],
  attrs: [{
    tfName: "N",
    name: "n",
    type: "number",
    defaultValue: 2
  }]
}, {
  tfOpName: "GatherV2",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "indices",
    type: "tensor"
  }, {
    start: 2,
    name: "axis",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "Gather",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "indices",
    type: "tensor"
  }],
  attrs: [{
    tfName: "axis",
    name: "axis",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "validate_indices",
    name: "validateIndices",
    type: "bool",
    notSupported: !0
  }]
}, {
  tfOpName: "Reverse",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "dims",
    type: "bool",
    notSupported: !0
  }]
}, {
  tfOpName: "ReverseV2",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number[]"
  }]
}, {
  tfOpName: "Slice",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "begin",
    type: "number[]"
  }, {
    start: 2,
    name: "size",
    type: "number[]"
  }]
}, {
  tfOpName: "StridedSlice",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "begin",
    type: "number[]"
  }, {
    start: 2,
    name: "end",
    type: "number[]"
  }, {
    start: 3,
    name: "strides",
    type: "number[]"
  }],
  attrs: [{
    tfName: "begin_mask",
    name: "beginMask",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "end_mask",
    name: "endMask",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "new_axis_mask",
    name: "newAxisMask",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "ellipsis_mask",
    name: "ellipsisMask",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "shrink_axis_mask",
    name: "shrinkAxisMask",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "Pack",
  category: "slice_join",
  inputs: [{
    start: 0,
    end: 0,
    name: "tensors",
    type: "tensors"
  }],
  attrs: [{
    tfName: "axis",
    name: "axis",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "Unpack",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "tensor",
    type: "tensor"
  }],
  attrs: [{
    tfName: "axis",
    name: "axis",
    type: "number",
    defaultValue: 0
  }, {
    tfName: "num",
    name: "num",
    type: "number",
    defaultValue: 0,
    notSupported: !0
  }]
}, {
  tfOpName: "Tile",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "reps",
    type: "number[]"
  }]
}, {
  tfOpName: "Split",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "axis",
    type: "number",
    defaultValue: 0
  }, {
    start: 1,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "num_split",
    name: "numOrSizeSplits",
    type: "number",
    defaultValue: 1
  }]
}, {
  tfOpName: "SplitV",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "numOrSizeSplits",
    type: "number[]"
  }, {
    start: 2,
    name: "axis",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "ScatterNd",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "indices",
    type: "tensor"
  }, {
    start: 1,
    name: "values",
    type: "tensor"
  }, {
    start: 2,
    name: "shape",
    type: "number[]"
  }]
}, {
  tfOpName: "GatherNd",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "indices",
    type: "tensor"
  }]
}, {
  tfOpName: "SparseToDense",
  category: "slice_join",
  inputs: [{
    start: 0,
    name: "sparseIndices",
    type: "tensor"
  }, {
    start: 1,
    name: "outputShape",
    type: "number[]"
  }, {
    start: 2,
    name: "sparseValues",
    type: "tensor"
  }, {
    start: 3,
    name: "defaultValue",
    type: "tensor"
  }],
  attrs: [{
    tfName: "validate_indices",
    name: "validateIndices",
    type: "bool",
    defaultValue: !1,
    notSupported: !0
  }]
}],
    sliceJoin = Object.freeze({
  json: json$13
}),
    json$14 = [{
  tfOpName: "FFT",
  category: "spectral",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "IFFT",
  category: "spectral",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }]
}, {
  tfOpName: "RFFT",
  category: "spectral",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "fft_length",
    type: "number",
    notSupported: !0
  }]
}, {
  tfOpName: "IRFFT",
  category: "spectral",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "fft_length",
    type: "number",
    notSupported: !0
  }]
}],
    spectral = Object.freeze({
  json: json$14
}),
    json$15 = [{
  tfOpName: "Cast",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "SrcT",
    name: "sdtype",
    type: "dtype",
    notSupported: !0
  }, {
    tfName: "DstT",
    name: "dtype",
    type: "dtype"
  }]
}, {
  tfOpName: "ExpandDims",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "axis",
    type: "number"
  }]
}, {
  tfOpName: "Pad",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "padding",
    type: "number[]"
  }],
  attrs: [{
    tfName: "constant_value",
    name: "constantValue",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "PadV2",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "padding",
    type: "number[]"
  }, {
    start: 2,
    name: "constantValue",
    type: "number",
    defaultValue: 0
  }]
}, {
  tfOpName: "Reshape",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "shape",
    type: "number[]"
  }]
}, {
  tfOpName: "Squeeze",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "axis",
    tfDeprecatedName: "squeeze_dims",
    name: "axis",
    type: "number[]"
  }]
}, {
  tfOpName: "SpaceToBatchND",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "blockShape",
    type: "number[]"
  }, {
    start: 2,
    name: "paddings",
    type: "number[]"
  }]
}, {
  tfOpName: "BatchToSpaceND",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }, {
    start: 1,
    name: "blockShape",
    type: "number[]"
  }, {
    start: 2,
    name: "crops",
    type: "number[]"
  }]
}, {
  tfOpName: "DepthToSpace",
  category: "transformation",
  inputs: [{
    start: 0,
    name: "x",
    type: "tensor"
  }],
  attrs: [{
    tfName: "block_size",
    name: "blockSize",
    type: "number"
  }, {
    tfName: "data_format",
    name: "dataFormat",
    type: "string"
  }]
}],
    transformation = Object.freeze({
  json: json$15
}),
    OperationMapper = function () {
  function e() {
    var e = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, logical, image$1, graph, matrices, normalization, reduction, sliceJoin, spectral, transformation],
        t = [].concat.apply([], e.map(function (e) {
      return e.json;
    }));
    this.opMappers = t.reduce(function (e, t) {
      return e[t.tfOpName] = t, e;
    }, {});
  }

  return Object.defineProperty(e, "Instance", {
    get: function () {
      return this._instance || (this._instance = new this());
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.transformGraph = function (e, t) {
    var a = this;
    void 0 === t && (t = {});
    var r = [],
        n = [],
        s = e.node.reduce(function (e, t) {
      return e[t.name] = a.mapNode(t), t.op.startsWith("Placeholder") && r.push(e[t.name]), "Const" === t.op && n.push(e[t.name]), e;
    }, {}),
        o = [],
        p = [],
        u = {},
        i = {};
    null != t && (u = this.mapSignatureEntries(t.inputs), i = this.mapSignatureEntries(t.outputs));
    var m = Object.keys(s);
    return m.forEach(function (e) {
      var t = s[e];
      t.inputNames.forEach(function (e) {
        var a = getNodeNameAndIndex(e)[0];
        t.inputs.push(s[a]), s[a].children.push(t);
      });
    }), 0 === Object.keys(i).length ? m.forEach(function (e) {
      var t = s[e];
      0 === t.children.length && p.push(t);
    }) : Object.keys(i).forEach(function (e) {
      var t = getNodeNameAndIndex(e)[0],
          a = s[t];
      null != a && (a.signatureKey = i[e], p.push(a));
    }), Object.keys(u).length > 0 ? Object.keys(u).forEach(function (e) {
      var t = getNodeNameAndIndex(e)[0],
          a = s[t];
      a && (a.signatureKey = u[e], o.push(a));
    }) : o = r, {
      nodes: s,
      inputs: o,
      outputs: p,
      weights: n,
      placeholders: r,
      signature: t
    };
  }, e.prototype.mapSignatureEntries = function (e) {
    return Object.keys(e || {}).reduce(function (t, a) {
      return t[e[a].name] = a, t;
    }, {});
  }, e.prototype.mapNode = function (e) {
    var t = getRegisteredOp(e.op) || this.opMappers[e.op] || {};
    null == e.attr && (e.attr = {});
    var a = {
      name: e.name,
      op: e.op,
      category: t.category,
      inputNames: (e.input || []).map(function (e) {
        return e.startsWith("^") ? e.substr(1) : e;
      }),
      inputs: [],
      children: [],
      inputParams: {},
      attrParams: {},
      rawAttrs: e.attr
    };
    return null != t.inputs && (a.inputParams = t.inputs.reduce(function (e, t) {
      return e[t.name] = {
        type: t.type,
        inputIndexStart: t.start,
        inputIndexEnd: t.end
      }, e;
    }, {})), null != t.attrs && (a.attrParams = t.attrs.reduce(function (t, a) {
      var r = a.type,
          n = void 0;

      switch (a.type) {
        case "string":
          void 0 === (n = getStringParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getStringParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "string[]":
          void 0 === (n = getStringArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getStringArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "number":
          void 0 === (n = getNumberParam(e.attr, a.tfName, a.defaultValue || 0)) && a.tfDeprecatedName && (n = getNumberParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "number[]":
          void 0 === (n = getNumericArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getNumericArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "bool":
          void 0 === (n = getBoolParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getBoolParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "bool[]":
          void 0 === (n = getBoolArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getBoolArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "shape":
          void 0 === (n = getTensorShapeParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getTensorShapeParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "shape[]":
          void 0 === (n = getTensorShapeArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getTensorShapeArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "dtype":
          void 0 === (n = getDtypeParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getDtypeParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "dtype[]":
          void 0 === (n = getDtypeArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getDtypeArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));
          break;

        case "tensor":
        case "tensors":
          break;

        default:
          throw new Error("Unsupported param type: " + a.type + " for op: " + e.op);
      }

      return t[a.name] = {
        value: n,
        type: r
      }, t;
    }, {})), a;
  }, e;
}();

function decodeBase64(e) {
  var t = (0, _tfjsCore.env)().global;
  if (void 0 !== t.atob) return t.atob(e);
  if ("undefined" != typeof Buffer) return new Buffer(e, "base64").toString();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}

function parseStringParam(e, t) {
  var a = Array.isArray(e) ? String.fromCharCode.apply(null, e) : decodeBase64(e);
  return t ? a : a.toLowerCase();
}

function getStringParam(e, t, a, r) {
  void 0 === r && (r = !1);
  var n = e[t];
  return null != n ? parseStringParam(n.s, r) : a;
}

function getBoolParam(e, t, a) {
  var r = e[t];
  return r ? r.b : a;
}

function getNumberParam(e, t, a) {
  var r = e[t] || {},
      n = null != r.i ? r.i : null != r.f ? r.f : a;
  return "number" == typeof n ? n : parseInt(n, 10);
}

function parseDtypeParam(e) {
  switch ("string" == typeof e && (e = DataType[e]), e) {
    case DataType.DT_FLOAT:
      return "float32";

    case DataType.DT_INT32:
    case DataType.DT_INT64:
      return "int32";

    case DataType.DT_BOOL:
      return "bool";

    case DataType.DT_DOUBLE:
      return "float32";

    case DataType.DT_STRING:
      return "string";

    default:
      return null;
  }
}

function getDtypeParam(e, t, a) {
  var r = e[t];
  return r && r.type ? parseDtypeParam(r.type) : a;
}

function getDtypeArrayParam(e, t, a) {
  var r = e[t];
  return r && r.list && r.list.type ? r.list.type.map(function (e) {
    return parseDtypeParam(e);
  }) : a;
}

function parseTensorShapeParam(e) {
  if (!e.unknownRank) return null != e.dim ? e.dim.map(function (e) {
    return "number" == typeof e.size ? e.size : parseInt(e.size, 10);
  }) : [];
}

function getTensorShapeParam(e, t, a) {
  var r = e[t];
  return r && r.shape ? parseTensorShapeParam(r.shape) : a;
}

function getNumericArrayParam(e, t, a) {
  var r = e[t];
  return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(function (e) {
    return "number" == typeof e ? e : parseInt(e, 10);
  }) : a;
}

function getStringArrayParam(e, t, a, r) {
  void 0 === r && (r = !1);
  var n = e[t];
  return n && n.list && n.list.s ? n.list.s.map(function (e) {
    return parseStringParam(e, r);
  }) : a;
}

function getTensorShapeArrayParam(e, t, a) {
  var r = e[t];
  return r && r.list && r.list.shape ? r.list.shape.map(function (e) {
    return parseTensorShapeParam(e);
  }) : a;
}

function getBoolArrayParam(e, t, a) {
  var r = e[t];
  return r && r.list && r.list.b ? r.list.b : a;
}

var NodeValueImpl = function () {
  function e(e, t, a) {
    var r = this;
    this.node = e, this.tensorMap = t, this.context = a, this.inputs = [], this.attrs = {}, this.inputs = e.inputNames.map(function (e) {
      return r.getInput(e);
    }), null != e.rawAttrs && (this.attrs = Object.keys(e.rawAttrs).reduce(function (e, t) {
      return e[t] = r.getAttr(t), e;
    }, {}));
  }

  return e.prototype.getInput = function (e) {
    return getTensor(e, this.tensorMap, this.context);
  }, e.prototype.getAttr = function (e, t) {
    var a = this.node.rawAttrs[e];
    if (null != a.tensor) return getTensor(e, this.tensorMap, this.context);
    if (null != a.i || null != a.f) return getNumberParam(this.node.rawAttrs, e, t);
    if (null != a.s) return getStringParam(this.node.rawAttrs, e, t);
    if (null != a.b) return getBoolParam(this.node.rawAttrs, e, t);
    if (null != a.shape) return getTensorShapeParam(this.node.rawAttrs, e, t);
    if (null != a.type) return getDtypeParam(this.node.rawAttrs, e, t);

    if (null != a.list) {
      if (null != a.list.i || null != a.list.f) return getNumericArrayParam(this.node.rawAttrs, e, t);
      if (null != a.list.s) return getStringArrayParam(this.node.rawAttrs, e, t);
      if (null != a.list.shape) return getTensorShapeArrayParam(this.node.rawAttrs, e, t);
      if (null != a.list.b) return getBoolArrayParam(this.node.rawAttrs, e, t);
      if (null != a.list.type) return getDtypeArrayParam(this.node.rawAttrs, e, t);
    }

    return t;
  }, e;
}(),
    executeOp = function (e, t, a) {
  switch (e.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [(0, _tfjsCore.add)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "AddN":
      return [(0, _tfjsCore.addN)(getParamValue("tensors", e, t, a))];

    case "FloorMod":
    case "Mod":
      return [(0, _tfjsCore.mod)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Mul":
      return [(0, _tfjsCore.mul)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "RealDiv":
    case "Div":
      return [(0, _tfjsCore.div)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "DivNoNan":
      return [(0, _tfjsCore.divNoNan)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "FloorDiv":
      return [(0, _tfjsCore.floorDiv)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Sub":
      return [(0, _tfjsCore.sub)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Minimum":
      return [(0, _tfjsCore.minimum)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Maximum":
      return [(0, _tfjsCore.maximum)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Pow":
      return [(0, _tfjsCore.pow)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "SquaredDifference":
      return [(0, _tfjsCore.squaredDifference)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$1 = function (e, t, a) {
  switch (e.op) {
    case "Abs":
    case "ComplexAbs":
      return [(0, _tfjsCore.abs)(getParamValue("x", e, t, a))];

    case "Acos":
      return [(0, _tfjsCore.acos)(getParamValue("x", e, t, a))];

    case "Acosh":
      return [(0, _tfjsCore.acosh)(getParamValue("x", e, t, a))];

    case "Asin":
      return [(0, _tfjsCore.asin)(getParamValue("x", e, t, a))];

    case "Asinh":
      return [(0, _tfjsCore.asinh)(getParamValue("x", e, t, a))];

    case "Atan":
      return [(0, _tfjsCore.atan)(getParamValue("x", e, t, a))];

    case "Atan2":
      return [(0, _tfjsCore.atan2)(getParamValue("x", e, t, a), getParamValue("y", e, t, a))];

    case "Atanh":
      return [(0, _tfjsCore.atanh)(getParamValue("x", e, t, a))];

    case "Ceil":
      return [(0, _tfjsCore.ceil)(getParamValue("x", e, t, a))];

    case "Complex":
      return [(0, _tfjsCore.complex)(getParamValue("real", e, t, a), getParamValue("imag", e, t, a))];

    case "Cos":
      return [(0, _tfjsCore.cos)(getParamValue("x", e, t, a))];

    case "Cosh":
      return [(0, _tfjsCore.cosh)(getParamValue("x", e, t, a))];

    case "Elu":
      return [(0, _tfjsCore.elu)(getParamValue("x", e, t, a))];

    case "Erf":
      return [(0, _tfjsCore.erf)(getParamValue("x", e, t, a))];

    case "Exp":
      return [(0, _tfjsCore.exp)(getParamValue("x", e, t, a))];

    case "Expm1":
      return [(0, _tfjsCore.expm1)(getParamValue("x", e, t, a))];

    case "Floor":
      return [(0, _tfjsCore.floor)(getParamValue("x", e, t, a))];

    case "Log":
      return [(0, _tfjsCore.log)(getParamValue("x", e, t, a))];

    case "Log1p":
      return [(0, _tfjsCore.log1p)(getParamValue("x", e, t, a))];

    case "Imag":
      return [(0, _tfjsCore.imag)(getParamValue("x", e, t, a))];

    case "Neg":
      return [(0, _tfjsCore.neg)(getParamValue("x", e, t, a))];

    case "Reciprocal":
      return [(0, _tfjsCore.reciprocal)(getParamValue("x", e, t, a))];

    case "Real":
      return [(0, _tfjsCore.real)(getParamValue("x", e, t, a))];

    case "Relu":
      return [(0, _tfjsCore.relu)(getParamValue("x", e, t, a))];

    case "Round":
      return [(0, _tfjsCore.round)(getParamValue("x", e, t, a))];

    case "Selu":
      return [(0, _tfjsCore.selu)(getParamValue("x", e, t, a))];

    case "Sigmoid":
      return [(0, _tfjsCore.sigmoid)(getParamValue("x", e, t, a))];

    case "Sin":
      return [(0, _tfjsCore.sin)(getParamValue("x", e, t, a))];

    case "Sign":
      return [(0, _tfjsCore.sign)(getParamValue("x", e, t, a))];

    case "Sinh":
      return [(0, _tfjsCore.sinh)(getParamValue("x", e, t, a))];

    case "Softplus":
      return [(0, _tfjsCore.softplus)(getParamValue("x", e, t, a))];

    case "Sqrt":
      return [(0, _tfjsCore.sqrt)(getParamValue("x", e, t, a))];

    case "Square":
      return [(0, _tfjsCore.square)(getParamValue("x", e, t, a))];

    case "Tanh":
      return [(0, _tfjsCore.tanh)(getParamValue("x", e, t, a))];

    case "Tan":
      return [(0, _tfjsCore.tan)(getParamValue("x", e, t, a))];

    case "Relu6":
    case "ClipByValue":
      return [(0, _tfjsCore.clipByValue)(getParamValue("x", e, t, a), getParamValue("clipValueMin", e, t, a), getParamValue("clipValueMax", e, t, a))];

    case "Rsqrt":
      return [(0, _tfjsCore.rsqrt)(getTensor(e.inputNames[0], t, a))];

    case "Prod":
      return [(0, _tfjsCore.prod)(getParamValue("x", e, t, a), getParamValue("axes", e, t, a))];

    case "LeakyRelu":
      return [(0, _tfjsCore.leakyRelu)(getParamValue("x", e, t, a), getParamValue("alpha", e, t, a))];

    case "Prelu":
      return [(0, _tfjsCore.prelu)(getParamValue("x", e, t, a), getParamValue("alpha", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    TensorArray = function () {
  function e(t, a, r, n, s, o, p) {
    this.name = t, this.dtype = a, this.maxSize = r, this.elementShape = n, this.identicalElementShapes = s, this.dynamicSize = o, this.clearAfterRead = p, this.tensors = [], this.closed_ = !1, this.id = e.nextId++;
  }

  return Object.defineProperty(e.prototype, "closed", {
    get: function () {
      return this.closed_;
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.clearAndClose = function () {
    this.tensors.forEach(function (e) {
      return e.tensor.dispose();
    }), this.tensors = [], this.closed_ = !0;
  }, e.prototype.size = function () {
    return this.tensors.length;
  }, e.prototype.read = function (e) {
    if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
    if (e < 0 || e >= this.tensors.length) throw new Error("Tried to read from index " + e + ", but array size is: " + this.tensors.length);
    var t = this.tensors[e];
    if (t.cleared) throw new Error("TensorArray " + this.name + ": Could not read index " + e + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
    return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor;
  }, e.prototype.readMany = function (e) {
    var t = this;
    return e.map(function (e) {
      return t.read(e);
    });
  }, e.prototype.write = function (e, t) {
    if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
    if (e < 0 || !this.dynamicSize && e >= this.maxSize) throw new Error("Tried to write to index " + e + ", but array is not resizeable and size is: " + this.maxSize);
    var a = this.tensors[e] || {};
    if (t.dtype !== this.dtype) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ",\n          because the value dtype is " + t.dtype + ", but TensorArray dtype is " + this.dtype + ".");
    if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, t.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + e + "."), a && a.read) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ", because it has already been read.");
    if (a && a.written) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ", because it has already been written.");
    a.tensor = t, a.written = !0, this.tensors[e] = a;
  }, e.prototype.writeMany = function (e, t) {
    var a = this;
    if (e.length !== t.length) throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + e.length + " is not the same as tensors size: " + t.length + ".");
    e.forEach(function (e, r) {
      return a.write(e, t[r]);
    });
  }, e.prototype.gather = function (e, t) {
    if (t && t !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + t);

    if (!e) {
      e = [];

      for (var a = 0; a < this.size(); a++) e.push(a);
    }

    if (0 === e.length) return (0, _tfjsCore.tensor)([], [0].concat(this.elementShape));
    var r = this.readMany(e);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: "), (0, _tfjsCore.stack)(r, 0);
  }, e.prototype.concat = function (e) {
    if (e && e !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + e);
    if (0 === this.size()) return (0, _tfjsCore.tensor)([], [0].concat(this.elementShape));

    for (var t = [], a = 0; a < this.size(); a++) t.push(a);

    var r = this.readMany(t);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + r[0].shape + ")"), (0, _tfjsCore.concat)(r, 0);
  }, e.prototype.scatter = function (e, t) {
    if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
    if (e.length !== t.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + e.length + " vs. " + t.shape[0]);
    var a = Math.max.apply(Math, e);
    if (!this.dynamicSize && a >= this.maxSize) throw new Error("Max index must be < array size (" + a + "  vs. " + this.maxSize + ")");
    this.writeMany(e, (0, _tfjsCore.unstack)(t, 0));
  }, e.prototype.split = function (e, t) {
    var a = this;
    if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
    var r = 0,
        n = e.map(function (e) {
      return r += e;
    });
    if (r !== t.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r + ", and tensor's shape is: " + t.shape);
    if (!this.dynamicSize && e.length !== this.maxSize) throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + e.length + "), and the TensorArray is not marked as dynamically resizeable");
    var s = 0 === r ? 0 : t.size / r,
        o = [];
    (0, _tfjsCore.tidy)(function () {
      t = t.reshape([1, r, s]);

      for (var p = 0; p < e.length; ++p) {
        var u = [0, 0 === p ? 0 : n[p - 1], 0],
            i = [1, e[p], s];
        o[p] = (0, _tfjsCore.slice)(t, u, i).reshape(a.elementShape);
      }

      return o;
    });

    for (var p = [], u = 0; u < e.length; u++) p[u] = u;

    this.writeMany(p, o);
  }, e.prototype.assertShapesMatchAllowUndefinedSize = function (e, t, a) {
    void 0 === a && (a = ""), _tfjsCore.util.assert(this.shapesEqualAllowUndefinedSize(e, t), function () {
      return a + " Shapes " + e + " and " + t + " must match";
    });
  }, e.prototype.shapesEqualAllowUndefinedSize = function (e, t) {
    if (e.length !== t.length) return !1;

    for (var a = 0; a < e.length; a++) if (-1 !== e[a] && -1 !== t[a] && e[a] !== t[a]) return !1;

    return !0;
  }, e.nextId = 0, e;
}(),
    _this = void 0,
    executeOp$2 = function (e, t, a) {
  return __awaiter(_this, void 0, void 0, function () {
    var r, n, s, o, p, u, i, m, l, c, d, y, f, g, h, N, x, V, b, P, T, v, O, S, _, w, A, D, E, I, C, M, k, F, z;

    return __generator(this, function (j) {
      switch (j.label) {
        case 0:
          switch (e.op) {
            case "LoopCond":
              return [3, 1];

            case "Switch":
              return [3, 2];

            case "Merge":
              return [3, 4];

            case "Enter":
              return [3, 5];

            case "Exit":
              return [3, 6];

            case "NextIteration":
              return [3, 7];

            case "TensorArrayV3":
              return [3, 8];

            case "TensorArrayWriteV3":
              return [3, 9];

            case "TensorArrayReadV3":
              return [3, 10];

            case "TensorArrayGatherV3":
              return [3, 11];

            case "TensorArrayScatterV3":
              return [3, 12];

            case "TensorArrayConcatV3":
              return [3, 13];

            case "TensorArraySplitV3":
              return [3, 14];

            case "TensorArraySizeV3":
              return [3, 15];

            case "TensorArrayCloseV3":
              return [3, 16];
          }

          return [3, 17];

        case 1:
          return [2, [getParamValue("pred", e, t, a).clone()]];

        case 2:
          return r = getParamValue("pred", e, t, a), n = getParamValue("data", e, t, a), [4, r.data()];

        case 3:
          return [2, j.sent()[0] ? [void 0, n.clone()] : [n.clone(), void 0]];

        case 4:
          return [2, (s = e.inputNames.find(function (e) {
            return void 0 !== getTensor(e, t, a);
          })) ? [getTensor(s, t, a).clone()] : void 0];

        case 5:
          return o = getParamValue("frameName", e, t, a), p = getParamValue("tensor", e, t, a), a.enterFrame(o), [2, [p.clone()]];

        case 6:
          return u = getParamValue("tensor", e, t, a), a.exitFrame(), [2, [u.clone()]];

        case 7:
          return i = getParamValue("tensor", e, t, a), a.nextIteration(), [2, [i.clone()]];

        case 8:
          return m = getParamValue("size", e, t, a), l = getParamValue("dtype", e, t, a), c = getParamValue("elementShape", e, t, a), d = getParamValue("dynamicSize", e, t, a), y = getParamValue("clearAfterRead", e, t, a), f = getParamValue("identicalElementShapes", e, t, a), g = getParamValue("name", e, t, a), h = new TensorArray(g, l, m, c, f, d, y), a.addTensorArray(h), [2, [(0, _tfjsCore.scalar)(h.id), (0, _tfjsCore.scalar)(1)]];

        case 9:
          return N = getParamValue("tensorArrayId", e, t, a), x = getParamValue("index", e, t, a), V = getParamValue("tensor", e, t, a), a.getTensorArray(N).write(x, V), [2, [(0, _tfjsCore.scalar)(1)]];

        case 10:
          return b = getParamValue("tensorArrayId", e, t, a), P = getParamValue("index", e, t, a), [2, [a.getTensorArray(b).read(P)]];

        case 11:
          return T = getParamValue("tensorArrayId", e, t, a), v = getParamValue("indices", e, t, a), O = getParamValue("dtype", e, t, a), [2, [a.getTensorArray(T).gather(v, O)]];

        case 12:
          return S = getParamValue("tensorArrayId", e, t, a), _ = getParamValue("indices", e, t, a), w = getParamValue("tensor", e, t, a), a.getTensorArray(S).scatter(_, w), [2, [(0, _tfjsCore.scalar)(1)]];

        case 13:
          return A = getParamValue("tensorArrayId", e, t, a), D = a.getTensorArray(A), E = getParamValue("dtype", e, t, a), [2, [D.concat(E)]];

        case 14:
          return I = getParamValue("tensorArrayId", e, t, a), C = getParamValue("tensor", e, t, a), M = getParamValue("lengths", e, t, a), a.getTensorArray(I).split(M, C), [2, [(0, _tfjsCore.scalar)(1)]];

        case 15:
          return k = getParamValue("tensorArrayId", e, t, a), F = a.getTensorArray(k), [2, [(0, _tfjsCore.scalar)(F.size(), "int32")]];

        case 16:
          return z = getParamValue("tensorArrayId", e, t, a), a.getTensorArray(z).clearAndClose(), [2, [(0, _tfjsCore.scalar)(0)]];

        case 17:
          throw TypeError("Node type " + e.op + " is not implemented");
      }
    });
  });
},
    executeOp$3 = function (e, t, a) {
  switch (e.op) {
    case "Conv1D":
      var r = getParamValue("stride", e, t, a),
          n = getParamValue("pad", e, t, a),
          s = getParamValue("dataFormat", e, t, a).toUpperCase(),
          o = getParamValue("dilation", e, t, a);
      return [(0, _tfjsCore.conv1d)(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), r, n, s, o)];

    case "Conv2D":
      r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), s = getParamValue("dataFormat", e, t, a).toUpperCase();
      var p = getParamValue("dilations", e, t, a);
      return [(0, _tfjsCore.conv2d)(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), [r[1], r[2]], n, s, [p[1], p[2]])];

    case "_FusedConv2D":
    case "FusedDepthwiseConv2dNative":
      var u = getParamValue("fusedOps", e, t, a),
          i = u[0],
          m = u[1],
          l = "biasadd" === i,
          c = "prelu" === m,
          d = "fusedbatchnorm" === i,
          y = getParamValue("numArgs", e, t, a);

      if (l) {
        if (c && 2 !== y) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!c && 1 !== y) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
      }

      if (d) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");
      r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), s = getParamValue("dataFormat", e, t, a).toUpperCase(), p = getParamValue("dilations", e, t, a);
      var f = getParamValue("args", e, t, a),
          g = f[0],
          h = f[1];
      return [("_FusedConv2D" === e.op ? _tfjsCore.fused.conv2d : _tfjsCore.fused.depthwiseConv2d)({
        x: getParamValue("x", e, t, a),
        filter: getParamValue("filter", e, t, a),
        strides: [r[1], r[2]],
        pad: n,
        dataFormat: s,
        dilations: [p[1], p[2]],
        bias: g,
        activation: m,
        preluActivationWeights: h
      })];

    case "Conv2DBackpropInput":
    case "Conv2dTranspose":
      var N = getParamValue("outputShape", e, t, a);
      r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a);
      return [(0, _tfjsCore.conv2dTranspose)(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), N, [r[1], r[2]], n)];

    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d":
      r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), p = getParamValue("dilations", e, t, a), s = getParamValue("dataFormat", e, t, a).toUpperCase();
      return [(0, _tfjsCore.depthwiseConv2d)(getParamValue("input", e, t, a), getParamValue("filter", e, t, a), [r[1], r[2]], n, s, [p[1], p[2]])];

    case "Conv3D":
      r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), s = getParamValue("dataFormat", e, t, a).toUpperCase(), p = getParamValue("dilations", e, t, a);
      return [(0, _tfjsCore.conv3d)(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), [r[1], r[2], r[3]], n, s, [p[1], p[2], p[3]])];

    case "AvgPool":
      r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a);
      var x = getParamValue("kernelSize", e, t, a);
      return [(0, _tfjsCore.avgPool)(getParamValue("x", e, t, a), [x[1], x[2]], [r[1], r[2]], n)];

    case "MaxPool":
      r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
      return [(0, _tfjsCore.maxPool)(getParamValue("x", e, t, a), [x[1], x[2]], [r[1], r[2]], n)];

    case "AvgPool3D":
      r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
      return [(0, _tfjsCore.avgPool3d)(getParamValue("x", e, t, a), [x[1], x[2], x[3]], [r[1], r[2], r[3]], n)];

    case "MaxPool3D":
      r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
      return [(0, _tfjsCore.maxPool3d)(getParamValue("x", e, t, a), [x[1], x[2], x[3]], [r[1], r[2], r[3]], n)];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$4 = function (e, t, a) {
  switch (e.op) {
    case "Fill":
      var r = getParamValue("shape", e, t, a),
          n = getParamValue("dtype", e, t, a),
          s = getParamValue("value", e, t, a);
      return [(0, _tfjsCore.fill)(r, s, n)];

    case "LinSpace":
      var o = getParamValue("start", e, t, a),
          p = getParamValue("stop", e, t, a),
          u = getParamValue("num", e, t, a);
      return [(0, _tfjsCore.linspace)(o, p, u)];

    case "Multinomial":
      var i = getParamValue("logits", e, t, a),
          m = getParamValue("numSamples", e, t, a),
          l = getParamValue("seed", e, t, a);
      return [(0, _tfjsCore.multinomial)(i, m, l)];

    case "OneHot":
      var c = getParamValue("indices", e, t, a),
          d = getParamValue("depth", e, t, a),
          y = getParamValue("onValue", e, t, a),
          f = getParamValue("offValue", e, t, a);
      return [(0, _tfjsCore.oneHot)(c, d, y, f)];

    case "Ones":
      return [(0, _tfjsCore.ones)(getParamValue("shape", e, t, a), getParamValue("dtype", e, t, a))];

    case "OnesLike":
      return [(0, _tfjsCore.onesLike)(getParamValue("x", e, t, a))];

    case "RandomUniform":
      return [(0, _tfjsCore.randomUniform)(getParamValue("shape", e, t, a), getParamValue("minval", e, t, a), getParamValue("maxval", e, t, a), getParamValue("dtype", e, t, a))];

    case "Range":
      o = getParamValue("start", e, t, a);
      var g = getParamValue("stop", e, t, a),
          h = getParamValue("step", e, t, a);
      return [(0, _tfjsCore.range)(o, g, h, getParamValue("dtype", e, t, a))];

    case "TruncatedNormal":
      r = getParamValue("shape", e, t, a);
      var N = getParamValue("mean", e, t, a),
          x = getParamValue("stdDev", e, t, a);
      l = getParamValue("seed", e, t, a);
      return [(0, _tfjsCore.truncatedNormal)(r, N, x, getParamValue("dtype", e, t, a), l)];

    case "Zeros":
      return [(0, _tfjsCore.zeros)(getParamValue("shape", e, t, a), getParamValue("dtype", e, t, a))];

    case "ZerosLike":
      return [(0, _tfjsCore.zerosLike)(getParamValue("x", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    _this$1 = void 0,
    executeOp$5 = function (e, t, a) {
  return __awaiter(_this$1, void 0, void 0, function () {
    var r, n, s, o, p, u, i, m;
    return __generator(this, function (l) {
      switch (l.label) {
        case 0:
          switch (e.op) {
            case "NonMaxSuppressionV5":
            case "NonMaxSuppressionV3":
            case "NonMaxSuppressionV2":
              return [3, 1];

            case "Where":
              return [3, 5];

            case "ListDiff":
              return [3, 7];
          }

          return [3, 8];

        case 1:
          return r = getParamValue("boxes", e, t, a), n = getParamValue("scores", e, t, a), s = getParamValue("maxOutputSize", e, t, a), o = getParamValue("iouThreshold", e, t, a), p = getParamValue("scoreThreshold", e, t, a), "NonMaxSuppressionV5" !== e.op ? [3, 3] : (u = getParamValue("softNmsSigma", e, t, a), [4, _tfjsCore.image.nonMaxSuppressionWithScoreAsync(r, n, s, o, p, u)]);

        case 2:
          return [2, [(m = l.sent()).selectedIndices, m.selectedScores]];

        case 3:
          return [4, _tfjsCore.image.nonMaxSuppressionAsync(r, n, s, o, p)];

        case 4:
          return [2, [l.sent()]];

        case 5:
          return i = getParamValue("condition", e, t, a).asType("bool"), [4, (0, _tfjsCore.whereAsync)(i)];

        case 6:
          return m = [l.sent()], i.dispose(), [2, m];

        case 7:
          return [2, (0, _tfjsCore.setdiff1dAsync)(getParamValue("x", e, t, a), getParamValue("y", e, t, a))];

        case 8:
          throw TypeError("Node type " + e.op + " is not implemented");
      }
    });
  });
},
    executeOp$6 = function (e, t, a) {
  switch (e.op) {
    case "TopKV2":
      var r = getParamValue("x", e, t, a),
          n = getParamValue("k", e, t, a),
          s = getParamValue("sorted", e, t, a),
          o = (0, _tfjsCore.topk)(r, n, s);
      return [o.values, o.indices];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$7 = function (e, t, a) {
  switch (e.op) {
    case "Const":
      return t[e.name];

    case "PlaceholderWithDefault":
      var r = getParamValue("default", e, t, a);
      return [getTensor(e.name, t, a) || r];

    case "Placeholder":
      return [getTensor(e.name, t, a)];

    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars":
      return [getParamValue("x", e, t, a).clone()];

    case "IdentityN":
      return getParamValue("x", e, t, a).map(function (e) {
        return e.clone();
      });

    case "Snapshot":
      return [getParamValue("x", e, t, a).clone()];

    case "Shape":
      return [(0, _tfjsCore.tensor1d)(getParamValue("x", e, t, a).shape, "int32")];

    case "ShapeN":
      return getParamValue("x", e, t, a).map(function (e) {
        return (0, _tfjsCore.tensor1d)(e.shape);
      });

    case "Size":
      return [(0, _tfjsCore.scalar)(getParamValue("x", e, t, a).size, "int32")];

    case "Rank":
      return [(0, _tfjsCore.scalar)(getParamValue("x", e, t, a).rank, "int32")];

    case "NoOp":
      return [(0, _tfjsCore.scalar)(1)];

    case "Print":
      var n = getParamValue("x", e, t, a),
          s = getParamValue("data", e, t, a),
          o = getParamValue("message", e, t, a),
          p = getParamValue("summarize", e, t, a);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o);

      for (var u = 0; u < s.length; u++) console.log(Array.prototype.slice.call(s[u].dataSync()).slice(0, p));

      return [n];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$8 = function (e, t, a) {
  switch (e.op) {
    case "ResizeBilinear":
      var r = getParamValue("images", e, t, a),
          n = getParamValue("size", e, t, a),
          s = getParamValue("alignCorners", e, t, a);
      return [_tfjsCore.image.resizeBilinear(r, [n[0], n[1]], s)];

    case "ResizeNearestNeighbor":
      r = getParamValue("images", e, t, a), n = getParamValue("size", e, t, a), s = getParamValue("alignCorners", e, t, a);
      return [_tfjsCore.image.resizeNearestNeighbor(r, [n[0], n[1]], s)];

    case "CropAndResize":
      var o = getParamValue("image", e, t, a),
          p = getParamValue("boxes", e, t, a),
          u = getParamValue("boxInd", e, t, a),
          i = getParamValue("cropSize", e, t, a),
          m = getParamValue("method", e, t, a),
          l = getParamValue("extrapolationValue", e, t, a);
      return [_tfjsCore.image.cropAndResize(o, p, u, i, m, l)];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$9 = function (e, t, a) {
  switch (e.op) {
    case "Equal":
      return [(0, _tfjsCore.equal)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "NotEqual":
      return [(0, _tfjsCore.notEqual)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Greater":
      return [(0, _tfjsCore.greater)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "GreaterEqual":
      return [(0, _tfjsCore.greaterEqual)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Less":
      return [(0, _tfjsCore.less)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "LessEqual":
      return [(0, _tfjsCore.lessEqual)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "LogicalAnd":
      return [(0, _tfjsCore.logicalAnd)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "LogicalNot":
      return [(0, _tfjsCore.logicalNot)(getParamValue("a", e, t, a))];

    case "LogicalOr":
      return [(0, _tfjsCore.logicalOr)(getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    case "Select":
      return [(0, _tfjsCore.where)(getParamValue("condition", e, t, a), getParamValue("a", e, t, a), getParamValue("b", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$10 = function (e, t, a) {
  switch (e.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [(0, _tfjsCore.matMul)(getParamValue("a", e, t, a), getParamValue("b", e, t, a), getParamValue("transposeA", e, t, a), getParamValue("transposeB", e, t, a))];

    case "Transpose":
      return [(0, _tfjsCore.transpose)(getParamValue("x", e, t, a), getParamValue("perm", e, t, a))];

    case "_FusedMatMul":
      var r = getParamValue("fusedOps", e, t, a),
          n = r[0],
          s = r[1],
          o = "biasadd" === n,
          p = "prelu" === s,
          u = getParamValue("numArgs", e, t, a);

      if (o) {
        if (p && 2 !== u) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!p && 1 !== u) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
      }

      var i = getParamValue("args", e, t, a),
          m = i[0],
          l = i[1];
      return [_tfjsCore.fused.matMul({
        a: getParamValue("a", e, t, a),
        b: getParamValue("b", e, t, a),
        transposeA: getParamValue("transposeA", e, t, a),
        transposeB: getParamValue("transposeB", e, t, a),
        bias: m,
        activation: s,
        preluActivationWeights: l
      })];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$11 = function (e, t, a) {
  switch (e.op) {
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
    case "FusedBatchNormV3":
      return [(0, _tfjsCore.batchNorm)(getParamValue("x", e, t, a), getParamValue("mean", e, t, a), getParamValue("variance", e, t, a), getParamValue("offset", e, t, a), getParamValue("scale", e, t, a), getParamValue("epsilon", e, t, a))];

    case "LRN":
      return [(0, _tfjsCore.localResponseNormalization)(getParamValue("x", e, t, a), getParamValue("radius", e, t, a), getParamValue("bias", e, t, a), getParamValue("alpha", e, t, a), getParamValue("beta", e, t, a))];

    case "Softmax":
      return [(0, _tfjsCore.softmax)(getParamValue("x", e, t, a))];

    case "LogSoftmax":
      return [(0, _tfjsCore.logSoftmax)(getParamValue("x", e, t, a))];

    case "SparseToDense":
      return [(0, _tfjsCore.sparseToDense)(getParamValue("sparseIndices", e, t, a), getParamValue("outputShape", e, t, a), getParamValue("sparseValues", e, t, a), getParamValue("defaultValue", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$12 = function (e, t, a) {
  switch (e.op) {
    case "Max":
      var r = getParamValue("axis", e, t, a),
          n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.max)(getParamValue("x", e, t, a), r, n)];

    case "Mean":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.mean)(getParamValue("x", e, t, a), r, n)];

    case "Min":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.min)(getParamValue("x", e, t, a), r, n)];

    case "Sum":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.sum)(getParamValue("x", e, t, a), r, n)];

    case "All":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.all)(getParamValue("x", e, t, a), r, n)];

    case "Any":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.any)(getParamValue("x", e, t, a), r, n)];

    case "ArgMax":
      r = getParamValue("axis", e, t, a);
      return [(0, _tfjsCore.argMax)(getParamValue("x", e, t, a), r)];

    case "ArgMin":
      r = getParamValue("axis", e, t, a);
      return [(0, _tfjsCore.argMin)(getParamValue("x", e, t, a), r)];

    case "Prod":
      r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
      return [(0, _tfjsCore.prod)(getParamValue("x", e, t, a), r, n)];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$13 = function (e, t, a) {
  switch (e.op) {
    case "ConcatV2":
    case "Concat":
      var r = getParamValue("n", e, t, a),
          n = getParamValue("axis", e, t, a),
          s = getParamValue("tensors", e, t, a);
      return s = s.slice(0, r), [(0, _tfjsCore.concat)(s, n)];

    case "GatherV2":
    case "Gather":
      n = getParamValue("axis", e, t, a);
      var o = getParamValue("x", e, t, a),
          p = getParamValue("indices", e, t, a);
      return [(0, _tfjsCore.gather)(o, p.asType("int32"), n)];

    case "ReverseV2":
    case "Reverse":
      n = getParamValue("axis", e, t, a), o = getParamValue("x", e, t, a);
      return [(0, _tfjsCore.reverse)(o, n)];

    case "Slice":
      var u = getParamValue("begin", e, t, a),
          i = getParamValue("size", e, t, a);
      return [(0, _tfjsCore.slice)(getParamValue("x", e, t, a), u, i)];

    case "StridedSlice":
      u = getParamValue("begin", e, t, a);
      var m = getParamValue("end", e, t, a),
          l = getParamValue("strides", e, t, a),
          c = getParamValue("beginMask", e, t, a),
          d = getParamValue("endMask", e, t, a),
          y = getParamValue("ellipsisMask", e, t, a),
          f = getParamValue("newAxisMask", e, t, a),
          g = getParamValue("shrinkAxisMask", e, t, a),
          h = getParamValue("x", e, t, a);
      if (1 === u.length && h.shape.length > 1) for (var N = 1; N < h.shape.length; N++) u.push(0), m.push(h.shape[N]), l.push(l[0]);
      return [(0, _tfjsCore.stridedSlice)(h, u, m, l, c, d, y, f, g)];

    case "Pack":
      return (0, _tfjsCore.tidy)(function () {
        var r = getParamValue("axis", e, t, a),
            n = getParamValue("tensors", e, t, a),
            s = n[0].shape,
            o = n[0].squeeze().shape,
            p = n.map(function (e) {
          var t = _tfjsCore.util.arraysEqual(e.shape, s);

          if (!t && !_tfjsCore.util.arraysEqual(e.squeeze().shape, o)) throw new Error("the input tensors shape does not match");
          return t ? e : e.reshape(s);
        });
        return [(0, _tfjsCore.stack)(p, r)];
      });

    case "Unpack":
      return (0, _tfjsCore.tidy)(function () {
        var r = getParamValue("axis", e, t, a),
            n = getParamValue("tensor", e, t, a);
        return (0, _tfjsCore.unstack)(n, r);
      });

    case "Tile":
      var x = getParamValue("reps", e, t, a);
      return [(0, _tfjsCore.tile)(getParamValue("x", e, t, a), x)];

    case "Split":
    case "SplitV":
      n = getParamValue("axis", e, t, a);
      var V = getParamValue("numOrSizeSplits", e, t, a);
      return (0, _tfjsCore.split)(getParamValue("x", e, t, a), V, n);

    case "ScatterNd":
      p = getParamValue("indices", e, t, a);
      var b = getParamValue("values", e, t, a),
          P = getParamValue("shape", e, t, a);
      return [(0, _tfjsCore.scatterND)(p, b, P)];

    case "GatherNd":
      var T = getParamValue("x", e, t, a);
      p = getParamValue("indices", e, t, a);
      return [(0, _tfjsCore.gatherND)(T, p)];

    case "SparseToDense":
      p = getParamValue("sparseIndices", e, t, a), P = getParamValue("outputShape", e, t, a);
      var v = getParamValue("sparseValues", e, t, a),
          O = getParamValue("defaultValue", e, t, a);
      return [(0, _tfjsCore.sparseToDense)(p, v, P, v.dtype === O.dtype ? O : O.asType(v.dtype))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$14 = function (e, t, a) {
  switch (e.op) {
    case "FFT":
      return [(0, _tfjsCore.fft)(getParamValue("x", e, t, a))];

    case "IFFT":
      return [(0, _tfjsCore.ifft)(getParamValue("x", e, t, a))];

    case "RFFT":
      return [(0, _tfjsCore.rfft)(getParamValue("x", e, t, a))];

    case "IRFFT":
      return [(0, _tfjsCore.irfft)(getParamValue("x", e, t, a))];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
},
    executeOp$15 = function (e, t, a) {
  switch (e.op) {
    case "Cast":
      return [(0, _tfjsCore.cast)(getParamValue("x", e, t, a), getParamValue("dtype", e, t, a))];

    case "ExpandDims":
      var r = getParamValue("axis", e, t, a);
      return [(0, _tfjsCore.expandDims)(getParamValue("x", e, t, a), r)];

    case "Squeeze":
      r = getParamValue("axis", e, t, a);
      return [(0, _tfjsCore.squeeze)(getParamValue("x", e, t, a), r)];

    case "Reshape":
      return [(0, _tfjsCore.reshape)(getParamValue("x", e, t, a), getParamValue("shape", e, t, a))];

    case "PadV2":
    case "Pad":
      return [(0, _tfjsCore.pad)(getParamValue("x", e, t, a), split$1(getParamValue("padding", e, t, a), 2), getParamValue("constantValue", e, t, a))];

    case "SpaceToBatchND":
      var n = getParamValue("blockShape", e, t, a),
          s = split$1(getParamValue("paddings", e, t, a), 2);
      return [(0, _tfjsCore.spaceToBatchND)(getParamValue("x", e, t, a), n, s)];

    case "BatchToSpaceND":
      n = getParamValue("blockShape", e, t, a);
      var o = split$1(getParamValue("crops", e, t, a), 2);
      return [(0, _tfjsCore.batchToSpaceND)(getParamValue("x", e, t, a), n, o)];

    case "DepthToSpace":
      var p = getParamValue("blockSize", e, t, a),
          u = getParamValue("dataFormat", e, t, a).toUpperCase();
      return [(0, _tfjsCore.depthToSpace)(getParamValue("x", e, t, a), p, u)];

    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
};

function executeOp$16(e, t, a) {
  var r = function (e, t, a) {
    switch (e.category) {
      case "arithmetic":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp(e, t, a);
        });

      case "basic_math":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$1(e, t, a);
        });

      case "control":
        return executeOp$2(e, t, a);

      case "convolution":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$3(e, t, a);
        });

      case "creation":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$4(e, t, a);
        });

      case "dynamic":
        return executeOp$5(e, t, a);

      case "evaluation":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$6(e, t, a);
        });

      case "image":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$8(e, t, a);
        });

      case "graph":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$7(e, t, a);
        });

      case "logical":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$9(e, t, a);
        });

      case "matrices":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$10(e, t, a);
        });

      case "normalization":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$11(e, t, a);
        });

      case "reduction":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$12(e, t, a);
        });

      case "slice_join":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$13(e, t, a);
        });

      case "spectral":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$14(e, t, a);
        });

      case "transformation":
        return (0, _tfjsCore.tidy)(function () {
          return executeOp$15(e, t, a);
        });

      case "custom":
        var r = getRegisteredOp(e.op);
        if (r && r.customExecutor) return r.customExecutor(new NodeValueImpl(e, t, a));
        throw TypeError("Custom op " + e.op + " is not registered.");

      default:
        throw TypeError("Unknown op '" + e.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
    }
  }(e, t, a);

  return r instanceof Promise ? r.then(function (e) {
    return [].concat(e);
  }) : [].concat(r);
}

var ExecutionContext = function () {
  function e(e, t) {
    this.weightMap = e, this.tensorArrayMap = t, this.rootContext = {
      id: 0,
      frameName: "",
      iterationId: 0
    }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }

  return e.prototype.newFrame = function (e, t) {
    return {
      id: e,
      frameName: t,
      iterationId: 0
    };
  }, Object.defineProperty(e.prototype, "currentContext", {
    get: function () {
      return this.contexts;
    },
    set: function (e) {
      this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "currentContextId", {
    get: function () {
      return this._currentContextIds[0];
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "currentContextIds", {
    get: function () {
      return this._currentContextIds;
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.generateCurrentContextIds = function () {
    for (var e = [], t = 0; t < this.contexts.length - 1; t++) {
      var a = this.contexts.slice(0, this.contexts.length - t);
      e.push(this.contextIdforContexts(a));
    }

    e.push(""), this._currentContextIds = e;
  }, e.prototype.contextIdforContexts = function (e) {
    return e ? e.map(function (e) {
      return 0 === e.id && 0 === e.iterationId ? "" : e.frameName + "-" + e.iterationId;
    }).join("/") : "";
  }, e.prototype.enterFrame = function (e) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
  }, e.prototype.exitFrame = function () {
    if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
    this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
  }, e.prototype.nextIteration = function () {
    if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
    this.contexts = this.contexts.slice(), this.lastId++;
    var e = Object.assign({}, this.contexts[this.contexts.length - 1]);
    e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
  }, e.prototype.getWeight = function (e) {
    return this.weightMap[e];
  }, e.prototype.addTensorArray = function (e) {
    this.tensorArrayMap[e.id] = e;
  }, e.prototype.getTensorArray = function (e) {
    return this.tensorArrayMap[e];
  }, e;
}();

function getExecutionSubgraph(e, t, a) {
  for (var r = new Set(), n = [], s = null, o = null, p = new Set(), u = Object.keys(e).map(function (e) {
    return parseNodeName(e)[0];
  }), i = t.slice(); i.length > 0;) {
    var m = i.pop();
    (isControlFlow(m) || isDynamicShape(m)) && null == s && (o = (s = m).children.map(function (e) {
      return e.name;
    }).filter(function (e) {
      return r.has(e);
    })), r.add(m.name), null == a[m.name] && -1 === u.indexOf(m.name) && (0 !== m.inputs.length ? m.inputs.forEach(function (e) {
      p.has(e.name) || (p.add(e.name), i.push(e));
    }) : n.push(m.name));
  }

  return {
    inputs: e,
    outputs: t,
    usedNodes: r,
    missingInputs: n,
    dynamicNode: s,
    syncInputs: o
  };
}

function getNodesInTopologicalOrder(e, t, a) {
  var r = a.usedNodes,
      n = a.inputs,
      s = [];
  Object.keys(n).map(function (e) {
    return parseNodeName(e)[0];
  }).map(function (t) {
    return e.nodes[t];
  }).forEach(function (e) {
    r.has(e.name) && s.push(e);
  }), e.weights.forEach(function (e) {
    r.has(e.name) && s.push(e);
  });

  for (var o = new Set(), p = []; s.length > 0;) {
    var u = s.pop();
    o.add(u.name), t[u.name] || p.push(u), u.children.forEach(function (e) {
      !o.has(e.name) && r.has(e.name) && e.inputs.every(function (e) {
        return o.has(e.name);
      }) && s.push(e);
    });
  }

  return p;
}

var CONTROL_FLOW_OPS = ["Switch", "Merge", "Enter", "Exit", "NextIteration"],
    DYNAMIC_SHAPE_OPS = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"];

function isControlFlow(e) {
  return CONTROL_FLOW_OPS.indexOf(e.op) >= 0;
}

function isDynamicShape(e) {
  return DYNAMIC_SHAPE_OPS.indexOf(e.op) >= 0;
}

var GraphExecutor = function () {
  function e(e) {
    this.graph = e, this.compiledMap = new Map(), this._weightMap = {}, this.SEPERATOR = ",", this._outputs = e.outputs, this._inputs = e.inputs, this._signature = e.signature;
  }

  return Object.defineProperty(e.prototype, "weightMap", {
    get: function () {
      return this._weightMap;
    },
    set: function (e) {
      var t = Object.keys(e).map(function (t) {
        return e[t].map(function (e) {
          return e.id;
        });
      });
      this.weightIds = [].concat.apply([], t), this._weightMap = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "inputs", {
    get: function () {
      return this._inputs.map(function (e) {
        return {
          name: e.name,
          shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
          dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
        };
      });
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "outputs", {
    get: function () {
      return this._outputs.map(function (e) {
        return {
          name: e.name,
          shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
          dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
        };
      });
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "inputNodes", {
    get: function () {
      return this._inputs.map(function (e) {
        return e.signatureKey || e.name;
      });
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "outputNodes", {
    get: function () {
      return this._outputs.map(function (e) {
        return e.signatureKey || e.name;
      });
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.getCompilationKey = function (e, t) {
    var a = e.map(function (e) {
      return e.name;
    }).sort(),
        r = t.map(function (e) {
      return e.name;
    }).sort();
    return a.join(this.SEPERATOR) + "--" + r.join(this.SEPERATOR);
  }, e.prototype.compile = function (e, t) {
    var a = getExecutionSubgraph(e, t, this.weightMap),
        r = a.missingInputs,
        n = a.dynamicNode,
        s = a.syncInputs;
    if (null != n) throw new Error("This execution contains the node '" + n.name + "', which has the dynamic op '" + n.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + s + "]");

    if (r.length > 0) {
      var o = t.map(function (e) {
        return e.name;
      }),
          p = Object.keys(e);
      throw new Error("Cannot compute the outputs [" + o + "] from the provided inputs [" + p + "]. Missing the following inputs: [" + r + "]");
    }

    return getNodesInTopologicalOrder(this.graph, this.weightMap, a);
  }, e.prototype.execute = function (e, t) {
    var a = this;
    e = this.mapInputs(e);
    var r = Object.keys(e).sort();
    this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t);
    var n = r.map(function (e) {
      return a.graph.nodes[parseNodeName(e)[0]];
    }),
        s = t.map(function (e) {
      return a.graph.nodes[parseNodeName(e)[0]];
    }),
        o = this.getCompilationKey(n, s),
        p = this.compiledMap.get(o);
    null == p && (p = this.compile(e, s), this.compiledMap.set(o, p));
    var u = {};
    return (0, _tfjsCore.tidy)(function () {
      var r = new ExecutionContext(a._weightMap, u),
          n = __assign({}, a.weightMap);

      Object.keys(e).forEach(function (t) {
        var a = parseNodeName(t),
            r = a[0],
            s = [];
        s[a[1]] = e[t], n[r] = s;
      });

      for (var s = a.getFrozenTensorIds(n), o = {}, i = 0; i < p.length; i++) {
        var m = p[i];

        if (!n[m.name]) {
          var l = executeOp$16(m, n, r);
          if (l instanceof Promise) throw new Error("The execution of the op '" + m.op + "' returned a promise. Please use model.executeAsync() instead.");
          n[m.name] = l, a.checkTensorForDisposal(m.name, m, n, r, s, t, o);
        }
      }

      return t.map(function (e) {
        return getTensor(e, n, r);
      });
    });
  }, e.prototype.getFrozenTensorIds = function (e) {
    var t = [].concat.apply([], Object.keys(e).map(function (t) {
      return e[t];
    }).map(function (e) {
      return e.map(function (e) {
        return e.id;
      });
    }));
    return new Set(t);
  }, e.prototype.checkTensorForDisposal = function (e, t, a, r, n, s, o) {
    "control" !== t.category && -1 === s.indexOf(e) && (a[e].forEach(function (e) {
      null != e && (o[e.id] = (o[e.id] || 0) + t.children.length);
    }), t.inputs.forEach(function (e) {
      if ("control" !== e.category) {
        var t = getTensorsForCurrentContenxt(e.name, a, r);
        null != t && t.forEach(function (e) {
          if (e && !n.has(e.id)) {
            var t = o[e.id];
            1 === t ? (e.dispose(), delete o[e.id]) : null != t && o[e.id]--;
          }
        });
      }
    }));
  }, e.prototype.executeAsync = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var a,
          r,
          n,
          s,
          o,
          p,
          u = this;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            return e = this.mapInputs(e), this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t), a = {}, r = new ExecutionContext(this._weightMap, a), [4, this.executeWithControlFlow(e, r, t)];

          case 1:
            return n = i.sent(), s = t.map(function (e) {
              return getTensor(e, n, r);
            }), o = new Set(s.map(function (e) {
              return e.id;
            })), p = new Set(Object.keys(e).map(function (t) {
              return e[t].id;
            })), Object.keys(n).forEach(function (e) {
              n[e].forEach(function (e) {
                !e || e.isDisposed || o.has(e.id) || p.has(e.id) || -1 !== u.weightIds.indexOf(e.id) || e.dispose();
              });
            }), [2, s];
        }
      });
    });
  }, e.prototype.executeWithControlFlow = function (e, t, a) {
    return __awaiter(this, void 0, void 0, function () {
      var r,
          n,
          s,
          o,
          p,
          u,
          i,
          m,
          l,
          c,
          d,
          y,
          f,
          g,
          h,
          N,
          x = this;
      return __generator(this, function (V) {
        switch (V.label) {
          case 0:
            r = Object.keys(e), n = r.map(function (e) {
              return x.graph.nodes[parseNodeName(e)[0]];
            }), s = a.map(function (e) {
              return x.graph.nodes[parseNodeName(e)[0]];
            }), o = getExecutionSubgraph(e, s, this.weightMap), p = o.usedNodes, u = o.missingInputs, i = o.dynamicNode, m = o.syncInputs, l = n.concat(this.graph.weights).map(function (e) {
              return {
                node: e,
                contexts: t.currentContext
              };
            }), c = __assign({}, this.weightMap), Object.keys(e).forEach(function (t) {
              var a = parseNodeName(t),
                  r = a[0],
                  n = [];
              n[a[1]] = e[t], c[r] = n;
            }), d = {}, y = this.getFrozenTensorIds(c), f = {}, V.label = 1;

          case 1:
            return l.length > 0 ? (g = this.processStack(n, l, t, c, f, y, a, d, p), [4, Promise.all(g)]) : [3, 3];

          case 2:
            return V.sent(), [3, 1];

          case 3:
            if (null == i && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), (h = s.filter(function (e) {
              return !isControlFlow(e) && !getTensor(e.name, c, t);
            }).map(function (e) {
              return e.name;
            })).length > 0) throw N = "", null != i && (N = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + m + "]"), new Error("Cannot compute the outputs [" + h + "] from the provided inputs [" + r + "]. Consider providing the following inputs: [" + u + "]. " + N);
            return [2, c];
        }
      });
    });
  }, e.prototype.processStack = function (e, t, a, r, n, s, o, p, u) {
    for (var i = this, m = [], l = function () {
      var l = t.pop();
      a.currentContext = l.contexts;
      var d = "";

      if ("Enter" === l.node.op && getParamValue("isConstant", l.node, r, a) && (d = getNodeNameAndIndex(l.node.name, a)[0]), -1 === e.indexOf(l.node)) {
        var y = executeOp$16(l.node, r, a);
        d || (d = getNodeNameAndIndex(l.node.name, a)[0]);
        var f = a.currentContext;
        y instanceof Promise ? m.push(y.then(function (e) {
          return r[d] = e, a.currentContext = f, i.checkTensorForDisposal(d, l.node, r, a, s, o, p), i.processChildNodes(l.node, t, a, r, n, u), e;
        })) : (r[d] = y, c.checkTensorForDisposal(d, l.node, r, a, s, o, p), c.processChildNodes(l.node, t, a, r, n, u));
      } else c.processChildNodes(l.node, t, a, r, n, u);
    }, c = this; t.length > 0;) l();

    return m;
  }, e.prototype.processChildNodes = function (e, t, a, r, n, s) {
    e.children.forEach(function (e) {
      var o = getNodeNameAndIndex(e.name, a)[0];
      !n[o] && s.has(e.name) && ("Merge" === e.op ? e.inputNames.some(function (e) {
        return !!getTensor(e, r, a);
      }) && (n[o] = !0, t.push({
        contexts: a.currentContext,
        node: e
      })) : e.inputNames.every(function (e) {
        return !!getTensor(e, r, a);
      }) && (n[o] = !0, t.push({
        contexts: a.currentContext,
        node: e
      })));
    });
  }, e.prototype.dispose = function () {
    var e = this;
    Object.keys(this.weightMap).forEach(function (t) {
      return e.weightMap[t].forEach(function (e) {
        return e.dispose();
      });
    });
  }, e.prototype.checkInputShapeAndType = function (e) {
    var t = this;
    Object.keys(e).forEach(function (a) {
      var r = e[a],
          n = parseNodeName(a)[0],
          s = t.graph.nodes[n];

      if (s.attrParams.shape && s.attrParams.shape.value) {
        var o = s.attrParams.shape.value,
            p = o.length === r.shape.length && r.shape.every(function (e, t) {
          return -1 === o[t] || o[t] === e;
        });

        _tfjsCore.util.assert(p, function () {
          return "The shape of dict['" + s.name + "'] provided in model.execute(dict) must be [" + o + "], but was [" + r.shape + "]";
        });
      }

      s.attrParams.dtype && s.attrParams.dtype.value && _tfjsCore.util.assert(r.dtype === s.attrParams.dtype.value, function () {
        return "The dtype of dict['" + s.name + "'] provided in model.execute(dict) must be " + s.attrParams.dtype.value + ", but was " + r.dtype;
      });
    });
  }, e.prototype.mapInputs = function (e) {
    var t = {};

    for (var a in e) {
      if (null != this._signature && null != this._signature.inputs && null != this._signature.inputs[a]) t[this._signature.inputs[a].name] = e[a];else t[a] = e[a];
    }

    return t;
  }, e.prototype.checkInputs = function (e) {
    var t = this,
        a = Object.keys(e).filter(function (e) {
      var a = parseNodeName(e)[0];
      return null == t.graph.nodes[a];
    });
    if (a.length > 0) throw new Error("The dict provided in model.execute(dict) has keys: [" + a + "] that are not part of graph");
  }, e.prototype.mapOutputs = function (e) {
    var t = this;
    return e.map(function (e) {
      return null != t._signature && null != t._signature.outputs && null != t._signature.outputs[e] ? t._signature.outputs[e].name : e;
    }, {});
  }, e.prototype.checkOutputs = function (e) {
    var t = this;
    e.forEach(function (e) {
      var a = parseNodeName(e)[0];
      if (!t.graph.nodes[a]) throw new Error("The output '" + e + "' is not found in the graph");
    });
  }, e;
}(),
    TFHUB_SEARCH_PARAM = "?tfjs-format=file",
    DEFAULT_MODEL_NAME = "model.json",
    GraphModel = function () {
  function e(e, t) {
    void 0 === t && (t = {}), this.modelUrl = e, this.loadOptions = t, this.version = "n/a", null == t && (this.loadOptions = {});
  }

  return Object.defineProperty(e.prototype, "modelVersion", {
    get: function () {
      return this.version;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "inputNodes", {
    get: function () {
      return this.executor.inputNodes;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "outputNodes", {
    get: function () {
      return this.executor.outputNodes;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "inputs", {
    get: function () {
      return this.executor.inputs;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "outputs", {
    get: function () {
      return this.executor.outputs;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e.prototype, "weights", {
    get: function () {
      return this.executor.weightMap;
    },
    enumerable: !0,
    configurable: !0
  }), e.prototype.findIOHandler = function () {
    var e = this.modelUrl;
    if (null != e.load) this.handler = e;else if (null != this.loadOptions.requestInit) this.handler = _tfjsCore.io.browserHTTPRequest(e, this.loadOptions);else {
      var t = _tfjsCore.io.getLoadHandlers(e, this.loadOptions.onProgress);

      if (0 === t.length) t.push(_tfjsCore.io.browserHTTPRequest(e, this.loadOptions));else if (t.length > 1) throw new Error("Found more than one (" + t.length + ") load handlers for URL '" + [e] + "'");
      this.handler = t[0];
    }
  }, e.prototype.load = function () {
    return __awaiter(this, void 0, void 0, function () {
      var e, t, a, r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            if (this.findIOHandler(), null == this.handler.load) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
            return e = this, [4, this.handler.load()];

          case 1:
            return e.artifacts = n.sent(), t = this.artifacts.modelTopology, a = {}, null != this.artifacts.userDefinedMetadata && (a = this.artifacts.userDefinedMetadata.signature), this.version = t.versions.producer + "." + t.versions.minConsumer, r = _tfjsCore.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs), this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(t, a)), this.executor.weightMap = this.convertTensorMapToTensorsMap(r), [2, !0];
        }
      });
    });
  }, e.prototype.save = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (a) {
        if ("string" == typeof e) {
          if (0 === (t = _tfjsCore.io.getSaveHandlers(e)).length) throw new Error("Cannot find any save handlers for URL '" + e + "'");
          if (t.length > 1) throw new Error("Found more than one (" + t.length + ") save handlers for URL '" + e + "'");
          e = t[0];
        }

        if (null == e.save) throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
        return [2, e.save(this.artifacts)];
      });
    });
  }, e.prototype.predict = function (e, t) {
    return this.execute(e, this.outputNodes);
  }, e.prototype.normalizeInputs = function (e) {
    if (!(e instanceof _tfjsCore.Tensor || Array.isArray(e))) return e;
    if ((e = Array.isArray(e) ? e : [e]).length !== this.inputNodes.length) throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + e.length + " input tensors.");
    return this.inputNodes.reduce(function (t, a, r) {
      return t[a] = e[r], t;
    }, {});
  }, e.prototype.normalizeOutputs = function (e) {
    return e = e || this.outputNodes, Array.isArray(e) ? e : [e];
  }, e.prototype.execute = function (e, t) {
    e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
    var a = this.executor.execute(e, t);
    return a.length > 1 ? a : a[0];
  }, e.prototype.executeAsync = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var a;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return e = this.normalizeInputs(e), t = this.normalizeOutputs(t), [4, this.executor.executeAsync(e, t)];

          case 1:
            return [2, (a = r.sent()).length > 1 ? a : a[0]];
        }
      });
    });
  }, e.prototype.convertTensorMapToTensorsMap = function (e) {
    return Object.keys(e).reduce(function (t, a) {
      return t[a] = [e[a]], t;
    }, {});
  }, e.prototype.dispose = function () {
    this.executor.dispose();
  }, e;
}();

exports.GraphModel = GraphModel;

function loadGraphModel(e, t) {
  return void 0 === t && (t = {}), __awaiter(this, void 0, void 0, function () {
    var a;
    return __generator(this, function (r) {
      switch (r.label) {
        case 0:
          if (null == e) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
          return null == t && (t = {}), t.fromTFHub && null == e.load && (e.endsWith("/") || (e += "/"), e = "" + e + DEFAULT_MODEL_NAME + TFHUB_SEARCH_PARAM), [4, (a = new GraphModel(e, t)).load()];

        case 1:
          return r.sent(), [2, a];
      }
    });
  });
}

var version = "1.7.1";
exports.version_converter = version;
},{"@tensorflow/tfjs-core":"node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@tensorflow-models/posenet/dist/posenet.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeMultiplePoses = decodeMultiplePoses;
exports.decodeSinglePose = decodeSinglePose;
exports.load = load;
exports.getAdjacentKeyPoints = getAdjacentKeyPoints;
exports.getBoundingBox = getBoundingBox;
exports.getBoundingBoxPoints = getBoundingBoxPoints;
exports.scaleAndFlipPoses = scaleAndFlipPoses;
exports.scalePose = scalePose;
exports.version = exports.PoseNet = exports.poseChain = exports.partNames = exports.partIds = exports.partChannels = exports.MobileNet = void 0;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _tfjsConverter = require("@tensorflow/tfjs-converter");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
    * @license
    * Copyright 2019 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
var extendStatics = function (e, t) {
  return (extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (e, t) {
    e.__proto__ = t;
  } || function (e, t) {
    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
  })(e, t);
};

function __extends(e, t) {
  function n() {
    this.constructor = e;
  }

  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());
}

var __assign = function () {
  return (__assign = Object.assign || function (e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);

    return e;
  }).apply(this, arguments);
};

function __awaiter(e, t, n, r) {
  return new (n || (n = Promise))(function (o, i) {
    function s(e) {
      try {
        a(r.next(e));
      } catch (e) {
        i(e);
      }
    }

    function u(e) {
      try {
        a(r.throw(e));
      } catch (e) {
        i(e);
      }
    }

    function a(e) {
      e.done ? o(e.value) : new n(function (t) {
        t(e.value);
      }).then(s, u);
    }

    a((r = r.apply(e, t || [])).next());
  });
}

function __generator(e, t) {
  var n,
      r,
      o,
      i,
      s = {
    label: 0,
    sent: function () {
      if (1 & o[0]) throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  };
  return i = {
    next: u(0),
    throw: u(1),
    return: u(2)
  }, "function" == typeof Symbol && (i[Symbol.iterator] = function () {
    return this;
  }), i;

  function u(i) {
    return function (u) {
      return function (i) {
        if (n) throw new TypeError("Generator is already executing.");

        for (; s;) try {
          if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;

          switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {
            case 0:
            case 1:
              o = i;
              break;

            case 4:
              return s.label++, {
                value: i[1],
                done: !1
              };

            case 5:
              s.label++, r = i[1], i = [0];
              continue;

            case 7:
              i = s.ops.pop(), s.trys.pop();
              continue;

            default:
              if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {
                s = 0;
                continue;
              }

              if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {
                s.label = i[1];
                break;
              }

              if (6 === i[0] && s.label < o[1]) {
                s.label = o[1], o = i;
                break;
              }

              if (o && s.label < o[2]) {
                s.label = o[2], s.ops.push(i);
                break;
              }

              o[2] && s.ops.pop(), s.trys.pop();
              continue;
          }

          i = t.call(e, s);
        } catch (e) {
          i = [6, e], r = 0;
        } finally {
          n = o = 0;
        }

        if (5 & i[0]) throw i[1];
        return {
          value: i[0] ? i[1] : void 0,
          done: !0
        };
      }([i, u]);
    };
  }
}

var BaseModel = function () {
  function e(e, t) {
    this.model = e, this.outputStride = t;
    var n = this.model.inputs[0].shape;
    tf.util.assert(-1 === n[1] && -1 === n[2], function () {
      return "Input shape [" + n[1] + ", " + n[2] + "] must both be equal to or -1";
    });
  }

  return e.prototype.predict = function (e) {
    var t = this;
    return (0, tf.tidy)(function () {
      var n = t.preprocessInput(e.toFloat()).expandDims(0),
          r = t.model.predict(n).map(function (e) {
        return e.squeeze([0]);
      }),
          o = t.nameOutputResults(r);
      return {
        heatmapScores: o.heatmap.sigmoid(),
        offsets: o.offsets,
        displacementFwd: o.displacementFwd,
        displacementBwd: o.displacementBwd
      };
    });
  }, e.prototype.dispose = function () {
    this.model.dispose();
  }, e;
}(),
    MobileNet = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.preprocessInput = function (e) {
    return (0, tf.tidy)(function () {
      return (0, tf.div)(e, 127.5).sub(1);
    });
  }, t.prototype.nameOutputResults = function (e) {
    return {
      offsets: e[0],
      heatmap: e[1],
      displacementFwd: e[2],
      displacementBwd: e[3]
    };
  }, t;
}(BaseModel);

exports.MobileNet = MobileNet;

function half(e) {
  return Math.floor(e / 2);
}

var MaxHeap = function () {
  function e(e, t) {
    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;
  }

  return e.prototype.enqueue = function (e) {
    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);
  }, e.prototype.dequeue = function () {
    var e = this.priorityQueue[0];
    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;
  }, e.prototype.empty = function () {
    return -1 === this.numberOfElements;
  }, e.prototype.size = function () {
    return this.numberOfElements + 1;
  }, e.prototype.all = function () {
    return this.priorityQueue.slice(0, this.numberOfElements + 1);
  }, e.prototype.max = function () {
    return this.priorityQueue[0];
  }, e.prototype.swim = function (e) {
    for (; e > 0 && this.less(half(e), e);) this.exchange(e, half(e)), e = half(e);
  }, e.prototype.sink = function (e) {
    for (; 2 * e <= this.numberOfElements;) {
      var t = 2 * e;
      if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;
      this.exchange(e, t), e = t;
    }
  }, e.prototype.getValueAt = function (e) {
    return this.getElementValue(this.priorityQueue[e]);
  }, e.prototype.less = function (e, t) {
    return this.getValueAt(e) < this.getValueAt(t);
  }, e.prototype.exchange = function (e, t) {
    var n = this.priorityQueue[e];
    this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = n;
  }, e;
}();

function scoreIsMaximumInLocalWindow(e, t, n, r, o, i) {
  for (var s = i.shape, u = s[0], a = s[1], l = !0, p = Math.max(n - o, 0), c = Math.min(n + o + 1, u), f = p; f < c; ++f) {
    for (var d = Math.max(r - o, 0), h = Math.min(r + o + 1, a), m = d; m < h; ++m) if (i.get(f, m, e) > t) {
      l = !1;
      break;
    }

    if (!l) break;
  }

  return l;
}

function buildPartWithScoreQueue(e, t, n) {
  for (var r = n.shape, o = r[0], i = r[1], s = r[2], u = new MaxHeap(o * i * s, function (e) {
    return e.score;
  }), a = 0; a < o; ++a) for (var l = 0; l < i; ++l) for (var p = 0; p < s; ++p) {
    var c = n.get(a, l, p);
    c < e || scoreIsMaximumInLocalWindow(p, c, a, l, t, n) && u.enqueue({
      score: c,
      part: {
        heatmapY: a,
        heatmapX: l,
        id: p
      }
    });
  }

  return u;
}

var partNames = ["nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle"],
    NUM_KEYPOINTS = partNames.length,
    partIds = partNames.reduce(function (e, t, n) {
  return e[t] = n, e;
}, {}),
    connectedPartNames = [["leftHip", "leftShoulder"], ["leftElbow", "leftShoulder"], ["leftElbow", "leftWrist"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["rightHip", "rightShoulder"], ["rightElbow", "rightShoulder"], ["rightElbow", "rightWrist"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"], ["leftShoulder", "rightShoulder"], ["leftHip", "rightHip"]],
    poseChain = [["nose", "leftEye"], ["leftEye", "leftEar"], ["nose", "rightEye"], ["rightEye", "rightEar"], ["nose", "leftShoulder"], ["leftShoulder", "leftElbow"], ["leftElbow", "leftWrist"], ["leftShoulder", "leftHip"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["nose", "rightShoulder"], ["rightShoulder", "rightElbow"], ["rightElbow", "rightWrist"], ["rightShoulder", "rightHip"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"]],
    connectedPartIndices = connectedPartNames.map(function (e) {
  var t = e[0],
      n = e[1];
  return [partIds[t], partIds[n]];
}),
    partChannels = ["left_face", "right_face", "right_upper_leg_front", "right_lower_leg_back", "right_upper_leg_back", "left_lower_leg_front", "left_upper_leg_front", "left_upper_leg_back", "left_lower_leg_back", "right_feet", "right_lower_leg_front", "left_feet", "torso_front", "torso_back", "right_upper_arm_front", "right_upper_arm_back", "right_lower_arm_back", "left_lower_arm_front", "left_upper_arm_front", "left_upper_arm_back", "left_lower_arm_back", "right_hand", "right_lower_arm_front", "left_hand"];
exports.partChannels = partChannels;
exports.poseChain = poseChain;
exports.partIds = partIds;
exports.partNames = partNames;

function getOffsetPoint(e, t, n, r) {
  return {
    y: r.get(e, t, n),
    x: r.get(e, t, n + NUM_KEYPOINTS)
  };
}

function getImageCoords(e, t, n) {
  var r = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, n),
      o = r.y,
      i = r.x;
  return {
    x: e.heatmapX * t + i,
    y: e.heatmapY * t + o
  };
}

function clamp(e, t, n) {
  return e < t ? t : e > n ? n : e;
}

function squaredDistance(e, t, n, r) {
  var o = n - e,
      i = r - t;
  return o * o + i * i;
}

function addVectors(e, t) {
  return {
    x: e.x + t.x,
    y: e.y + t.y
  };
}

var parentChildrenTuples = poseChain.map(function (e) {
  var t = e[0],
      n = e[1];
  return [partIds[t], partIds[n]];
}),
    parentToChildEdges = parentChildrenTuples.map(function (e) {
  return e[1];
}),
    childToParentEdges = parentChildrenTuples.map(function (e) {
  return e[0];
});

function getDisplacement(e, t, n) {
  var r = n.shape[2] / 2;
  return {
    y: n.get(t.y, t.x, e),
    x: n.get(t.y, t.x, r + e)
  };
}

function getStridedIndexNearPoint(e, t, n, r) {
  return {
    y: clamp(Math.round(e.y / t), 0, n - 1),
    x: clamp(Math.round(e.x / t), 0, r - 1)
  };
}

function traverseToTargetKeypoint(e, t, n, r, o, i, s, u) {
  void 0 === u && (u = 2);

  for (var a = r.shape, l = a[0], p = a[1], c = getDisplacement(e, getStridedIndexNearPoint(t.position, i, l, p), s), f = addVectors(t.position, c), d = 0; d < u; d++) {
    var h = getStridedIndexNearPoint(f, i, l, p),
        m = getOffsetPoint(h.y, h.x, n, o);
    f = addVectors({
      x: h.x * i,
      y: h.y * i
    }, {
      x: m.x,
      y: m.y
    });
  }

  var g = getStridedIndexNearPoint(f, i, l, p),
      _ = r.get(g.y, g.x, n);

  return {
    position: f,
    part: partNames[n],
    score: _
  };
}

function decodePose(e, t, n, r, o, i) {
  var s = t.shape[2],
      u = parentToChildEdges.length,
      a = new Array(s),
      l = e.part,
      p = e.score,
      c = getImageCoords(l, r, n);
  a[l.id] = {
    score: p,
    part: partNames[l.id],
    position: c
  };

  for (var f = u - 1; f >= 0; --f) {
    var d = parentToChildEdges[f],
        h = childToParentEdges[f];
    a[d] && !a[h] && (a[h] = traverseToTargetKeypoint(f, a[d], h, t, n, r, i));
  }

  for (f = 0; f < u; ++f) {
    d = childToParentEdges[f], h = parentToChildEdges[f];
    a[d] && !a[h] && (a[h] = traverseToTargetKeypoint(f, a[d], h, t, n, r, o));
  }

  return a;
}

function withinNmsRadiusOfCorrespondingPoint(e, t, n, r) {
  var o = n.x,
      i = n.y;
  return e.some(function (e) {
    var n = e.keypoints[r].position;
    return squaredDistance(i, o, n.y, n.x) <= t;
  });
}

function getInstanceScore(e, t, n) {
  return n.reduce(function (n, r, o) {
    var i = r.position,
        s = r.score;
    return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (n += s), n;
  }, 0) / n.length;
}

var kLocalMaximumRadius = 1;

function decodeMultiplePoses(e, t, n, r, o, i, s, u) {
  void 0 === s && (s = .5), void 0 === u && (u = 20);

  for (var a = [], l = buildPartWithScoreQueue(s, kLocalMaximumRadius, e), p = u * u; a.length < i && !l.empty();) {
    var c = l.dequeue();

    if (!withinNmsRadiusOfCorrespondingPoint(a, p, getImageCoords(c.part, o, t), c.part.id)) {
      var f = decodePose(c, e, t, o, n, r),
          d = getInstanceScore(a, p, f);
      a.push({
        keypoints: f,
        score: d
      });
    }
  }

  return a;
}

function mod(e, t) {
  return (0, tf.tidy)(function () {
    var n = e.div((0, tf.scalar)(t, "int32"));
    return e.sub(n.mul((0, tf.scalar)(t, "int32")));
  });
}

function argmax2d(e) {
  var t = e.shape,
      n = t[0],
      r = t[1],
      o = t[2];
  return (0, tf.tidy)(function () {
    var t = e.reshape([n * r, o]).argMax(0),
        i = t.div((0, tf.scalar)(r, "int32")).expandDims(1),
        s = mod(t, r).expandDims(1);
    return (0, tf.concat)([i, s], 1);
  });
}

function getPointsConfidence(e, t) {
  for (var n = t.shape[0], r = new Float32Array(n), o = 0; o < n; o++) {
    var i = t.get(o, 0),
        s = t.get(o, 1);
    r[o] = e.get(i, s, o);
  }

  return r;
}

function getOffsetPoint$1(e, t, n, r) {
  return {
    y: r.get(e, t, n),
    x: r.get(e, t, n + NUM_KEYPOINTS)
  };
}

function getOffsetVectors(e, t) {
  for (var n = [], r = 0; r < NUM_KEYPOINTS; r++) {
    var o = getOffsetPoint$1(e.get(r, 0).valueOf(), e.get(r, 1).valueOf(), r, t),
        i = o.x,
        s = o.y;
    n.push(s), n.push(i);
  }

  return (0, tf.tensor2d)(n, [NUM_KEYPOINTS, 2]);
}

function getOffsetPoints(e, t, n) {
  return (0, tf.tidy)(function () {
    var r = getOffsetVectors(e, n);
    return e.toTensor().mul((0, tf.scalar)(t, "int32")).toFloat().add(r);
  });
}

function decodeSinglePose(e, t, n) {
  return __awaiter(this, void 0, void 0, function () {
    var r, o, i, s, u, a, l, p, c, f;
    return __generator(this, function (d) {
      switch (d.label) {
        case 0:
          return r = 0, o = argmax2d(e), [4, Promise.all([e.buffer(), t.buffer(), o.buffer()])];

        case 1:
          return i = d.sent(), s = i[0], u = i[1], a = i[2], [4, (l = getOffsetPoints(a, n, u)).buffer()];

        case 2:
          return p = d.sent(), c = Array.from(getPointsConfidence(s, a)), f = c.map(function (e, t) {
            return r += e, {
              position: {
                y: p.get(t, 0),
                x: p.get(t, 1)
              },
              part: partNames[t],
              score: e
            };
          }), o.dispose(), l.dispose(), [2, {
            keypoints: f,
            score: r / f.length
          }];
      }
    });
  });
}

var MOBILENET_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",
    RESNET50_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";

function resNet50Checkpoint(e, t) {
  var n = "model-stride" + e + ".json";
  return 4 === t ? RESNET50_BASE_URL + "float/" + n : RESNET50_BASE_URL + "quant" + t + "/" + n;
}

function mobileNetCheckpoint(e, t, n) {
  var r = {
    1: "100",
    .75: "075",
    .5: "050"
  },
      o = "model-stride" + e + ".json";
  return 4 === n ? MOBILENET_BASE_URL + "float/" + r[t] + "/" + o : MOBILENET_BASE_URL + "quant" + n + "/" + r[t] + "/" + o;
}

var imageNetMean = [-123.15, -115.9, -103.06],
    ResNet = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.preprocessInput = function (e) {
    return e.add(imageNetMean);
  }, t.prototype.nameOutputResults = function (e) {
    var t = e[0],
        n = e[1];
    return {
      offsets: e[2],
      heatmap: e[3],
      displacementFwd: t,
      displacementBwd: n
    };
  }, t;
}(BaseModel);

function eitherPointDoesntMeetConfidence(e, t, n) {
  return e < n || t < n;
}

function getAdjacentKeyPoints(e, t) {
  return connectedPartIndices.reduce(function (n, r) {
    var o = r[0],
        i = r[1];
    return eitherPointDoesntMeetConfidence(e[o].score, e[i].score, t) ? n : (n.push([e[o], e[i]]), n);
  }, []);
}

var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
    POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

function getBoundingBox(e) {
  return e.reduce(function (e, t) {
    var n = e.maxX,
        r = e.maxY,
        o = e.minX,
        i = e.minY,
        s = t.position,
        u = s.x,
        a = s.y;
    return {
      maxX: Math.max(n, u),
      maxY: Math.max(r, a),
      minX: Math.min(o, u),
      minY: Math.min(i, a)
    };
  }, {
    maxX: NEGATIVE_INFINITY,
    maxY: NEGATIVE_INFINITY,
    minX: POSITIVE_INFINITY,
    minY: POSITIVE_INFINITY
  });
}

function getBoundingBoxPoints(e) {
  var t = getBoundingBox(e),
      n = t.minX,
      r = t.minY,
      o = t.maxX,
      i = t.maxY;
  return [{
    x: n,
    y: r
  }, {
    x: o,
    y: r
  }, {
    x: o,
    y: i
  }, {
    x: n,
    y: i
  }];
}

function toTensorBuffers3D(e) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (t) {
      return [2, Promise.all(e.map(function (e) {
        return e.buffer();
      }))];
    });
  });
}

function scalePose(e, t, n, r, o) {
  return void 0 === r && (r = 0), void 0 === o && (o = 0), {
    score: e.score,
    keypoints: e.keypoints.map(function (e) {
      var i = e.score,
          s = e.part,
          u = e.position;
      return {
        score: i,
        part: s,
        position: {
          x: u.x * n + o,
          y: u.y * t + r
        }
      };
    })
  };
}

function scalePoses(e, t, n, r, o) {
  return void 0 === r && (r = 0), void 0 === o && (o = 0), 1 === n && 1 === t && 0 === r && 0 === o ? e : e.map(function (e) {
    return scalePose(e, t, n, r, o);
  });
}

function flipPoseHorizontal(e, t) {
  return {
    score: e.score,
    keypoints: e.keypoints.map(function (e) {
      var n = e.score,
          r = e.part,
          o = e.position;
      return {
        score: n,
        part: r,
        position: {
          x: t - 1 - o.x,
          y: o.y
        }
      };
    })
  };
}

function flipPosesHorizontal(e, t) {
  return t <= 0 ? e : e.map(function (e) {
    return flipPoseHorizontal(e, t);
  });
}

function toValidInputResolution(e, t) {
  return isValidInputResolution(e, t) ? e : Math.floor(e / t) * t + 1;
}

function validateInputResolution(e) {
  tf.util.assert("number" == typeof e || "object" == typeof e, function () {
    return "Invalid inputResolution " + e + ". Should be a number or an object with width and height";
  }), "object" == typeof e && (tf.util.assert("number" == typeof e.width, function () {
    return "inputResolution.width has a value of " + e.width + " which is invalid; it must be a number";
  }), tf.util.assert("number" == typeof e.height, function () {
    return "inputResolution.height has a value of " + e.height + " which is invalid; it must be a number";
  }));
}

function getValidInputResolutionDimensions(e, t) {
  return validateInputResolution(e), "object" == typeof e ? [toValidInputResolution(e.height, t), toValidInputResolution(e.width, t)] : [toValidInputResolution(e, t), toValidInputResolution(e, t)];
}

var VALID_OUTPUT_STRIDES = [8, 16, 32];

function assertValidOutputStride(e) {
  tf.util.assert("number" == typeof e, function () {
    return "outputStride is not a number";
  }), tf.util.assert(VALID_OUTPUT_STRIDES.indexOf(e) >= 0, function () {
    return "outputStride of " + e + " is invalid. It must be either 8, 16, or 32";
  });
}

function isValidInputResolution(e, t) {
  return (e - 1) % t == 0;
}

function assertValidResolution(e, t) {
  tf.util.assert("number" == typeof e[0] && "number" == typeof e[1], function () {
    return "both resolution values must be a number but had values " + e;
  }), tf.util.assert(isValidInputResolution(e[0], t), function () {
    return "height of " + e[0] + " is invalid for output stride " + t + ".";
  }), tf.util.assert(isValidInputResolution(e[1], t), function () {
    return "width of " + e[1] + " is invalid for output stride " + t + ".";
  });
}

function getInputTensorDimensions(e) {
  return e instanceof tf.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];
}

function toInputTensor(e) {
  return e instanceof tf.Tensor ? e : tf.browser.fromPixels(e);
}

function padAndResizeTo(e, t) {
  var n = t[0],
      r = t[1],
      o = getInputTensorDimensions(e),
      i = o[0],
      s = o[1],
      u = r / n,
      a = [0, 0, 0, 0],
      l = a[0],
      p = a[1],
      c = a[2],
      f = a[3];
  return s / i < u ? (l = 0, p = 0, c = Math.round(.5 * (u * i - s)), f = Math.round(.5 * (u * i - s))) : (l = Math.round(.5 * (1 / u * s - i)), p = Math.round(.5 * (1 / u * s - i)), c = 0, f = 0), {
    resized: (0, tf.tidy)(function () {
      var t = toInputTensor(e);
      return (t = (0, tf.pad3d)(t, [[l, p], [c, f], [0, 0]])).resizeBilinear([n, r]);
    }),
    padding: {
      top: l,
      left: c,
      right: f,
      bottom: p
    }
  };
}

function scaleAndFlipPoses(e, t, n, r, o) {
  var i = t[0],
      s = t[1],
      u = n[0],
      a = n[1],
      l = scalePoses(e, (i + r.top + r.bottom) / u, (s + r.left + r.right) / a, -r.top, -r.left);
  return o ? flipPosesHorizontal(l, s) : l;
}

var MOBILENET_V1_CONFIG = {
  architecture: "MobileNetV1",
  outputStride: 16,
  multiplier: .75,
  inputResolution: 257
},
    VALID_ARCHITECTURE = ["MobileNetV1", "ResNet50"],
    VALID_STRIDE = {
  MobileNetV1: [8, 16, 32],
  ResNet50: [32, 16]
},
    VALID_MULTIPLIER = {
  MobileNetV1: [.5, .75, 1],
  ResNet50: [1]
},
    VALID_QUANT_BYTES = [1, 2, 4];

function validateModelConfig(e) {
  if (null == (e = e || MOBILENET_V1_CONFIG).architecture && (e.architecture = "MobileNetV1"), VALID_ARCHITECTURE.indexOf(e.architecture) < 0) throw new Error("Invalid architecture " + e.architecture + ". Should be one of " + VALID_ARCHITECTURE);
  if (null == e.inputResolution && (e.inputResolution = 257), validateInputResolution(e.inputResolution), null == e.outputStride && (e.outputStride = 16), VALID_STRIDE[e.architecture].indexOf(e.outputStride) < 0) throw new Error("Invalid outputStride " + e.outputStride + ". Should be one of " + VALID_STRIDE[e.architecture] + " for architecutre " + e.architecture + ".");
  if (null == e.multiplier && (e.multiplier = 1), VALID_MULTIPLIER[e.architecture].indexOf(e.multiplier) < 0) throw new Error("Invalid multiplier " + e.multiplier + ". Should be one of " + VALID_MULTIPLIER[e.architecture] + " for architecutre " + e.architecture + ".");
  if (null == e.quantBytes && (e.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e.quantBytes) < 0) throw new Error("Invalid quantBytes " + e.quantBytes + ". Should be one of " + VALID_QUANT_BYTES + " for architecutre " + e.architecture + ".");
  return e;
}

var SINGLE_PERSON_INFERENCE_CONFIG = {
  flipHorizontal: !1
},
    MULTI_PERSON_INFERENCE_CONFIG = {
  flipHorizontal: !1,
  maxDetections: 5,
  scoreThreshold: .5,
  nmsRadius: 20
};

function validateMultiPersonInputConfig(e) {
  var t = e.maxDetections,
      n = e.scoreThreshold,
      r = e.nmsRadius;
  if (t <= 0) throw new Error("Invalid maxDetections " + t + ". Should be > 0");
  if (n < 0 || n > 1) throw new Error("Invalid scoreThreshold " + n + ". Should be in range [0.0, 1.0]");
  if (r <= 0) throw new Error("Invalid nmsRadius " + r + ".");
}

var PoseNet = function () {
  function e(e, t) {
    assertValidOutputStride(e.outputStride), assertValidResolution(t, e.outputStride), this.baseModel = e, this.inputResolution = t;
  }

  return e.prototype.estimateMultiplePoses = function (e, t) {
    return void 0 === t && (t = MULTI_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {
      var n, r, o, i, s, u, a, l, p, c, f, d, h, m, g, _, I, v, y, E, b;

      return __generator(this, function (N) {
        switch (N.label) {
          case 0:
            return n = __assign({}, MULTI_PERSON_INFERENCE_CONFIG, t), validateMultiPersonInputConfig(t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), f = c.heatmapScores, d = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, toTensorBuffers3D([f, d, h, m])];

          case 1:
            return g = N.sent(), _ = g[0], I = g[1], v = g[2], y = g[3], [4, decodeMultiplePoses(_, I, v, y, r, n.maxDetections, n.scoreThreshold, n.nmsRadius)];

          case 2:
            return E = N.sent(), b = scaleAndFlipPoses(E, [s, u], o, p, n.flipHorizontal), f.dispose(), d.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, b];
        }
      });
    });
  }, e.prototype.estimateSinglePose = function (e, t) {
    return void 0 === t && (t = SINGLE_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {
      var n, r, o, i, s, u, a, l, p, c, f, d, h, m, g, _;

      return __generator(this, function (I) {
        switch (I.label) {
          case 0:
            return n = __assign({}, SINGLE_PERSON_INFERENCE_CONFIG, t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), f = c.heatmapScores, d = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, decodeSinglePose(f, d, r)];

          case 1:
            return g = I.sent(), _ = scaleAndFlipPoses([g], [s, u], o, p, n.flipHorizontal), f.dispose(), d.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, _[0]];
        }
      });
    });
  }, e.prototype.estimatePoses = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return "single-person" !== t.decodingMethod ? [3, 2] : [4, this.estimateSinglePose(e, t)];

          case 1:
            return [2, [n.sent()]];

          case 2:
            return [2, this.estimateMultiplePoses(e, t)];
        }
      });
    });
  }, e.prototype.dispose = function () {
    this.baseModel.dispose();
  }, e;
}();

exports.PoseNet = PoseNet;

function loadMobileNet(e) {
  return __awaiter(this, void 0, void 0, function () {
    var t, n, r, o, i, s, u;
    return __generator(this, function (a) {
      switch (a.label) {
        case 0:
          if (t = e.outputStride, n = e.quantBytes, r = e.multiplier, null == tf) throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          return o = mobileNetCheckpoint(t, r, n), [4, (0, _tfjsConverter.loadGraphModel)(e.modelUrl || o)];

        case 1:
          return i = a.sent(), s = new MobileNet(i, t), u = getValidInputResolutionDimensions(e.inputResolution, s.outputStride), [2, new PoseNet(s, u)];
      }
    });
  });
}

function loadResNet(e) {
  return __awaiter(this, void 0, void 0, function () {
    var t, n, r, o, i, s;
    return __generator(this, function (u) {
      switch (u.label) {
        case 0:
          if (t = e.outputStride, n = e.quantBytes, null == tf) throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          return r = resNet50Checkpoint(t, n), [4, (0, _tfjsConverter.loadGraphModel)(e.modelUrl || r)];

        case 1:
          return o = u.sent(), i = new ResNet(o, t), s = getValidInputResolutionDimensions(e.inputResolution, i.outputStride), [2, new PoseNet(i, s)];
      }
    });
  });
}

function load(e) {
  return void 0 === e && (e = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (t) {
      return "ResNet50" === (e = validateModelConfig(e)).architecture ? [2, loadResNet(e)] : "MobileNetV1" === e.architecture ? [2, loadMobileNet(e)] : [2, null];
    });
  });
}

var version = "2.2.1";
exports.version = version;
},{"@tensorflow/tfjs-core":"node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","@tensorflow/tfjs-converter":"node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js"}],"node_modules/@tensorflow-models/facemesh/dist/facemesh.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.load = load$1;
exports.FaceMesh = void 0;

var _tfjsCore = require("@tensorflow/tfjs-core");

var _tfjsConverter = require("@tensorflow/tfjs-converter");

/**
    * @license
    * Copyright 2020 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
const disposeBox = e => {
  e.startEndTensor.dispose(), e.startPoint.dispose(), e.endPoint.dispose();
},
      createBox = e => ({
  startEndTensor: e,
  startPoint: (0, _tfjsCore.slice)(e, [0, 0], [-1, 2]),
  endPoint: (0, _tfjsCore.slice)(e, [0, 2], [-1, 2])
}),
      scaleBox = (e, t) => {
  const s = (0, _tfjsCore.mul)(e.startPoint, t),
        o = (0, _tfjsCore.mul)(e.endPoint, t),
        n = (0, _tfjsCore.concat2d)([s, o], 1);
  return createBox(n);
},
      ANCHORS_CONFIG = {
  strides: [8, 16],
  anchors: [2, 6]
},
      NUM_LANDMARKS = 6;

function generateAnchors(e, t, s) {
  const o = [];

  for (let n = 0; n < s.strides.length; n++) {
    const i = s.strides[n],
          r = Math.floor((t + i - 1) / i),
          a = Math.floor((e + i - 1) / i),
          c = s.anchors[n];

    for (let e = 0; e < r; e++) {
      const t = i * (e + .5);

      for (let e = 0; e < a; e++) {
        const s = i * (e + .5);

        for (let e = 0; e < c; e++) o.push([s, t]);
      }
    }
  }

  return o;
}

function decodeBounds(e, t, s) {
  const o = (0, _tfjsCore.slice)(e, [0, 1], [-1, 2]),
        n = (0, _tfjsCore.add)(o, t),
        i = (0, _tfjsCore.slice)(e, [0, 3], [-1, 2]),
        r = (0, _tfjsCore.div)(i, s),
        a = (0, _tfjsCore.div)(n, s),
        c = (0, _tfjsCore.div)(r, 2),
        l = (0, _tfjsCore.sub)(a, c),
        d = (0, _tfjsCore.add)(a, c),
        h = (0, _tfjsCore.mul)(l, s),
        u = (0, _tfjsCore.mul)(d, s);
  return (0, _tfjsCore.concat2d)([h, u], 1);
}

function getInputTensorDimensions(e) {
  return e instanceof _tfjsCore.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];
}

function flipFaceHorizontal(e, t) {
  let s, o, n;

  if (e.topLeft instanceof _tfjsCore.Tensor && e.bottomRight instanceof _tfjsCore.Tensor) {
    const [i, r] = (0, _tfjsCore.tidy)(() => [(0, _tfjsCore.concat)([(0, _tfjsCore.sub)(t - 1, e.topLeft.slice(0, 1)), e.topLeft.slice(1, 1)]), (0, _tfjsCore.concat)([(0, _tfjsCore.sub)(t - 1, e.bottomRight.slice(0, 1)), e.bottomRight.slice(1, 1)])]);
    s = i, o = r, null != e.landmarks && (n = (0, _tfjsCore.tidy)(() => {
      const s = (0, _tfjsCore.sub)((0, _tfjsCore.tensor1d)([t - 1, 0]), e.landmarks),
            o = (0, _tfjsCore.tensor1d)([1, -1]);
      return (0, _tfjsCore.mul)(s, o);
    }));
  } else {
    const [i, r] = e.topLeft,
          [a, c] = e.bottomRight;
    s = [t - 1 - i, r], o = [t - 1 - a, c], null != e.landmarks && (n = e.landmarks.map(e => [t - 1 - e[0], e[1]]));
  }

  const i = {
    topLeft: s,
    bottomRight: o
  };
  return null != n && (i.landmarks = n), null != e.probability && (i.probability = e.probability instanceof _tfjsCore.Tensor ? e.probability.clone() : e.probability), i;
}

function scaleBoxFromPrediction(e, t) {
  return (0, _tfjsCore.tidy)(() => {
    let s;
    return s = e.hasOwnProperty("box") ? e.box : e, scaleBox(s, t).startEndTensor.squeeze();
  });
}

class BlazeFaceModel {
  constructor(e, t, s, o, n, i) {
    this.blazeFaceModel = e, this.width = t, this.height = s, this.maxFaces = o, this.anchorsData = generateAnchors(t, s, ANCHORS_CONFIG), this.anchors = (0, _tfjsCore.tensor2d)(this.anchorsData), this.inputSizeData = [t, s], this.inputSize = (0, _tfjsCore.tensor1d)([t, s]), this.iouThreshold = n, this.scoreThreshold = i;
  }

  async getBoundingBoxes(e, t, s = !0) {
    const [o, n, i] = (0, _tfjsCore.tidy)(() => {
      const t = e.resizeBilinear([this.width, this.height]),
            s = (0, _tfjsCore.mul)((0, _tfjsCore.sub)(t.div(255), .5), 2),
            o = this.blazeFaceModel.predict(s).squeeze(),
            n = decodeBounds(o, this.anchors, this.inputSize),
            i = (0, _tfjsCore.slice)(o, [0, 0], [-1, 1]);
      return [o, n, (0, _tfjsCore.sigmoid)(i).squeeze()];
    }),
          r = console.warn;

    console.warn = () => {};

    const a = _tfjsCore.image.nonMaxSuppression(n, i, this.maxFaces, this.iouThreshold, this.scoreThreshold);

    console.warn = r;
    const c = await a.array();
    a.dispose();
    let l = c.map(e => (0, _tfjsCore.slice)(n, [e, 0], [1, -1]));
    t || (l = await Promise.all(l.map(async e => {
      const t = await e.array();
      return e.dispose(), t;
    })));
    const d = e.shape[1],
          h = e.shape[2];
    let u;
    u = t ? (0, _tfjsCore.div)([h, d], this.inputSize) : [h / this.inputSizeData[0], d / this.inputSizeData[1]];
    const p = [];

    for (let e = 0; e < l.length; e++) {
      const n = l[e],
            r = (0, _tfjsCore.tidy)(() => {
        const r = createBox(n instanceof _tfjsCore.Tensor ? n : (0, _tfjsCore.tensor2d)(n));
        if (!s) return r;
        const a = c[e];
        let l;
        return l = t ? this.anchors.slice([a, 0], [1, 2]) : this.anchorsData[a], {
          box: r,
          landmarks: (0, _tfjsCore.slice)(o, [a, NUM_LANDMARKS - 1], [1, -1]).squeeze().reshape([NUM_LANDMARKS, -1]),
          probability: (0, _tfjsCore.slice)(i, [a], [1]),
          anchor: l
        };
      });
      p.push(r);
    }

    return n.dispose(), i.dispose(), o.dispose(), {
      boxes: p,
      scaleFactor: u
    };
  }

  async estimateFaces(e, t = !1, s = !1, o = !0) {
    const [, n] = getInputTensorDimensions(e),
          i = (0, _tfjsCore.tidy)(() => (e instanceof _tfjsCore.Tensor || (e = _tfjsCore.browser.fromPixels(e)), e.toFloat().expandDims(0))),
          {
      boxes: r,
      scaleFactor: a
    } = await this.getBoundingBoxes(i, t, o);
    return i.dispose(), t ? r.map(e => {
      const t = scaleBoxFromPrediction(e, a);
      let i = {
        topLeft: t.slice([0], [2]),
        bottomRight: t.slice([2], [2])
      };

      if (o) {
        const {
          landmarks: t,
          probability: s,
          anchor: o
        } = e,
              n = t.add(o).mul(a);
        i.landmarks = n, i.probability = s;
      }

      return s && (i = flipFaceHorizontal(i, n)), i;
    }) : Promise.all(r.map(async e => {
      const t = scaleBoxFromPrediction(e, a);
      let i;

      if (o) {
        const [s, o, n] = await Promise.all([e.landmarks, t, e.probability].map(async e => e.array())),
              r = e.anchor,
              [c, l] = a,
              d = s.map(e => [(e[0] + r[0]) * c, (e[1] + r[1]) * l]);
        i = {
          topLeft: o.slice(0, 2),
          bottomRight: o.slice(2),
          landmarks: d,
          probability: n
        }, disposeBox(e.box), e.landmarks.dispose(), e.probability.dispose();
      } else {
        const e = await t.array();
        i = {
          topLeft: e.slice(0, 2),
          bottomRight: e.slice(2)
        };
      }

      return t.dispose(), s && (i = flipFaceHorizontal(i, n)), i;
    }));
  }

}

const BLAZEFACE_MODEL_URL = "https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1";

async function load({
  maxFaces: e = 10,
  inputWidth: t = 128,
  inputHeight: s = 128,
  iouThreshold: o = .3,
  scoreThreshold: n = .75
} = {}) {
  const i = await (0, _tfjsConverter.loadGraphModel)(BLAZEFACE_MODEL_URL, {
    fromTFHub: !0
  });
  return new BlazeFaceModel(i, t, s, e, o, n);
}

const MESH_ANNOTATIONS = {
  silhouette: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109],
  lipsUpperOuter: [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291],
  lipsLowerOuter: [146, 91, 181, 84, 17, 314, 405, 321, 375, 291],
  lipsUpperInner: [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308],
  lipsLowerInner: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308],
  rightEyeUpper0: [246, 161, 160, 159, 158, 157, 173],
  rightEyeLower0: [33, 7, 163, 144, 145, 153, 154, 155, 133],
  rightEyeUpper1: [247, 30, 29, 27, 28, 56, 190],
  rightEyeLower1: [130, 25, 110, 24, 23, 22, 26, 112, 243],
  rightEyeUpper2: [113, 225, 224, 223, 222, 221, 189],
  rightEyeLower2: [226, 31, 228, 229, 230, 231, 232, 233, 244],
  rightEyeLower3: [143, 111, 117, 118, 119, 120, 121, 128, 245],
  rightEyebrowUpper: [156, 70, 63, 105, 66, 107, 55, 193],
  rightEyebrowLower: [35, 124, 46, 53, 52, 65],
  leftEyeUpper0: [466, 388, 387, 386, 385, 384, 398],
  leftEyeLower0: [263, 249, 390, 373, 374, 380, 381, 382, 362],
  leftEyeUpper1: [467, 260, 259, 257, 258, 286, 414],
  leftEyeLower1: [359, 255, 339, 254, 253, 252, 256, 341, 463],
  leftEyeUpper2: [342, 445, 444, 443, 442, 441, 413],
  leftEyeLower2: [446, 261, 448, 449, 450, 451, 452, 453, 464],
  leftEyeLower3: [372, 340, 346, 347, 348, 349, 350, 357, 465],
  leftEyebrowUpper: [383, 300, 293, 334, 296, 336, 285, 417],
  leftEyebrowLower: [265, 353, 276, 283, 282, 295],
  midwayBetweenEyes: [168],
  noseTip: [1],
  noseBottom: [2],
  noseRightCorner: [98],
  noseLeftCorner: [327],
  rightCheek: [205],
  leftCheek: [425]
};

function disposeBox$1(e) {
  null != e && null != e.startPoint && (e.startEndTensor.dispose(), e.startPoint.dispose(), e.endPoint.dispose());
}

function createBox$1(e, t, s) {
  return {
    startEndTensor: e,
    startPoint: null != t ? t : (0, _tfjsCore.slice)(e, [0, 0], [-1, 2]),
    endPoint: null != s ? s : (0, _tfjsCore.slice)(e, [0, 2], [-1, 2])
  };
}

function scaleBoxCoordinates(e, t) {
  const s = (0, _tfjsCore.mul)(e.startPoint, t),
        o = (0, _tfjsCore.mul)(e.endPoint, t);
  return createBox$1((0, _tfjsCore.concat2d)([s, o], 1));
}

function getBoxSize(e) {
  return (0, _tfjsCore.tidy)(() => {
    const t = (0, _tfjsCore.sub)(e.endPoint, e.startPoint);
    return (0, _tfjsCore.abs)(t);
  });
}

function getBoxCenter(e) {
  return (0, _tfjsCore.tidy)(() => {
    const t = (0, _tfjsCore.div)((0, _tfjsCore.sub)(e.endPoint, e.startPoint), 2);
    return (0, _tfjsCore.add)(e.startPoint, t);
  });
}

function cutBoxFromImageAndResize(e, t, s) {
  const o = t.shape[1],
        n = t.shape[2],
        i = e.startEndTensor;
  return (0, _tfjsCore.tidy)(() => {
    const e = (0, _tfjsCore.concat2d)([i.slice([0, 1], [-1, 1]), i.slice([0, 0], [-1, 1]), i.slice([0, 3], [-1, 1]), i.slice([0, 2], [-1, 1])], 0),
          r = (0, _tfjsCore.div)(e.transpose(), [o, n, o, n]);
    return _tfjsCore.image.cropAndResize(t, r, [0], s);
  });
}

function enlargeBox(e, t = 1.5) {
  return (0, _tfjsCore.tidy)(() => {
    const s = getBoxCenter(e),
          o = getBoxSize(e),
          n = (0, _tfjsCore.mul)((0, _tfjsCore.div)(o, 2), t),
          i = (0, _tfjsCore.sub)(s, n),
          r = (0, _tfjsCore.add)(s, n);
    return createBox$1((0, _tfjsCore.concat2d)([i, r], 1), i, r);
  });
}

const LANDMARKS_COUNT = 468,
      UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD = .25;

class Pipeline {
  constructor(e, t, s, o, n, i) {
    this.regionsOfInterest = [], this.runsWithoutFaceDetector = 0, this.boundingBoxDetector = e, this.meshDetector = t, this.meshWidth = s, this.meshHeight = o, this.maxContinuousChecks = n, this.maxFaces = i;
  }

  async predict(e) {
    if (this.shouldUpdateRegionsOfInterest()) {
      const t = !0,
            s = !1,
            {
        boxes: o,
        scaleFactor: n
      } = await this.boundingBoxDetector.getBoundingBoxes(e, t, s);
      if (0 === o.length) return n.dispose(), this.clearAllRegionsOfInterest(), null;
      const i = o.map(e => enlargeBox(scaleBoxCoordinates(e, n)));
      o.forEach(disposeBox$1), this.updateRegionsOfInterest(i), this.runsWithoutFaceDetector = 0;
    } else this.runsWithoutFaceDetector++;

    return (0, _tfjsCore.tidy)(() => this.regionsOfInterest.map((t, s) => {
      const o = cutBoxFromImageAndResize(t, e, [this.meshHeight, this.meshWidth]).div(255),
            [, n, i] = this.meshDetector.predict(o),
            r = (0, _tfjsCore.reshape)(i, [-1, 3]),
            a = (0, _tfjsCore.div)(getBoxSize(t), [this.meshWidth, this.meshHeight]),
            c = (0, _tfjsCore.mul)(r, a.concat((0, _tfjsCore.tensor2d)([1], [1, 1]), 1)).add(t.startPoint.concat((0, _tfjsCore.tensor2d)([0], [1, 1]), 1)),
            l = this.calculateLandmarksBoundingBox(c);
      return disposeBox$1(this.regionsOfInterest[s]), this.regionsOfInterest[s] = l, {
        coords: r,
        scaledCoords: c,
        box: l,
        flag: n.squeeze()
      };
    }));
  }

  updateRegionsOfInterest(e) {
    for (let t = 0; t < e.length; t++) {
      const s = e[t],
            o = this.regionsOfInterest[t];
      let n = 0;

      if (o && o.startPoint) {
        const [e, t, i, r] = s.startEndTensor.arraySync()[0],
              [a, c, l, d] = o.startEndTensor.arraySync()[0],
              h = Math.max(e, a),
              u = Math.max(t, c),
              p = (Math.min(i, l) - h) * (Math.min(r, d) - u);
        n = p / ((i - e) * (r - t) + (l - a) * (d - t) - p);
      }

      n > UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD ? disposeBox$1(s) : (this.regionsOfInterest[t] = s, disposeBox$1(o));
    }

    for (let t = e.length; t < this.regionsOfInterest.length; t++) disposeBox$1(this.regionsOfInterest[t]);

    this.regionsOfInterest = this.regionsOfInterest.slice(0, e.length);
  }

  clearRegionOfInterest(e) {
    null != this.regionsOfInterest[e] && (disposeBox$1(this.regionsOfInterest[e]), this.regionsOfInterest = [...this.regionsOfInterest.slice(0, e), ...this.regionsOfInterest.slice(e + 1)]);
  }

  clearAllRegionsOfInterest() {
    for (let e = 0; e < this.regionsOfInterest.length; e++) disposeBox$1(this.regionsOfInterest[e]);

    this.regionsOfInterest = [];
  }

  shouldUpdateRegionsOfInterest() {
    const e = this.regionsOfInterest.length,
          t = 0 === e;
    return 1 === this.maxFaces || t ? t : e !== this.maxFaces && this.runsWithoutFaceDetector >= this.maxContinuousChecks;
  }

  calculateLandmarksBoundingBox(e) {
    const t = e.slice([0, 0], [LANDMARKS_COUNT, 1]),
          s = e.slice([0, 1], [LANDMARKS_COUNT, 1]);
    return enlargeBox(createBox$1((0, _tfjsCore.stack)([t.min(), s.min(), t.max(), s.max()]).expandDims(0)));
  }

}

const FACEMESH_GRAPHMODEL_PATH = "https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",
      MESH_MODEL_INPUT_WIDTH = 192,
      MESH_MODEL_INPUT_HEIGHT = 192;

async function load$1({
  maxContinuousChecks: e = 5,
  detectionConfidence: t = .9,
  maxFaces: s = 10,
  iouThreshold: o = .3,
  scoreThreshold: n = .75
} = {}) {
  const [i, r] = await Promise.all([loadDetectorModel(s, o, n), loadMeshModel()]);
  return new FaceMesh(i, r, e, t, s);
}

async function loadDetectorModel(e, t, s) {
  return load({
    maxFaces: e,
    iouThreshold: t,
    scoreThreshold: s
  });
}

async function loadMeshModel() {
  return (0, _tfjsConverter.loadGraphModel)(FACEMESH_GRAPHMODEL_PATH, {
    fromTFHub: !0
  });
}

function getInputTensorDimensions$1(e) {
  return e instanceof _tfjsCore.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];
}

function flipFaceHorizontal$1(e, t) {
  if (e.mesh instanceof _tfjsCore.Tensor) {
    const [s, o, n, i] = (0, _tfjsCore.tidy)(() => {
      const s = (0, _tfjsCore.tensor1d)([t - 1, 0, 0]),
            o = (0, _tfjsCore.tensor1d)([1, -1, 1]);
      return (0, _tfjsCore.tidy)(() => [(0, _tfjsCore.concat)([(0, _tfjsCore.sub)(t - 1, e.boundingBox.topLeft.slice(0, 1)), e.boundingBox.topLeft.slice(1, 1)]), (0, _tfjsCore.concat)([(0, _tfjsCore.sub)(t - 1, e.boundingBox.bottomRight.slice(0, 1)), e.boundingBox.bottomRight.slice(1, 1)]), (0, _tfjsCore.sub)(s, e.mesh).mul(o), (0, _tfjsCore.sub)(s, e.scaledMesh).mul(o)]);
    });
    return Object.assign({}, e, {
      boundingBox: {
        topLeft: s,
        bottomRight: o
      },
      mesh: n,
      scaledMesh: i
    });
  }

  return Object.assign({}, e, {
    boundingBox: {
      topLeft: [t - 1 - e.boundingBox.topLeft[0], e.boundingBox.topLeft[1]],
      bottomRight: [t - 1 - e.boundingBox.bottomRight[0], e.boundingBox.bottomRight[1]]
    },
    mesh: e.mesh.map(e => {
      const s = e.slice(0);
      return s[0] = t - 1 - e[0], s;
    }),
    scaledMesh: e.scaledMesh.map(e => {
      const s = e.slice(0);
      return s[0] = t - 1 - e[0], s;
    })
  });
}

class FaceMesh {
  constructor(e, t, s, o, n) {
    this.pipeline = new Pipeline(e, t, MESH_MODEL_INPUT_WIDTH, MESH_MODEL_INPUT_HEIGHT, s, n), this.detectionConfidence = o;
  }

  static getAnnotations() {
    return MESH_ANNOTATIONS;
  }

  async estimateFaces(e, t = !1, s = !1) {
    const [, o] = getInputTensorDimensions$1(e),
          n = (0, _tfjsCore.tidy)(() => (e instanceof _tfjsCore.Tensor || (e = _tfjsCore.browser.fromPixels(e)), e.toFloat().expandDims(0))),
          i = (0, _tfjsCore.env)().get("WEBGL_PACK_DEPTHWISECONV");
    (0, _tfjsCore.env)().set("WEBGL_PACK_DEPTHWISECONV", !0);
    const r = await this.pipeline.predict(n);
    return (0, _tfjsCore.env)().set("WEBGL_PACK_DEPTHWISECONV", i), n.dispose(), null != r && r.length > 0 ? Promise.all(r.map(async (e, n) => {
      const {
        coords: i,
        scaledCoords: r,
        box: a,
        flag: c
      } = e;
      let l = [c];
      t || (l = l.concat([i, r, a.startPoint, a.endPoint]));
      const d = await Promise.all(l.map(async e => e.array())),
            h = d[0];

      if (c.dispose(), h < this.detectionConfidence && this.pipeline.clearRegionOfInterest(n), t) {
        const e = {
          faceInViewConfidence: h,
          mesh: i,
          scaledMesh: r,
          boundingBox: {
            topLeft: a.startPoint.squeeze(),
            bottomRight: a.endPoint.squeeze()
          }
        };
        return s ? flipFaceHorizontal$1(e, o) : e;
      }

      const [u, p, f, m] = d.slice(1);
      r.dispose(), i.dispose();
      let g = {
        faceInViewConfidence: h,
        boundingBox: {
          topLeft: f,
          bottomRight: m
        },
        mesh: u,
        scaledMesh: p
      };
      s && (g = flipFaceHorizontal$1(g, o));
      const b = {};

      for (const e in MESH_ANNOTATIONS) b[e] = MESH_ANNOTATIONS[e].map(e => g.scaledMesh[e]);

      return g.annotations = b, g;
    })) : [];
  }

}

exports.FaceMesh = FaceMesh;
},{"@tensorflow/tfjs-core":"node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","@tensorflow/tfjs-converter":"node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js"}],"node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.input = input;
exports.loadLayersModel = loadLayersModel;
exports.model = model;
exports.registerCallbackConstructor = registerCallbackConstructor;
exports.sequential = sequential;
exports.version_layers = exports.LayerVariable = exports.Sequential = exports.RNN = exports.LayersModel = exports.SymbolicTensor = exports.InputSpec = exports.EarlyStopping = exports.callbacks = exports.Callback = exports.History = exports.CustomCallback = exports.CallbackList = exports.regularizers = exports.models = exports.metrics = exports.layers = exports.initializers = exports.constraints = void 0;

var _tfjsCore = require("@tensorflow/tfjs-core");

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics = function (e, t) {
  return (extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (e, t) {
    e.__proto__ = t;
  } || function (e, t) {
    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
  })(e, t);
};

function __extends(e, t) {
  function n() {
    this.constructor = e;
  }

  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());
}

var _epsilon,
    __assign = function () {
  return (__assign = Object.assign || function (e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);

    return e;
  }).apply(this, arguments);
};

function __awaiter(e, t, n, r) {
  return new (n || (n = Promise))(function (i, a) {
    function o(e) {
      try {
        l(r.next(e));
      } catch (e) {
        a(e);
      }
    }

    function s(e) {
      try {
        l(r.throw(e));
      } catch (e) {
        a(e);
      }
    }

    function l(e) {
      e.done ? i(e.value) : new n(function (t) {
        t(e.value);
      }).then(o, s);
    }

    l((r = r.apply(e, t || [])).next());
  });
}

function __generator(e, t) {
  var n,
      r,
      i,
      a,
      o = {
    label: 0,
    sent: function () {
      if (1 & i[0]) throw i[1];
      return i[1];
    },
    trys: [],
    ops: []
  };
  return a = {
    next: s(0),
    throw: s(1),
    return: s(2)
  }, "function" == typeof Symbol && (a[Symbol.iterator] = function () {
    return this;
  }), a;

  function s(a) {
    return function (s) {
      return function (a) {
        if (n) throw new TypeError("Generator is already executing.");

        for (; o;) try {
          if (n = 1, r && (i = 2 & a[0] ? r.return : a[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, a[1])).done) return i;

          switch (r = 0, i && (a = [2 & a[0], i.value]), a[0]) {
            case 0:
            case 1:
              i = a;
              break;

            case 4:
              return o.label++, {
                value: a[1],
                done: !1
              };

            case 5:
              o.label++, r = a[1], a = [0];
              continue;

            case 7:
              a = o.ops.pop(), o.trys.pop();
              continue;

            default:
              if (!(i = (i = o.trys).length > 0 && i[i.length - 1]) && (6 === a[0] || 2 === a[0])) {
                o = 0;
                continue;
              }

              if (3 === a[0] && (!i || a[1] > i[0] && a[1] < i[3])) {
                o.label = a[1];
                break;
              }

              if (6 === a[0] && o.label < i[1]) {
                o.label = i[1], i = a;
                break;
              }

              if (i && o.label < i[2]) {
                o.label = i[2], o.ops.push(a);
                break;
              }

              i[2] && o.ops.pop(), o.trys.pop();
              continue;
          }

          a = t.call(e, o);
        } catch (e) {
          a = [6, e], r = 0;
        } finally {
          n = i = 0;
        }

        if (5 & a[0]) throw a[1];
        return {
          value: a[0] ? a[1] : void 0,
          done: !0
        };
      }([a, s]);
    };
  }
}

function epsilon() {
  return null == _epsilon && (_epsilon = (0, _tfjsCore.backend)().epsilon()), _epsilon;
}

function imageDataFormat() {
  return "channelsLast";
}

var AttributeError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    RuntimeError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    ValueError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    NotImplementedError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    AssertionError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error),
    IndexError = function (e) {
  function t(n) {
    var r = e.call(this, n) || this;
    return Object.setPrototypeOf(r, t.prototype), r;
  }

  return __extends(t, e), t;
}(Error);

function pyListRepeat(e, t) {
  if (Array.isArray(e)) {
    for (var n = [], r = 0; r < t; r++) n = n.concat(e);

    return n;
  }

  return (n = new Array(t)).fill(e), n;
}

function assert(e, t) {
  if (!e) throw new AssertionError(t);
}

function count(e, t) {
  for (var n = 0, r = 0, i = e; r < i.length; r++) {
    i[r] === t && n++;
  }

  return n;
}

function singletonOrArray(e) {
  return 1 === e.length ? e[0] : e;
}

function toList(e) {
  return Array.isArray(e) ? e : [e];
}

function toSnakeCase(e) {
  var t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  return "_" !== t[0] ? t : "private" + t;
}

function toCamelCase(e) {
  return e.length <= 1 ? e : -1 === e.indexOf("_") ? e : e.replace(/[_]+(\w|$)/g, function (e, t) {
    return t.toUpperCase();
  });
}

var _GLOBAL_CUSTOM_OBJECTS = {};

function serializeKerasObject(e) {
  if (null === e || void 0 === e) return null;
  var t = {};
  return t.className = e.getClassName(), t.config = e.getConfig(), t;
}

function convertNDArrayScalarsInConfig(e) {
  if (null != e && "object" == typeof e) if (Array.isArray(e)) e.forEach(function (e) {
    return convertNDArrayScalarsInConfig(e);
  });else for (var t = 0, n = Object.keys(e); t < n.length; t++) {
    var r = n[t],
        i = e[r];
    null != i && "object" == typeof i && (Array.isArray(i) || "ndarray" !== i.type || "number" != typeof i.value ? convertNDArrayScalarsInConfig(i) : e[r] = i.value);
  }
}

function deserializeKerasObject(e, t, n, r, i) {
  var a, o, s;

  if (void 0 === t && (t = {}), void 0 === n && (n = {}), void 0 === r && (r = "object"), void 0 === i && (i = !1), "string" == typeof e) {
    var l = e,
        u = void 0;
    if (l in n) u = n[l];else if (l in _GLOBAL_CUSTOM_OBJECTS) u = _GLOBAL_CUSTOM_OBJECTS[l];else if (null == (u = t[l])) throw new ValueError("Unknown " + r + ": " + e + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
    return u;
  }

  var c = e;
  if (null == c.className || null == c.config) throw new ValueError(r + ": Improper config format: " + JSON.stringify(c) + ".\n'className' and 'config' must set.");
  var p = c.className,
      h = void 0,
      d = void 0;
  if (p in n ? (h = (a = n[p])[0], d = a[1]) : p in _GLOBAL_CUSTOM_OBJECTS ? (h = (o = _GLOBAL_CUSTOM_OBJECTS.className)[0], d = o[1]) : p in t && (h = (s = t[p])[0], d = s[1]), null == h) throw new ValueError("Unknown " + r + ": " + p + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");

  if (null != d) {
    for (var f = {}, g = 0, m = Object.keys(_GLOBAL_CUSTOM_OBJECTS); g < m.length; g++) {
      f[S = m[g]] = _GLOBAL_CUSTOM_OBJECTS[S];
    }

    for (var y = 0, v = Object.keys(n); y < v.length; y++) {
      f[S = v[y]] = n[S];
    }

    c.config.customObjects = f;

    for (var b = __assign({}, _GLOBAL_CUSTOM_OBJECTS), w = 0, z = Object.keys(n); w < z.length; w++) {
      var S = z[w];
      _GLOBAL_CUSTOM_OBJECTS[S] = n[S];
    }

    convertNDArrayScalarsInConfig(c.config);
    var A = d(h, c.config, n, i);
    return _GLOBAL_CUSTOM_OBJECTS = __assign({}, b), A;
  }

  b = __assign({}, _GLOBAL_CUSTOM_OBJECTS);

  for (var _ = 0, I = Object.keys(n); _ < I.length; _++) {
    S = I[_];
    _GLOBAL_CUSTOM_OBJECTS[S] = n[S];
  }

  A = new h(c.config);
  return _GLOBAL_CUSTOM_OBJECTS = __assign({}, b), A;
}

function numberCompare(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}

function reverseNumberCompare(e, t) {
  return -1 * numberCompare(e, t);
}

function unique(e) {
  if (null == e) return e;

  for (var t = [], n = 0, r = e; n < r.length; n++) {
    var i = r[n];
    -1 === t.indexOf(i) && t.push(i);
  }

  return t;
}

function isObjectEmpty(e) {
  if (null == e) throw new ValueError("Invalid value in obj: " + JSON.stringify(e));

  for (var t in e) if (e.hasOwnProperty(t)) return !1;

  return !0;
}

function checkStringTypeUnionValue(e, t, n) {
  if (null != n && e.indexOf(n) < 0) throw new ValueError(n + " is not a valid " + t + ".  Valid values are " + e + " or null/undefined.");
}

function checkArrayTypeAndLength(e, t, n, r) {
  return void 0 === n && (n = 0), void 0 === r && (r = 1 / 0), assert(n >= 0), assert(r >= n), Array.isArray(e) && e.length >= n && e.length <= r && e.every(function (e) {
    return typeof e === t;
  });
}

function assertPositiveInteger(e, t) {
  Array.isArray(e) ? (_tfjsCore.util.assert(e.length > 0, function () {
    return t + " is unexpectedly an empty array.";
  }), e.forEach(function (e, n) {
    return assertPositiveInteger(e, "element " + (n + 1) + " of " + t);
  })) : _tfjsCore.util.assert(Number.isInteger(e) && e > 0, function () {
    return "Expected " + t + " to be a positive integer, but got " + formatAsFriendlyString(e) + ".";
  });
}

function formatAsFriendlyString(e) {
  return null === e ? "null" : Array.isArray(e) ? "[" + e.map(function (e) {
    return formatAsFriendlyString(e);
  }).join(",") + "]" : "string" == typeof e ? '"' + e + '"' : "" + e;
}

function debounce(e, t) {
  var n,
      r = _tfjsCore.util.now();

  return function () {
    for (var i = [], a = 0; a < arguments.length; a++) i[a] = arguments[a];

    var o = _tfjsCore.util.now();

    return o - r < t ? n : (r = o, n = e.apply(void 0, i));
  };
}

function mapActivationToFusedKernel(e) {
  return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null;
}

function calcL2Norms(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.sqrt)((0, _tfjsCore.sum)((0, _tfjsCore.mulStrict)(e, e), t, !0));
  });
}

var Constraint = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    return {};
  }, t;
}(_tfjsCore.serialization.Serializable),
    MaxNorm = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.defaultMaxValue = 2, n.defaultAxis = 0, n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue, n.axis = null != t.axis ? t.axis : n.defaultAxis, n;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      var n = calcL2Norms(e, t.axis),
          r = (0, _tfjsCore.clipByValue)(n, 0, t.maxValue);
      return (0, _tfjsCore.mul)(e, (0, _tfjsCore.div)(r, (0, _tfjsCore.add)(epsilon(), n)));
    });
  }, t.prototype.getConfig = function () {
    return {
      maxValue: this.maxValue,
      axis: this.axis
    };
  }, t.className = "MaxNorm", t;
}(Constraint);

_tfjsCore.serialization.registerClass(MaxNorm);

var UnitNorm = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.defaultAxis = 0, n.axis = null != t.axis ? t.axis : n.defaultAxis, n;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      return (0, _tfjsCore.div)(e, (0, _tfjsCore.add)(epsilon(), calcL2Norms(e, t.axis)));
    });
  }, t.prototype.getConfig = function () {
    return {
      axis: this.axis
    };
  }, t.className = "UnitNorm", t;
}(Constraint);

_tfjsCore.serialization.registerClass(UnitNorm);

var NonNeg = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.relu)(e);
  }, t.className = "NonNeg", t;
}(Constraint);

_tfjsCore.serialization.registerClass(NonNeg);

var MinMaxNorm = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.defaultMinValue = 0, n.defaultMaxValue = 1, n.defaultRate = 1, n.defaultAxis = 0, n.minValue = null != t.minValue ? t.minValue : n.defaultMinValue, n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue, n.rate = null != t.rate ? t.rate : n.defaultRate, n.axis = null != t.axis ? t.axis : n.defaultAxis, n;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      var n = calcL2Norms(e, t.axis),
          r = (0, _tfjsCore.add)((0, _tfjsCore.mul)(t.rate, (0, _tfjsCore.clipByValue)(n, t.minValue, t.maxValue)), (0, _tfjsCore.mul)(1 - t.rate, n));
      return (0, _tfjsCore.mul)(e, (0, _tfjsCore.div)(r, (0, _tfjsCore.add)(epsilon(), n)));
    });
  }, t.prototype.getConfig = function () {
    return {
      minValue: this.minValue,
      maxValue: this.maxValue,
      rate: this.rate,
      axis: this.axis
    };
  }, t.className = "MinMaxNorm", t;
}(Constraint);

_tfjsCore.serialization.registerClass(MinMaxNorm);

var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
  maxNorm: "MaxNorm",
  minMaxNorm: "MinMaxNorm",
  nonNeg: "NonNeg",
  unitNorm: "UnitNorm"
};

function serializeConstraint(e) {
  return serializeKerasObject(e);
}

function deserializeConstraint(e, t) {
  return void 0 === t && (t = {}), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "constraint");
}

function getConstraint(e) {
  return null == e ? null : "string" == typeof e ? deserializeConstraint({
    className: e in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[e] : e,
    config: {}
  }) : e instanceof Constraint ? e : deserializeConstraint(e);
}

function maxNorm(e) {
  return new MaxNorm(e);
}

function unitNorm(e) {
  return new UnitNorm(e);
}

function nonNeg() {
  return new NonNeg();
}

function minMaxNorm(e) {
  return new MinMaxNorm(e);
}

var exports_constraints = Object.freeze({
  maxNorm: maxNorm,
  unitNorm: unitNorm,
  nonNeg: nonNeg,
  minMaxNorm: minMaxNorm
}),
    VALID_DATA_FORMAT_VALUES = ["channelsFirst", "channelsLast"],
    VALID_PADDING_MODE_VALUES = ["valid", "same", "causal"],
    VALID_POOL_MODE_VALUES = ["max", "avg"],
    VALID_BIDIRECTIONAL_MERGE_MODES = ["sum", "mul", "concat", "ave"],
    nameMap = new Map();
exports.constraints = exports_constraints;

function checkDataFormat(e) {
  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, "DataFormat", e);
}

function checkPaddingMode(e) {
  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, "PaddingMode", e);
}

function checkPoolMode(e) {
  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, "PoolMode", e);
}

var _nameScopeStack = [],
    _nameScopeDivider = "/";

function nameScope(e, t) {
  _nameScopeStack.push(e);

  try {
    var n = t();
    return _nameScopeStack.pop(), n;
  } catch (e) {
    throw _nameScopeStack.pop(), e;
  }
}

function currentNameScopePrefix() {
  return 0 === _nameScopeStack.length ? "" : _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
}

function getScopedTensorName(e) {
  if (!isValidTensorName(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  return currentNameScopePrefix() + e;
}

function getUniqueTensorName(e) {
  if (!isValidTensorName(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  nameMap.has(e) || nameMap.set(e, 0);
  var t = nameMap.get(e);

  if (nameMap.set(e, nameMap.get(e) + 1), t > 0) {
    var n = e + "_" + t;
    return nameMap.set(n, 1), n;
  }

  return e;
}

var tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);

function isValidTensorName(e) {
  return !!e.match(tensorNameRegex);
}

function isInteger(e) {
  return e === parseInt(e.toString(), 10);
}

function arrayProd(e, t, n) {
  null == t && (t = 0), null == n && (n = e.length);

  for (var r = 1, i = t; i < n; ++i) r *= e[i];

  return r;
}

function toArray1D(e) {
  return e = Array.isArray(e) ? new Float32Array(e) : e, (0, _tfjsCore.tensor1d)(e);
}

function min$1(e) {
  return (0, _tfjsCore.min)(toArray1D(e)).dataSync()[0];
}

function max$1(e) {
  return (0, _tfjsCore.max)(toArray1D(e)).dataSync()[0];
}

function range(e, t) {
  if (t < e) throw new ValueError("end (" + t + ") < begin (" + e + ") is forbidden.");

  for (var n = [], r = e; r < t; ++r) n.push(r);

  return n;
}

function cast$1(e, t) {
  return e.asType(t);
}

function expandDims$1(e, t) {
  void 0 === t && (t = -1);
  var n = e.shape.slice();
  return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), e.reshape(n);
}

function repeat(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    if (2 !== e.shape.length) throw new ValueError("repeat() expects a rank-2 tensor, but received a rank-" + e.shape.length + " tensor.");
    return tile$1(expandDims$1(e, 1), [1, t, 1]);
  });
}

function flatten(e) {
  var t = [arrayProd(e.shape)];
  return e.reshape(t);
}

function batchFlatten(e) {
  if (e.rank <= 1) throw new ValueError("batchFlatten requires a minimum rank of 2. Got rank: " + e.rank + ".");
  var t = [e.shape[0], arrayProd(e.shape, 1)];
  return e.reshape(t);
}

function sliceAlongFirstAxis(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    switch (e.rank) {
      case 1:
        return (0, _tfjsCore.slice1d)(e, t, n);

      case 2:
        return (0, _tfjsCore.slice2d)(e, [t, 0], [n, e.shape[1]]);

      case 3:
        return (0, _tfjsCore.slice3d)(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);

      case 4:
        return (0, _tfjsCore.slice4d)(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);

      case 5:
        return (0, _tfjsCore.slice)(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);

      case 6:
        return (0, _tfjsCore.slice)(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);

      default:
        throw new ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: " + e.rank);
    }
  });
}

function sliceAlongLastAxis(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    switch (e.rank) {
      case 1:
        return (0, _tfjsCore.slice1d)(e, t, n);

      case 2:
        return (0, _tfjsCore.slice2d)(e, [0, t], [e.shape[0], n]);

      case 3:
        return (0, _tfjsCore.slice3d)(e, [0, 0, t], [e.shape[0], e.shape[1], n]);

      case 4:
        return (0, _tfjsCore.slice4d)(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);

      default:
        throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank);
    }
  });
}

function sliceAlongAxis(e, t, n, r) {
  return (0, _tfjsCore.tidy)(function () {
    switch (e.rank) {
      case 1:
        return (0, _tfjsCore.slice1d)(e, t, n);

      case 2:
        switch (r) {
          case 1:
            return sliceAlongFirstAxis(e, t, n);

          case 2:
            return sliceAlongLastAxis(e, t, n);

          default:
            throw new ValueError("The axis is not within the rank of the tensor " + r);
        }

      case 3:
        switch (r) {
          case 1:
            return sliceAlongFirstAxis(e, t, n);

          case 2:
            return (0, _tfjsCore.slice3d)(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);

          case 3:
            return sliceAlongLastAxis(e, t, n);

          default:
            throw new ValueError("The axis is not within the rank of the tensor " + r);
        }

      case 4:
        switch (r) {
          case 1:
            return sliceAlongFirstAxis(e, t, n);

          case 2:
            return (0, _tfjsCore.slice4d)(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);

          case 3:
            return (0, _tfjsCore.slice4d)(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);

          case 4:
            return sliceAlongLastAxis(e, t, n);

          default:
            throw new ValueError("The axis is not within the rank of the tensor " + r);
        }

      default:
        throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank);
    }
  });
}

function concatenate(e, t) {
  var n;
  return void 0 === t && (t = -1), t < 0 && (t = 0 !== (n = e[0].rank) ? n : 0), t === e[0].rank && (t = -1), (0, _tfjsCore.concat)(e, t);
}

function concatAlongFirstAxis(e, t) {
  switch (e.rank) {
    case 1:
      return (0, _tfjsCore.concat1d)([e, t]);

    case 2:
      return (0, _tfjsCore.concat2d)([e, t], 0);

    case 3:
      return (0, _tfjsCore.concat3d)([e, t], 0);

    case 4:
      return (0, _tfjsCore.concat4d)([e, t], 0);

    default:
      throw new ValueError("concatAlongFirstAxis() received an unsupported tensor rank: " + e.rank);
  }
}

function tile$1(e, t) {
  if (Array.isArray(t) || (t = [t]), e.rank !== t.length) throw new ValueError("The length of input n (" + t.length + ") does not match the number of dimensions in input x (" + e.rank + ")");
  return (0, _tfjsCore.tile)(e, t);
}

function randomNormal$1(e, t, n, r, i) {
  return void 0 === t && (t = 0), void 0 === n && (n = 1), (0, _tfjsCore.randomNormal)(e, t, n, r, i);
}

function dot(e, t, n, r) {
  if (e.rank < 2 || t.rank < 2) throw new NotImplementedError("dot requires both inputs to be rank >= 2 but got x shape = " + e.shape + " and y shape = " + t.shape);
  if (t.rank >= 3 && e.shape.slice(-1)[0] !== (c = t.shape.slice(-2)[0])) throw new NotImplementedError("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = " + e.shape + " and  y shape = " + t.shape);

  if (2 === e.rank && 2 === t.rank) {
    var i = !1,
        a = !1;
    return _tfjsCore.fused.matMul({
      a: e,
      b: t,
      transposeA: i,
      transposeB: a,
      bias: r ? reshapeBias(e.rank, r, imageDataFormat()) : null,
      activation: n
    });
  }

  var o = e.shape.slice(),
      s = o.pop();
  e = e.reshape([-1, s]);
  var l = t.shape.slice(),
      u = l.pop(),
      c = l.pop(),
      p = l.concat([u]),
      h = Array.from({
    length: t.rank
  }, function (e, n) {
    return 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n;
  });
  t = t.transpose(h).reshape([c, -1]);
  var d = o.concat(p);
  i = !1, a = !1;
  return _tfjsCore.fused.matMul({
    a: e,
    b: t,
    transposeA: i,
    transposeB: a,
    bias: r ? reshapeBias(e.rank, r, imageDataFormat()) : null,
    activation: n
  }).reshape(d);
}

function gather$1(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    return t = Array.isArray(t) ? (0, _tfjsCore.tensor1d)(t, "int32") : t.toInt(), (0, _tfjsCore.gather)(e, t, n);
  });
}

function square(e) {
  return (0, _tfjsCore.mulStrict)(e, e);
}

function reshapeBias(e, t, n) {
  var r = t.shape;
  if (1 !== t.rank && t.rank !== e) throw new ValueError("Unexpected bias dimensions: " + t.rank + "; expected it to be 1 or " + e);

  if (5 === e) {
    if ("channelsFirst" === n) return 1 === r.length ? t.reshape([1, r[0], 1, 1, 1]) : t.reshape([1, r[3], r[0], r[1], r[2]]);
    if ("channelsLast" === n) return 1 === r.length ? t.reshape([1, 1, 1, 1, r[0]]) : t.reshape([1].concat(r));
  } else if (4 === e) {
    if ("channelsFirst" === n) return 1 === r.length ? t.reshape([1, r[0], 1, 1]) : t.reshape([1, r[2], r[0], r[1]]);
    if ("channelsLast" === n) return 1 === r.length ? t.reshape([1, 1, 1, r[0]]) : t.reshape([1].concat(r));
  } else if (3 === e) {
    if ("channelsFirst" === n) return 1 === r.length ? t.reshape([1, r[0], 1]) : t.reshape([1, r[1], r[0]]);
    if ("channelsLast" === n) return 1 === r.length ? t.reshape([1, 1, r[0]]) : t.reshape([1].concat(r));
  } else if (e < 3) return t;

  throw new ValueError("Unsupported input rank by biasAdd: " + t.rank);
}

function biasAdd(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    return null == n && (n = imageDataFormat()), checkDataFormat(n), e.add(reshapeBias(e.rank, t, n));
  });
}

function elu$1(e, t) {
  if (void 0 === t && (t = 1), 1 !== t) throw new NotImplementedError("Support for alpha values other than 1 (" + t + ") is not implemented yet.");
  return (0, _tfjsCore.elu)(e);
}

function softsign(e) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.div)(e, (0, _tfjsCore.abs)(e).add(1));
  });
}

function dropout$1(e, t, n, r) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.dropout)(e, t, n, r);
  });
}

function hardSigmoid(e) {
  return (0, _tfjsCore.tidy)(function () {
    var t = (0, _tfjsCore.add)(.5, (0, _tfjsCore.mul)(.2, e));
    return (0, _tfjsCore.clipByValue)(t, 0, 1);
  });
}

function inTrainPhase(e, t, n) {
  return void 0 === n && (n = !1), n ? e() : t();
}

var VALID_FAN_MODE_VALUES = ["fanIn", "fanOut", "fanAvg"],
    VALID_DISTRIBUTION_VALUES = ["normal", "uniform", "truncatedNormal"];

function checkFanMode(e) {
  checkStringTypeUnionValue(VALID_FAN_MODE_VALUES, "FanMode", e);
}

function checkDistribution(e) {
  checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES, "Distribution", e);
}

var Initializer = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.fromConfigUsesCustomObjects = function () {
    return !1;
  }, t.prototype.getConfig = function () {
    return {};
  }, t;
}(_tfjsCore.serialization.Serializable),
    Zeros = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return (0, _tfjsCore.zeros)(e, t);
  }, t.className = "Zeros", t;
}(Initializer);

_tfjsCore.serialization.registerClass(Zeros);

var Ones = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return (0, _tfjsCore.ones)(e, t);
  }, t.className = "Ones", t;
}(Initializer);

_tfjsCore.serialization.registerClass(Ones);

var Constant = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    if ("object" != typeof t) throw new ValueError("Expected argument of type ConstantConfig but got " + t);
    if (void 0 === t.value) throw new ValueError("config must have value set but got " + t);
    return n.value = t.value, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return (0, _tfjsCore.mul)((0, _tfjsCore.scalar)(n.value), (0, _tfjsCore.ones)(e, t));
    });
  }, t.prototype.getConfig = function () {
    return {
      value: this.value
    };
  }, t.className = "Constant", t;
}(Initializer);

_tfjsCore.serialization.registerClass(Constant);

var RandomUniform = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.DEFAULT_MINVAL = -.05, n.DEFAULT_MAXVAL = .05, n.minval = t.minval || n.DEFAULT_MINVAL, n.maxval = t.maxval || n.DEFAULT_MAXVAL, n.seed = t.seed, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return (0, _tfjsCore.randomUniform)(e, this.minval, this.maxval, t);
  }, t.prototype.getConfig = function () {
    return {
      minval: this.minval,
      maxval: this.maxval,
      seed: this.seed
    };
  }, t.className = "RandomUniform", t;
}(Initializer);

_tfjsCore.serialization.registerClass(RandomUniform);

var RandomNormal = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = t.mean || n.DEFAULT_MEAN, n.stddev = t.stddev || n.DEFAULT_STDDEV, n.seed = t.seed, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new NotImplementedError("randomNormal does not support dType " + t + ".");
    return randomNormal$1(e, this.mean, this.stddev, t, this.seed);
  }, t.prototype.getConfig = function () {
    return {
      mean: this.mean,
      stddev: this.stddev,
      seed: this.seed
    };
  }, t.className = "RandomNormal", t;
}(Initializer);

_tfjsCore.serialization.registerClass(RandomNormal);

var TruncatedNormal = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = t.mean || n.DEFAULT_MEAN, n.stddev = t.stddev || n.DEFAULT_STDDEV, n.seed = t.seed, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new NotImplementedError("truncatedNormal does not support dType " + t + ".");
    return (0, _tfjsCore.truncatedNormal)(e, this.mean, this.stddev, t, this.seed);
  }, t.prototype.getConfig = function () {
    return {
      mean: this.mean,
      stddev: this.stddev,
      seed: this.seed
    };
  }, t.className = "TruncatedNormal", t;
}(Initializer);

_tfjsCore.serialization.registerClass(TruncatedNormal);

var Identity = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return n.gain = null != t.gain ? t.gain : 1, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (2 !== e.length || e[0] !== e[1]) throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");
      return (0, _tfjsCore.mul)(n.gain, (0, _tfjsCore.eye)(e[0]));
    });
  }, t.prototype.getConfig = function () {
    return {
      gain: this.gain
    };
  }, t.className = "Identity", t;
}(Initializer);

function computeFans(e, t) {
  var n, r;
  if (void 0 === t && (t = "channelsLast"), checkDataFormat(t), 2 === e.length) n = e[0], r = e[1];else if (-1 !== [3, 4, 5].indexOf(e.length)) {
    if ("channelsFirst" === t) {
      var i = arrayProd(e, 2);
      n = e[1] * i, r = e[0] * i;
    } else if ("channelsLast" === t) {
      i = arrayProd(e, 0, e.length - 2);
      n = e[e.length - 2] * i, r = e[e.length - 1] * i;
    }
  } else {
    var a = arrayProd(e);
    n = Math.sqrt(a), r = Math.sqrt(a);
  }
  return [n, r];
}

_tfjsCore.serialization.registerClass(Identity);

var VarianceScaling = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    if (t.scale < 0) throw new ValueError("scale must be a positive float. Got: " + t.scale);
    return n.scale = null == t.scale ? 1 : t.scale, n.mode = null == t.mode ? "fanIn" : t.mode, checkFanMode(n.mode), n.distribution = null == t.distribution ? "normal" : t.distribution, checkDistribution(n.distribution), n.seed = t.seed, n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    var n = computeFans(e),
        r = n[0],
        i = n[1],
        a = this.scale;

    if ("fanIn" === this.mode ? a /= Math.max(1, r) : "fanOut" === this.mode ? a /= Math.max(1, i) : a /= Math.max(1, (r + i) / 2), "normal" === this.distribution) {
      var o = Math.sqrt(a);
      if ("float32" !== (t = t || "float32") && "int32" !== t) throw new NotImplementedError(this.getClassName() + " does not support dType " + t + ".");
      return (0, _tfjsCore.truncatedNormal)(e, 0, o, t, this.seed);
    }

    var s = Math.sqrt(3 * a);
    return (0, _tfjsCore.randomUniform)(e, -s, s, t);
  }, t.prototype.getConfig = function () {
    return {
      scale: this.scale,
      mode: this.mode,
      distribution: this.distribution,
      seed: this.seed
    };
  }, t.className = "VarianceScaling", t;
}(Initializer);

_tfjsCore.serialization.registerClass(VarianceScaling);

var GlorotUniform = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 1,
      mode: "fanAvg",
      distribution: "uniform",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "GlorotUniform", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(GlorotUniform);

var GlorotNormal = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 1,
      mode: "fanAvg",
      distribution: "normal",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "GlorotNormal", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(GlorotNormal);

var HeNormal = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 2,
      mode: "fanIn",
      distribution: "normal",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "HeNormal", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(HeNormal);

var HeUniform = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 2,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "HeUniform", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(HeUniform);

var LeCunNormal = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 1,
      mode: "fanIn",
      distribution: "normal",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "LeCunNormal", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(LeCunNormal);

var LeCunUniform = function (e) {
  function t(t) {
    return e.call(this, {
      scale: 1,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == t ? null : t.seed
    }) || this;
  }

  return __extends(t, e), t.prototype.getClassName = function () {
    return VarianceScaling.className;
  }, t.className = "LeCunNormal", t;
}(VarianceScaling);

_tfjsCore.serialization.registerClass(LeCunUniform);

var Orthogonal = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    if (n.DEFAULT_GAIN = 1, n.gain = null == t.gain ? n.DEFAULT_GAIN : t.gain, n.seed = t.seed, null != n.seed) throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");
    return n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (2 !== e.length) throw new NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.");
      e[0] * e[1] > 2e3 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (" + e[0] * e[1] + ") elements: Slowness may result.");

      var t = randomNormal$1(e[0] > e[1] ? [e[1], e[0]] : e, 0, 1, "float32"),
          r = _tfjsCore.linalg.gramSchmidt(t);

      return e[0] > e[1] && (r = r.transpose()), (0, _tfjsCore.mul)(n.gain, r);
    });
  }, t.prototype.getConfig = function () {
    return {
      gain: this.gain,
      seed: this.seed
    };
  }, t.className = "Orthogonal", t;
}(Initializer);

_tfjsCore.serialization.registerClass(Orthogonal);

var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
  constant: "Constant",
  glorotNormal: "GlorotNormal",
  glorotUniform: "GlorotUniform",
  heNormal: "HeNormal",
  heUniform: "HeUniform",
  identity: "Identity",
  leCunNormal: "LeCunNormal",
  leCunUniform: "LeCunUniform",
  ones: "Ones",
  orthogonal: "Orthogonal",
  randomNormal: "RandomNormal",
  randomUniform: "RandomUniform",
  truncatedNormal: "TruncatedNormal",
  varianceScaling: "VarianceScaling",
  zeros: "Zeros"
};

function deserializeInitializer(e, t) {
  return void 0 === t && (t = {}), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "initializer");
}

function serializeInitializer(e) {
  return serializeKerasObject(e);
}

function getInitializer(e) {
  if ("string" == typeof e) {
    var t = e in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e] : e;
    if ("GlorotNormal" === t) return new GlorotNormal();
    if ("GlorotUniform" === t) return new GlorotUniform();
    if ("HeNormal" === t) return new HeNormal();
    if ("HeUniform" === t) return new HeUniform();
    if ("LeCunNormal" === t) return new LeCunNormal();
    if ("LeCunUniform" === t) return new LeCunUniform();
    var n = {};
    return n.className = t, n.config = {}, deserializeInitializer(n);
  }

  return e instanceof Initializer ? e : deserializeInitializer(e);
}

function zeros$1() {
  return new Zeros();
}

function ones$1() {
  return new Ones();
}

function constant(e) {
  return new Constant(e);
}

function randomUniform$1(e) {
  return new RandomUniform(e);
}

function randomNormal$2(e) {
  return new RandomNormal(e);
}

function truncatedNormal$1(e) {
  return new TruncatedNormal(e);
}

function identity(e) {
  return new Identity(e);
}

function varianceScaling(e) {
  return new VarianceScaling(e);
}

function glorotUniform(e) {
  return new GlorotUniform(e);
}

function glorotNormal(e) {
  return new GlorotNormal(e);
}

function heNormal(e) {
  return new HeNormal(e);
}

function heUniform(e) {
  return new HeUniform(e);
}

function leCunNormal(e) {
  return new LeCunNormal(e);
}

function leCunUniform(e) {
  return new LeCunUniform(e);
}

function orthogonal(e) {
  return new Orthogonal(e);
}

var exports_initializers = Object.freeze({
  zeros: zeros$1,
  ones: ones$1,
  constant: constant,
  randomUniform: randomUniform$1,
  randomNormal: randomNormal$2,
  truncatedNormal: truncatedNormal$1,
  identity: identity,
  varianceScaling: varianceScaling,
  glorotUniform: glorotUniform,
  glorotNormal: glorotNormal,
  heNormal: heNormal,
  heUniform: heUniform,
  leCunNormal: leCunNormal,
  leCunUniform: leCunUniform,
  orthogonal: orthogonal
}),
    _nextUniqueTensorId = 0;
exports.initializers = exports_initializers;

function getNextUniqueTensorId() {
  return _nextUniqueTensorId++;
}

var _uidPrefixes = {};

function getUid(e) {
  return void 0 === e && (e = ""), e in _uidPrefixes || (_uidPrefixes[e] = 0), _uidPrefixes[e] += 1, e + _uidPrefixes[e].toString();
}

function isArrayOfShapes(e) {
  return Array.isArray(e) && Array.isArray(e[0]);
}

function normalizeShapeList(e) {
  return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [e];
}

function getExactlyOneTensor(e) {
  var t;

  if (Array.isArray(e)) {
    if (1 !== e.length) throw new ValueError("Expected Tensor length to be 1; got " + e.length);
    t = e[0];
  } else t = e;

  return t;
}

function getExactlyOneShape(e) {
  if (Array.isArray(e) && Array.isArray(e[0])) {
    if (1 === e.length) return (e = e)[0];
    throw new ValueError("Expected exactly 1 Shape; got " + e.length);
  }

  return e;
}

function countParamsInWeights(e) {
  for (var t = 0, n = 0, r = e; n < r.length; n++) {
    var i = r[n];
    0 === i.shape.length ? t += 1 : t += i.shape.reduce(function (e, t) {
      return e * t;
    });
  }

  return t;
}

var DEFAULT_VARIABLE_NAME_PREFIX = "Variable",
    LayerVariable = function () {
  function e(e, t, n, r, i) {
    void 0 === t && (t = "float32"), void 0 === n && (n = DEFAULT_VARIABLE_NAME_PREFIX), void 0 === r && (r = !0), void 0 === i && (i = null), this.dtype = null == t ? "float32" : t, this.shape = e.shape, this.id = getNextUniqueTensorId(), n = null == n ? DEFAULT_VARIABLE_NAME_PREFIX : n, this.originalName = getScopedTensorName(n), this.name = getUniqueTensorName(this.originalName), this.trainable_ = r, this.constraint = i, this.val = (0, _tfjsCore.variable)(e, this.trainable_, this.name, this.dtype);
  }

  return e.prototype.read = function () {
    return this.assertNotDisposed(), this.val;
  }, e.prototype.write = function (e) {
    return this.assertNotDisposed(), checkShapesMatch(this.val, e), this.val.id !== e.id && (this.val.assign(e), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this;
  }, e.prototype.dispose = function () {
    this.assertNotDisposed(), this.val.dispose();
  }, e.prototype.assertNotDisposed = function () {
    if (this.val.isDisposed) throw new Error("LayersVariable " + this.name + " is already disposed.");
  }, Object.defineProperty(e.prototype, "trainable", {
    get: function () {
      return this.trainable_;
    },
    set: function (e) {
      this.trainable_ = e, this.val.trainable = e;
    },
    enumerable: !0,
    configurable: !0
  }), e;
}();

exports.LayerVariable = LayerVariable;

function checkShapesMatch(e, t) {
  if (e.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape));
}

function batchGetValue(e) {
  return e.map(function (e) {
    return e.read();
  });
}

function batchSetValue(e) {
  e.forEach(function (e) {
    e[0].write(e[1]);
  });
}

var InputSpec = function () {
  return function (e) {
    this.dtype = e.dtype, this.shape = e.shape, null != e.shape ? this.ndim = e.shape.length : this.ndim = e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {};
  };
}(),
    SymbolicTensor = function () {
  return function (e, t, n, r, i, a, o) {
    this.dtype = e, this.shape = t, this.sourceLayer = n, this.inputs = r, this.callArgs = i, this.outputTensorIndex = o, this.id = getNextUniqueTensorId(), null != a && (this.originalName = getScopedTensorName(a), this.name = getUniqueTensorName(this.originalName)), this.rank = t.length;
  };
}(),
    _nextNodeID = 0,
    Node = function () {
  function e(e, t) {
    this.callArgs = t, this.id = _nextNodeID++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;

    for (var n = 0, r = e.inboundLayers; n < r.length; n++) {
      var i = r[n];
      null != i && i.outboundNodes.push(this);
    }

    e.outboundLayer.inboundNodes.push(this);
  }

  return e.prototype.getConfig = function () {
    for (var e = [], t = 0, n = this.inboundLayers; t < n.length; t++) {
      var r = n[t];
      null != r ? e.push(r.name) : e.push(null);
    }

    return {
      outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
      inboundLayers: e,
      nodeIndices: this.nodeIndices,
      tensorIndices: this.tensorIndices
    };
  }, e;
}(),
    _nextLayerID = 0,
    Layer = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    n._callHook = null, n._addedWeightNames = [], n._stateful = !1, n.id = _nextLayerID++, n.activityRegularizer = null, n.inputSpec = null, n.supportsMasking = !1, n._trainableWeights = [], n._nonTrainableWeights = [], n._losses = [], n._updates = [], n._built = !1, n.inboundNodes = [], n.outboundNodes = [];
    var r = t.name;

    if (!r) {
      var i = n.getClassName();
      r = toSnakeCase(i) + "_" + getUid(i);
    }

    if (n.name = r, n.trainable_ = null == t.trainable || t.trainable, null != t.inputShape || null != t.batchInputShape) {
      var a = void 0;
      if (null != t.batchInputShape) a = t.batchInputShape;else if (null != t.inputShape) {
        var o = null;
        null != t.batchSize && (o = t.batchSize), a = [o].concat(t.inputShape);
      }
      n.batchInputShape = a;
      var s = t.dtype;
      null == s && (s = t.inputDType), null == s && (s = "float32"), n.dtype = s;
    }

    return null != t.weights ? n.initialWeights = t.weights : n.initialWeights = null, n._refCount = null, n.fastWeightInitDuringBuild = !1, n;
  }

  return __extends(t, e), t.nodeKey = function (e, t) {
    return e.name + "_ib-" + t.toString();
  }, t.prototype.getNodeAtIndex = function (e, t) {
    if (0 === this.inboundNodes.length) throw new RuntimeError("The layer has never been called and thus has no defined " + t + ".");
    if (this.inboundNodes.length <= e) throw new ValueError("Asked to get " + t + " at node " + e + ", but the layer has only " + this.inboundNodes.length + " inbound nodes.");
    return this.inboundNodes[e];
  }, t.prototype.getInputAt = function (e) {
    return singletonOrArray(this.getNodeAtIndex(e, "input").inputTensors);
  }, t.prototype.getOutputAt = function (e) {
    return singletonOrArray(this.getNodeAtIndex(e, "output").outputTensors);
  }, Object.defineProperty(t.prototype, "input", {
    get: function () {
      if (this.inboundNodes.length > 1) throw new AttributeError("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');
      if (0 === this.inboundNodes.length) throw new AttributeError("Layer " + this.name + " is not connected, no input to return.");
      return singletonOrArray(this.getNodeAtIndex(0, "input").inputTensors);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "output", {
    get: function () {
      if (0 === this.inboundNodes.length) throw new AttributeError("Layer " + this.name + " has no inbound nodes.");
      if (this.inboundNodes.length > 1) throw new AttributeError("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');
      return singletonOrArray(this.getNodeAtIndex(0, "output").outputTensors);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "losses", {
    get: function () {
      return this._losses;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.calculateLosses = function () {
    return this.losses.map(function (e) {
      return e();
    });
  }, Object.defineProperty(t.prototype, "updates", {
    get: function () {
      return this._updates;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "built", {
    get: function () {
      return this._built;
    },
    set: function (e) {
      this._built = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "trainable", {
    get: function () {
      return this.trainable_;
    },
    set: function (e) {
      this._trainableWeights.forEach(function (t) {
        return t.trainable = e;
      }), this.trainable_ = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      return this.trainable_ ? this._trainableWeights.filter(function (e) {
        return e.trainable;
      }) : [];
    },
    set: function (e) {
      this._trainableWeights = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      return this.trainable ? this._trainableWeights.filter(function (e) {
        return !e.trainable;
      }).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
    },
    set: function (e) {
      this._nonTrainableWeights = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "weights", {
    get: function () {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "stateful", {
    get: function () {
      return this._stateful;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.resetStates = function () {
    if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
  }, t.prototype.assertInputCompatibility = function (e) {
    if (e = toList(e), null != this.inputSpec && 0 !== this.inputSpec.length) {
      var t = toList(this.inputSpec);
      if (e.length !== t.length) throw new ValueError("Layer " + this.name + " expects " + t.length + " inputs, but it received " + e.length + " input tensors. Input received: " + e);

      for (var n = 0; n < e.length; n++) {
        var r = e[n],
            i = t[n];

        if (null != i) {
          var a = r.rank;
          if (null != i.ndim && a !== i.ndim) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected ndim=" + i.ndim + ", found ndim=" + a);
          if (null != i.maxNDim && a > i.maxNDim) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected max_ndim=" + i.maxNDim + ", found ndim=" + a);
          if (null != i.minNDim && a < i.minNDim) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected min_ndim=" + i.minNDim + ", found ndim=" + a + ".");
          if (null != i.dtype && r.dtype !== i.dtype) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + " : expected dtype=" + i.dtype + ", found dtype=" + r.dtype + ".");

          if (i.axes) {
            var o = r.shape;

            for (var s in i.axes) {
              var l = Number(s),
                  u = i.axes[s],
                  c = l >= 0 ? o[l] : o[o.length + l];
              if (null != u && -1 === [u, null].indexOf(c)) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected axis " + l + " of input shape to have value " + u + " but got shape " + o + ".");
            }
          }

          if (null != i.shape) for (var p = 0; p < i.shape.length; ++p) {
            var h = i.shape[p],
                d = r.shape[p];
            if (null != h && null != d && h !== d) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected shape=" + i.shape + ", found shape=" + r.shape + ".");
          }
        }
      }
    }
  }, t.prototype.call = function (e, t) {
    return e;
  }, t.prototype.invokeCallHook = function (e, t) {
    null != this._callHook && this._callHook(e, t);
  }, t.prototype.setCallHook = function (e) {
    this._callHook = e;
  }, t.prototype.clearCallHook = function () {
    this._callHook = null;
  }, t.prototype.apply = function (e, t) {
    var n = this;
    t = t || {}, this.assertNotDisposed();

    for (var r = toList(e), i = !0, a = 0, o = r; a < o.length; a++) {
      if (!(o[a] instanceof SymbolicTensor)) {
        i = !1;
        break;
      }
    }

    for (var s = !0, l = 0, u = r; l < u.length; l++) {
      if (u[l] instanceof SymbolicTensor) {
        s = !1;
        break;
      }
    }

    if (i === s) throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");
    return nameScope(this.name, function () {
      if (!n.built) {
        n.assertInputCompatibility(e);

        for (var i = [], a = 0, o = toList(e); a < o.length; a++) {
          var l = o[a];
          i.push(l.shape);
        }

        n.build(singletonOrArray(i)), n.built = !0, n.initialWeights && n.setWeights(n.initialWeights), null === n._refCount && s && (n._refCount = 1);
      }

      if (n.assertInputCompatibility(e), s) {
        for (var u = [], c = 0, p = toList(g = n.call(e, t)); c < p.length; c++) {
          var h = p[c];
          -1 !== r.indexOf(h) && (h = h.clone()), u.push(h);
        }

        if (g = singletonOrArray(u), null != n.activityRegularizer) throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return g;
      }

      var d = collectInputShape(e),
          f = n.computeOutputShape(d),
          g = void 0,
          m = guessOutputDType(e);
      if (n.warnOnIncompatibleInputShape(Array.isArray(e) ? d[0] : d), g = null != f && f.length > 0 && Array.isArray(f[0]) ? f.map(function (r, i) {
        return new SymbolicTensor(m, r, n, toList(e), t, n.name, i);
      }) : new SymbolicTensor(m, f, n, toList(e), t, n.name), n.addInboundNode(e, g, null, null, d, f, t), n._refCount++, null != n.activityRegularizer) throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
      return g;
    });
  }, t.prototype.warnOnIncompatibleInputShape = function (e) {
    if (null != this.batchInputShape) if (e.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: " + JSON.stringify(e) + ") does not match that of the batchInputShape (" + JSON.stringify(this.batchInputShape) + ") of the layer " + this.name);else {
      var t = !1;
      this.batchInputShape.forEach(function (n, r) {
        null != n && null != e[r] && e[r] !== n && (t = !0);
      }), t && console.warn("The shape of the input tensor (" + JSON.stringify(e) + ") does not match the expectation of layer " + this.name + ": " + JSON.stringify(this.batchInputShape));
    }
  }, Object.defineProperty(t.prototype, "outputShape", {
    get: function () {
      if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new AttributeError("The layer " + this.name + " has never been called and thus has no defined output shape.");

      for (var e = [], t = 0, n = this.inboundNodes; t < n.length; t++) {
        var r = n[t],
            i = JSON.stringify(r.outputShapes);
        -1 === e.indexOf(i) && e.push(i);
      }

      if (1 === e.length) {
        var a = this.inboundNodes[0].outputShapes;
        return Array.isArray(a) && Array.isArray(a[0]) && 1 === a.length ? a[0] : a;
      }

      throw new AttributeError("The layer " + this.name + ' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.');
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.countParams = function () {
    if (!this.built) throw new RuntimeError("You tried to call countParams() on " + this.name + ", but the layer is not built yet. Build it first by calling build(batchInputShape).");
    return countParamsInWeights(this.weights);
  }, t.prototype.build = function (e) {
    this.built = !0;
  }, t.prototype.getWeights = function (e) {
    return void 0 === e && (e = !1), batchGetValue(e ? this.trainableWeights : this.weights);
  }, t.prototype.setWeights = function (e) {
    var t = this;
    (0, _tfjsCore.tidy)(function () {
      var n = t.weights;
      if (n.length !== e.length) throw new ValueError('You called setWeights(weights) on layer "' + t.name + '" with a weight list of length ' + e.length + ", but the layer was expecting " + n.length + " weights. Provided weights: " + e + "...");

      if (0 !== n.length) {
        for (var r = [], i = batchGetValue(n), a = 0; a < i.length; ++a) {
          var o = i[a],
              s = n[a],
              l = e[a];
          if (!_tfjsCore.util.arraysEqual(o.shape, l.shape)) throw new ValueError("Layer weight shape " + o.shape + " not compatible with provided weight shape " + l.shape);
          r.push([s, l]);
        }

        batchSetValue(r);
      }
    });
  }, t.prototype.addWeight = function (e, t, n, r, i, a, o) {
    if (-1 !== this._addedWeightNames.indexOf(e)) throw new ValueError("Duplicate weight name " + e + " for layer " + this.name);
    this._addedWeightNames.push(e), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (r = getInitializer("zeros"));
    var s = r.apply(t, n),
        l = new LayerVariable(s, n, e, a, o);
    return s.dispose(), null != i && this.addLoss(function () {
      return i.apply(l.read());
    }), null == a && (a = !0), a ? this._trainableWeights.push(l) : this._nonTrainableWeights.push(l), l;
  }, t.prototype.setFastWeightInitDuringBuild = function (e) {
    this.fastWeightInitDuringBuild = e;
  }, t.prototype.addLoss = function (e) {
    var t;
    null == e || Array.isArray(e) && 0 === e.length || (e = toList(e), void 0 !== this._losses && null !== this._losses && (t = this.losses).push.apply(t, e));
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.computeMask = function (e, t) {
    var n = this;

    if (!this.supportsMasking) {
      if (null != t) {
        if (!Array.isArray(t)) throw new TypeError("Layer " + this.name + " does not support masking, but was passed an inputMask.");
        t.forEach(function (e) {
          if (null != e) throw new TypeError("Layer " + n.name + " does not support masking, but was passed an inputMask.");
        });
      }

      return null;
    }

    return t;
  }, t.prototype.addInboundNode = function (e, t, n, r, i, a, o) {
    void 0 === o && (o = null);
    var s = toList(e);
    t = toList(t), n = toList(n), r = toList(r), i = normalizeShapeList(i), a = normalizeShapeList(a);

    for (var l = [], u = [], c = [], p = 0, h = s; p < h.length; p++) {
      var d = h[p];
      l.push(d.sourceLayer), u.push(d.nodeIndex), c.push(d.tensorIndex);
    }

    new Node({
      outboundLayer: this,
      inboundLayers: l,
      nodeIndices: u,
      tensorIndices: c,
      inputTensors: s,
      outputTensors: t,
      inputMasks: n,
      outputMasks: r,
      inputShapes: i,
      outputShapes: a
    }, o);

    for (var f = 0; f < t.length; f++) t[f].sourceLayer = this, t[f].nodeIndex = this.inboundNodes.length - 1, t[f].tensorIndex = f;
  }, t.prototype.getConfig = function () {
    var e = {
      name: this.name,
      trainable: this.trainable
    };
    return null != this.batchInputShape && (e.batchInputShape = this.batchInputShape), null != this.dtype && (e.dtype = this.dtype), e;
  }, t.prototype.disposeWeights = function () {
    return this.weights.forEach(function (e) {
      return e.dispose();
    }), this.weights.length;
  }, t.prototype.assertNotDisposed = function () {
    if (0 === this._refCount) throw new Error("Layer '" + this.name + "' is already disposed.");
  }, t.prototype.dispose = function () {
    if (!this.built) throw new Error("Cannot dispose Layer " + this.name + " because it has not been built yet.");
    if (null === this._refCount) throw new Error("Cannot dispose Layer " + this.name + " because it has not been used yet.");
    this.assertNotDisposed();
    var e = 0;
    return 0 == --this._refCount && (e = this.disposeWeights()), {
      refCountAfterDispose: this._refCount,
      numDisposedVariables: e
    };
  }, t;
}(_tfjsCore.serialization.Serializable);

exports.SymbolicTensor = SymbolicTensor;
exports.InputSpec = InputSpec;

function collectInputShape(e) {
  for (var t = [], n = 0, r = e = toList(e); n < r.length; n++) {
    var i = r[n];
    t.push(i.shape);
  }

  return singletonOrArray(t);
}

function guessOutputDType(e) {
  return "float32";
}

function getSourceInputs(e, t, n) {
  if ((null == t || null != n && n > 0) && (t = e.sourceLayer, n = e.nodeIndex), 0 === t.inboundNodes.length) return [e];
  var r = t.inboundNodes[n];
  if (0 === r.inboundLayers.length) return r.inputTensors;

  for (var i = [], a = 0; a < r.inboundLayers.length; a++) for (var o = 0, s = getSourceInputs(r.inputTensors[a], r.inboundLayers[a], r.nodeIndices[a]); o < s.length; o++) {
    var l = s[o];
    -1 === i.indexOf(l) && i.push(l);
  }

  return i;
}

var ModelLoggingVerbosity,
    InputLayer = function (e) {
  function t(t) {
    var n = e.call(this, {
      dtype: t.dtype,
      name: null != t.name ? t.name : getUid("input").toString()
    }) || this;
    if (null == t.batchSize && (t.batchSize = null), null == t.sparse && (t.sparse = !1), n.trainable = !1, n.built = !0, n.sparse = t.sparse, null != t.inputShape && null != t.batchInputShape) throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
    var r = t.batchInputShape;

    if (null == r) {
      if (null == t.inputShape) throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
      r = [t.batchSize].concat(t.inputShape);
    } else if (null != t.batchSize) throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");

    var i = t.dtype || "float32";
    n.batchInputShape = r, n.dtype = i, n.inputSpec = [{
      shape: r
    }];
    var a = new SymbolicTensor(n.dtype, n.batchInputShape, n, [], {}, n.name);
    return a.nodeIndex = 0, a.tensorIndex = 0, new Node({
      outboundLayer: n,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: [a],
      outputTensors: [a],
      inputMasks: [null],
      outputMasks: [null],
      inputShapes: [r],
      outputShapes: [r]
    }), n;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    throw new ValueError("Cannot pass any input to an InputLayer's apply() method. InputLayer name: " + this.name);
  }, t.prototype.dispose = function () {
    return {
      refCountAfterDispose: this._refCount,
      numDisposedVariables: 0
    };
  }, t.prototype.getConfig = function () {
    return {
      batchInputShape: this.batchInputShape,
      dtype: this.dtype,
      sparse: this.sparse,
      name: this.name
    };
  }, t.className = "InputLayer", t;
}(Layer);

function Input(e) {
  if (null == e.batchShape && null == e.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
  if (null != e.batchShape && null != e.shape) throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
  var t = e.batchShape;
  null != e.shape && null == t && (t = [null].concat(e.shape));
  var n = e.dtype;
  return null == n && (n = "float32"), new InputLayer({
    batchInputShape: t,
    name: e.name,
    dtype: n,
    sparse: e.sparse
  }).inboundNodes[0].outputTensors[0];
}

function resolveScalarsInLogs(e) {
  return __awaiter(this, void 0, void 0, function () {
    var t, n, r, i, a, o, s, l;
    return __generator(this, function (u) {
      switch (u.label) {
        case 0:
          if (null == e) return [2];

          for (i in t = [], n = [], r = [], e) "number" != typeof (a = e[i]) && (o = a, t.push(o.data()), n.push(i), r.push(o));

          return t.length > 0 ? [4, Promise.all(t)] : [3, 2];

        case 1:
          for (s = u.sent(), l = 0; l < s.length; ++l) e[n[l]] = s[l][0];

          (0, _tfjsCore.dispose)(r), u.label = 2;

        case 2:
          return [2];
      }
    });
  });
}

function disposeTensorsInLogs(e) {
  if (null != e) for (var t in e) {
    var n = e[t];
    "number" != typeof n && n.dispose();
  }
}

_tfjsCore.serialization.registerClass(InputLayer), function (e) {
  e[e.SILENT = 0] = "SILENT", e[e.VERBOSE = 1] = "VERBOSE";
}(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));

var DEFAULT_YIELD_EVERY_MS = 125,
    BaseCallback = function () {
  function e() {
    this.validationData = null;
  }

  return e.prototype.setParams = function (e) {
    this.params = e;
  }, e.prototype.onEpochBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onBatchBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onBatchEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.onTrainEnd = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2];
      });
    });
  }, e.prototype.setModel = function (e) {}, e;
}(),
    CallbackList = function () {
  function e(e, t) {
    void 0 === t && (t = 10), null == e && (e = []), this.callbacks = e, this.queueLength = t;
  }

  return e.prototype.append = function (e) {
    this.callbacks.push(e);
  }, e.prototype.setParams = function (e) {
    for (var t = 0, n = this.callbacks; t < n.length; t++) {
      n[t].setParams(e);
    }
  }, e.prototype.setModel = function (e) {
    for (var t = 0, n = this.callbacks; t < n.length; t++) {
      n[t].setModel(e);
    }
  }, e.prototype.onEpochBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            null == t && (t = {}), n = 0, r = this.callbacks, i.label = 1;

          case 1:
            return n < r.length ? [4, r[n].onEpochBegin(e, t)] : [3, 4];

          case 2:
            i.sent(), i.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            null == t && (t = {}), n = 0, r = this.callbacks, i.label = 1;

          case 1:
            return n < r.length ? [4, r[n].onEpochEnd(e, t)] : [3, 4];

          case 2:
            i.sent(), i.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onBatchBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            null == t && (t = {}), n = 0, r = this.callbacks, i.label = 1;

          case 1:
            return n < r.length ? [4, r[n].onBatchBegin(e, t)] : [3, 4];

          case 2:
            i.sent(), i.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onBatchEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            null == t && (t = {}), n = 0, r = this.callbacks, i.label = 1;

          case 1:
            return n < r.length ? [4, r[n].onBatchEnd(e, t)] : [3, 4];

          case 2:
            i.sent(), i.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      var t, n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            null == e && (e = {}), t = 0, n = this.callbacks, r.label = 1;

          case 1:
            return t < n.length ? [4, n[t].onTrainBegin(e)] : [3, 4];

          case 2:
            r.sent(), r.label = 3;

          case 3:
            return t++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e.prototype.onTrainEnd = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      var t, n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            null == e && (e = {}), t = 0, n = this.callbacks, r.label = 1;

          case 1:
            return t < n.length ? [4, n[t].onTrainEnd(e)] : [3, 4];

          case 2:
            r.sent(), r.label = 3;

          case 3:
            return t++, [3, 1];

          case 4:
            return [2];
        }
      });
    });
  }, e;
}(),
    BaseLogger = function (e) {
  function t() {
    return e.call(this) || this;
  }

  return __extends(t, e), t.prototype.onEpochBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return this.seen = 0, this.totals = {}, [2];
      });
    });
  }, t.prototype.onBatchEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var e,
          n,
          r,
          i,
          a = this;
      return __generator(this, function (o) {
        for (i in null == t && (t = {}), e = null == t.size ? 0 : t.size, this.seen += e, n = function (n) {
          var i = t[n];
          if ("number" == typeof i) r.totals.hasOwnProperty(n) || (r.totals[n] = 0), r.totals[n] = r.totals[n] + i * e;else {
            var o = void 0;
            n in r.totals ? o = r.totals[n] : r.totals[n] = 0;
            var s = (0, _tfjsCore.tidy)(function () {
              return (0, _tfjsCore.add)(a.totals[n], (0, _tfjsCore.mul)(i, e));
            });
            r.totals[n] = s, null != o && o.dispose();
          }
        }, r = this, t) n(i);

        return [2];
      });
    });
  }, t.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var e,
          n,
          r,
          i,
          a,
          o = this;
      return __generator(this, function (s) {
        if (null != t) for (e = function (e) {
          if (null == n.totals[e]) return "continue";
          "number" == typeof n.totals[e] ? t[e] = n.totals[e] / n.seen : (0, _tfjsCore.tidy)(function () {
            var n = (0, _tfjsCore.mul)((0, _tfjsCore.div)(1, o.seen), o.totals[e]);
            t[e] = n, o.totals[e].dispose(), (0, _tfjsCore.keep)(t[e]);
          });
        }, n = this, r = 0, i = this.params.metrics; r < i.length; r++) a = i[r], e(a);
        return [2];
      });
    });
  }, t;
}(BaseCallback),
    History = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return this.epoch = [], this.history = {}, [2];
      });
    });
  }, t.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (r) {
        for (n in null == t && (t = {}), this.epoch.push(e), t) null == this.history[n] && (this.history[n] = []), this.history[n].push(t[n]);

        return [2];
      });
    });
  }, t.prototype.syncData = function () {
    return __awaiter(this, void 0, void 0, function () {
      var e, t, n, r, i, a, o, s, l;
      return __generator(this, function (u) {
        switch (u.label) {
          case 0:
            for (r in e = [], t = [], n = [], this.history) for (i = this.history[r], a = 0; a < i.length; ++a) "number" != typeof i[a] && (o = i[a], e.push(o.data()), t.push(r), n.push(a));

            return [4, Promise.all(e)];

          case 1:
            for (s = u.sent(), l = 0; l < s.length; ++l) this.history[t[l]][n[l]].dispose(), this.history[t[l]][n[l]] = s[l][0];

            return [2];
        }
      });
    });
  }, t;
}(BaseCallback),
    CustomCallback = function (e) {
  function t(t, n) {
    var r = e.call(this) || this;
    if (r.currentEpoch = 0, r.yieldEvery = n || "auto", "auto" === r.yieldEvery && (r.yieldEvery = DEFAULT_YIELD_EVERY_MS), "never" === r.yieldEvery && null != t.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
    return _tfjsCore.util.isNumber(r.yieldEvery) && (r.maybeWait = debounce(r.maybeWait.bind(r), r.yieldEvery)), r.trainBegin = t.onTrainBegin, r.trainEnd = t.onTrainEnd, r.epochBegin = t.onEpochBegin, r.epochEnd = t.onEpochEnd, r.batchBegin = t.onBatchBegin, r.batchEnd = t.onBatchEnd, r.yield = t.onYield, r;
  }

  return __extends(t, e), t.prototype.maybeWait = function (e, t, n) {
    return __awaiter(this, void 0, void 0, function () {
      var r;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            return r = [], null == this.yield ? [3, 2] : [4, resolveScalarsInLogs(n)];

          case 1:
            i.sent(), r.push(this.yield(e, t, n)), i.label = 2;

          case 2:
            return r.push((0, _tfjsCore.nextFrame)()), [4, Promise.all(r)];

          case 3:
            return i.sent(), [2];
        }
      });
    });
  }, t.prototype.onEpochBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return this.currentEpoch = e, null == this.epochBegin ? [3, 3] : [4, resolveScalarsInLogs(t)];

          case 1:
            return n.sent(), [4, this.epochBegin(e, t)];

          case 2:
            n.sent(), n.label = 3;

          case 3:
            return [2];
        }
      });
    });
  }, t.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return n = [], null == this.epochEnd ? [3, 2] : [4, resolveScalarsInLogs(t)];

          case 1:
            r.sent(), n.push(this.epochEnd(e, t)), r.label = 2;

          case 2:
            return "epoch" === this.yieldEvery && n.push((0, _tfjsCore.nextFrame)()), [4, Promise.all(n)];

          case 3:
            return r.sent(), [2];
        }
      });
    });
  }, t.prototype.onBatchBegin = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return null == this.batchBegin ? [3, 3] : [4, resolveScalarsInLogs(t)];

          case 1:
            return n.sent(), [4, this.batchBegin(e, t)];

          case 2:
            n.sent(), n.label = 3;

          case 3:
            return [2];
        }
      });
    });
  }, t.prototype.onBatchEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return n = [], null == this.batchEnd ? [3, 2] : [4, resolveScalarsInLogs(t)];

          case 1:
            r.sent(), n.push(this.batchEnd(e, t)), r.label = 2;

          case 2:
            return "batch" === this.yieldEvery ? n.push((0, _tfjsCore.nextFrame)()) : _tfjsCore.util.isNumber(this.yieldEvery) && n.push(this.maybeWait(this.currentEpoch, e, t)), [4, Promise.all(n)];

          case 3:
            return r.sent(), [2];
        }
      });
    });
  }, t.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return null == this.trainBegin ? [3, 3] : [4, resolveScalarsInLogs(e)];

          case 1:
            return t.sent(), [4, this.trainBegin(e)];

          case 2:
            t.sent(), t.label = 3;

          case 3:
            return [2];
        }
      });
    });
  }, t.prototype.onTrainEnd = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return null == this.trainEnd ? [3, 3] : [4, resolveScalarsInLogs(e)];

          case 1:
            return t.sent(), [4, this.trainEnd(e)];

          case 2:
            t.sent(), t.label = 3;

          case 3:
            return [2];
        }
      });
    });
  }, t;
}(BaseCallback);

exports.CustomCallback = CustomCallback;
exports.History = History;
exports.CallbackList = CallbackList;

function standardizeCallbacks(e, t) {
  return null == e && (e = {}), e instanceof BaseCallback ? [e] : Array.isArray(e) && e[0] instanceof BaseCallback ? e : toList(e).map(function (e) {
    return new CustomCallback(e, t);
  });
}

var CallbackConstructorRegistry = function () {
  function e() {}

  return e.registerCallbackConstructor = function (t, n) {
    _tfjsCore.util.assert(t >= 0 && Number.isInteger(t), function () {
      return "Verbosity level is expected to be an integer >= 0, but got " + t;
    }), e.checkForDuplicate(n), null == e.constructors[t] && (e.constructors[t] = []), e.constructors[t].push(n);
  }, e.checkForDuplicate = function (t) {
    for (var n in e.constructors) {
      e.constructors[+n].forEach(function (e) {
        if (e === t) throw new ValueError("Duplicate callback constructor.");
      });
    }
  }, e.clear = function () {
    e.constructors = {};
  }, e.createCallbacks = function (t) {
    var n = [];

    for (var r in e.constructors) {
      var i = +r;
      t >= i && n.push.apply(n, e.constructors[i]);
    }

    return n.map(function (e) {
      return new e();
    });
  }, e.constructors = {}, e;
}();

function configureCallbacks(e, t, n, r, i, a, o, s, l) {
  var u = new History(),
      c = [new BaseLogger()].concat(CallbackConstructorRegistry.createCallbacks(t));
  null != e && c.push.apply(c, e), c.push(u);
  var p = new CallbackList(c);
  return p.setParams({
    epochs: n,
    initialEpoch: r,
    samples: i,
    steps: a,
    batchSize: o,
    verbose: t,
    doValidation: s,
    metrics: l
  }), {
    callbackList: p,
    history: u
  };
}

function deserialize(e, t, n) {
  return void 0 === t && (t = {}), void 0 === n && (n = !1), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "layer", n);
}

function l2Normalize(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    "float32" !== e.dtype && (e = e.asType("float32"));
    var n = (0, _tfjsCore.sum)(square(e), t, !0),
        r = (0, _tfjsCore.fill)(n.shape, epsilon()),
        i = (0, _tfjsCore.sqrt)((0, _tfjsCore.maximum)(n, r));
    return (0, _tfjsCore.div)(e, i);
  });
}

function meanSquaredError(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.mean)(square((0, _tfjsCore.sub)(t, e)), -1);
  });
}

function meanAbsoluteError(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.mean)((0, _tfjsCore.abs)((0, _tfjsCore.sub)(t, e)), -1);
  });
}

function meanAbsolutePercentageError(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.sub)(e, t),
        r = (0, _tfjsCore.clipByValue)((0, _tfjsCore.abs)(e), epsilon(), Number.MAX_VALUE),
        i = (0, _tfjsCore.abs)((0, _tfjsCore.div)(n, r));
    return (0, _tfjsCore.mul)(100, (0, _tfjsCore.mean)(i, -1));
  });
}

function meanSquaredLogarithmicError(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.clipByValue)(t, epsilon(), Number.MAX_VALUE),
        r = (0, _tfjsCore.log)((0, _tfjsCore.add)(1, n)),
        i = (0, _tfjsCore.clipByValue)(e, epsilon(), Number.MAX_VALUE),
        a = (0, _tfjsCore.log)((0, _tfjsCore.add)(1, i));
    return (0, _tfjsCore.mean)(square((0, _tfjsCore.sub)(r, a)), -1);
  });
}

function squaredHinge(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.maximum)(0, (0, _tfjsCore.sub)(1, (0, _tfjsCore.mul)(e, t)));
    return (0, _tfjsCore.mean)(square(n), -1);
  });
}

function hinge(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.maximum)(0, (0, _tfjsCore.sub)(1, (0, _tfjsCore.mul)(e, t)));
    return (0, _tfjsCore.mean)(n, -1);
  });
}

function categoricalHinge(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.sum)((0, _tfjsCore.mul)(e, t), -1),
        r = (0, _tfjsCore.max)((0, _tfjsCore.mul)((0, _tfjsCore.sub)(1, e), t), -1);
    return (0, _tfjsCore.maximum)(0, (0, _tfjsCore.add)(1, (0, _tfjsCore.sub)(r, n)));
  });
}

function logcosh(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = Math.log(2),
        r = (0, _tfjsCore.sub)(t, e),
        i = (0, _tfjsCore.sub)((0, _tfjsCore.add)(r, (0, _tfjsCore.softplus)((0, _tfjsCore.mul)(-2, r))), n);
    return (0, _tfjsCore.mean)(i, -1);
  });
}

function categoricalCrossentropy(e, t, n) {
  return void 0 === n && (n = !1), (0, _tfjsCore.tidy)(function () {
    if (n) t = (0, _tfjsCore.softmax)(t);else {
      var r = (0, _tfjsCore.sum)(t, t.shape.length - 1, !0);
      t = (0, _tfjsCore.div)(t, r);
    }
    return t = (0, _tfjsCore.clipByValue)(t, epsilon(), 1 - epsilon()), (0, _tfjsCore.neg)((0, _tfjsCore.sum)((0, _tfjsCore.mul)(e.toFloat(), (0, _tfjsCore.log)(t)), t.shape.length - 1));
  });
}

function sparseCategoricalCrossentropy(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.floor)(flatten(e)).toInt(),
        r = (t = (0, _tfjsCore.clipByValue)(t, epsilon(), 1 - epsilon())).shape;
    return categoricalCrossentropy((0, _tfjsCore.oneHot)(n, r[r.length - 1]).reshape(r), t, !1);
  });
}

function sigmoidCrossEntropyWithLogits(e, t) {
  if (!_tfjsCore.util.arraysEqual(e.shape, t.shape)) throw new ValueError("logits and labels must have the same shape, but got shapes " + JSON.stringify(e.shape) + " and " + JSON.stringify(t.shape));
  return (0, _tfjsCore.tidy)(function () {
    var n = t.relu(),
        r = t.abs().neg();
    return n.sub(t.mul(e)).add(r.exp().log1p());
  });
}

function binaryCrossentropy(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n;
    return n = (0, _tfjsCore.clipByValue)(t, epsilon(), 1 - epsilon()), n = (0, _tfjsCore.log)((0, _tfjsCore.div)(n, (0, _tfjsCore.sub)(1, n))), (0, _tfjsCore.mean)(sigmoidCrossEntropyWithLogits(e, n), -1);
  });
}

function kullbackLeiblerDivergence(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.clipByValue)(e, epsilon(), 1),
        r = (0, _tfjsCore.clipByValue)(t, epsilon(), 1);
    return (0, _tfjsCore.sum)((0, _tfjsCore.mul)(e, (0, _tfjsCore.log)((0, _tfjsCore.div)(n, r))), -1);
  });
}

function poisson(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.log)((0, _tfjsCore.add)(epsilon(), t));
    return (0, _tfjsCore.mean)((0, _tfjsCore.sub)(t, (0, _tfjsCore.mul)(e, n)), -1);
  });
}

function cosineProximity(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = l2Normalize(e, -1),
        r = l2Normalize(t, -1),
        i = (0, _tfjsCore.mul)(n, r);
    return (0, _tfjsCore.neg)((0, _tfjsCore.sum)(i, -1));
  });
}

var lossesMap = {
  meanSquaredError: meanSquaredError,
  meanAbsoluteError: meanAbsoluteError,
  meanAbsolutePercentageError: meanAbsolutePercentageError,
  meanSquaredLogarithmicError: meanSquaredLogarithmicError,
  squaredHinge: squaredHinge,
  hinge: hinge,
  categoricalHinge: categoricalHinge,
  logcosh: logcosh,
  categoricalCrossentropy: categoricalCrossentropy,
  sparseCategoricalCrossentropy: sparseCategoricalCrossentropy,
  binaryCrossentropy: binaryCrossentropy,
  kullbackLeiblerDivergence: kullbackLeiblerDivergence,
  poisson: poisson,
  cosineProximity: cosineProximity
};

function get(e) {
  if ("string" == typeof e) {
    if (e in lossesMap) return lossesMap[e];
    var t = "Unknown loss " + e;
    throw e.toLowerCase().includes("softmaxcrossentropy") && (t = "Unknown loss " + e + '. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'), new ValueError(t);
  }

  return e;
}

function binaryAccuracy(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = (0, _tfjsCore.mul)(.5, (0, _tfjsCore.onesLike)(t)),
        r = cast$1((0, _tfjsCore.greater)(t, n), e.dtype);
    return (0, _tfjsCore.mean)((0, _tfjsCore.equal)(e, r), -1);
  });
}

function categoricalAccuracy(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return cast$1((0, _tfjsCore.equal)((0, _tfjsCore.argMax)(e, -1), (0, _tfjsCore.argMax)(t, -1)), "float32");
  });
}

function truePositives(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.logicalAnd)(e.equal(1), t.equal(1)).sum().cast("float32");
  });
}

function falseNegatives(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.logicalAnd)(e.equal(1), t.equal(0)).sum().cast("float32");
  });
}

function falsePositives(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return (0, _tfjsCore.logicalAnd)(e.equal(0), t.equal(1)).sum().cast("float32");
  });
}

function precision(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = truePositives(e, t),
        r = falsePositives(e, t),
        i = n.add(r);
    return (0, _tfjsCore.where)((0, _tfjsCore.greater)(i, 0), n.div(i), 0).cast("float32");
  });
}

function recall(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    var n = truePositives(e, t),
        r = falseNegatives(e, t),
        i = n.add(r);
    return (0, _tfjsCore.where)((0, _tfjsCore.greater)(i, 0), n.div(i), 0).cast("float32");
  });
}

function binaryCrossentropy$1(e, t) {
  return binaryCrossentropy(e, t);
}

function sparseCategoricalAccuracy(e, t) {
  return e.rank === t.rank && (e = e.squeeze([e.rank - 1])), (t = t.argMax(-1)).dtype !== e.dtype && (t = t.asType(e.dtype)), (0, _tfjsCore.equal)(e, t).asType("float32");
}

var mse$1 = meanSquaredError,
    MSE$1 = meanSquaredError,
    mae$1 = meanAbsoluteError,
    MAE$1 = meanAbsoluteError,
    mape$1 = meanAbsolutePercentageError,
    MAPE$1 = meanAbsolutePercentageError,
    categoricalCrossentropy$1 = categoricalCrossentropy,
    cosine$1 = cosineProximity,
    sparseCategoricalCrossentropy$1 = sparseCategoricalCrossentropy,
    metricsMap = {
  binaryAccuracy: binaryAccuracy,
  categoricalAccuracy: categoricalAccuracy,
  precision: precision,
  categoricalCrossentropy: categoricalCrossentropy$1,
  sparseCategoricalCrossentropy: sparseCategoricalCrossentropy$1,
  mse: mse$1,
  MSE: MSE$1,
  mae: mae$1,
  MAE: MAE$1,
  mape: mape$1,
  MAPE: MAPE$1,
  cosine: cosine$1
};

function get$1(e) {
  if ("string" == typeof e && e in metricsMap) return metricsMap[e];
  if ("string" != typeof e && null != e) return e;
  throw new ValueError("Unknown metric " + e);
}

function getLossOrMetricName(e) {
  if (assert(null !== e, "Unknown LossOrMetricFn " + e), "string" == typeof e) return e;

  for (var t = void 0, n = 0, r = Object.keys(lossesMap); n < r.length; n++) {
    var i = r[n];

    if (lossesMap[i] === e) {
      t = i;
      break;
    }
  }

  if (void 0 !== t) return t;

  for (var a = 0, o = Object.keys(metricsMap); a < o.length; a++) {
    i = o[a];

    if (metricsMap[i] === e) {
      t = i;
      break;
    }
  }

  return void 0 !== t ? t : e.name;
}

function getOptimizer(e) {
  var t = {
    Adagrad: function () {
      return _tfjsCore.train.adagrad(.01);
    },
    Adadelta: function () {
      return _tfjsCore.train.adadelta(1, .95, epsilon());
    },
    Adam: function () {
      return _tfjsCore.train.adam(.001, .9, .999, epsilon());
    },
    Adamax: function () {
      return _tfjsCore.train.adamax(.002, .9, .999, epsilon(), 0);
    },
    RMSProp: function () {
      return _tfjsCore.train.rmsprop(.001, .9, 0, epsilon());
    },
    SGD: function () {
      return _tfjsCore.train.sgd(.01);
    }
  };
  if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t) return t[e]();
  throw new ValueError("Unknown Optimizer " + e);
}

var MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1048576;

function checkUserDefinedMetadata(e, t, n) {
  if (void 0 === n && (n = !1), null == e || "object" != typeof e || Object.getPrototypeOf(e) !== Object.prototype || !plainObjectCheck(e)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");

  if (n) {
    var r = JSON.stringify(e);
    r.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH && console.warn('User-defined metadata of model "' + t + '" is too large in size (length=' + r.length + " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= " + MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH + ".");
  }
}

function plainObjectCheck(e) {
  if (null === e) return !0;

  if ("object" == typeof e) {
    if (Object.getPrototypeOf(e) === Object.prototype) {
      for (var t = 0, n = Object.keys(e); t < n.length; t++) {
        var r = n[t];
        if ("string" != typeof r) return !1;
        if (!plainObjectCheck(e[r])) return !1;
      }

      return !0;
    }

    if (Array.isArray(e)) {
      for (var i = 0, a = e; i < a.length; i++) {
        if (!plainObjectCheck(a[i])) return !1;
      }

      return !0;
    }

    return !1;
  }

  var o = typeof e;
  return "string" === o || "number" === o || "boolean" === o;
}

function printSummary(e, t, n, r) {
  void 0 === r && (r = console.log);
  var i,
      a = isModelSequentialLike(e),
      o = ["Layer (type)", "Output shape", "Param #"];
  if (a ? (t = t || 65, n = n || [.45, .85, 1]) : (t = t || 98, n = n || [.33, .55, .67, 1]), n[n.length - 1] <= 1 && (n = n.map(function (e) {
    return Math.floor(t * e);
  })), !a) for (var s in o.push("Receives inputs"), i = [], e.nodesByDepth) i.push.apply(i, e.nodesByDepth[s]);
  r("_".repeat(t)), printRow(o, n, r), r("=".repeat(t));

  for (var l = e.layers, u = 0; u < l.length; ++u) a ? printLayerSummary(l[u], n, r) : printLayerSummaryWithConnections(l[u], n, i, r), r((u === l.length - 1 ? "=" : "_").repeat(t));

  e.checkTrainableWeightsConsistency();
  var c = countTrainableParams(e),
      p = countParamsInWeights(e.nonTrainableWeights);
  r("Total params: " + (c + p)), r("Trainable params: " + c), r("Non-trainable params: " + p), r("_".repeat(t));
}

function countTrainableParams(e) {
  return null != e.collectedTrainableWeights ? countParamsInWeights(e.collectedTrainableWeights) : countParamsInWeights(e.trainableWeights);
}

function isModelSequentialLike(e) {
  var t = !0,
      n = [],
      r = [];

  for (var i in e.nodesByDepth) n.push(e.nodesByDepth[i]);

  for (var a = 0, o = n; a < o.length; a++) {
    var s = o[a];

    if (s.length > 1 || 1 === s.length && s[0].inboundLayers.length > 1) {
      t = !1;
      break;
    }

    r.push.apply(r, s);
  }

  if (t) for (var l = 0, u = e.layers; l < u.length; l++) {
    for (var c = !1, p = 0, h = u[l].inboundNodes; p < h.length; p++) {
      var d = h[p];

      if (-1 !== r.indexOf(d)) {
        if (c) {
          t = !1;
          break;
        }

        c = !0;
      }
    }

    if (!t) break;
  }
  return t;
}

function printRow(e, t, n) {
  void 0 === n && (n = console.log);

  for (var r = "", i = 0; i < e.length; ++i) i > 0 && (r = r.slice(0, r.length - 1) + " "), r = (r += e[i]).slice(0, t[i]), r += " ".repeat(t[i] - r.length);

  n(r);
}

function printLayerSummary(e, t, n) {
  var r;

  try {
    r = JSON.stringify(e.outputShape);
  } catch (e) {
    r = "multiple";
  }

  printRow([e.name + " (" + e.getClassName() + ")", r, e.countParams().toString()], t, n);
}

function printLayerSummaryWithConnections(e, t, n, r) {
  var i;

  try {
    i = JSON.stringify(e.outputShape);
  } catch (e) {
    i = "multiple";
  }

  for (var a = [], o = 0, s = e.inboundNodes; o < s.length; o++) {
    var l = s[o];
    if (!(null != n && n.length > 0 && -1 === n.indexOf(l))) for (var u = 0; u < l.inboundLayers.length; ++u) {
      var c = l.inboundLayers[u].name,
          p = l.nodeIndices[u],
          h = l.tensorIndices[u];
      a.push(c + "[" + p + "][" + h + "]");
    }
  }

  var d = e.name,
      f = e.getClassName(),
      g = 0 === a.length ? "" : a[0];
  printRow([d + " (" + f + ")", i, e.countParams().toString(), g], t, r);

  for (u = 1; u < a.length; ++u) printRow(["", "", "", a[u]], t, r);
}

function isArrayItemInputOrOutputName(e, t, n) {
  return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n;
}

function convertPythonicToTs(e, t) {
  if (null === e) return null;
  if ("string" == typeof e) return toCamelCase(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    for (var n = [], r = e.length, i = 0; i < r; ++i) {
      var a = e[i];
      isArrayItemInputOrOutputName(t, i, a) ? n.push(a) : n.push(convertPythonicToTs(a, t));
    }

    return n;
  }

  for (var o = {}, s = 0, l = Object.keys(e); s < l.length; s++) {
    var u = l[s],
        c = e[u];
    if ("name" === u && "string" == typeof c) o[u] = c;else {
      var p = toCamelCase(u);
      o[p] = convertPythonicToTs(c, p);
    }
  }

  return o;
}

function convertTsToPythonic(e, t) {
  if (null === e || void 0 === e) return null;
  if ("string" == typeof e) return toSnakeCase(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    for (var n = [], r = e.length, i = 0; i < r; ++i) {
      var a = e[i];
      isArrayItemInputOrOutputName(t, i, a) ? n.push(a) : n.push(convertTsToPythonic(a, t));
    }

    return n;
  }

  for (var o = {}, s = 0, l = Object.keys(e); s < l.length; s++) {
    var u = l[s],
        c = e[u],
        p = toSnakeCase(u);
    o[p] = "name" !== u && "className" !== u || "string" != typeof c ? convertTsToPythonic(c, u) : c;
  }

  return o;
}

var version = "1.7.1";
exports.version_layers = version;

function assertFeedCompatibility(e, t) {
  if (null == e.dtype || e.dtype === t.dtype) return t;

  try {
    return (0, _tfjsCore.cast)(t, e.dtype);
  } catch (n) {
    throw new ValueError("The dtype of the feed (" + t.dtype + ") can not be cast to the dtype of the key '" + e.name + "' (" + e.dtype + ").");
  }
}

var FeedDict = function () {
  function e(t) {
    if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, t instanceof e) for (var n in t.id2Value) this.id2Value[n] = t.id2Value[n], n in t.id2Mask && (this.id2Mask[n] = t.id2Mask[n]);else {
      if (null == t) return;

      for (var r = 0, i = t; r < i.length; r++) {
        var a = i[r];
        this.add(a.key, a.value);
      }
    }
  }

  return e.prototype.add = function (e, t, n) {
    if (null != this.id2Value[e.id]) throw new ValueError("Duplicate key: name=" + e.name + ", id=" + e.id);
    return this.id2Value[e.id] = assertFeedCompatibility(e, t), this.name2Id[e.name] = e.id, null != n && (this.id2Mask[e.id] = n), this;
  }, e.prototype.addFeed = function (e) {
    this.add(e.key, e.value);
  }, e.prototype.hasKey = function (e) {
    return null != this.id2Value[e.id];
  }, e.prototype.names = function () {
    return Object.keys(this.name2Id);
  }, e.prototype.getValue = function (e) {
    if (e instanceof SymbolicTensor) {
      if (null == this.id2Value[e.id]) throw new ValueError("Nonexistent key: " + e.name);
      return this.id2Value[e.id];
    }

    var t = this.name2Id[e];
    if (null == t) throw new ValueError("Feed dict has no SymbolicTensor name: " + e);
    return this.id2Value[t];
  }, e.prototype.getMask = function (e) {
    if (e instanceof SymbolicTensor) {
      if (null == this.id2Value[e.id]) throw new ValueError("Nonexistent key: " + e.name);
      return this.id2Mask[e.id];
    }

    var t = this.name2Id[e];
    if (null == t) throw new ValueError("Feed dict has no SymbolicTensor name: " + e);
    return this.id2Mask[t];
  }, e.prototype.disposeMasks = function () {
    null != this.id2Mask && (0, _tfjsCore.dispose)(this.id2Mask);
  }, e;
}(),
    cachedSorted = {},
    cachedRecipientCounts = {};

function execute(e, t, n, r) {
  for (var i = null != n && n.training, a = Array.isArray(e), o = a ? e : [e], s = o.map(function (e) {
    return e.name;
  }), l = [], u = t.names(), c = 0, p = s; c < p.length; c++) {
    var h = p[c];
    -1 !== u.indexOf(h) ? l.push(t.getValue(h)) : l.push(null);
  }

  null != r && (r.maxNumTensors = -1 / 0, r.minNumTensors = 1 / 0);
  var d,
      f,
      g = s.join(",") + "|" + t.names().join(",");

  if (null == cachedSorted[g]) {
    var m = getTopologicalSortAndRecipientCounts(o, t);
    d = m.sorted, f = m.recipientCounts, cachedSorted[g] = d, cachedRecipientCounts[g] = f;
  }

  d = cachedSorted[g], f = {}, i || Object.assign(f, cachedRecipientCounts[g]);

  for (var y = new FeedDict(t), v = 0; v < d.length; ++v) {
    if (null != r) {
      var b = (0, _tfjsCore.memory)().numTensors;
      b > r.maxNumTensors && (r.maxNumTensors = b), b < r.minNumTensors && (r.minNumTensors = b);
    }

    var w = d[v],
        z = w.sourceLayer;

    if (!(z instanceof InputLayer)) {
      for (var S = [], A = [], _ = [], I = !1, C = 0, E = w.inputs; C < E.length; C++) {
        var N = E[C],
            k = y.getValue(N),
            x = y.getMask(N);
        S.push(k), A.push(x), null != x && (I = !0), i || (f[N.name]--, 0 !== f[N.name] || t.hasKey(N) || -1 !== s.indexOf(N.name) || k.isDisposed || !0 === N.sourceLayer.stateful || _.push(k));
      }

      I && ((n = n || {}).mask = A[0]);
      var L = toList(z.apply(S, n)),
          T = null;
      z.supportsMasking && (T = z.computeMask(S, A));

      for (var D = getNodeOutputs(w), O = Array.isArray(D) ? D : [D], R = 0; R < O.length; ++R) {
        y.hasKey(O[R]) || y.add(O[R], L[R], Array.isArray(T) ? T[0] : T);
        var M = s.indexOf(O[R].name);
        -1 !== M && (l[M] = L[R]);
      }

      i || (0, _tfjsCore.dispose)(_);
    }
  }

  return y.disposeMasks(), a ? l : l[0];
}

function getTopologicalSortAndRecipientCounts(e, t) {
  _tfjsCore.util.assert(null != e && e.length > 0, function () {
    return "Expected at least one fetch, got none";
  });

  var n = [],
      r = {};

  if (1 === e.length) {
    var i = getTopologicalSortAndRecipientCountsForOneFetch(e[0], t);
    n = i.sorted, r = i.recipientMap;
  } else for (var a = new Set(), o = 0, s = e; o < s.length; o++) {
    for (var l = getTopologicalSortAndRecipientCountsForOneFetch(s[o], t), u = l.sorted, c = l.recipientMap, p = 0, h = u; p < h.length; p++) {
      var d = h[p];
      a.has(d.name) || (n.push(d), a.add(d.name));
    }

    var f = function (e) {
      null == r[e] && (r[e] = new Set()), c[e].forEach(function (t) {
        return r[e].add(t);
      });
    };

    for (var g in c) f(g);
  }

  return {
    sorted: n,
    recipientCounts: recipientMap2Counts(r)
  };
}

function recipientMap2Counts(e) {
  var t = {};

  for (var n in e) t[n] = e[n].size;

  return t;
}

function getTopologicalSortAndRecipientCountsForOneFetch(e, t) {
  for (var n = new Set(), r = [], i = {}, a = 0, o = t.names(); a < o.length; a++) {
    var s = o[a];
    n.add(s);
  }

  var l = [],
      u = [];

  for (l.push(e); l.length > 0;) {
    var c = l[l.length - 1];
    if (n.has(c.name)) l.pop();else {
      var p = u[u.length - 1] === l.length - 1;
      if (0 === c.inputs.length || p) l.pop(), r.push(c), n.add(c.name), p && u.pop();else {
        u.push(l.length - 1);

        for (var h = 0, d = c.inputs; h < d.length; h++) {
          var f = d[h];
          null == i[f.name] && (i[f.name] = new Set()), i[f.name].add(c.name), n.has(f.name) || l.push(f);
        }
      }
    }
  }

  return {
    sorted: r,
    recipientMap: i
  };
}

function getNodeOutputs(e) {
  var t;
  if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;else {
    for (var n = null, r = 0; r < e.sourceLayer.inboundNodes.length; ++r) for (var i = 0, a = e.sourceLayer.inboundNodes[r].outputTensors; i < a.length; i++) {
      if (a[i].id === e.id) {
        n = r;
        break;
      }
    }

    t = e.sourceLayer.getOutputAt(n);
  }
  return t;
}

var Container = function (e) {
  function t(n) {
    var r = e.call(this, {}) || this;

    if (r.containerNodes = new Set(), r.name = n.name, null == r.name) {
      var i = r.getClassName().toLowerCase();
      r.name = getUid(i);
    }

    if (r.supportsMasking = !1, r.trainable_ = !0, Array.isArray(n.inputs) ? r.inputs = n.inputs.slice() : r.inputs = [n.inputs], Array.isArray(n.outputs) ? r.outputs = n.outputs.slice() : r.outputs = [n.outputs], unique(r.inputs).length !== r.inputs.length) throw new ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " + r.inputs.map(function (e) {
      return e.name;
    }));
    unique(r.outputs).length !== r.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " + r.outputs.map(function (e) {
      return e.name;
    })), r.inputLayers = [], r.inputLayersNodeIndices = [], r.inputLayersTensorIndices = [], r.outputLayers = [], r.outputLayersNodeIndices = [], r.outputLayersTensorIndices = [], r.layers = [], r.internalContainerRefs = [];

    for (var a = 0, o = r.outputs; a < o.length; a++) {
      var s = (C = o[a]).sourceLayer,
          l = C.nodeIndex,
          u = C.tensorIndex;
      r.outputLayers.push(s), r.outputLayersNodeIndices.push(l), r.outputLayersTensorIndices.push(u);
    }

    for (var c = 0, p = r.inputs; c < p.length; c++) {
      s = (C = p[c]).sourceLayer, l = C.nodeIndex, u = C.tensorIndex;
      assert(0 === l, "input layer has >1 nodes"), assert(0 === u, "input layer has >1 tensors"), r.inputLayers.push(s), r.inputLayersNodeIndices.push(l), r.inputLayersTensorIndices.push(u);
    }

    r.inputNames = [], r.outputNames = [], r.feedInputShapes = [], r.feedInputNames = [], r.feedOutputNames = [];

    for (var h = 0; h < r.inputLayers.length; h++) {
      if (!((s = r.inputLayers[h]) instanceof InputLayer)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: " + n.inputs + ". Input " + h + " (0-based) originates from layer type " + s.getClassName() + ".");
      r.inputNames.push(s.name), r.feedInputShapes.push(s.batchInputShape), r.feedInputNames.push(s.name);
    }

    for (var d = 0, f = r.outputLayers; d < f.length; d++) {
      s = f[d];
      r.outputNames.push(s.name);
    }

    r.internalInputShapes = r.inputs.map(function (e) {
      return e.shape;
    }), r.internalOutputShapes = r.outputs.map(function (e) {
      return e.shape;
    });

    for (var g = {}, m = {}, y = {}, v = {}, b = {}, w = [], z = function (e, n, i, a, o, s) {
      null != a && null != o && null != s || (a = e.sourceLayer, o = e.nodeIndex, s = e.tensorIndex);
      var l = a.inboundNodes[o];
      if (-1 !== i.indexOf(l)) throw new RuntimeError("The tensor " + e.name + ' at layer "' + a.name + '" is part of a cycle.');

      if (-1 === n.indexOf(l)) {
        r.containerNodes.add(t.nodeKey(a, o)), (a.id in b) || (b[a.id] = Object.keys(b).length), -1 === i.indexOf(l) && i.push(l);

        for (var u = l.inboundLayers.length, c = 0; c < u; c++) {
          var p = l.inputTensors[c],
              h = l.inboundLayers[c],
              d = l.nodeIndices[c],
              f = l.tensorIndices[c];
          z(p, n, i, h, d, f);
        }

        for (n.push(l); i.indexOf(l) >= 0;) i.splice(i.indexOf(l), 1);

        w.push(l);
      }
    }, S = [], A = [], _ = 0, I = r.outputs; _ < I.length; _++) {
      var C = I[_];
      z(C, S, A);
    }

    for (var E = 0, N = w.slice().reverse(); E < N.length; E++) {
      m[(K = N[E]).id] = K, K.id in g || (g[K.id] = 0);
      var k = g[K.id],
          x = null == y[K.outboundLayer.id] ? 0 : y[K.outboundLayer.id];
      k = Math.max(k, x), y[K.outboundLayer.id] = k, v[K.outboundLayer.id] = K.outboundLayer, g[K.id] = k;

      for (h = 0; h < K.inboundLayers.length; h++) {
        var L = K.inboundLayers[h],
            T = (l = K.nodeIndices[h], L.inboundNodes[l]),
            D = null == g[T.id] ? 0 : g[T.id];
        g[T.id] = Math.max(k + 1, D), m[T.id] = T;
      }
    }

    var O = {};

    for (var R in g) {
      (k = g[R]) in O || (O[k] = []), O[k].push(m[R]);
    }

    var M = {};

    for (var P in y) {
      (k = y[P]) in M || (M[k] = []), M[k].push(v[P]);
    }

    var F = Object.keys(M).map(function (e) {
      return parseInt(e, 10);
    }).sort(reverseNumberCompare);
    r.layers = [];

    for (var V = 0, B = F; V < B.length; V++) {
      var U = M[k = B[V]];
      U.sort(function (e, t) {
        var n = b[e.id],
            r = b[t.id];
        return n < r ? -1 : n > r ? 1 : 0;
      });

      for (var j = 0, W = U; j < W.length; j++) {
        (s = W[j]) instanceof t && r.internalContainerRefs.push(s), r.layers.push(s);
      }
    }

    r.layersByDepth = M, F = Object.keys(O).map(function (e) {
      return parseInt(e, 10);
    }).sort(reverseNumberCompare);

    for (var $ = r.inputs.slice(), q = [], G = 0, H = F; G < H.length; G++) for (var J = 0, Z = O[k = H[G]]; J < Z.length; J++) {
      var K;

      if (null != (s = (K = Z[J]).outboundLayer)) {
        for (var Y = 0, X = K.inputTensors; Y < X.length; Y++) {
          C = X[Y];
          if (-1 === $.indexOf(C)) throw new RuntimeError("Graph disconnected: cannot obtain value for tensor " + C + ' at layer "' + s.name + '". The following previous layers were accessed without issue: ' + q);
        }

        for (var Q = 0, ee = K.outputTensors; Q < ee.length; Q++) {
          C = ee[Q];
          $.push(C);
        }

        q.push(s.name);
      }
    }

    r.nodesByDepth = O;

    for (var te = r.layers.map(function (e) {
      return e.name;
    }), ne = function (e) {
      var t = te.filter(function (t) {
        return t === e;
      }).length;
      if (1 !== t) throw new RuntimeError('The name "' + e + '" is used ' + t + " times in the model. All layer names should be unique. Layer names: " + JSON.stringify(te));
    }, re = 0, ie = te; re < ie.length; re++) {
      ne(ie[re]);
    }

    return r.outboundNodes = [], r.inboundNodes = [], new Node({
      outboundLayer: r,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: r.inputs,
      outputTensors: r.outputs,
      inputMasks: r.inputs.map(function (e) {
        return null;
      }),
      outputMasks: r.outputs.map(function (e) {
        return null;
      }),
      inputShapes: r.inputs.map(function (e) {
        return e.shape;
      }),
      outputShapes: r.outputs.map(function (e) {
        return e.shape;
      })
    }), r.built = !0, r._refCount = 1, r;
  }

  return __extends(t, e), t.prototype.assertNotDisposed = function () {
    if (0 === this._refCount) throw new Error("Container '" + this.name + "' is already disposed.");
  }, t.prototype.dispose = function () {
    this.assertNotDisposed();
    var e = {
      refCountAfterDispose: null,
      numDisposedVariables: 0
    };

    if (0 == --this._refCount) {
      for (var t = 0, n = this.layers; t < n.length; t++) {
        var r = n[t];
        e.numDisposedVariables += r.dispose().numDisposedVariables;
      }

      for (var i = 0, a = this.internalContainerRefs; i < a.length; i++) {
        var o = a[i];
        e.numDisposedVariables += o.dispose().numDisposedVariables;
      }
    }

    return e.refCountAfterDispose = this._refCount, e;
  }, Object.defineProperty(t.prototype, "trainable", {
    get: function () {
      return this.trainable_;
    },
    set: function (e) {
      this.layers.forEach(function (t) {
        t._trainableWeights.forEach(function (t) {
          return t.trainable = e;
        });
      }), this.trainable_ = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      if (this._trainableWeights.length > 0) throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
      if (!this.trainable) return [];

      for (var e = [], t = 0, n = this.layers; t < n.length; t++) {
        var r = n[t];
        e = e.concat(r.trainableWeights);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      for (var e = [], t = 0, n = this.layers; t < n.length; t++) {
        var r = n[t];
        e.push.apply(e, r.nonTrainableWeights);
      }

      if (!this.trainable) {
        for (var i = [], a = 0, o = this.layers; a < o.length; a++) {
          r = o[a];
          i.push.apply(i, r.trainableWeights);
        }

        return i.concat(e);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "weights", {
    get: function () {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.loadWeights = function (e, t) {
    void 0 === t && (t = !0);

    for (var n = {}, r = 0, i = 0, a = this.layers; i < a.length; i++) for (var o = 0, s = a[i].weights; o < s.length; o++) {
      var l = s[o];
      if (null != n[l.originalName]) throw new ValueError("Duplicate weight name: " + l.originalName);
      n[l.originalName] = l, r++;
    }

    var u = [];

    for (var c in e) {
      if (null != n[c]) u.push([n[c], e[c]]);else if (t) throw new ValueError("Provided weight data has no target variable: " + c);
      delete n[c];
    }

    if (t) {
      var p = [];

      for (var h in n) p.push(h);

      if (p.length > 0) throw new ValueError(p.length + " of " + r + " weights are not set: " + p);
    }

    batchSetValue(u);
  }, t.prototype.updatedConfig = function () {
    var e = this.getConfig(),
        t = {};
    return t.className = this.getClassName(), t.config = e, t.kerasVersion = "tfjs-layers " + version, t.backend = "TensorFlow.js", t;
  }, t.prototype.toJSON = function (e, t) {
    void 0 === t && (t = !0);
    var n = convertTsToPythonic(this.updatedConfig());
    return t ? JSON.stringify(n) : n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      e = toList(e);

      for (var r = new FeedDict(), i = 0; i < n.inputs.length; ++i) r.add(n.inputs[i], e[i]);

      return execute(n.outputs, r, t);
    });
  }, t.prototype.computeMask = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r;
      return e = toList(e), r = null == t ? pyListRepeat(null, e.length) : toList(t), n.runInternalGraph(e, r)[1];
    });
  }, t.prototype.computeOutputShape = function (e) {
    var t = normalizeShapeList(e);
    if (t.length !== this.inputLayers.length) throw new ValueError("Invalid inputShape argument " + e + ": model has " + this.inputLayers.length + " tensor inputs.");

    for (var n = {}, r = 0; r < t.length; r++) {
      var i = this.inputLayers[r],
          a = t[r];
      n[A = i.name + "_0_0"] = a;
    }

    var o = Object.keys(this.nodesByDepth).map(function (e) {
      return parseInt(e, 10);
    }).sort(reverseNumberCompare);
    if (o.length > 1) for (var s = 0, l = o; s < l.length; s++) for (var u = l[s], c = 0, p = this.nodesByDepth[u]; c < p.length; c++) {
      var h = p[c];
      i = h.outboundLayer;

      if (-1 === this.inputLayers.map(function (e) {
        return e.id;
      }).indexOf(i.id)) {
        for (var d = [], f = 0; f < h.inboundLayers.length; f++) {
          var g = h.inboundLayers[f],
              m = h.nodeIndices[f],
              y = h.tensorIndices[f],
              v = n[A = g.name + "_" + m + "_" + y];
          d.push(v);
        }

        var b = normalizeShapeList(i.computeOutputShape(singletonOrArray(d))),
            w = i.inboundNodes.indexOf(h);

        for (f = 0; f < b.length; f++) {
          n[A = i.name + "_" + w + "_" + f] = b[f];
        }
      }
    }
    var z = [],
        S = [];

    for (r = 0; r < this.outputLayers.length; r++) {
      i = this.outputLayers[r], w = this.outputLayersNodeIndices[r], y = this.outputLayersTensorIndices[r];
      var A = i.name + "_" + w + "_" + y;
      S.push(A);
    }

    for (r = 0; r < S.length; r++) {
      var _ = S[r];
      assert(_ in n), z.push(n[_]);
    }

    return singletonOrArray(z);
  }, t.prototype.runInternalGraph = function (e, t) {
    null == t && (t = pyListRepeat(null, e.length));

    for (var n = {}, r = 0; r < this.inputs.length; ++r) {
      var i = this.inputs[r],
          a = e[r],
          o = t[r];
      n[i.id] = [a, o];
    }

    for (var s = 0, l = Object.keys(this.nodesByDepth).map(function (e) {
      return parseInt(e, 10);
    }).sort(reverseNumberCompare); s < l.length; s++) for (var u = l[s], c = 0, p = this.nodesByDepth[u]; c < p.length; c++) {
      for (var h = p[c], d = h.outboundLayer, f = h.inputTensors, g = h.outputTensors, m = new Array(), y = 0, v = f; y < v.length; y++) {
        (i = v[y]).id in n && m.push(n[i.id]);
      }

      if (m.length === f.length) {
        var b = {},
            w = void 0,
            z = void 0,
            S = void 0,
            A = void 0;

        if (null != h.callArgs && (b = h.callArgs), 1 === m.length) {
          var _ = m[0],
              I = _[0],
              C = _[1];
          null == b.mask && (b.mask = C), S = toList(d.call(I, b)), A = toList(d.computeMask(I, C)), w = [I], z = [C];
        } else w = m.map(function (e) {
          return e[0];
        }), z = m.map(function (e) {
          return e[1];
        }), null == b.mask && (b.mask = z), S = toList(d.call(w, b)), A = toList(d.computeMask(w, z));

        if (d.activityRegularizer) throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");

        for (r = 0; r < g.length; ++r) {
          i = g[r], a = S[r], o = A[r];
          n[i.id] = [a, o];
        }
      }
    }

    for (var E = [], N = [], k = [], x = 0, L = this.outputs; x < L.length; x++) {
      assert((i = L[x]).id in n, "Could not compute output " + i.name + " : " + i.id);
      var T = n[i.id],
          D = T[0];
      o = T[1];
      k.push(D.shape), E.push(D), N.push(o);
    }

    return [E, N, k];
  }, t.prototype.buildNodeConversionMap = function (e) {
    for (var n, r = {}, i = 0, a = this.layers; i < a.length; i++) {
      var o = a[i];
      n = o instanceof t ? 1 : 0;

      for (var s = 0; s < o.inboundNodes.length; s++) {
        var l = t.nodeKey(o, s);
        this.containerNodes.has(l) && (r[l] = n, n += 1);
      }
    }

    return r;
  }, t.prototype.getLayer = function (e, t) {
    if (null != t) {
      if (this.layers.length <= t) throw new ValueError("Was asked to retrieve layer at index " + t + ", but model only has " + this.layers.length + " layer(s).");
      return this.layers[t];
    }

    if (null == e) throw new ValueError("Provide either a layer name or layer index");

    for (var n = 0, r = this.layers; n < r.length; n++) {
      var i = r[n];
      if (i.name === e) return i;
    }

    throw new ValueError("No such layer: " + e);
  }, t.prototype.calculateLosses = function () {
    var e = this;
    return (0, _tfjsCore.tidy)(function () {
      for (var n = [], r = 0, i = e.layers; r < i.length; r++) for (var a = i[r], o = 0; o < a.inboundNodes.length; ++o) {
        var s = t.nodeKey(a, o);
        e.containerNodes.has(s) && n.push.apply(n, a.calculateLosses());
      }

      return n;
    });
  }, t.prototype.getConfig = function () {
    for (var e = {
      name: this.name
    }, n = this.buildNodeConversionMap(this.layers), r = [], i = 0, a = this.layers; i < a.length; i++) {
      for (var o = (w = a[i]).getClassName(), s = w.getConfig(), l = [], u = 0; u < w.inboundNodes.length; u++) {
        var c = w.inboundNodes[u],
            p = t.nodeKey(w, u),
            h = {};

        if (this.containerNodes.has(p)) {
          if (c.callArgs) try {
            JSON.stringify(c.callArgs), h = c.callArgs;
          } catch (e) {
            console.warn("Layer " + w.name + " was passed non-serializable keyword arguments: " + c.callArgs + ". They will not be included in the serialized model (and thus will be missing at deserialization time)."), h = {};
          }

          if (c.inboundLayers.length > 0) {
            for (var d = [], f = 0; f < c.inboundLayers.length; f++) {
              var g = c.inboundLayers[f],
                  m = c.nodeIndices[f],
                  y = c.tensorIndices[f];
              null == (S = n[t.nodeKey(g, m)]) && (S = 0), d.push([g.name, S, y, h]);
            }

            l.push(d);
          }
        }
      }

      var v = {};
      v.name = w.name, v.className = o, v.config = s, v.inboundNodes = l, r.push(v);
    }

    e.layers = r;
    var b = [];

    for (f = 0; f < this.inputLayers.length; f++) {
      var w = this.inputLayers[f];
      m = this.inputLayersNodeIndices[f], p = t.nodeKey(w, m);

      if (this.containerNodes.has(p)) {
        null !== (S = n[p]) && void 0 !== S || (S = 0);
        y = this.inputLayersTensorIndices[f];
        b.push([w.name, S, y]);
      }
    }

    e.inputLayers = b;
    var z = [];

    for (f = 0; f < this.outputLayers.length; f++) {
      w = this.outputLayers[f], m = this.outputLayersNodeIndices[f], p = t.nodeKey(w, m);

      if (this.containerNodes.has(p)) {
        var S;
        null !== (S = n[p]) && void 0 !== S || (S = 0);
        y = this.outputLayersTensorIndices[f];
        z.push([w.name, S, y]);
      }
    }

    return e.outputLayers = z, e;
  }, t.fromConfig = function (e, t, n, r) {
    void 0 === n && (n = {}), void 0 === r && (r = !1);
    var i = {},
        a = {};

    function o(e, t) {
      e.name in a ? a[e.name].push(t) : a[e.name] = [t];
    }

    function s(e, t) {
      for (var n, r = [], a = 0, s = t; a < s.length; a++) {
        var l = s[a],
            u = l[0],
            c = l[1],
            p = l[2];
        if (n = null == l[3] ? {} : l[3], !(u in i)) return void o(e, t);
        var h = i[u];
        if (h.inboundNodes.length <= c) return void o(e, t);
        var d = h.inboundNodes[c];
        r.push(d.outputTensors[p]);
      }

      r.length > 0 && e.apply(singletonOrArray(r), n);
    }

    function l(e) {
      var n = e.name,
          a = deserialize(e, null != t.customObjects ? t.customObjects : {});
      a.setFastWeightInitDuringBuild(r), i[n] = a, e.inboundNodes.forEach(function (e) {
        if (!(e instanceof Array)) throw new ValueError("Corrupted configuration, expected array for nodeData: " + e);
        o(a, e);
      });
    }

    for (var u = t.name, c = t.layers, p = 0, h = c; p < h.length; p++) {
      l(g = h[p]);
    }

    for (; !isObjectEmpty(a);) for (var d = 0, f = c; d < f.length; d++) {
      var g = f[d];

      if ((k = i[g.name]).name in a) {
        var m = a[k.name];
        delete a[k.name];

        for (var y = 0, v = m; y < v.length; y++) {
          s(k, v[y]);
        }
      }
    }

    for (var b = [], w = [], z = 0, S = t.inputLayers; z < S.length; z++) {
      var A = (g = S[z])[0],
          _ = g[1],
          I = g[2];
      assert(A in i);
      var C = (k = i[A]).inboundNodes[_].outputTensors;
      b.push(C[I]);
    }

    for (var E = 0, N = t.outputLayers; E < N.length; E++) {
      A = (g = N[E])[0], _ = g[1], I = g[2];
      assert(A in i);
      var k;
      C = (k = i[A]).inboundNodes[_].outputTensors;
      w.push(C[I]);
    }

    return new e({
      inputs: b,
      outputs: w,
      name: u
    });
  }, Object.defineProperty(t.prototype, "stateful", {
    get: function () {
      if (this._stateful) throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");

      for (var e = 0, t = this.layers; e < t.length; e++) {
        if (t[e].stateful) return !0;
      }

      return !1;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.resetStates = function () {
    var e = this;
    (0, _tfjsCore.tidy)(function () {
      e.layers.forEach(function (e) {
        e.stateful && e.resetStates();
      });
    });
  }, t;
}(Layer);

function standardizeSampleOrClassWeights(e, t, n) {
  var r = t.length;
  if (null == e || Array.isArray(e) && 0 === e.length) return t.map(function (e) {
    return null;
  });
  if (1 === r) return Array.isArray(e) && 1 === e.length ? e : "object" == typeof e && t[0] in e ? [e[t[0]]] : [e];

  if (Array.isArray(e)) {
    if (e.length !== r) throw new Error("Provided " + n + " is an array of " + e.length + " element(s), but the model has " + r + " outputs. Make sure a set of weights is provided for each model output.");
    return e;
  }

  if ("object" == typeof e && Object.keys(e).length > 0 && "object" == typeof e[Object.keys(e)[0]]) {
    var i = [];
    return t.forEach(function (t) {
      t in e ? i.push(e[t]) : i.push(null);
    }), i;
  }

  throw new Error("The model has multiple (" + r + ") outputs, so " + n + " must be either an array with " + r + " elements or an object with " + t + " keys. Provided " + n + " not understood: " + JSON.stringify(e));
}

function standardizeClassWeights(e, t) {
  return standardizeSampleOrClassWeights(e, t, "classWeight");
}

function standardizeWeights(e, t, n, r) {
  return __awaiter(this, void 0, void 0, function () {
    var i, a, o, s, l;
    return __generator(this, function (u) {
      switch (u.label) {
        case 0:
          if (null != t || null != r) throw new Error("Support sampleWeight is not implemented yet");
          return null == n ? [3, 2] : (i = (0, _tfjsCore.tidy)(function () {
            if (1 === e.shape.length) return e.clone();

            if (2 === e.shape.length) {
              if (e.shape[1] > 1) {
                return e.argMax(1);
              }

              if (1 === e.shape[1]) return e.reshape([e.shape[0]]);
              throw new Error("Encountered unexpected last-dimension size (" + e.shape[1] + ") during handling of class weights. The size is expected to be >= 1.");
            }

            throw new Error("Unexpected rank of target (y) tensor (" + e.rank + ") during handling of class weights. The rank is expected to be 1 or 2.");
          }), s = (o = Array).from, [4, i.data()]);

        case 1:
          return a = s.apply(o, [u.sent()]), (0, _tfjsCore.dispose)(i), l = [], a.forEach(function (e) {
            if (null == n[e]) throw new Error("classWeight must contain all classes in the training data. The class " + e + " exists in the data but not in classWeight");
            l.push(n[e]);
          }), [2, (0, _tfjsCore.tensor1d)(l, "float32")];

        case 2:
          return [2, null];
      }
    });
  });
}

function computeWeightedLoss(e, t) {
  return (0, _tfjsCore.mul)(e, t);
}

var DEFAULT_VALIDATION_BATCH_SIZE = 32;

function standardizeDataIteratorOutput(e, t) {
  var n,
      r,
      i = t;
  n = i.xs, r = i.ys, _tfjsCore.util.assert(null != n && null != r, function () {
    return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " + t;
  });
  var a = flattenTensorOrArrayOrMap("input", e.inputNames, n),
      o = flattenTensorOrArrayOrMap("output", e.outputNames, r),
      s = a[0].shape[0];
  _tfjsCore.util.assert(a.length === e.inputs.length, function () {
    return "LayersModel has " + e.inputs.length + " inputs, but the dataset provides " + a.length + " inputs.  (Expected input keys: " + JSON.stringify(e.inputNames) + ")";
  }), _tfjsCore.util.assert(o.length === e.outputs.length, function () {
    return "LayersModel has " + e.outputs.length + " outputs, but the dataset provides " + o.length + " outputs.  (Expected output keys: " + JSON.stringify(e.outputNames) + ")";
  });

  for (var l = function (t) {
    _tfjsCore.util.assert(a[t].shape[0] === s, function () {
      return "Batch size mismatch: input " + e.inputNames[t] + " has " + a[t].shape[0] + "; expected  " + s + " based on input " + e.inputNames[0] + ".";
    });
  }, u = 0; u < a.length; u++) l(u);

  for (var c = function (t) {
    _tfjsCore.util.assert(o[t].shape[0] === s, function () {
      return "Batch size mismatch: output " + e.outputNames[t] + " has " + o[t].shape[0] + "; expected  " + s + " based on input " + e.inputNames[0] + ".";
    });
  }, p = 0; p < o.length; p++) c(p);

  return {
    xs: a,
    ys: o
  };
}

function flattenTensorOrArrayOrMap(e, t, n) {
  if (n instanceof _tfjsCore.Tensor) return [n];
  if (Array.isArray(n)) return _tfjsCore.util.assert(n.length === t.length, function () {
    return "Received an array of " + n.length + " Tensors, but expected " + t.length + " to match the " + e + " keys " + t + ".";
  }), n;

  for (var r = [], i = 0, a = t; i < a.length; i++) {
    var o = a[i];
    if (null == n[o]) throw new ValueError("The feature data generated by the dataset lacks the required " + e + " key '" + o + "'.");
    r.push(n[o]);
  }

  return r;
}

function standardizeTensorValidationData(e) {
  if (3 === e.length) throw new NotImplementedError("Validation with sample weights is not implemented yet.");
  return {
    xs: e[0],
    ys: e[1]
  };
}

function fitDataset(e, t, n) {
  return __awaiter(this, void 0, void 0, function () {
    var r, i, a, o, s, l, u, c, p, h, d, f, g, m, y, v, b, w, z, S, A, _, I, C, E, N, k, x, L, T, D, O, R, M;

    return __generator(this, function (P) {
      switch (P.label) {
        case 0:
          if (r = null != n.batchesPerEpoch, _tfjsCore.util.assert(null != e.optimizer, function () {
            return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).";
          }), _tfjsCore.util.assert(null != n, function () {
            return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.";
          }), _tfjsCore.util.assert(null != n.epochs && n.epochs > 0 && Number.isInteger(n.epochs), function () {
            return "For fitDataset(), config.epochs is expected to be a positive integer, but got " + n.epochs;
          }), _tfjsCore.util.assert(!r || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), function () {
            return "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got " + n.batchesPerEpoch;
          }), _tfjsCore.util.assert(null == n.validationSplit, function () {
            return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.";
          }), e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
          e.isTraining = !0, P.label = 1;

        case 1:
          return P.trys.push([1,, 26, 27]), i = null != n.validationData, a = void 0, o = void 0, i && (isDatasetObject(n.validationData) ? _tfjsCore.util.assert(null == n.validationBatches || n.validationBatches > 0 && Number.isInteger(n.validationBatches), function () {
            return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got " + n.validationBatches;
          }) : (s = standardizeTensorValidationData(n.validationData), a = s.xs, o = s.ys)), l = e.makeTrainFunction(), u = e.getDedupedMetricsNames(), c = void 0, c = i ? u.slice().concat(u.map(function (e) {
            return "val_" + e;
          })) : u.slice(), p = standardizeCallbacks(n.callbacks, n.yieldEvery), h = null == n.verbose ? 1 : n.verbose, d = configureCallbacks(p, h, n.epochs, null, null, getStepsPerEpoch(t, n), null, i, c), f = d.callbackList, g = d.history, f.setModel(e), e.history = g, [4, f.onTrainBegin()];

        case 2:
          return P.sent(), e.stopTraining_ = !1, m = null == n.initialEpoch ? 0 : n.initialEpoch, [4, t.iterator()];

        case 3:
          y = P.sent(), P.label = 4;

        case 4:
          return m < n.epochs ? (v = {}, [4, f.onEpochBegin(m)]) : [3, 23];

        case 5:
          return P.sent(), b = 0, w = 0, r ? [3, 7] : [4, t.iterator()];

        case 6:
          y = P.sent(), P.label = 7;

        case 7:
          return !r || b < n.batchesPerEpoch ? [4, y.next()] : [3, 21];

        case 8:
          return z = P.sent(), r && z.done ? (console.warn("You provided `batchesPerEpoch` as " + n.batchesPerEpoch + ", but your dataset iterator ran out of data after " + b + " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " + n.batchesPerEpoch * n.epochs + " batches). You may need to use the repeat() function when building your dataset."), [3, 21]) : null == z.value ? [3, 15] : (S = standardizeDataIteratorOutput(e, z.value), A = S.xs, _ = S.ys, (I = {}).batch = w, I.size = A[0].shape[0], [4, f.onBatchBegin(w, I)]);

        case 9:
          if (P.sent(), C = [], null == n.classWeight) return [3, 13];
          E = standardizeClassWeights(n.classWeight, e.outputNames), M = 0, P.label = 10;

        case 10:
          return M < E.length ? (k = (N = C).push, [4, standardizeWeights(_[M], null, E[M])]) : [3, 13];

        case 11:
          k.apply(N, [P.sent()]), P.label = 12;

        case 12:
          return ++M, [3, 10];

        case 13:
          for (x = A.concat(_).concat(C), L = l(x), (0, _tfjsCore.dispose)(x), M = 0; M < u.length; ++M) T = u[M], D = L[M], I[T] = D, (0, _tfjsCore.keep)(D);

          return [4, f.onBatchEnd(w, I)];

        case 14:
          P.sent(), disposeTensorsInLogs(I), w++, b++, P.label = 15;

        case 15:
          return (r ? b >= n.batchesPerEpoch : z.done) ? i ? (O = void 0, isDatasetObject(n.validationData) ? (R = toList, [4, e.evaluateDataset(n.validationData, {
            batches: n.validationBatches
          })]) : [3, 17]) : [3, 19] : [3, 20];

        case 16:
          return O = R.apply(void 0, [P.sent()]), [3, 18];

        case 17:
          O = toList(e.evaluate(a, o, {
            batchSize: null == n.validationBatchSize ? DEFAULT_VALIDATION_BATCH_SIZE : n.validationBatchSize,
            verbose: 0
          })), P.label = 18;

        case 18:
          for (M = 0; M < e.metricsNames.length; ++M) v["val_" + e.metricsNames[M]] = O[M];

          P.label = 19;

        case 19:
          return [3, 21];

        case 20:
          return e.stopTraining_ ? [3, 21] : [3, 7];

        case 21:
          return [4, f.onEpochEnd(m, v)];

        case 22:
          return P.sent(), m++, e.stopTraining_ ? [3, 23] : [3, 4];

        case 23:
          return [4, f.onTrainEnd()];

        case 24:
          return P.sent(), [4, e.history.syncData()];

        case 25:
          return P.sent(), [2, e.history];

        case 26:
          return e.isTraining = !1, [7];

        case 27:
          return [2];
      }
    });
  });
}

function getStepsPerEpoch(e, t) {
  var n = null;
  return null != t.batchesPerEpoch ? n = t.batchesPerEpoch : Number.isFinite(e.size) && (n = e.size), n;
}

function isDatasetObject(e) {
  return "function" == typeof e.iterator;
}

function isLazyIteratorObject(e) {
  return "function" == typeof e.next;
}

function evaluateDataset(e, t, n) {
  return __awaiter(this, void 0, void 0, function () {
    var r, i, a, o, s, l, u, c, p, h;
    return __generator(this, function (d) {
      switch (d.label) {
        case 0:
          if (r = null != (n = n || {}).batches, i = e.testFunction, a = [], n.verbose > 0) throw new NotImplementedError("Verbose mode is not implemented yet.");
          return _tfjsCore.util.assert(!r || n.batches > 0 && Number.isInteger(n.batches), function () {
            return "Test loop expects `batches` to be a positive integer, but received " + JSON.stringify(n.batches);
          }), isLazyIteratorObject(t) ? (s = t, [3, 3]) : [3, 1];

        case 1:
          return [4, t.iterator()];

        case 2:
          s = d.sent(), d.label = 3;

        case 3:
          o = s, l = 0, u = 0, c = function () {
            var t;
            return __generator(this, function (s) {
              switch (s.label) {
                case 0:
                  return [4, o.next()];

                case 1:
                  return t = s.sent(), a = (0, _tfjsCore.tidy)(function () {
                    if (t.value) {
                      var n = standardizeDataIteratorOutput(e, t.value),
                          r = n.xs,
                          o = n.ys,
                          s = r.concat(o),
                          c = (0, _tfjsCore.tidy)(function () {
                        return i(s);
                      });
                      if ((0, _tfjsCore.dispose)(s), 0 === u) for (var p = 0; p < c.length; ++p) a.push((0, _tfjsCore.scalar)(0));

                      var h = s[0].shape[0],
                          d = function (e) {
                        var t = c[e],
                            n = a[e];
                        a[e] = (0, _tfjsCore.tidy)(function () {
                          return (0, _tfjsCore.add)(a[e], (0, _tfjsCore.mul)(h, t));
                        }), u > 0 && (0, _tfjsCore.dispose)(n);
                      };

                      for (p = 0; p < c.length; ++p) d(p);

                      (0, _tfjsCore.dispose)(c), l += h, ++u;
                    }

                    return a;
                  }), t.done ? (r && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, " + n.batches + " batches). You may need to use the repeat() function when building your dataset."), [2, "break"]) : [2];
              }
            });
          }, d.label = 4;

        case 4:
          return !r || u < n.batches ? [5, c()] : [3, 6];

        case 5:
          return "break" === d.sent() ? [3, 6] : [3, 4];

        case 6:
          for (p = 0; p < a.length; ++p) h = a[p], a[p] = (0, _tfjsCore.div)(a[p], l), (0, _tfjsCore.dispose)(h);

          return [2, singletonOrArray(a)];
      }
    });
  });
}

function checkBatchSize(e) {
  _tfjsCore.util.assert(e > 0 && Number.isInteger(e), function () {
    return "batchSize is required to be a positive integer, but got " + e;
  });
}

function sliceArrays(e, t, n) {
  return null == e ? [null] : Array.isArray(e) ? e.map(function (e) {
    return sliceAlongFirstAxis(e, t, n - t);
  }) : sliceAlongFirstAxis(e, t, n - t);
}

function sliceArraysByIndices(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return null == e ? null : Array.isArray(e) ? e.map(function (e) {
      return sliceArraysByIndices(e, t);
    }) : gather$1(e, "int32" === t.dtype ? t : t.toInt());
  });
}

function makeBatches(e, t) {
  for (var n = [], r = 0, i = null; r < e;) (i = r + t) >= e && (i = e), n.push([r, i]), r = i;

  return n;
}

function fitLoop(e, t, n, r, i, a, o, s, l, u, c, p, h, d, f) {
  return __awaiter(this, void 0, void 0, function () {
    var g, m, y, v, b, w, z, S;
    return __generator(this, function (A) {
      switch (A.label) {
        case 0:
          if (null == i && (i = 32), null == a && (a = 1), null == c && (c = !0), null == h && (h = 0), g = !1, null != l && null != u && (g = !0), null != f && (g = !0, null == d)) throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
          return null != (m = e.checkNumSamples(n, i, d, "steps_per_epoch")) && (y = range(0, m)), null == o && (o = 1), v = configureCallbacks(s, o, a, h, m, d, i, g, p), b = v.callbackList, w = v.history, b.setModel(e), e.history = w, [4, b.onTrainBegin()];

        case 1:
          A.sent(), e.stopTraining_ = !1, z = function (a) {
            var o, s, p, h, f;
            return __generator(this, function (v) {
              switch (v.label) {
                case 0:
                  return [4, b.onEpochBegin(a)];

                case 1:
                  if (v.sent(), o = {}, null == d) return [3, 2];
                  throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");

                case 2:
                  if ("batch" === c) throw new NotImplementedError("batch shuffling is not implemneted yet");
                  c && _tfjsCore.util.shuffle(y), s = (0, _tfjsCore.tensor1d)(y), p = makeBatches(m, i), h = function (a) {
                    var c;
                    return __generator(this, function (h) {
                      switch (h.label) {
                        case 0:
                          return c = {}, [4, b.onBatchBegin(a, c)];

                        case 1:
                          return h.sent(), (0, _tfjsCore.tidy)(function () {
                            var h = p[a][0],
                                d = p[a][1],
                                f = sliceAlongFirstAxis(s, h, d - h);
                            c.batch = a, c.size = d - h;

                            for (var m = sliceArraysByIndices(n, f), y = t(m), v = 0; v < r.length; ++v) {
                              var b = r[v],
                                  w = y[v];
                              c[b] = w, (0, _tfjsCore.keep)(w);
                            }

                            if (a === p.length - 1 && g) {
                              var z = e.testLoop(l, u, i);

                              for (v = 0; v < r.length; ++v) {
                                b = r[v], w = z[v];
                                (0, _tfjsCore.keep)(w), o["val_" + b] = w;
                              }
                            }
                          }), [4, b.onBatchEnd(a, c)];

                        case 2:
                          return h.sent(), disposeTensorsInLogs(c), e.stopTraining_ ? [2, "break"] : [2];
                      }
                    });
                  }, f = 0, v.label = 3;

                case 3:
                  return f < p.length ? [5, h(f)] : [3, 6];

                case 4:
                  if ("break" === v.sent()) return [3, 6];
                  v.label = 5;

                case 5:
                  return ++f, [3, 3];

                case 6:
                  s.dispose(), v.label = 7;

                case 7:
                  return [4, b.onEpochEnd(a, o)];

                case 8:
                  return v.sent(), e.stopTraining_ ? [2, "break"] : [2];
              }
            });
          }, S = h, A.label = 2;

        case 2:
          return S < a ? [5, z(S)] : [3, 5];

        case 3:
          if ("break" === A.sent()) return [3, 5];
          A.label = 4;

        case 4:
          return ++S, [3, 2];

        case 5:
          return [4, b.onTrainEnd()];

        case 6:
          return A.sent(), [4, e.history.syncData()];

        case 7:
          return A.sent(), [2, e.history];
      }
    });
  });
}

function fitTensors(e, t, n, r) {
  return void 0 === r && (r = {}), __awaiter(this, void 0, void 0, function () {
    var i, a, o, s, l, u, c, p, h, d, f, g, m, y, v, b, w, z, S, A, _, I;

    return __generator(this, function (C) {
      switch (C.label) {
        case 0:
          if (e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
          e.isTraining = !0, C.label = 1;

        case 1:
          return C.trys.push([1,, 7, 8]), checkBatchSize(p = null == r.batchSize ? 32 : r.batchSize), h = !1, [4, e.standardizeUserData(t, n, r.sampleWeight, r.classWeight, h, p)];

        case 2:
          if (d = C.sent(), i = d[0], a = d[1], c = d[2], f = !1, g = void 0, !(null != r.validationData && r.validationData.length > 0)) return [3, 4];
          if (f = !0, 2 !== r.validationData.length) throw 3 === r.validationData.length ? new NotImplementedError("validationData including sample weights is not supported yet.") : new ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " + r.validationData + " is invalid.");
          return o = r.validationData[0], s = r.validationData[1], m = !0, [4, e.standardizeUserData(o, s, null, null, m, p)];

        case 3:
          return y = C.sent(), l = y[0], u = y[1], g = l.concat(u), [3, 5];

        case 4:
          null != r.validationSplit && r.validationSplit > 0 && r.validationSplit < 1 ? (f = !0, v = Math.floor(i[0].shape[0] * (1 - r.validationSplit)), b = i[0].shape[0], l = sliceArrays(i, v, b), i = sliceArrays(i, 0, v), u = sliceArrays(a, v, b), a = sliceArrays(a, 0, v), g = l.concat(u)) : null != r.validationSteps && (f = !0), C.label = 5;

        case 5:
          return w = i.concat(a).concat(c), e.checkTrainableWeightsConsistency(), z = e.makeTrainFunction(), S = e.getDedupedMetricsNames(), A = void 0, _ = void 0, f ? (e.makeTestFunction(), A = e.testFunction, _ = S.slice().concat(S.map(function (e) {
            return "val_" + e;
          }))) : (A = null, g = [], _ = S.slice()), I = standardizeCallbacks(r.callbacks, r.yieldEvery), [4, fitLoop(e, z, w, S, p, r.epochs, r.verbose, I, A, g, r.shuffle, _, r.initialEpoch, null, null)];

        case 6:
          return [2, C.sent()];

        case 7:
          return e.isTraining = !1, disposeNewTensors(i, t), disposeNewTensors(a, n), disposeNewTensors(l, o), disposeNewTensors(u, s), null != c && (0, _tfjsCore.dispose)(c), [7];

        case 8:
          return [2];
      }
    });
  });
}

function ensureTensorsRank2OrHigher(e) {
  var t = [];
  e instanceof _tfjsCore.Tensor && (e = [e]);

  for (var n = 0; n < e.length; ++n) {
    var r = e[n];
    if (1 === r.rank) t.push(expandDims$1(r, 1));else {
      if (0 === r.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
      t.push(r);
    }
  }

  return t;
}

function disposeNewTensors(e, t) {
  if (null != e) {
    var n = [];
    if (t instanceof _tfjsCore.Tensor) n.push(t.id);else if (Array.isArray(t)) t.forEach(function (e) {
      return n.push(e.id);
    });else if (null != t) for (var r in t) {
      var i = t[r];
      n.push(i.id);
    }
    var a = [];
    if (e instanceof _tfjsCore.Tensor) -1 === n.indexOf(e.id) && a.push(e);else if (Array.isArray(e)) e.forEach(function (e) {
      -1 === n.indexOf(e.id) && a.push(e);
    });else if (null != e) for (var o in e) {
      var s = e[o];
      -1 === n.indexOf(s.id) && a.push(s);
    }
    a.forEach(function (e) {
      e.isDisposed || e.dispose();
    });
  }
}

function isDataTensor(e) {
  return e instanceof _tfjsCore.Tensor;
}

function isDataArray(e) {
  return Array.isArray(e);
}

function isDataDict(e) {
  return !isDataTensor(e) && !isDataArray(e);
}

function standardizeInputData(e, t, n, r, i) {
  if (void 0 === r && (r = !0), void 0 === i && (i = ""), null == t || 0 === t.length) {
    if (null != e) {
      var a = !1;
      if (isDataArray(e) && e.length > 0) a = !0;else if (isDataDict(e)) {
        for (var o in e) if (e.hasOwnProperty(o)) {
          a = !0;
          break;
        }
      } else a = !0;
      if (a) throw new ValueError("Error when checking model " + i + " expected no data, but got " + e);
    }

    return [];
  }

  if (null == e) return t.map(function (e) {
    return null;
  });
  var s;

  if (isDataDict(e)) {
    e = e, s = [];

    for (var l = 0, u = t; l < u.length; l++) {
      var c = u[l];
      if (null == e[c]) throw new ValueError('No data provided for "' + c + '". Need data for each key in: ' + t);
      s.push(e[c]);
    }
  } else if (isDataArray(e)) {
    if ((e = e).length !== t.length) throw new ValueError("Error when checking model " + i + ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see " + t.length + " Tensor(s), but instead got the following list of Tensor(s): " + e);
    s = e;
  } else {
    if (e = e, t.length > 1) throw new ValueError("The model " + i + " expects " + t.length + " Tensor(s), but only received one Tensor. Found: Tensor with shape " + e.shape);
    s = [e];
  }

  if (s = ensureTensorsRank2OrHigher(s), null != n) for (var p = 0; p < t.length; ++p) if (null != n[p]) {
    var h = s[p];
    if (h.shape.length !== n[p].length) throw new ValueError("Error when checking " + i + ": expected " + t[p] + " to have " + n[p].length + " dimension(s). but got array with shape " + h.shape);

    for (var d = 0; d < n[p].length; ++d) if (0 !== d || r) {
      var f = h.shape[d],
          g = n[p][d];
      if (null != g && g >= 0 && f !== g) throw new ValueError("Error when checking " + i + ": expected " + t[p] + " to have shape [" + n[p] + "], but got array with shape [" + h.shape + "].");
    }
  }
  return s;
}

function checkArrayLengths(e, t, n) {
  var r = unique(e.map(function (e) {
    return e.shape[0];
  }));
  r.sort();
  var i = unique(t.map(function (e) {
    return e.shape[0];
  }));
  if (i.sort(), r.length > 1) throw new ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: " + JSON.stringify(e.map(function (e) {
    return e.shape;
  })));
  if (i.length > 1) throw new ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: " + JSON.stringify(t.map(function (e) {
    return e.shape;
  })));
  if (r.length > 0 && i.length > 0 && !_tfjsCore.util.arraysEqual(r, i)) throw new ValueError("Input Tensors should have the same number of samples as target Tensors. Found " + r[0] + " input sample(s) and " + i[0] + " target sample(s).");
}

function checkLossAndTargetCompatibility(e, t, n) {
  for (var r = [meanSquaredError, binaryCrossentropy, categoricalCrossentropy], i = 0; i < e.length; ++i) {
    var a = e[i],
        o = t[i],
        s = n[i];

    if (null != o) {
      if (o === categoricalCrossentropy && 1 === a.shape[a.shape.length - 1]) throw new ValueError("You are passing a target array of shape " + a.shape + " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");
      if (-1 !== r.indexOf(o)) for (var l = a.shape.slice(1), u = s.slice(1), c = 0; c < l.length; ++c) {
        var p = l[c],
            h = u[c];
        if (null != h && p !== h) throw new ValueError("A target Tensor with shape " + a.shape + " was passed for an output of shape " + s + ", while using a loss function that expects targets to have the same shape as the output.");
      }
    }
  }
}

function checkInputData(e, t, n, r, i) {
  var a;

  if (void 0 === r && (r = !0), void 0 === i && (i = ""), Array.isArray(e)) {
    if (e.length !== t.length) throw new ValueError("Error when checking model " + i + ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see " + t.length + " Tensor(s), but instead got " + e.length + " Tensors(s).");
    a = e;
  } else {
    if (t.length > 1) throw new ValueError("The model expects " + t.length + " " + i + " Tensors, but only received one Tensor. Found: array with shape " + JSON.stringify(e.shape) + ".");
    a = [e];
  }

  if (null != n) for (var o = 0; o < t.length; ++o) if (null != n[o]) {
    var s = a[o];
    if (s.shape.length !== n[o].length) throw new ValueError("Error when checking " + i + ": expected " + t[o] + " to have " + n[o].length + " dimension(s), but got array with shape " + JSON.stringify(s.shape));

    for (var l = 0; l < n[o].length; ++l) if (0 !== l || r) {
      var u = s.shape[l],
          c = n[o][l];
      if (null != c && c !== u) throw new ValueError("Error when checking " + i + ": expected " + t[o] + " to have shape " + JSON.stringify(n[o]) + " but got array with shape " + JSON.stringify(s.shape) + ".");
    }
  }
}

function collectMetrics(e, t) {
  if (null == e || Array.isArray(e) && 0 === e.length) return t.map(function (e) {
    return [];
  });
  var n;
  if ("string" == typeof e || "function" == typeof e) n = [e];else {
    if (!Array.isArray(e) && "object" != typeof e) throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: " + e);
    n = e;
  }
  if (Array.isArray(n)) return t.map(function (e) {
    return n;
  });

  for (var r = [], i = 0, a = t; i < a.length; i++) {
    var o = a[i],
        s = n.hasOwnProperty(o) ? n[o] : [];
    Array.isArray(s) || (s = [s]), r.push(s);
  }

  return r;
}

var LAYERS_MODEL_FORMAT_NAME = "layers-model",
    LayersModel = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.isTraining = !1, n;
  }

  return __extends(t, e), t.prototype.summary = function (e, t, n) {
    if (void 0 === n && (n = console.log), !this.built) throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
    printSummary(this, e, t, n);
  }, t.prototype.compile = function (e) {
    var t = this;
    if (null == e.loss && (e.loss = []), this.loss = e.loss, "string" == typeof e.optimizer) this.optimizer_ = getOptimizer(e.optimizer), this.isOptimizerOwned = !0;else {
      if (!(e.optimizer instanceof _tfjsCore.Optimizer)) throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");
      this.optimizer_ = e.optimizer, this.isOptimizerOwned = !1;
    }
    var n = [];
    if (Array.isArray(e.loss) || "string" == typeof e.loss || "function" == typeof e.loss) {
      if (Array.isArray(e.loss)) {
        if (e.loss.length !== this.outputs.length) throw new ValueError("When passing an Array as loss, it should have one entry per model output. The model has " + this.outputs.length + " output(s), but you passed loss=" + e.loss + ".");
        var r = e.loss;
        n = r.map(function (e) {
          return get(e);
        });
      } else {
        var i = get(e.loss);
        this.outputs.forEach(function (e) {
          n.push(i);
        });
      }
    } else {
      for (var a in e.loss = e.loss, e.loss) if (-1 === this.outputNames.indexOf(a)) throw new ValueError('Unknown entry in loss dictionary: "' + a + '". Only expected the following keys: ' + this.outputNames);

      for (var o = 0, s = this.outputNames; o < s.length; o++) {
        var l = s[o];
        null == e.loss[l] && console.warn('Output "' + l + '" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ' + l + " during training"), n.push(get(e.loss[l]));
      }
    }
    this.lossFunctions = n, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];

    for (var u = 0; u < this.outputs.length; ++u) {
      var c = this.internalOutputShapes[u],
          p = this.outputNames[u];
      this.feedOutputNames.push(p), this.feedOutputShapes.push(c), this.feedLossFns.push(this.lossFunctions[u]);
    }

    var h = [];
    this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], nameScope("loss", function () {
      for (var e = 0; e < t.outputs.length; ++e) if (-1 === h.indexOf(e)) {
        var n = t.lossFunctions[e];
        t.outputs.length > 1 && (t.metricsTensors.push([n, e]), t.metricsNames.push(t.outputNames[e] + "_loss"));
      }
    });
    var d = collectMetrics(e.metrics, this.outputNames);
    nameScope("metric", function () {
      for (var e = function (e) {
        if (-1 !== h.indexOf(e)) return "continue";
        !function (n) {
          for (var r, i, a, o = function (n) {
            if ("string" == typeof n && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(n)) {
              var o = t.internalOutputShapes[e];
              1 === o[o.length - 1] || t.lossFunctions[e] === binaryCrossentropy ? -1 !== ["accuracy", "acc"].indexOf(n) ? i = binaryAccuracy : -1 !== ["crossentropy", "ce"].indexOf(n) && (i = binaryCrossentropy$1) : t.lossFunctions[e] === sparseCategoricalCrossentropy ? -1 !== ["accuracy", "acc"].indexOf(n) ? i = sparseCategoricalAccuracy : -1 !== ["crossentropy", "ce"].indexOf(n) && (i = sparseCategoricalCrossentropy$1) : -1 !== ["accuracy", "acc"].indexOf(n) ? i = categoricalAccuracy : -1 !== ["crossentropy", "ce"].indexOf(n) && (i = categoricalCrossentropy$1);
              var s = void 0;
              -1 !== ["accuracy", "acc"].indexOf(n) ? s = "acc" : -1 !== ["crossentropy", "ce"].indexOf(n) && (s = "ce"), a = i, r = "" + s;
            } else {
              var l = get$1(n);
              a = l, r = "" + getLossOrMetricName(n);
            }

            var u;
            nameScope(r, function () {
              u = a;
            }), function (e, n, r) {
              t.outputNames.length > 1 && (n = t.outputNames[e] + "_" + n), t.metricsNames.push(n), t.metricsTensors.push([r, e]);
            }(e, r, u);
          }, s = 0, l = n; s < l.length; s++) o(l[s]);
        }(d[e]);
      }, n = 0; n < t.outputs.length; ++n) e(n);
    }), this.collectedTrainableWeights = this.trainableWeights;
  }, t.prototype.checkTrainableWeightsConsistency = function () {
    null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
  }, t.prototype.evaluate = function (e, t, n) {
    void 0 === n && (n = {});
    var r = null == n.batchSize ? 32 : n.batchSize;
    checkBatchSize(r);
    var i = this.standardizeUserDataXY(e, t, !0, r);

    try {
      var a = i[0].concat(i[1]);
      this.makeTestFunction();
      var o = this.testFunction;
      return singletonOrArray(this.testLoop(o, a, r, n.verbose, n.steps));
    } finally {
      disposeNewTensors(i[0], e), disposeNewTensors(i[1], t);
    }
  }, t.prototype.evaluateDataset = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        return this.makeTestFunction(), [2, evaluateDataset(this, e, t)];
      });
    });
  }, t.prototype.checkNumSamples = function (e, t, n, r) {
    var i;

    if (void 0 === r && (r = "steps"), null != n) {
      if (i = null, null != t) throw new ValueError("If " + r + " is set, batchSize must be null or undefined.Got batchSize = " + t);
    } else {
      if (null == e) throw new ValueError("Either the input data should have a defined shape, or " + r + " shoud be specified.");
      i = Array.isArray(e) ? e[0].shape[0] : e.shape[0];
    }

    return i;
  }, t.prototype.execute = function (e, t) {
    if (Array.isArray(t) && 0 === t.length) throw new ValueError("`outputs` is an empty Array, which is not allowed.");
    var n = Array.isArray(t),
        r = n ? t : [t],
        i = this.retrieveSymbolicTensors(r),
        a = new FeedDict();

    if (e instanceof _tfjsCore.Tensor && (e = [e]), Array.isArray(e)) {
      if (e.length !== this.inputs.length) throw new ValueError("The number of inputs provided (" + e.length + ") does not match the number of inputs of this model (" + this.inputs.length + ").");

      for (var o = 0; o < this.inputs.length; ++o) a.add(this.inputs[o], e[o]);
    } else for (var s = 0, l = this.inputs; s < l.length; s++) {
      var u = l[s],
          c = e[u.name];
      if (null == c) throw new ValueError("No value is provided for the model's input " + u.name);
      a.add(u, c);
    }

    var p = execute(i, a);
    return n ? p : p[0];
  }, t.prototype.retrieveSymbolicTensors = function (e) {
    for (var t = pyListRepeat(null, e.length), n = e.length, r = 0, i = this.layers; r < i.length; r++) {
      for (var a = i[r], o = Array.isArray(a.output) ? a.output : [a.output], s = o.map(function (e) {
        return e.name;
      }), l = 0; l < e.length; ++l) {
        var u = s.indexOf(e[l]);
        if (-1 !== u && (t[l] = o[u], n--), 0 === n) break;
      }

      if (0 === n) break;
    }

    if (n > 0) {
      var c = [];
      throw t.forEach(function (t, n) {
        null == t && c.push(e[n]);
      }), new ValueError("Cannot find SymbolicTensors for output name(s): " + JSON.stringify(c));
    }

    return t;
  }, t.prototype.predictLoop = function (e, t, n) {
    var r = this;
    return void 0 === t && (t = 32), void 0 === n && (n = !1), (0, _tfjsCore.tidy)(function () {
      var i = r.checkNumSamples(e);
      if (n) throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");

      for (var a = makeBatches(i, t), o = r.outputs.map(function (e) {
        return [];
      }), s = function (t) {
        (0, _tfjsCore.tidy)(function () {
          var n = a[t][0],
              i = a[t][1],
              o = sliceArrays(e, n, i),
              s = [];
          if (Array.isArray(o)) for (var l = 0; l < o.length; ++l) s.push({
            key: r.inputs[l],
            value: o[l]
          });else s.push({
            key: r.inputs[0],
            value: o
          });
          var u = new FeedDict(s);
          return execute(r.outputs, u);
        }).forEach(function (e, t) {
          return o[t].push(e);
        });
      }, l = 0; l < a.length; ++l) s(l);

      return singletonOrArray(o.map(function (e) {
        return (0, _tfjsCore.concat)(e, 0);
      }));
    });
  }, t.prototype.predict = function (e, t) {
    void 0 === t && (t = {});
    var n = ensureTensorsRank2OrHigher(e);
    checkInputData(n, this.inputNames, this.feedInputShapes, !1);

    try {
      var r = null == t.batchSize ? 32 : t.batchSize;
      return checkBatchSize(r), this.predictLoop(n, r);
    } finally {
      disposeNewTensors(n, e);
    }
  }, t.prototype.predictOnBatch = function (e) {
    checkInputData(e, this.inputNames, this.feedInputShapes, !0);
    var t = (Array.isArray(e) ? e[0] : e).shape[0];
    return this.predictLoop(e, t);
  }, t.prototype.standardizeUserDataXY = function (e, t, n, r) {
    if (void 0 === n && (n = !0), null == this.optimizer_) throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");

    for (var i = [], a = 0; a < this.feedOutputShapes.length; ++a) {
      var o = this.feedOutputShapes[a];
      this.feedLossFns[a] === sparseCategoricalCrossentropy ? i.push(o.slice(0, o.length - 1).concat([1])) : i.push(o);
    }

    if (checkArrayLengths(e = standardizeInputData(e, this.feedInputNames, this.feedInputShapes, !1, "input"), t = standardizeInputData(t, this.feedOutputNames, i, !1, "target"), null), checkLossAndTargetCompatibility(t, this.feedLossFns, this.feedOutputShapes), this.stateful && null != r && r > 0 && e[0].shape[0] % r != 0) throw new ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " + r + ". Found: " + e[0].shape[0] + " sample(s).");
    return [e, t];
  }, t.prototype.standardizeUserData = function (e, t, n, r, i, a) {
    return void 0 === i && (i = !0), __awaiter(this, void 0, void 0, function () {
      var o, s, l, u, c, p, h, d;
      return __generator(this, function (f) {
        switch (f.label) {
          case 0:
            if (o = this.standardizeUserDataXY(e, t, i, a), s = o[0], l = o[1], null != n) throw new Error("sample weight is not supported yet.");
            if (u = null, null == r) return [3, 4];
            c = standardizeClassWeights(r, this.outputNames), u = [], p = 0, f.label = 1;

          case 1:
            return p < c.length ? (d = (h = u).push, [4, standardizeWeights(l[p], null, c[p])]) : [3, 4];

          case 2:
            d.apply(h, [f.sent()]), f.label = 3;

          case 3:
            return ++p, [3, 1];

          case 4:
            return [2, [s, l, u]];
        }
      });
    });
  }, t.prototype.testLoop = function (e, t, n, r, i) {
    var a = this;
    return void 0 === r && (r = 0), (0, _tfjsCore.tidy)(function () {
      var o = a.checkNumSamples(t, n, i, "steps"),
          s = [];
      if (r > 0) throw new NotImplementedError("Verbose mode is not implemented yet.");
      if (null != i) throw new NotImplementedError("steps mode in testLoop() is not implemented yet");

      for (var l = makeBatches(o, n), u = (0, _tfjsCore.tensor1d)(range(0, o)), c = 0; c < l.length; ++c) {
        var p = l[c][0],
            h = l[c][1],
            d = sliceAlongFirstAxis(u, p, h - p),
            f = sliceArraysByIndices(t, d),
            g = e(f);
        if (0 === c) for (var m = 0; m < g.length; ++m) s.push((0, _tfjsCore.scalar)(0));

        for (m = 0; m < g.length; ++m) {
          var y = g[m];
          s[m] = (0, _tfjsCore.add)(s[m], (0, _tfjsCore.mul)(h - p, y));
        }
      }

      for (m = 0; m < s.length; ++m) s[m] = (0, _tfjsCore.div)(s[m], o);

      return s;
    });
  }, t.prototype.getDedupedMetricsNames = function () {
    for (var e = this.metricsNames, t = [], n = 0; n < e.length; ++n) {
      var r = e[n],
          i = r;
      if (count(e, r) > 1) i += "_" + count(e.slice(0, n), r);
      t.push(i);
    }

    return t;
  }, t.prototype.makeTrainFunction = function () {
    var e = this;
    return function (t) {
      var n = [],
          r = t.slice(0, e.inputs.length),
          i = t.slice(e.inputs.length, e.inputs.length + e.outputs.length),
          a = t.slice(e.inputs.length + e.outputs.length, e.inputs.length + 2 * e.outputs.length),
          o = [],
          s = e.collectedTrainableWeights.map(function (e) {
        return e.read();
      });
      return [e.optimizer_.minimize(function () {
        for (var t = [], s = 0; s < e.inputs.length; ++s) t.push({
          key: e.inputs[s],
          value: r[s]
        });

        var l,
            u = new FeedDict(t),
            c = execute(e.outputs, u, {
          training: !0
        });

        for (s = 0; s < e.lossFunctions.length; ++s) {
          var p = (0, e.lossFunctions[s])(i[s], c[s]);
          null != a[s] && (p = computeWeightedLoss(p, a[s]));
          var h = (0, _tfjsCore.mean)(p);
          n.push(h), l = 0 === s ? p : (0, _tfjsCore.add)(l, p);
        }

        for (s = 0; s < e.metricsTensors.length; ++s) {
          var d = void 0;
          if (e.outputs.length > 1 && s < e.outputs.length) d = n[s];else {
            var f = e.metricsTensors[s][0],
                g = e.metricsTensors[s][1];
            d = (0, _tfjsCore.mean)(f(i[g], c[g]));
          }
          (0, _tfjsCore.keep)(d), o.push(d);
        }

        return l = (0, _tfjsCore.mean)(l), e.calculateLosses().forEach(function (e) {
          l = (0, _tfjsCore.add)(l, e);
        }), l;
      }, !0, s)].concat(o);
    };
  }, t.prototype.makeTestFunction = function () {
    var e = this;

    this.testFunction = function (t) {
      return (0, _tfjsCore.tidy)(function () {
        for (var n, r = [], i = t.slice(0, e.inputs.length), a = t.slice(e.inputs.length, e.inputs.length + e.outputs.length), o = [], s = 0; s < e.inputs.length; ++s) o.push({
          key: e.inputs[s],
          value: i[s]
        });

        var l = new FeedDict(o),
            u = execute(e.outputs, l);

        for (s = 0; s < e.lossFunctions.length; ++s) {
          var c = e.lossFunctions[s],
              p = (0, _tfjsCore.mean)(c(a[s], u[s]));
          n = 0 === s ? p : (0, _tfjsCore.add)(n, p), r.push(n);
        }

        for (s = 0; s < e.metricsTensors.length; ++s) {
          var h = e.metricsTensors[s][0],
              d = e.metricsTensors[s][1],
              f = (0, _tfjsCore.mean)(h(a[d], u[d]));
          r.push(f);
        }

        return r;
      });
    };
  }, t.prototype.fit = function (e, t, n) {
    return void 0 === n && (n = {}), __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (r) {
        return [2, fitTensors(this, e, t, n)];
      });
    });
  }, t.prototype.fitDataset = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        return [2, fitDataset(this, e, t)];
      });
    });
  }, t.prototype.trainOnBatch = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r, i, a, o, s, l, u, c;
      return __generator(this, function (p) {
        switch (p.label) {
          case 0:
            return [4, this.standardizeUserData(e, t)];

          case 1:
            n = p.sent(), r = n[0], i = n[1], a = this.makeTrainFunction(), o = a(r.concat(i)), s = [], l = 0, u = o, p.label = 2;

          case 2:
            return l < u.length ? [4, u[l].data()] : [3, 5];

          case 3:
            c = p.sent(), s.push(c[0]), p.label = 4;

          case 4:
            return l++, [3, 2];

          case 5:
            return (0, _tfjsCore.dispose)(o), [2, singletonOrArray(s)];
        }
      });
    });
  }, t.prototype.getNamedWeights = function (e) {
    for (var t = [], n = null != e && e.trainableOnly, r = n ? this.trainableWeights : this.weights, i = this.getWeights(n), a = 0; a < r.length; ++a) n && !r[a].trainable || t.push({
      name: r[a].originalName,
      tensor: i[a]
    });

    return t;
  }, Object.defineProperty(t.prototype, "stopTraining", {
    get: function () {
      return this.stopTraining_;
    },
    set: function (e) {
      this.stopTraining_ = e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "optimizer", {
    get: function () {
      return this.optimizer_;
    },
    set: function (e) {
      this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1);
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.dispose = function () {
    var t = e.prototype.dispose.call(this);

    if (0 === t.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
      var n = (0, _tfjsCore.memory)().numTensors;
      this.optimizer_.dispose(), t.numDisposedVariables += n - (0, _tfjsCore.memory)().numTensors;
    }

    return t;
  }, t.prototype.getLossIdentifiers = function () {
    var e;
    if ("string" == typeof this.loss) e = toSnakeCase(this.loss);else if (Array.isArray(this.loss)) {
      for (var t = 0, n = this.loss; t < n.length; t++) {
        if ("string" != typeof n[t]) throw new Error("Serialization of non-string loss is not supported.");
      }

      e = this.loss.map(function (e) {
        return toSnakeCase(e);
      });
    } else {
      var r = Object.keys(this.loss);
      e = {};

      for (var i = this.loss, a = 0, o = r; a < o.length; a++) {
        var s = o[a];
        if ("string" != typeof i[s]) throw new Error("Serialization of non-string loss is not supported.");
        e[s] = toSnakeCase(i[s]);
      }
    }
    return e;
  }, t.prototype.getMetricIdentifiers = function () {
    if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [toSnakeCase(getLossOrMetricName(this.metrics))];
    if (Array.isArray(this.metrics)) return this.metrics.map(function (e) {
      return toSnakeCase(getLossOrMetricName(e));
    });
    var e = {};

    for (var t in this.metrics) e[t] = toSnakeCase(getLossOrMetricName(this.metrics[t]));

    return e;
  }, t.prototype.getTrainingConfig = function () {
    return {
      loss: this.getLossIdentifiers(),
      metrics: this.getMetricIdentifiers(),
      optimizer_config: {
        class_name: this.optimizer.getClassName(),
        config: this.optimizer.getConfig()
      }
    };
  }, t.prototype.loadTrainingConfig = function (e) {
    if (null != e.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
    if (null != e.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
    if (null != e.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
    var t,
        n,
        r = deserialize(convertPythonicToTs(e.optimizer_config));
    if ("string" == typeof e.loss) t = toCamelCase(e.loss);else if (Array.isArray(e.loss)) t = e.loss.map(function (e) {
      return toCamelCase(e);
    });else if (null != e.loss) for (var i in t = {}, e.loss) t[i] = toCamelCase(e.loss[i]);
    if (Array.isArray(e.metrics)) n = e.metrics.map(function (e) {
      return toCamelCase(e);
    });else if (null != e.metrics) for (var i in n = {}, e.metrics) n[i] = toCamelCase(e.metrics[i]);
    this.compile({
      loss: t,
      metrics: n,
      optimizer: r
    });
  }, t.prototype.save = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n, r, i, a, o, s, l, u, c, p, h, d, f, g;
      return __generator(this, function (m) {
        switch (m.label) {
          case 0:
            if ("string" == typeof e) {
              if (0 === (n = _tfjsCore.io.getSaveHandlers(e)).length) throw new ValueError("Cannot find any save handlers for URL '" + e + "'");
              if (n.length > 1) throw new ValueError("Found more than one (" + n.length + ") save handlers for URL '" + e + "'");
              e = n[0];
            }

            if (null == e.save) throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
            return [4, _tfjsCore.io.encodeWeights(this.getNamedWeights(t))];

          case 1:
            return r = m.sent(), i = !1, a = null, o = this.toJSON(a, i), s = {
              modelTopology: o,
              format: LAYERS_MODEL_FORMAT_NAME,
              generatedBy: "TensorFlow.js tfjs-layers v" + version,
              convertedBy: null
            }, null != t && t.includeOptimizer && null != this.optimizer ? (s.trainingConfig = this.getTrainingConfig(), l = "optimizer", d = (h = _tfjsCore.io).encodeWeights, [4, this.optimizer.getWeights()]) : [3, 4];

          case 2:
            return [4, d.apply(h, [m.sent(), l])];

          case 3:
            u = m.sent(), c = u.data, p = u.specs, (g = r.specs).push.apply(g, p), r.data = _tfjsCore.io.concatenateArrayBuffers([r.data, c]), m.label = 4;

          case 4:
            return null != this.userDefinedMetadata && (f = !0, checkUserDefinedMetadata(this.userDefinedMetadata, this.name, f), s.userDefinedMetadata = this.userDefinedMetadata), s.weightData = r.data, s.weightSpecs = r.specs, [2, e.save(s)];
        }
      });
    });
  }, t.prototype.setUserDefinedMetadata = function (e) {
    checkUserDefinedMetadata(e, this.name), this.userDefinedMetadata = e;
  }, t.prototype.getUserDefinedMetadata = function () {
    return this.userDefinedMetadata;
  }, t.className = "Model", t;
}(Container);

exports.LayersModel = LayersModel;

function modelFromJSON(e, t) {
  return __awaiter(this, void 0, void 0, function () {
    var n, r, i, a, o, s, l, u;
    return __generator(this, function (c) {
      switch (c.label) {
        case 0:
          return "modelTopology" in e || (e = {
            modelTopology: e
          }), null != (n = (e = e).modelTopology).model_config && (n = n.model_config), r = convertPythonicToTs(n), i = deserialize(r, t), null == e.weightsManifest ? [3, 2] : [4, _tfjsCore.io.loadWeights(e.weightsManifest, e.pathPrefix, i.weights.map(function (e) {
            return e.originalName;
          }))];

        case 1:
          for (a = c.sent(), o = {}, s = 0, l = i.weights; s < l.length; s++) u = l[s], o[u.originalName] = a[u.originalName];

          i.loadWeights(o), (0, _tfjsCore.dispose)(a), c.label = 2;

        case 2:
          return [2, i];
      }
    });
  });
}

function loadLayersModelInternal(e, t) {
  return __awaiter(this, void 0, void 0, function () {
    var n;
    return __generator(this, function (r) {
      if (null == t && (t = {}), "string" == typeof e) {
        if (0 === (n = _tfjsCore.io.getLoadHandlers(e, t.onProgress)).length) n.push(_tfjsCore.io.browserHTTPRequest(e, t));else if (n.length > 1) throw new ValueError("Found more than one (" + n.length + ") load handlers for URL '" + e + "'");
        e = n[0];
      }

      return [2, loadLayersModelFromIOHandler(e, void 0, t)];
    });
  });
}

function loadLayersModelFromIOHandler(e, t, n) {
  return __awaiter(this, void 0, void 0, function () {
    var r, i, a, o, s, l, u, c, p;
    return __generator(this, function (h) {
      switch (h.label) {
        case 0:
          if (null == n && (n = {}), null == e.load) throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
          return [4, e.load()];

        case 1:
          if (r = h.sent(), null != (i = r.modelTopology).model_config && (i = i.model_config), a = null == n.strict || n.strict, o = null != r.weightData && null != r.weightSpecs && a, s = deserialize(convertPythonicToTs(i), t, o), null != (l = r.trainingConfig) && s.loadTrainingConfig(l), null != r.userDefinedMetadata && s.setUserDefinedMetadata(r.userDefinedMetadata), null == r.weightData) return [3, 4];
          if (null == r.weightSpecs) throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
          return u = decodeModelAndOptimizerWeights(r.weightData, r.weightSpecs), c = u.modelWeights, p = u.optimizerWeights, s.loadWeights(c, a), null != s.optimizer && p.length > 0 ? [4, s.optimizer.setWeights(p)] : [3, 3];

        case 2:
          h.sent(), h.label = 3;

        case 3:
          (0, _tfjsCore.dispose)(c), (0, _tfjsCore.dispose)(p.map(function (e) {
            return e.tensor;
          })), h.label = 4;

        case 4:
          return [2, s];
      }
    });
  });
}

function decodeModelAndOptimizerWeights(e, t) {
  var n = _tfjsCore.io.decodeWeights(e, t),
      r = {},
      i = [];

  return t.forEach(function (e) {
    "optimizer" === e.group ? i.push({
      name: e.name,
      tensor: n[e.name]
    }) : r[e.name] = n[e.name];
  }), {
    modelWeights: r,
    optimizerWeights: i
  };
}

_tfjsCore.serialization.registerClass(LayersModel);

var Sequential = function (e) {
  function t(t) {
    var n = e.call(this, {
      inputs: [],
      outputs: []
    }) || this;
    if (t = t || {}, n.trainable = !0, n.built = !1, n.name = null != t.name ? t.name : getUid("sequential_"), null != t.layers) for (var r = 0, i = t.layers; r < i.length; r++) {
      var a = i[r];
      n.add(a);
    }
    return n;
  }

  return __extends(t, e), t.prototype.checkShape = function (e) {
    if (e.inboundNodes[0].outputTensors[0].shape.some(function (e) {
      return e < 0;
    })) throw new ValueError("Negative dimension size caused by adding layer " + e.name + " with input shape [" + e.inboundNodes[0].inputTensors[0].shape + "]");
  }, t.prototype.add = function (e) {
    var n,
        r = e instanceof t || e instanceof LayersModel;

    if (r) {
      if (1 !== (n = e).outputs.length) throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      if (1 !== n.inputs.length) throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
    }

    if (0 === this.outputs.length) {
      if (0 === e.inboundNodes.length) {
        if (null == e.batchInputShape) throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
        var i = Input({
          batchShape: e.batchInputShape,
          dtype: e.dtype,
          name: e.name + "_input"
        });
        e.apply(i);
      }

      if (r) this.outputs = n.outputs, this.inputs = n.inputs;else {
        if (1 !== e.inboundNodes.length) throw new ValueError("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer " + e.name + " which has " + e.inboundNodes.length + " pre-existing inbound connections.");
        if (1 !== e.inboundNodes[0].outputTensors.length) throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = getSourceInputs(this.outputs[0]);
      }
      this.inboundNodes = [], new Node({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: pyListRepeat(null, this.inputs.length),
        outputMasks: [null],
        inputShapes: this.inputs.map(function (e) {
          return e.shape;
        }),
        outputShapes: this.outputs[0].shape
      });
    } else {
      var a = e.apply(this.outputs[0]);
      if (Array.isArray(a)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      this.checkShape(e), this.outputs = [a], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }

    this.layers.push(e), this.built = !1;
  }, t.prototype.pop = function () {
    if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
    if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];else {
      var e = this.layers.length - 1;
      this.layers[e].outboundNodes = [], this.outputs = [this.layers[e].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
  }, t.prototype.call = function (e, t) {
    return null == this.model && this.build(), this.model.call(e, t);
  }, t.prototype.build = function (e) {
    if (getExactlyOneShape(e), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
    this.model = new LayersModel({
      inputs: this.inputs,
      outputs: this.outputs[0],
      name: this.name + "_model"
    }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0;
  }, t.prototype.countParams = function () {
    return this.built || this.build(), e.prototype.countParams.call(this);
  }, t.prototype.summary = function (t, n, r) {
    void 0 === r && (r = console.log), this.built || this.build(), e.prototype.summary.call(this, t, n, r);
  }, t.prototype.setWeights = function (e) {
    null == this.model && this.build(), this.model.setWeights(e);
  }, t.prototype.evaluate = function (e, t, n) {
    if (void 0 === n && (n = {}), !this.built) throw new RuntimeError("The model needs to be compiled before being used.");
    return this.model.evaluate(e, t, n);
  }, t.prototype.evaluateDataset = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        if (!this.built) throw new RuntimeError("The model needs to be compiled before being used.");
        return [2, this.model.evaluateDataset(e, t)];
      });
    });
  }, t.prototype.predict = function (e, t) {
    return void 0 === t && (t = {}), null == this.model && this.build(), this.model.predict(e, t);
  }, t.prototype.predictOnBatch = function (e) {
    return null == this.model && this.build(), this.model.predictOnBatch(e);
  }, t.prototype.compile = function (e) {
    this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
  }, Object.defineProperty(t.prototype, "optimizer", {
    get: function () {
      return null == this.model ? void 0 : this.model.optimizer;
    },
    set: function (e) {
      this.model.optimizer = e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.fit = function (e, t, n) {
    return void 0 === n && (n = {}), __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (r) {
        if (!this.built) throw new RuntimeError("The model needs to be compiled before being used.");
        return [2, this.model.fit(e, t, n)];
      });
    });
  }, t.prototype.fitDataset = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        if (!this.built) throw new RuntimeError("The model needs to be compiled before being used.");
        return [2, this.model.fitDataset(e, t)];
      });
    });
  }, t.prototype.trainOnBatch = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (n) {
        return [2, this.model.trainOnBatch(e, t)];
      });
    });
  }, t.fromConfig = function (e, n, r, i) {
    var a;
    void 0 === r && (r = {}), void 0 === i && (i = !1);
    var o = {};

    if (n instanceof Array) {
      if (null == n[0].className || "Merge" === n[0].className) throw new ValueError("Legacy serialization format not supported yet.");
      a = n;
    } else _tfjsCore.util.assert(null != n.layers, function () {
      return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.";
    }), a = n.layers, delete n.layers, o = n;

    var s = new e(o);
    if (!(s instanceof t)) throw new NotImplementedError("Sequential.fromConfig called on non-Sequential input: " + s);

    for (var l = 0, u = a; l < u.length; l++) {
      var c = deserialize(u[l], void 0, i);
      i && c.setFastWeightInitDuringBuild(!0), s.add(c);
    }

    return s;
  }, Object.defineProperty(t.prototype, "stopTraining", {
    get: function () {
      if (null == this.model) throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");
      return this.model.stopTraining;
    },
    set: function (e) {
      if (null == this.model) throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");
      this.model.stopTraining = e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getConfig = function () {
    for (var e = [], t = 0, n = this.layers; t < n.length; t++) {
      var r = n[t],
          i = {};
      i.className = r.getClassName(), i.config = r.getConfig(), e.push(i);
    }

    return {
      name: this.name,
      layers: e
    };
  }, t.className = "Sequential", t;
}(LayersModel);

exports.Sequential = Sequential;

function model(e) {
  return new LayersModel(e);
}

function sequential(e) {
  return new Sequential(e);
}

function loadLayersModel(e, t) {
  return null == t && (t = {}), loadLayersModelInternal(e, t);
}

function input(e) {
  return Input(e);
}

function registerCallbackConstructor(e, t) {
  CallbackConstructorRegistry.registerCallbackConstructor(e, t);
}

_tfjsCore.serialization.registerClass(Sequential);

var Activation = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    return {};
  }, t;
}(_tfjsCore.serialization.Serializable),
    Elu = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return void 0 === t && (t = 1), elu$1(e, t);
  }, t.className = "elu", t;
}(Activation);

_tfjsCore.serialization.registerClass(Elu);

var Selu = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.selu)(e);
  }, t.className = "selu", t;
}(Activation);

_tfjsCore.serialization.registerClass(Selu);

var Relu = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.relu)(e);
  }, t.className = "relu", t;
}(Activation);

_tfjsCore.serialization.registerClass(Relu);

var Relu6 = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      return (0, _tfjsCore.minimum)(6, (0, _tfjsCore.relu)(e));
    });
  }, t.className = "relu6", t;
}(Activation);

_tfjsCore.serialization.registerClass(Relu6);

var Linear = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return e;
  }, t.className = "linear", t;
}(Activation);

_tfjsCore.serialization.registerClass(Linear);

var Sigmoid = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.sigmoid)(e);
  }, t.className = "sigmoid", t;
}(Activation);

_tfjsCore.serialization.registerClass(Sigmoid);

var HardSigmoid = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return hardSigmoid(e);
  }, t.className = "hardSigmoid", t;
}(Activation);

_tfjsCore.serialization.registerClass(HardSigmoid);

var Softplus = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.softplus)(e);
  }, t.className = "softplus", t;
}(Activation);

_tfjsCore.serialization.registerClass(Softplus);

var Softsign = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return softsign(e);
  }, t.className = "softsign", t;
}(Activation);

_tfjsCore.serialization.registerClass(Softsign);

var Tanh = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    return (0, _tfjsCore.tanh)(e);
  }, t.className = "tanh", t;
}(Activation);

_tfjsCore.serialization.registerClass(Tanh);

var Softmax = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return void 0 === t && (t = -1), (0, _tfjsCore.softmax)(e, t);
  }, t.className = "softmax", t;
}(Activation);

_tfjsCore.serialization.registerClass(Softmax);

var LogSoftmax = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.apply = function (e, t) {
    return void 0 === t && (t = -1), (0, _tfjsCore.logSoftmax)(e, t);
  }, t.className = "logSoftmax", t;
}(Activation);

function serializeActivation(e) {
  return e.getClassName();
}

function deserializeActivation(e, t) {
  return void 0 === t && (t = {}), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "activation");
}

function getActivation(e) {
  var t;
  return null == e ? deserializeActivation(t = {
    className: "linear",
    config: {}
  }) : "string" == typeof e ? ((t = {}).className = e, t.config = {}, deserializeActivation(t)) : e instanceof Activation ? e : deserializeActivation(e);
}

function assertObjectArgs(e) {
  if (null != e && "object" != typeof e) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: " + e);
}

_tfjsCore.serialization.registerClass(LogSoftmax);

var Regularizer = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t;
}(_tfjsCore.serialization.Serializable),
    L1L2 = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    return assertObjectArgs(t), n.l1 = null == t || null == t.l1 ? .01 : t.l1, n.l2 = null == t || null == t.l2 ? .01 : t.l2, n.hasL1 = 0 !== n.l1, n.hasL2 = 0 !== n.l2, n;
  }

  return __extends(t, e), t.prototype.apply = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      var n = (0, _tfjsCore.zeros)([1]);
      return t.hasL1 && (n = (0, _tfjsCore.add)(n, (0, _tfjsCore.sum)((0, _tfjsCore.mul)(t.l1, (0, _tfjsCore.abs)(e))))), t.hasL2 && (n = (0, _tfjsCore.add)(n, (0, _tfjsCore.sum)((0, _tfjsCore.mul)(t.l2, square(e))))), n.asScalar();
    });
  }, t.prototype.getConfig = function () {
    return {
      l1: this.l1,
      l2: this.l2
    };
  }, t.fromConfig = function (e, t) {
    return new e({
      l1: t.l1,
      l2: t.l2
    });
  }, t.className = "L1L2", t;
}(Regularizer);

function l1(e) {
  return assertObjectArgs(e), new L1L2({
    l1: null != e ? e.l1 : null,
    l2: 0
  });
}

function l2(e) {
  return assertObjectArgs(e), new L1L2({
    l2: null != e ? e.l2 : null,
    l1: 0
  });
}

_tfjsCore.serialization.registerClass(L1L2);

var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
  l1l2: "L1L2"
};

function serializeRegularizer(e) {
  return serializeKerasObject(e);
}

function deserializeRegularizer(e, t) {
  return void 0 === t && (t = {}), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "regularizer");
}

function getRegularizer(e) {
  return null == e ? null : "string" == typeof e ? deserializeRegularizer({
    className: e in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e] : e,
    config: {}
  }) : e instanceof Regularizer ? e : deserializeRegularizer(e);
}

var ReLU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.supportsMasking = !0, null != t && (n.maxValue = t.maxValue), n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    e = getExactlyOneTensor(e);
    var n = (0, _tfjsCore.relu)(e);
    return null != this.maxValue && (n = (0, _tfjsCore.clipByValue)(n, 0, this.maxValue)), n;
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      maxValue: this.maxValue
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "ReLU", t;
}(Layer);

_tfjsCore.serialization.registerClass(ReLU);

var LeakyReLU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.DEFAULT_ALPHA = .3, null == t && (t = {}), n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha, n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = getExactlyOneTensor(e);
    return (0, _tfjsCore.leakyRelu)(n, this.alpha);
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      alpha: this.alpha
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "LeakyReLU", t;
}(Layer);

_tfjsCore.serialization.registerClass(LeakyReLU);

var PReLU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    if (n.DEFAULT_ALPHA_INITIALIZER = "zeros", null == t && (t = {}), n.supportsMasking = !0, n.alphaInitializer = getInitializer(t.alphaInitializer || n.DEFAULT_ALPHA_INITIALIZER), n.alphaRegularizer = getRegularizer(t.alphaRegularizer), n.alphaConstraint = getConstraint(t.alphaConstraint), null == t.sharedAxes) n.sharedAxes = null;else if (Array.isArray(t.sharedAxes)) n.sharedAxes = t.sharedAxes;else {
      if ("number" != typeof t.sharedAxes) throw new ValueError("Expected sharedAxes to be a number or an array of numbers, but got " + t.sharedAxes);
      n.sharedAxes = [t.sharedAxes];
    }
    return n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t = (e = getExactlyOneShape(e)).slice(1);
    if (null != this.sharedAxes) for (var n = 0, r = this.sharedAxes; n < r.length; n++) {
      t[(a = r[n]) - 1] = 1;
    }
    this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
    var i = {};
    if (null != this.sharedAxes) for (var a = 1; a < e.length; ++a) i[a] = e[a];
    this.inputSpec = [new InputSpec({
      ndim: e.length,
      axes: i
    })], this.built = !0;
  }, t.prototype.call = function (e, t) {
    return e = getExactlyOneTensor(e), (0, _tfjsCore.prelu)(e, this.alpha.read());
  }, t.prototype.getConfig = function () {
    var t = {
      alphaInitializer: serializeInitializer(this.alphaInitializer),
      alphaRegularizer: serializeRegularizer(this.alphaRegularizer),
      alphaConstraint: serializeConstraint(this.alphaConstraint),
      sharedAxes: this.sharedAxes
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "PReLU", t;
}(Layer);

_tfjsCore.serialization.registerClass(PReLU);

var ELU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    if (n.DEFAULT_ALPHA = 1, null == t && (t = {}), null != t.alpha && t.alpha !== n.DEFAULT_ALPHA) throw new NotImplementedError("Non-default alpha value (" + t.alpha + ") is not supported by the ELU layer yet.");
    return n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha, n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = getExactlyOneTensor(e);
    return (0, _tfjsCore.elu)(n);
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      alpha: this.alpha
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "ELU", t;
}(Layer);

_tfjsCore.serialization.registerClass(ELU);

var ThresholdedReLU = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.DEFAULT_THETA = 1, null == t && (t = {}), n.theta = null == t.theta ? n.DEFAULT_THETA : t.theta, n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = getExactlyOneTensor(e);
    return n.mul(cast$1(n.greater(this.theta), "float32"));
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      theta: this.theta
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "ThresholdedReLU", t;
}(Layer);

_tfjsCore.serialization.registerClass(ThresholdedReLU);

var Softmax$1 = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.DEFAULT_AXIS = 1, null == t && (t = {}), n.softmax = new Softmax().apply, n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis, n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = getExactlyOneTensor(e);
    return this.softmax(n, this.axis);
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = {
      axis: this.axis
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Softmax", t;
}(Layer);

function normalizeArray(e, t, n) {
  if ("number" == typeof e) return pyListRepeat(e, t);
  if (e.length !== t) throw new ValueError("The " + n + " argument must be an integer or tuple of " + t + " integers. Received: " + e.length + " elements.");

  for (var r = 0; r < t; ++r) {
    var i = e[r];
    if (!isInteger(i)) throw new ValueError("The " + n + " argument must be an integer or tuple of " + t + " integers. Received: " + JSON.stringify(e) + " including a non-integer number " + i);
  }

  return e;
}

function convOutputLength(e, t, n, r, i) {
  return void 0 === i && (i = 1), null == e ? e : (a = "same" === n ? e : e - (t + (t - 1) * (i - 1)) + 1, Math.floor((a + r - 1) / r));
  var a;
}

function deconvLength(e, t, n, r) {
  if (null == e) return null;
  if ("valid" === r) e = e * t + max$1([n - t, 0]);else {
    if ("same" !== r) throw new ValueError("Unsupport padding mode: " + r + ".");
    e *= t;
  }
  return e;
}

function preprocessConv2DInput(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return checkDataFormat(t), "channelsFirst" === t ? (0, _tfjsCore.transpose)(e, [0, 2, 3, 1]) : e;
  });
}

function preprocessConv3DInput(e, t) {
  return (0, _tfjsCore.tidy)(function () {
    return checkDataFormat(t), "channelsFirst" === t ? (0, _tfjsCore.transpose)(e, [0, 2, 3, 4, 1]) : e;
  });
}

function conv1dWithBias(e, t, n, r, i, a, o) {
  return void 0 === r && (r = 1), void 0 === i && (i = "valid"), void 0 === o && (o = 1), (0, _tfjsCore.tidy)(function () {
    if (null == a && (a = imageDataFormat()), checkDataFormat(a), 3 !== e.shape.length) throw new ValueError("The input of a conv1dWithBias operation should be 3, but is " + e.shape.length + " instead.");
    if (3 !== t.shape.length) throw new ValueError("The kernel for a conv1dWithBias operation should be 3, but is " + t.shape.length + " instead");
    if (null != n && 1 !== n.shape.length) throw new ValueError("The bias for a conv1dWithBias operation should be 1, but is " + t.shape.length + " instead");
    if ("channelsFirst" === a && (e = (0, _tfjsCore.transpose)(e, [0, 2, 1])), "causal" === i) throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    var s = (0, _tfjsCore.conv1d)(e, t, r, "same" === i ? "same" : "valid", "NWC", o);
    return null != n && (s = biasAdd(s, n)), s;
  });
}

function conv2dWithBiasActivation(e, t, n, r, i, a, o, s) {
  return void 0 === r && (r = [1, 1]), void 0 === i && (i = "valid"), void 0 === s && (s = null), (0, _tfjsCore.tidy)(function () {
    if (null == a && (a = imageDataFormat()), checkDataFormat(a), 3 !== e.rank && 4 !== e.rank) throw new ValueError("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received " + e.rank + ".");
    if (3 !== t.rank && 4 !== t.rank) throw new ValueError("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received " + e.rank + ".");
    var l = preprocessConv2DInput(e, a);
    if ("causal" === i) throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    return l = _tfjsCore.fused.conv2d({
      x: l,
      filter: t,
      strides: r,
      pad: "same" === i ? "same" : "valid",
      dilations: o,
      dataFormat: "NHWC",
      bias: n,
      activation: s
    }), "channelsFirst" === a && (l = (0, _tfjsCore.transpose)(l, [0, 3, 1, 2])), l;
  });
}

function conv3dWithBias(e, t, n, r, i, a, o) {
  return void 0 === r && (r = [1, 1, 1]), void 0 === i && (i = "valid"), (0, _tfjsCore.tidy)(function () {
    if (null == a && (a = imageDataFormat()), checkDataFormat(a), 4 !== e.rank && 5 !== e.rank) throw new ValueError("conv3dWithBias expects input to be of rank 4 or 5, but received " + e.rank + ".");
    if (4 !== t.rank && 5 !== t.rank) throw new ValueError("conv3dWithBias expects kernel to be of rank 4 or 5, but received " + e.rank + ".");
    var s = preprocessConv3DInput(e, a);
    if ("causal" === i) throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
    return s = (0, _tfjsCore.conv3d)(s, t, r, "same" === i ? "same" : "valid", "NDHWC", o), null != n && (s = biasAdd(s, n)), "channelsFirst" === a && (s = (0, _tfjsCore.transpose)(s, [0, 4, 1, 2, 3])), s;
  });
}

_tfjsCore.serialization.registerClass(Softmax$1);

var BaseConv = function (e) {
  function t(n, r) {
    var i = e.call(this, r) || this;
    if (i.bias = null, i.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", i.DEFAULT_BIAS_INITIALIZER = "zeros", t.verifyArgs(r), i.rank = n, assertPositiveInteger(i.rank, "rank"), 1 !== i.rank && 2 !== i.rank && 3 !== i.rank) throw new NotImplementedError("Convolution layer for rank other than 1, 2, or 3 (" + i.rank + ") is not implemented yet.");
    if (i.kernelSize = normalizeArray(r.kernelSize, n, "kernelSize"), i.strides = normalizeArray(null == r.strides ? 1 : r.strides, n, "strides"), i.padding = null == r.padding ? "valid" : r.padding, checkPaddingMode(i.padding), i.dataFormat = null == r.dataFormat ? "channelsLast" : r.dataFormat, checkDataFormat(i.dataFormat), i.activation = getActivation(r.activation), i.useBias = null == r.useBias || r.useBias, i.biasInitializer = getInitializer(r.biasInitializer || i.DEFAULT_BIAS_INITIALIZER), i.biasConstraint = getConstraint(r.biasConstraint), i.biasRegularizer = getRegularizer(r.biasRegularizer), i.activityRegularizer = getRegularizer(r.activityRegularizer), i.dilationRate = normalizeArray(null == r.dilationRate ? 1 : r.dilationRate, n, "dilationRate"), 1 === i.rank && Array.isArray(i.dilationRate) && 1 !== i.dilationRate.length) throw new ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received " + JSON.stringify(i.dilationRate));

    if (2 === i.rank) {
      if ("number" == typeof i.dilationRate) i.dilationRate = [i.dilationRate, i.dilationRate];else if (2 !== i.dilationRate.length) throw new ValueError("dilationRate must be a number or array of two numbers for 2D convolution, but received " + JSON.stringify(i.dilationRate));
    } else if (3 === i.rank) if ("number" == typeof i.dilationRate) i.dilationRate = [i.dilationRate, i.dilationRate, i.dilationRate];else if (3 !== i.dilationRate.length) throw new ValueError("dilationRate must be a number or array of three numbers for 3D convolution, but received " + JSON.stringify(i.dilationRate));

    return i;
  }

  return __extends(t, e), t.verifyArgs = function (e) {
    if (assert("kernelSize" in e, "required key 'kernelSize' not in config"), "number" != typeof e.kernelSize && !checkArrayTypeAndLength(e.kernelSize, "number", 1, 3)) throw new ValueError("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received " + JSON.stringify(e.kernelSize) + ".");
  }, t.prototype.getConfig = function () {
    var t = {
      kernelSize: this.kernelSize,
      strides: this.strides,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      biasInitializer: serializeInitializer(this.biasInitializer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      biasConstraint: serializeConstraint(this.biasConstraint)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    Conv = function (e) {
  function t(n, r) {
    var i = e.call(this, n, r) || this;
    return i.kernel = null, t.verifyArgs(r), i.filters = r.filters, assertPositiveInteger(i.filters, "filters"), i.kernelInitializer = getInitializer(r.kernelInitializer || i.DEFAULT_KERNEL_INITIALIZER), i.kernelConstraint = getConstraint(r.kernelConstraint), i.kernelRegularizer = getRegularizer(r.kernelRegularizer), i;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t;
    e = getExactlyOneShape(e);
    var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[n]) throw new ValueError("The channel dimension of the input should be defined. Found " + e[n]);
    var r = e[n],
        i = this.kernelSize.concat([r, this.filters]);
    this.kernel = this.addWeight("kernel", i, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
      ndim: this.rank + 2,
      axes: (t = {}, t[n] = r, t)
    }], this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t;
      e = getExactlyOneTensor(e);
      var r = null == n.bias ? null : n.bias.read(),
          i = mapActivationToFusedKernel(n.activation.getClassName());
      if (null != i && 2 === n.rank) t = conv2dWithBiasActivation(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate, i);else {
        if (1 === n.rank) t = conv1dWithBias(e, n.kernel.read(), r, n.strides[0], n.padding, n.dataFormat, n.dilationRate[0]);else if (2 === n.rank) t = conv2dWithBiasActivation(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);else {
          if (3 !== n.rank) throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");
          t = conv3dWithBias(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
        }
        null != n.activation && (t = n.activation.apply(t));
      }
      return t;
    });
  }, t.prototype.computeOutputShape = function (e) {
    e = getExactlyOneShape(e);

    for (var t = [], n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2), r = 0; r < n.length; ++r) {
      var i = convOutputLength(n[r], this.kernelSize[r], this.padding, this.strides[r], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r]);
      t.push(i);
    }

    var a = [e[0]];
    return "channelsLast" === this.dataFormat ? (a = a.concat(t)).push(this.filters) : (a.push(this.filters), a = a.concat(t)), a;
  }, t.prototype.getConfig = function () {
    var t = {
      filters: this.filters,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.verifyArgs = function (e) {
    if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1) throw new ValueError("Convolution layer expected config.filters to be a 'number' > 0 but got " + JSON.stringify(e.filters));
  }, t;
}(BaseConv),
    Conv2D = function (e) {
  function t(n) {
    var r = e.call(this, 2, n) || this;
    return t.verifyArgs(n), r;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.rank, t;
  }, t.verifyArgs = function (e) {
    if ("number" != typeof e.kernelSize && !checkArrayTypeAndLength(e.kernelSize, "number", 1, 2)) throw new ValueError("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received " + JSON.stringify(e.kernelSize) + ".");
  }, t.className = "Conv2D", t;
}(Conv);

_tfjsCore.serialization.registerClass(Conv2D);

var Conv3D = function (e) {
  function t(n) {
    var r = e.call(this, 3, n) || this;
    return t.verifyArgs(n), r;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.rank, t;
  }, t.verifyArgs = function (e) {
    if ("number" != typeof e.kernelSize && (!Array.isArray(e.kernelSize) || 1 !== e.kernelSize.length && 3 !== e.kernelSize.length)) throw new ValueError("Conv3D expects config.kernelSize to be number or [number, number, number], but received " + JSON.stringify(e.kernelSize) + ".");
  }, t.className = "Conv3D", t;
}(Conv);

_tfjsCore.serialization.registerClass(Conv3D);

var Conv2DTranspose = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    if (n.inputSpec = [new InputSpec({
      ndim: 4
    })], "same" !== n.padding && "valid" !== n.padding) throw new ValueError("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " + n.padding);
    return n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t;
    if (4 !== (e = getExactlyOneShape(e)).length) throw new ValueError("Input should have rank 4; Received input shape: " + JSON.stringify(e));
    var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[n]) throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");
    var r = e[n],
        i = this.kernelSize.concat([this.filters, r]);
    this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new InputSpec({
      ndim: 4,
      axes: (t = {}, t[n] = r, t)
    })], this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      if (4 !== t.shape.length) throw new ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" + t.shape.length);
      var r,
          i,
          a = t.shape,
          o = a[0];
      "channelsFirst" === n.dataFormat ? (r = 2, i = 3) : (r = 1, i = 2);
      var s = a[r],
          l = a[i],
          u = n.kernelSize[0],
          c = n.kernelSize[1],
          p = n.strides[0],
          h = n.strides[1],
          d = [o, deconvLength(s, p, u, n.padding), deconvLength(l, h, c, n.padding), n.filters];
      "channelsLast" !== n.dataFormat && (t = (0, _tfjsCore.transpose)(t, [0, 2, 3, 1]));
      var f = (0, _tfjsCore.conv2dTranspose)(t, n.kernel.read(), d, n.strides, n.padding);
      return "channelsLast" !== n.dataFormat && (f = (0, _tfjsCore.transpose)(f, [0, 3, 1, 2])), null != n.bias && (f = biasAdd(f, n.bias.read(), n.dataFormat)), null != n.activation && (f = n.activation.apply(f)), f;
    });
  }, t.prototype.computeOutputShape = function (e) {
    var t,
        n,
        r,
        i = (e = getExactlyOneShape(e)).slice();
    "channelsFirst" === this.dataFormat ? (t = 1, n = 2, r = 3) : (t = 3, n = 1, r = 2);
    var a = this.kernelSize[0],
        o = this.kernelSize[1],
        s = this.strides[0],
        l = this.strides[1];
    return i[t] = this.filters, i[n] = deconvLength(i[n], s, a, this.padding), i[r] = deconvLength(i[r], l, o, this.padding), i;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.dilationRate, t;
  }, t.className = "Conv2DTranspose", t;
}(Conv2D);

_tfjsCore.serialization.registerClass(Conv2DTranspose);

var SeparableConv = function (e) {
  function t(t, n) {
    var r = e.call(this, t, n) || this;
    if (r.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", r.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", r.depthwiseKernel = null, r.pointwiseKernel = null, null == n.filters) throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");
    if (null != n.kernelInitializer || null != n.kernelRegularizer || null != n.kernelConstraint) throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
    if (null != n.padding && "same" !== n.padding && "valid" !== n.padding) throw new ValueError("SeparableConv" + r.rank + "D supports only padding modes: 'same' and 'valid', but received " + JSON.stringify(n.padding));
    return r.depthMultiplier = null == n.depthMultiplier ? 1 : n.depthMultiplier, r.depthwiseInitializer = getInitializer(n.depthwiseInitializer || r.DEFAULT_DEPTHWISE_INITIALIZER), r.depthwiseRegularizer = getRegularizer(n.depthwiseRegularizer), r.depthwiseConstraint = getConstraint(n.depthwiseConstraint), r.pointwiseInitializer = getInitializer(n.depthwiseInitializer || r.DEFAULT_POINTWISE_INITIALIZER), r.pointwiseRegularizer = getRegularizer(n.pointwiseRegularizer), r.pointwiseConstraint = getConstraint(n.pointwiseConstraint), r;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t;
    if ((e = getExactlyOneShape(e)).length < this.rank + 2) throw new ValueError("Inputs to SeparableConv" + this.rank + "D should have rank " + (this.rank + 2) + ", but received input shape: " + JSON.stringify(e));
    var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[n] || e[n] < 0) throw new ValueError("The channel dimension of the inputs should be defined, but found " + JSON.stringify(e[n]));

    for (var r = e[n], i = this.kernelSize.concat([r, this.depthMultiplier]), a = [], o = 0; o < this.rank; ++o) a.push(1);

    a.push(r * this.depthMultiplier, this.filters);
    this.depthwiseKernel = this.addWeight("depthwise_kernel", i, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", a, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, !0, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.inputSpec = [new InputSpec({
      ndim: this.rank + 2,
      axes: (t = {}, t[n] = r, t)
    })], this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t;
      if (e = getExactlyOneTensor(e), 1 === n.rank) throw new NotImplementedError("1D separable convolution is not implemented yet.");
      return 2 === n.rank && ("channelsFirst" === n.dataFormat && (e = (0, _tfjsCore.transpose)(e, [0, 2, 3, 1])), t = (0, _tfjsCore.separableConv2d)(e, n.depthwiseKernel.read(), n.pointwiseKernel.read(), n.strides, n.padding, n.dilationRate, "NHWC")), n.useBias && (t = biasAdd(t, n.bias.read(), n.dataFormat)), null != n.activation && (t = n.activation.apply(t)), "channelsFirst" === n.dataFormat && (t = (0, _tfjsCore.transpose)(t, [0, 3, 1, 2])), t;
    });
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.rank, delete t.kernelInitializer, delete t.kernelRegularizer, delete t.kernelConstraint, t.depthwiseInitializer = serializeInitializer(this.depthwiseInitializer), t.pointwiseInitializer = serializeInitializer(this.pointwiseInitializer), t.depthwiseRegularizer = serializeRegularizer(this.depthwiseRegularizer), t.pointwiseRegularizer = serializeRegularizer(this.pointwiseRegularizer), t.depthwiseConstraint = serializeConstraint(this.depthwiseConstraint), t.pointwiseConstraint = serializeConstraint(this.pointwiseConstraint), t;
  }, t.className = "SeparableConv", t;
}(Conv),
    SeparableConv2D = function (e) {
  function t(t) {
    return e.call(this, 2, t) || this;
  }

  return __extends(t, e), t.className = "SeparableConv2D", t;
}(SeparableConv);

_tfjsCore.serialization.registerClass(SeparableConv2D);

var Conv1D = function (e) {
  function t(n) {
    var r = e.call(this, 1, n) || this;
    return t.verifyArgs(n), r.inputSpec = [{
      ndim: 3
    }], r;
  }

  return __extends(t, e), t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return delete t.rank, delete t.dataFormat, t;
  }, t.verifyArgs = function (e) {
    if ("number" != typeof e.kernelSize && !checkArrayTypeAndLength(e.kernelSize, "number", 1, 1)) throw new ValueError("Conv1D expects config.kernelSize to be number or number[] with length 1, but received " + JSON.stringify(e.kernelSize) + ".");
  }, t.className = "Conv1D", t;
}(Conv);

_tfjsCore.serialization.registerClass(Conv1D);

var Cropping2D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return "number" == typeof t.cropping ? n.cropping = [[t.cropping, t.cropping], [t.cropping, t.cropping]] : "number" == typeof t.cropping[0] ? n.cropping = [[t.cropping[0], t.cropping[0]], [t.cropping[1], t.cropping[1]]] : n.cropping = t.cropping, n.dataFormat = void 0 === t.dataFormat ? "channelsLast" : t.dataFormat, n.inputSpec = [{
      ndim: 4
    }], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return "channelsFirst" === this.dataFormat ? [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]] : [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return e = getExactlyOneTensor(e), "channelsLast" === n.dataFormat ? sliceAlongAxis(sliceAlongAxis(e, n.cropping[0][0], e.shape[1] - n.cropping[0][0] - n.cropping[0][1], 2), n.cropping[1][0], e.shape[2] - n.cropping[1][1] - n.cropping[1][0], 3) : sliceAlongAxis(sliceAlongAxis(e, n.cropping[0][0], e.shape[2] - n.cropping[0][0] - n.cropping[0][1], 3), n.cropping[1][0], e.shape[3] - n.cropping[1][1] - n.cropping[1][0], 4);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      cropping: this.cropping,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Cropping2D", t;
}(Layer);

_tfjsCore.serialization.registerClass(Cropping2D);

var UpSampling2D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_SIZE = [2, 2], n.inputSpec = [{
      ndim: 4
    }], n.size = null == t.size ? n.DEFAULT_SIZE : t.size, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    if ("channelsFirst" === this.dataFormat) {
      var t = null == e[2] ? null : this.size[0] * e[2],
          n = null == e[3] ? null : this.size[1] * e[3];
      return [e[0], e[1], t, n];
    }

    t = null == e[1] ? null : this.size[0] * e[1], n = null == e[2] ? null : this.size[1] * e[2];
    return [e[0], t, n, e[3]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e),
          r = t.shape;

      if ("channelsFirst" === n.dataFormat) {
        t = (0, _tfjsCore.transpose)(t, [0, 2, 3, 1]);
        var i = n.size[0] * r[2],
            a = n.size[1] * r[3],
            o = t.resizeNearestNeighbor([i, a]);
        return (0, _tfjsCore.transpose)(o, [0, 3, 1, 2]);
      }

      i = n.size[0] * r[1], a = n.size[1] * r[2];
      return t.resizeNearestNeighbor([i, a]);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      size: this.size,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "UpSampling2D", t;
}(Layer);

function depthwiseConv2d$1(e, t, n, r, i, a) {
  return void 0 === n && (n = [1, 1]), void 0 === r && (r = "valid"), (0, _tfjsCore.tidy)(function () {
    null == i && (i = imageDataFormat()), checkDataFormat(i);
    var o = preprocessConv2DInput(e, i);
    if (4 !== e.rank) throw new ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead " + e.rank + "-D");
    if (4 !== t.rank) throw new ValueError("depthwiseKernel is required to be 4-D, but is instead " + t.rank + "-D");
    return o = (0, _tfjsCore.depthwiseConv2d)(o, t, n, "same" === r ? "same" : "valid", "NHWC", a), "channelsFirst" === i && (o = (0, _tfjsCore.transpose)(o, [0, 3, 1, 2])), o;
  });
}

_tfjsCore.serialization.registerClass(UpSampling2D);

var DepthwiseConv2D = function (e) {
  function t(t) {
    var n = e.call(this, 2, t) || this;
    return n.depthwiseKernel = null, n.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier, n.depthwiseInitializer = getInitializer(t.depthwiseInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.depthwiseConstraint = getConstraint(t.depthwiseConstraint), n.depthwiseRegularizer = getRegularizer(t.depthwiseRegularizer), n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    if ((e = getExactlyOneShape(e)).length < 4) throw new ValueError("Inputs to DepthwiseConv2D should have rank 4. Received input shape: " + JSON.stringify(e) + ".");
    var t = "channelsFirst" === this.dataFormat ? 1 : 3;
    if (null == e[t] || e[t] < 0) throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (" + e[t] + ").");
    var n = e[t],
        r = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
    this.depthwiseKernel = this.addWeight("depthwise_kernel", r, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = depthwiseConv2d$1(e = getExactlyOneTensor(e), n.depthwiseKernel.read(), n.strides, n.padding, n.dataFormat, null);
      return n.useBias && (t = biasAdd(t, n.bias.read(), n.dataFormat)), null != n.activation && (t = n.activation.apply(t)), t;
    });
  }, t.prototype.computeOutputShape = function (e) {
    e = getExactlyOneShape(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
        r = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier,
        i = convOutputLength(t, this.kernelSize[0], this.padding, this.strides[0]),
        a = convOutputLength(n, this.kernelSize[1], this.padding, this.strides[1]);
    return "channelsFirst" === this.dataFormat ? [e[0], r, i, a] : [e[0], i, a, r];
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this);
    return t.depthMultiplier = this.depthMultiplier, t.depthwiseInitializer = serializeInitializer(this.depthwiseInitializer), t.depthwiseRegularizer = serializeRegularizer(this.depthwiseRegularizer), t.depthwiseConstraint = serializeConstraint(this.depthwiseRegularizer), t;
  }, t.className = "DepthwiseConv2D", t;
}(BaseConv);

_tfjsCore.serialization.registerClass(DepthwiseConv2D);

var Dropout = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.rate = Math.max(Math.min(t.rate, 1), 0), n.noiseShape = t.noiseShape, n.seed = t.seed, n.supportsMasking = !0, n;
  }

  return __extends(t, e), t.prototype.getNoiseShape = function (e) {
    if (null == this.noiseShape) return this.noiseShape;

    for (var t = e.shape, n = [], r = 0; r < this.noiseShape.length; ++r) n.push(null == this.noiseShape[r] ? t[r] : this.noiseShape[r]);

    return n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);

      if (0 < n.rate && n.rate < 1) {
        var i = null != t.training && t.training,
            a = n.getNoiseShape(r);
        return inTrainPhase(function () {
          return dropout$1(r, n.rate, a, n.seed);
        }, function () {
          return r;
        }, i);
      }

      return e;
    });
  }, t.prototype.getConfig = function () {
    var t = {
      rate: this.rate,
      noiseShape: this.noiseShape,
      seed: this.seed
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.prototype.dispose = function () {
    return e.prototype.dispose.call(this);
  }, t.className = "Dropout", t;
}(Layer);

_tfjsCore.serialization.registerClass(Dropout);

var SpatialDropout1D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.inputSpec = [{
      ndim: 3
    }], n;
  }

  return __extends(t, e), t.prototype.getNoiseShape = function (e) {
    var t = e.shape;
    return [t[0], 1, t[2]];
  }, t.className = "SpatialDropout1D", t;
}(Dropout);

_tfjsCore.serialization.registerClass(SpatialDropout1D);

var Dense = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;

    if (n.activation = null, n.useBias = !0, n.kernel = null, n.bias = null, n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_BIAS_INITIALIZER = "zeros", null == t.batchInputShape && null == t.inputShape && null != t.inputDim) {
      var r = null;
      null != t.batchSize && (r = t.batchSize), n.batchInputShape = [r, t.inputDim];
    }

    return n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(t.activation), null != t.useBias && (n.useBias = t.useBias), n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelConstraint = getConstraint(t.kernelConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.activityRegularizer = getRegularizer(t.activityRegularizer), n.supportsMasking = !0, n.inputSpec = [{
      minNDim: 2
    }], n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t,
        n = (e = getExactlyOneShape(e))[e.length - 1];
    null == this.kernel && (this.kernel = this.addWeight("kernel", [n, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
      minNDim: 2,
      axes: (t = {}, t[-1] = n, t)
    }], this.built = !0;
  }, t.prototype.computeOutputShape = function (e) {
    var t = (e = getExactlyOneShape(e)).slice();
    return t[t.length - 1] = this.units, t;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r,
          i = getExactlyOneTensor(e),
          a = mapActivationToFusedKernel(n.activation.getClassName());
      return null != a ? r = dot(i, n.kernel.read(), a, n.bias ? n.bias.read() : null) : (r = dot(i, n.kernel.read()), null != n.bias && (r = biasAdd(r, n.bias.read())), null != n.activation && (r = n.activation.apply(r))), r;
    });
  }, t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Dense", t;
}(Layer);

_tfjsCore.serialization.registerClass(Dense);

var Flatten = function (e) {
  function t(t) {
    var n = this;
    return t = t || {}, (n = e.call(this, t) || this).inputSpec = [{
      minNDim: 3
    }], n.dataFormat = t.dataFormat, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    for (var t = 0, n = (e = getExactlyOneShape(e)).slice(1); t < n.length; t++) {
      if (null == n[t]) throw new ValueError('The shape of the input to "Flatten" is not fully defined (got ' + e.slice(1) + '). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.');
    }

    return [e[0], arrayProd(e, 1)];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);

      if ("channelsFirst" === n.dataFormat && r.rank > 1) {
        for (var i = [0], a = 2; a < r.rank; ++a) i.push(a);

        i.push(1), r = r.transpose(i);
      }

      return batchFlatten(r);
    });
  }, t.prototype.getConfig = function () {
    var t = {};
    null != this.dataFormat && (t.dataFormat = this.dataFormat);
    var n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Flatten", t;
}(Layer);

_tfjsCore.serialization.registerClass(Flatten);

var Activation$1 = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n.activation = getActivation(t.activation), n;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);
      return n.activation.apply(r);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      activation: serializeActivation(this.activation)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Activation", t;
}(Layer);

_tfjsCore.serialization.registerClass(Activation$1);

var RepeatVector = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.n = t.n, n.inputSpec = [{
      ndim: 2
    }], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return [e[0], this.n, e[1]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return repeat(e = getExactlyOneTensor(e), n.n);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      n: this.n
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "RepeatVector", t;
}(Layer);

_tfjsCore.serialization.registerClass(RepeatVector);

var Reshape = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    n.targetShape = t.targetShape;

    for (var r = 0; r < n.targetShape.length; ++r) n.isUnknown(n.targetShape[r]) && (n.targetShape[r] = null);

    return n;
  }

  return __extends(t, e), t.prototype.isUnknown = function (e) {
    return e < 0 || null == e;
  }, t.prototype.fixUnknownDimension = function (e, t) {
    for (var n = "Total size of new array must be unchanged.", r = t.slice(), i = 1, a = null, o = 0; o < r.length; ++o) {
      var s = r[o];

      if (this.isUnknown(s)) {
        if (null !== a) throw new ValueError("Can only specifiy one unknown dimension.");
        a = o;
      } else i *= s;
    }

    var l = arrayProd(e);

    if (null !== a) {
      if (0 === i || l % i != 0) throw new ValueError(n);
      r[a] = l / i;
    } else if (l !== i) throw new ValueError(n);

    return r;
  }, t.prototype.computeOutputShape = function (e) {
    for (var t = !1, n = 0; n < e.length; ++n) if (this.isUnknown(e[n])) {
      t = !0;
      break;
    }

    return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e),
          i = r.shape,
          a = i.slice(0, 1).concat(n.fixUnknownDimension(i.slice(1), n.targetShape));
      return r.reshape(a);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      targetShape: this.targetShape
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Reshape", t;
}(Layer);

_tfjsCore.serialization.registerClass(Reshape);

var Permute = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    if (null == t.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
    if (!Array.isArray(t.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received " + t.dims + " instead.");
    var r = range(1, t.dims.length + 1);
    if (!_tfjsCore.util.arraysEqual(t.dims.slice().sort(), r)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(t.dims) + " `dims` must contain consecutive integers starting from 1.");
    return n.dims = t.dims, n.dimsIncludingBatch = [0].concat(n.dims), n.inputSpec = [new InputSpec({
      ndim: n.dims.length + 1
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    var t = (e = getExactlyOneShape(e)).slice();
    return this.dims.forEach(function (n, r) {
      t[r + 1] = e[n];
    }), t;
  }, t.prototype.call = function (e, t) {
    return (0, _tfjsCore.transpose)(getExactlyOneTensor(e), this.dimsIncludingBatch);
  }, t.prototype.getConfig = function () {
    var t = {
      dims: this.dims
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Permute", t;
}(Layer);

_tfjsCore.serialization.registerClass(Permute);

var Masking = function (e) {
  function t(t) {
    var n = e.call(this, null == t ? {} : t) || this;
    return n.supportsMasking = !0, n.maskValue = null != t ? null == t.maskValue ? 0 : t.maskValue : 0, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this),
        n = {
      maskValue: this.maskValue
    };
    return Object.assign(n, t), n;
  }, t.prototype.computeMask = function (e, t) {
    var n = getExactlyOneTensor(e);
    return (0, _tfjsCore.any)((0, _tfjsCore.notEqual)(n, this.maskValue), -1);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e),
          i = (0, _tfjsCore.any)((0, _tfjsCore.notEqual)(r, n.maskValue), -1, !0);
      return r.mul(i.asType(r.dtype));
    });
  }, t.className = "Masking", t;
}(Layer);

_tfjsCore.serialization.registerClass(Masking);

var Embedding = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;

    if (n.embeddings = null, n.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == t.batchInputShape && null == t.inputShape) {
      var r = null;
      null != t.batchSize && (r = t.batchSize), null == t.inputLength ? n.batchInputShape = [r, null] : n.batchInputShape = [r].concat(toList(t.inputLength));
    }

    return n.inputDim = t.inputDim, assertPositiveInteger(n.inputDim, "inputDim"), n.outputDim = t.outputDim, assertPositiveInteger(n.outputDim, "outputDim"), n.embeddingsInitializer = getInitializer(t.embeddingsInitializer || n.DEFAULT_EMBEDDINGS_INITIALIZER), n.embeddingsRegularizer = getRegularizer(t.embeddingsRegularizer), n.activityRegularizer = getRegularizer(t.activityRegularizer), n.embeddingsConstraint = getConstraint(t.embeddingsConstraint), n.maskZero = t.maskZero, n.supportsMasking = t.maskZero, n.inputLength = t.inputLength, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0;
  }, t.prototype.warnOnIncompatibleInputShape = function (e) {}, t.prototype.computeMask = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return n.maskZero ? (e = getExactlyOneTensor(e), (0, _tfjsCore.notEqual)(e, (0, _tfjsCore.zerosLike)(e))) : null;
    });
  }, t.prototype.computeOutputShape = function (e) {
    if (e = getExactlyOneShape(e), null == this.inputLength) return e.concat([this.outputDim]);
    var t = toList(this.inputLength);
    if (t.length !== e.length - 1) throw new ValueError('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e);

    for (var n = 0, r = 0; r < t.length; ++r) {
      var i = t[r],
          a = e[r + 1];
      if (null != i && null != a && i !== a) throw new ValueError('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e);
      null == i && (t[n] = a), n++;
    }

    return [e[0]].concat(t, [this.outputDim]);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);
      return "int32" !== r.dtype && (r = cast$1(r, "int32")), gather$1(n.embeddings.read(), r.as1D()).reshape(getExactlyOneShape(n.computeOutputShape(r.shape)));
    });
  }, t.prototype.getConfig = function () {
    var t = {
      inputDim: this.inputDim,
      outputDim: this.outputDim,
      embeddingsInitializer: serializeInitializer(this.embeddingsInitializer),
      embeddingsRegularizer: serializeRegularizer(this.embeddingsRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      embeddingsConstraint: serializeConstraint(this.embeddingsConstraint),
      maskZero: this.maskZero,
      inputLength: this.inputLength
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Embedding", t;
}(Layer);

_tfjsCore.serialization.registerClass(Embedding);

var Merge = function (e) {
  function t(t) {
    var n = e.call(this, t || {}) || this;
    return n.supportsMasking = !0, n;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    throw new NotImplementedError();
  }, t.prototype.computeElementwiseOpOutputShape = function (e, t) {
    if (null == e || null == t) return null;
    if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
    if (0 === t.length) return e;

    for (var n = e.slice(0, e.length - t.length), r = 0; r < t.length; ++r) {
      var i = e[e.length - t.length + r],
          a = t[r];
      if (null == i || null == a || i < 0 || a < 0) n.push(null);else if (1 === i) n.push(a);else if (1 === a) n.push(i);else {
        if (i !== a) throw new ValueError("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
        n.push(i);
      }
    }

    return n;
  }, t.prototype.build = function (e) {
    if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [getExactlyOneShape(e)]), (e = e).length < 2) throw new ValueError("A merge layer should be called on an Array of at least 2 inputs. Got " + e.length + " input(s).");

    for (var t = [], n = 0, r = e; n < r.length; n++) {
      null != (o = r[n]) && null !== o[0] && t.push(o[0]);
    }

    if ((t = unique(t)).length > 1) throw new ValueError("Can not merge tensors with different batch sizes. Got tensors with shapes: " + JSON.stringify(e) + ".");

    for (var i = null == e[0] ? null : e[0].slice(1), a = 1; a < e.length; ++a) {
      var o = null == e[a] ? null : e[a].slice(1);
      i = this.computeElementwiseOpOutputShape(i, o);
    }

    var s = e.map(function (e) {
      return e.length;
    });
    -1 === e.indexOf(null) && 1 === unique(s).length ? this.reshapeRequired = !1 : this.reshapeRequired = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (e = e, n.reshapeRequired) {
        var t = [],
            r = e.map(function (e) {
          return e.rank;
        });

        if (-1 === r.indexOf(null)) {
          for (var i = max$1(r), a = 0, o = e; a < o.length; a++) {
            for (var s = (h = o[a]).rank, l = 0; l < i - s; ++l) h = expandDims$1(h, 1);

            t.push(h);
          }

          return n.mergeFunction(t);
        }

        for (var u = !1, c = 0, p = e; c < p.length; c++) {
          var h;

          if (null == (s = (h = p[c]).rank)) {
            var d = h.shape,
                f = d[0],
                g = d.slice(1).concat([f]),
                m = h.reshape([f].concat(arrayProd(d.slice(1))));
            m = (m = (0, _tfjsCore.transpose)(m, [1, 0])).reshape(g), t.push(m), u = !0;
          } else if (s > 1) {
            var y = range(1, s).concat([0]);
            t.push((0, _tfjsCore.transpose)(h, y)), u = !0;
          } else t.push(h);
        }

        var v = n.mergeFunction(t),
            b = v.rank;
        if (u) if (null == b) {
          var w = v.shape;
          g = [f = w[w.length - 1]].concat(w.slice(0, w.length - 1));
          v = (0, _tfjsCore.transpose)(v.reshape([-1, f]), [1, 0]).reshape(g);
        } else if (b > 1) {
          y = [b - 1].concat(range(0, b - 1));
          v = (0, _tfjsCore.transpose)(v, y);
        }
        return v;
      }

      return n.mergeFunction(e);
    });
  }, t.prototype.computeOutputShape = function (e) {
    var t;
    t = null == (e = e)[0] ? null : e[0].slice(1);

    for (var n = 1; n < e.length; ++n) {
      var r = null == e[n] ? null : e[n].slice(1);
      t = this.computeElementwiseOpOutputShape(t, r);
    }

    for (var i = [], a = 0, o = e; a < o.length; a++) {
      null != (r = o[a]) && null !== r[0] && i.push(r[0]);
    }

    return t = 1 === (i = unique(i)).length ? i.concat(t) : [null].concat(t);
  }, t.prototype.computeMask = function (e, t) {
    return (0, _tfjsCore.tidy)(function () {
      if (null == t) return null;
      if (!Array.isArray(t)) throw new ValueError("`mask` should be an Array");
      if (!Array.isArray(e)) throw new ValueError("`inputs` should be an Array");
      if (t.length !== e.length) throw new ValueError("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (" + e.length + " vs " + t.length + ")");
      if (t.every(function (e) {
        return null == e;
      })) return null;

      for (var n = (t = t.map(function (e) {
        return null == e ? e : (0, _tfjsCore.expandDims)(e, 0);
      }))[0], r = 1; r < t.length - 1; ++r) n = (0, _tfjsCore.logicalAnd)(n, t[r]);

      return n;
    });
  }, t;
}(Layer),
    Add = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = (0, _tfjsCore.add)(t, e[n]);

      return t;
    });
  }, t.className = "Add", t;
}(Merge);

_tfjsCore.serialization.registerClass(Add);

var Multiply = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = (0, _tfjsCore.mul)(t, e[n]);

      return t;
    });
  }, t.className = "Multiply", t;
}(Merge);

_tfjsCore.serialization.registerClass(Multiply);

var Average = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = (0, _tfjsCore.add)(t, e[n]);

      return (0, _tfjsCore.mul)(1 / e.length, t);
    });
  }, t.className = "Average", t;
}(Merge);

_tfjsCore.serialization.registerClass(Average);

var Maximum = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0], n = 1; n < e.length; ++n) t = (0, _tfjsCore.maximum)(t, e[n]);

      return t;
    });
  }, t.className = "Maximum", t;
}(Merge);

_tfjsCore.serialization.registerClass(Maximum);

var Minimum = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.mergeFunction = function (e) {
    return (0, _tfjsCore.tidy)(function () {
      for (var t = e[0], n = 1; n < e.length; ++n) t = (0, _tfjsCore.minimum)(t, e[n]);

      return t;
    });
  }, t.className = "Minimum", t;
}(Merge);

_tfjsCore.serialization.registerClass(Minimum);

var Concatenate = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_AXIS = -1, null == t && (t = {}), n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis, n.supportsMasking = !0, n.reshapeRequired = !1, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length) throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");

    for (var t = !0, n = 0, r = e = e; n < r.length; n++) {
      if (null != (c = r[n])) {
        t = !1;
        break;
      }
    }

    if (!t) {
      for (var i = [], a = 0; a < e.length; ++a) {
        var o = e[a].slice();
        o.splice(this.axis, 1);

        for (var s = !1, l = 0, u = i; l < u.length; l++) {
          var c = u[l];

          if (_tfjsCore.util.arraysEqual(c, o)) {
            s = !0;
            break;
          }
        }

        s || i.push(o);
      }

      if (i.length > 1) throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
    }
  }, t.prototype.mergeFunction = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      return concatenate(e, t.axis);
    });
  }, t.prototype.computeOutputShape = function (e) {
    if (!Array.isArray(e) || !Array.isArray(e[0])) throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");

    for (var t = e, n = t[0].slice(), r = this.axis < 0 ? n.length + this.axis : this.axis, i = 0, a = t.slice(1); i < a.length; i++) {
      var o = a[i];

      if (null == n[r] || null == o[r]) {
        n[r] = null;
        break;
      }

      n[r] += o[r];
    }

    return n;
  }, t.prototype.computeMask = function (e, t) {
    var n = this;
    if (null == t) return null;
    if (!Array.isArray(t)) throw new ValueError("`mask` should be an array for Concatenate");
    if (!Array.isArray(e)) throw new ValueError("`inputs` should be an array for Concatenate");
    if (t.length !== e.length) throw new ValueError("Mismatch in the length of mask (" + t.length + ") and the legnth of inputs (" + e.length + ")");
    return (0, _tfjsCore.tidy)(function () {
      var r = !0;
      if (t.forEach(function (e) {
        null == e || (r = !1);
      }), r) return null;

      for (var i = [], a = 0; a < e.length; ++a) null == t[a] ? i.push((0, _tfjsCore.onesLike)(e[a]).asType("bool")) : t[a].rank < e[a].rank ? i.push((0, _tfjsCore.expandDims)(t[a], -1)) : i.push(t[a]);

      var o = (0, _tfjsCore.concat)(i, n.axis);
      return (0, _tfjsCore.all)(o, -1, !1);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      axis: this.axis
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Concatenate", t;
}(Merge);

function interpretAxis(e, t) {
  for (; e < 0;) e += t;

  return e;
}

function batchDot(e, t, n) {
  if (e.shape.length > 3 || t.shape.length > 3) throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");
  if (_tfjsCore.util.assert(e.shape.length >= 2, function () {
    return "batchDot requires the rank of x to be >= 2, but got " + e.shape.length;
  }), _tfjsCore.util.assert(e.shape.length >= 2, function () {
    return "batchDot requires the rank of y to be >= 2, but got " + t.shape.length;
  }), "number" == typeof n && (n = [n, n]), "complex64" === e.dtype || "complex64" === t.dtype) throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");
  var r = e.shape.length,
      i = t.shape.length;
  null == n && (n = [r - 1, i - 2]);
  var a = n;
  return (0, _tfjsCore.tidy)(function () {
    var n, o;

    if (r > i) {
      n = r - i;

      for (var s = [], l = 0; l < n; ++l) s.push(1);

      t = t.reshape(t.shape.concat(s));
    } else if (i > r) {
      n = i - r;

      for (s = [], l = 0; l < n; ++l) s.push(1);

      e = e.reshape(e.shape.concat(s));
    } else n = 0;

    if (2 === e.shape.length && 2 === t.shape.length) o = a[0] === a[1] ? e.mulStrict(t).sum(a[0]) : e.transpose([1, 0]).mulStrict(t).sum(a[1]);else {
      var u = a[0] !== e.shape.length - 1,
          c = a[1] === t.shape.length - 1;
      o = e.matMul(t, u, c);
    }

    if (n > 0) {
      var p = void 0,
          h = [];

      for (l = p = r > i ? r + i - 3 : r - 1; l < p + n; ++l) h.push(l);

      o = o.squeeze(h);
    }

    return 1 === o.shape.length && (o = o.expandDims(1)), o;
  });
}

_tfjsCore.serialization.registerClass(Concatenate);

var Dot = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.axes = t.axes, n.normalize = null != t.normalize && t.normalize, n.supportsMasking = !0, n.reshapeRequired = !1, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    _tfjsCore.util.assert(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
      return "A `Dot` layer should be called on a list of exactly 2 inputs.";
    });

    var t = e[0],
        n = e[1];
    if (t.length > 3 || n.length > 3) throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
    var r = this.interpretAxes(t, n);
    if (t[r[0]] !== n[r[1]]) throw new ValueError("Dimension incompatibility: " + t[r[0]] + " !== " + n[r[1]]);
  }, t.prototype.mergeFunction = function (e) {
    if (2 !== e.length) throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, but received " + e.length + " input(s).");
    var t,
        n = e[0],
        r = e[1];
    return t = Array.isArray(this.axes) ? this.axes.map(function (t, n) {
      return interpretAxis(t, e[n].shape.length);
    }) : [interpretAxis(this.axes, n.shape.length), interpretAxis(this.axes, r.shape.length)], this.normalize && (n = l2Normalize(n, t[0]), r = l2Normalize(r, t[1])), batchDot(n, r, t);
  }, t.prototype.interpretAxes = function (e, t) {
    return Array.isArray(this.axes) ? this.axes : [interpretAxis(this.axes, e.length), interpretAxis(this.axes, t.length)];
  }, t.prototype.computeOutputShape = function (e) {
    _tfjsCore.util.assert(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
      return "A `Dot` layer should be called on a list of exactly 2 inputs.";
    });

    var t = e[0].slice(),
        n = e[1].slice();
    if (t.length > 3 || n.length > 3) throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
    var r = this.interpretAxes(t, n);
    t.splice(r[0], 1), n.splice(r[1], 1), n.splice(0, 1);
    var i = t.concat(n);
    return 1 === i.length && i.push(1), i;
  }, t.prototype.computeMask = function (e, t) {
    return null;
  }, t.prototype.getConfig = function () {
    var t = {
      axes: this.axes,
      normalize: this.normalize
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "Dot", t;
}(Merge);

_tfjsCore.serialization.registerClass(Dot);

var GaussianNoise = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n.stddev = t.stddev, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this),
        n = {
      stddev: this.stddev
    };
    return Object.assign(n, t), n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);
      return inTrainPhase(function () {
        return randomNormal$1(r.shape, 0, n.stddev).add(r);
      }, function () {
        return r;
      }, t.training || !1);
    });
  }, t.className = "GaussianNoise", t;
}(Layer);

_tfjsCore.serialization.registerClass(GaussianNoise);

var GaussianDropout = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n.rate = t.rate, n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this),
        n = {
      rate: this.rate
    };
    return Object.assign(n, t), n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t);
      var r = getExactlyOneTensor(e);

      if (n.rate > 0 && n.rate < 1) {
        return inTrainPhase(function () {
          var e = Math.sqrt(n.rate / (1 - n.rate));
          return r.mul(randomNormal$1(r.shape, 1, e));
        }, function () {
          return r;
        }, t.training || !1);
      }

      return r;
    });
  }, t.className = "GaussianDropout", t;
}(Layer);

_tfjsCore.serialization.registerClass(GaussianDropout);

var AlphaDropout = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n.rate = t.rate, n.noiseShape = t.noiseShape, n;
  }

  return __extends(t, e), t.prototype._getNoiseShape = function (e) {
    return this.noiseShape || getExactlyOneTensor(e).shape;
  }, t.prototype.computeOutputShape = function (e) {
    return e;
  }, t.prototype.getConfig = function () {
    var t = e.prototype.getConfig.call(this),
        n = {
      rate: this.rate
    };
    return Object.assign(n, t), n;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (n.rate < 1 && n.rate > 0) {
        var r = n._getNoiseShape(e);

        return inTrainPhase(function () {
          var t = getExactlyOneTensor(e),
              i = -1.7580993408473766,
              a = (0, _tfjsCore.greaterEqual)((0, _tfjsCore.randomUniform)(r), n.rate);
          a = cast$1(a, "float32");
          var o = Math.pow((1 - n.rate) * (1 + n.rate * Math.pow(i, 2)), -.5),
              s = -o * i * n.rate;
          return t.mul(a).add(a.add(-1).mul(i)).mul(o).add(s);
        }, function () {
          return getExactlyOneTensor(e);
        }, t.training || !1);
      }

      return e;
    });
  }, t.className = "AlphaDropout", t;
}(Layer);

function batchNormalization(e, t, n, r, i, a) {
  var o;
  if (void 0 === a && (a = .001), 2 === e.rank) o = (0, _tfjsCore.batchNorm2d)(e, t, n, r, i, a);else if (3 === e.rank) o = (0, _tfjsCore.batchNorm3d)(e, t, n, r, i, a);else {
    if (4 !== e.rank) throw new NotImplementedError("batchNormalization is not implemented for array of rank " + e.rank + " yet");
    o = (0, _tfjsCore.batchNorm4d)(e, t, n, r, i, a);
  }
  return o;
}

function regularNormalizeBatchInTraining(e, t, n, r, i) {
  return void 0 === i && (i = .001), (0, _tfjsCore.tidy)(function () {
    var a = (0, _tfjsCore.moments)(e, r),
        o = a.mean,
        s = a.variance;
    return [batchNormalization(e, o, s, n, t, i), o, s];
  });
}

function broadcastNormalizeBatchInTraining(e, t, n, r, i) {
  return void 0 === i && (i = .001), (0, _tfjsCore.tidy)(function () {
    for (var a = (0, _tfjsCore.moments)(e, r), o = a.mean, s = a.variance, l = [], u = 0, c = range(0, e.rank); u < c.length; u++) {
      var p = c[u];
      -1 !== r.indexOf(p) ? l.push(1) : l.push(e.shape[p]);
    }

    var h = o.reshape(l),
        d = s.reshape(l),
        f = null == t ? null : t.reshape(l),
        g = null == n ? null : n.reshape(l);
    return [batchNormalization(e, h, d, g, f, i), o, s];
  });
}

function normalizeBatchInTraining(e, t, n, r, i) {
  return void 0 === i && (i = .001), _tfjsCore.util.arraysEqual(r.slice().sort(), range(0, e.rank - 1)) ? regularNormalizeBatchInTraining(e, t, n, r, i) : broadcastNormalizeBatchInTraining(e, t, n, r, i);
}

_tfjsCore.serialization.registerClass(AlphaDropout);

var BatchNormalization = function (e) {
  function t(t) {
    var n = this;
    return null == t && (t = {}), (n = e.call(this, t) || this).supportsMasking = !0, n.axis = null == t.axis ? -1 : t.axis, n.momentum = null == t.momentum ? .99 : t.momentum, n.epsilon = null == t.epsilon ? .001 : t.epsilon, n.center = null == t.center || t.center, n.scale = null == t.scale || t.scale, n.betaInitializer = getInitializer(t.betaInitializer || "zeros"), n.gammaInitializer = getInitializer(t.gammaInitializer || "ones"), n.movingMeanInitializer = getInitializer(t.movingMeanInitializer || "zeros"), n.movingVarianceInitializer = getInitializer(t.movingVarianceInitializer || "ones"), n.betaConstraint = getConstraint(t.betaConstraint), n.gammaConstraint = getConstraint(t.gammaConstraint), n.betaRegularizer = getRegularizer(t.betaRegularizer), n.gammaRegularizer = getRegularizer(t.gammaRegularizer), n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t;
    e = getExactlyOneShape(e);
    var n = this.axis >= 0 ? this.axis : this.axis + e.length,
        r = e[n];
    if (null == r) throw new ValueError("Axis " + n + " of input tensor should have a defined dimension but the layer received an input with shape " + JSON.stringify(e) + ".");
    this.inputSpec = [new InputSpec({
      ndim: e.length,
      axes: (t = {}, t[n] = r, t)
    })];
    var i = [r];
    this.scale && (this.gamma = this.addWeight("gamma", i, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", i, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", i, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", i, null, this.movingVarianceInitializer, null, !1), this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r = null != t.training && t.training,
          i = getExactlyOneTensor(e),
          a = i.shape,
          o = a.length,
          s = range(0, o),
          l = n.axis >= 0 ? n.axis : n.axis + o;
      s.splice(l, 1);
      var u = pyListRepeat(1, o);
      u[l] = a[l];
      var c = s.slice();
      c.sort();
      var p = !_tfjsCore.util.arraysEqual(c, range(0, o).slice(0, o - 1));
      if (!r) return function () {
        if (p) {
          var e = n.movingMean.read().reshape(u),
              t = n.movingVariance.read().reshape(u),
              r = n.center ? n.beta.read().reshape(u) : null,
              a = n.scale ? n.gamma.read().reshape(u) : null;
          return batchNormalization(i, e, t, r, a, n.epsilon);
        }

        return batchNormalization(i, n.movingMean.read(), n.movingVariance.read(), null == n.beta ? null : n.beta.read(), null == n.gamma ? null : n.gamma.read(), n.epsilon);
      }();

      var h = normalizeBatchInTraining(i, n.gamma.read(), n.beta.read(), s, n.epsilon),
          d = h[0],
          f = h[1],
          g = h[2],
          m = function (e, t, n) {
        (0, _tfjsCore.tidy)(function () {
          var r = 1 - n,
              i = e.read(),
              a = i.sub(t).mul(r);
          e.write(i.sub(a));
        });
      };

      return m(n.movingMean, f, n.momentum), m(n.movingVariance, g, n.momentum), d;
    });
  }, t.prototype.getConfig = function () {
    var t = {
      axis: this.axis,
      momentum: this.momentum,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: serializeInitializer(this.betaInitializer),
      gammaInitializer: serializeInitializer(this.gammaInitializer),
      movingMeanInitializer: serializeInitializer(this.movingMeanInitializer),
      movingVarianceInitializer: serializeInitializer(this.movingVarianceInitializer),
      betaRegularizer: serializeRegularizer(this.betaRegularizer),
      gammaRegularizer: serializeRegularizer(this.gammaRegularizer),
      betaConstraint: serializeConstraint(this.betaConstraint),
      gammaConstraint: serializeConstraint(this.gammaConstraint)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "BatchNormalization", t;
}(Layer);

_tfjsCore.serialization.registerClass(BatchNormalization);

var LayerNormalization = function (e) {
  function t(t) {
    var n = this;

    if (null == t && (t = {}), (n = e.call(this, t) || this).axis = null == t.axis ? -1 : t.axis, "number" == typeof n.axis) {
      if (!Number.isInteger(n.axis)) throw new Error("Expected axis to be an integer, but received " + n.axis);
    } else {
      if (!Array.isArray(n.axis)) throw new Error("Expected axis to be an integer or an array of integers, but received " + JSON.stringify(n.axis));

      for (var r = 0, i = n.axis; r < i.length; r++) {
        var a = i[r];
        if (!Number.isInteger(a)) throw new Error("Expected axis to be an array of integers, but received " + JSON.stringify(n.axis));
      }
    }

    return n.epsilon = null == t.epsilon ? .001 : t.epsilon, n.center = null == t.center || t.center, n.scale = null == t.scale || t.scale, n.betaInitializer = getInitializer(t.betaInitializer || "zeros"), n.gammaInitializer = getInitializer(t.gammaInitializer || "ones"), n.betaRegularizer = getRegularizer(t.betaRegularizer), n.gammaRegularizer = getRegularizer(t.gammaRegularizer), n.supportsMasking = !0, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t = (e = getExactlyOneShape(e)).length;
    "number" == typeof this.axis && (this.axis = [this.axis]);

    for (var n = 0; n < this.axis.length; ++n) this.axis[n] < 0 && (this.axis[n] += t);

    for (var r = 0, i = this.axis; r < i.length; r++) {
      var a = i[r];
      if (a < 0 || a >= t) throw new Error("Invalid axis: " + a);
    }

    if (this.axis.length !== unique(this.axis).length) throw new Error("Found duplicate axes in: " + this.axis);
    var o = this.axis.map(function (t) {
      return e[t];
    });
    this.scale ? this.gamma = this.addWeight("gamma", o, "float32", this.gammaInitializer, this.gammaRegularizer, !0) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", o, "float32", this.betaInitializer, this.betaRegularizer, !0) : this.beta = null, this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this,
        r = getExactlyOneTensor(e),
        i = r.shape,
        a = i.length;
    return (0, _tfjsCore.tidy)(function () {
      for (var e = (0, _tfjsCore.moments)(r, n.axis, !0), t = e.mean, o = e.variance, s = pyListRepeat(1, a), l = 0, u = n.axis; l < u.length; l++) {
        var c = u[l];
        s[c] = i[c];
      }

      for (var p = function (e) {
        return null != e && e.shape.length !== a && n.axis !== [a - 1] ? e.reshape(s) : e;
      }, h = p(n.gamma.read()), d = p(n.beta.read()), f = [], g = [], m = 0; m < a; ++m) -1 !== n.axis.indexOf(m) ? (f.push(i[m]), g.push(1)) : (f.push(1), g.push(i[m]));

      return t = t.tile(f), o = o.tile(f), h = h.tile(g), d = d.tile(g), batchNormalization(r, t, o, d, h, n.epsilon);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      axis: this.axis,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: serializeInitializer(this.betaInitializer),
      gammaInitializer: serializeInitializer(this.gammaInitializer),
      betaRegularizer: serializeRegularizer(this.betaRegularizer),
      gammaRegularizer: serializeRegularizer(this.gammaRegularizer)
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "LayerNormalization", t;
}(Layer);

function spatial2dPadding(e, t, n) {
  return (0, _tfjsCore.tidy)(function () {
    if (4 !== e.rank) throw new ValueError("temporalPadding expects input tensor to be 4-D, but received a " + e.rank + "-D tensor.");
    if (null == t && (t = [[1, 1], [1, 1]]), 2 !== t.length || 2 !== t[0].length || 2 !== t[1].length) throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
    if (null == n && (n = imageDataFormat()), "channelsLast" !== n && "channelsFirst" !== n) throw new ValueError("Unknown data format: " + n + ". Supported data formats are 'channelsLast' and 'channelsFirst.");
    var r;
    return r = "channelsFirst" === n ? [[0, 0], [0, 0], t[0], t[1]] : [[0, 0], t[0], t[1], [0, 0]], (0, _tfjsCore.pad)(e, r);
  });
}

_tfjsCore.serialization.registerClass(LayerNormalization);

var ZeroPadding2D = function (e) {
  function t(t) {
    var n = this;
    if (null == t && (t = {}), (n = e.call(this, t) || this).dataFormat = null == t.dataFormat ? imageDataFormat() : t.dataFormat, null == t.padding) n.padding = [[1, 1], [1, 1]];else if ("number" == typeof t.padding) n.padding = [[t.padding, t.padding], [t.padding, t.padding]];else {
      if (t.padding = t.padding, 2 !== t.padding.length) throw new ValueError("ZeroPadding2D expects padding to be a length-2 array, but received a length-" + t.padding.length + " array.");
      var r = void 0,
          i = void 0;
      if ("number" == typeof t.padding[0]) r = [t.padding[0], t.padding[0]], i = [t.padding[1], t.padding[1]];else {
        if (t.padding = t.padding, 2 !== t.padding[0].length) throw new ValueError("ZeroPadding2D expects height padding to be a length-2 array, but received a length-" + t.padding[0].length + " array.");
        if (r = t.padding[0], 2 !== t.padding[1].length) throw new ValueError("ZeroPadding2D expects width padding to be a length-2 array, but received a length-" + t.padding[1].length + " array.");
        i = t.padding[1];
      }
      n.padding = [r, i];
    }
    return n.inputSpec = [new InputSpec({
      ndim: 4
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    var t, n;
    return e = getExactlyOneShape(e), "channelsFirst" === this.dataFormat ? (t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null, [e[0], e[1], t, n]) : (t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null, [e[0], t, n, e[3]]);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return spatial2dPadding(getExactlyOneTensor(e), n.padding, n.dataFormat);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      padding: this.padding,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "ZeroPadding2D", t;
}(Layer);

function pool2d(e, t, n, r, i, a) {
  return (0, _tfjsCore.tidy)(function () {
    var o;
    checkDataFormat(i), checkPoolMode(a), checkPaddingMode(r), null == n && (n = [1, 1]), null == r && (r = "valid"), null == i && (i = imageDataFormat()), null == a && (a = "max"), e = preprocessConv2DInput(e, i);
    var s = "same" === r ? "same" : "valid";
    return o = "max" === a ? (0, _tfjsCore.maxPool)(e, t, n, s) : (0, _tfjsCore.avgPool)(e, t, n, s), "channelsFirst" === i && (o = (0, _tfjsCore.transpose)(o, [0, 3, 1, 2])), o;
  });
}

function pool3d(e, t, n, r, i, a) {
  return (0, _tfjsCore.tidy)(function () {
    var o;
    checkDataFormat(i), checkPoolMode(a), checkPaddingMode(r), null == n && (n = [1, 1, 1]), null == r && (r = "valid"), null == i && (i = imageDataFormat()), null == a && (a = "max"), e = preprocessConv3DInput(e, i);
    var s = "same" === r ? "same" : "valid";
    return o = "max" === a ? (0, _tfjsCore.maxPool3d)(e, t, n, s) : (0, _tfjsCore.avgPool3d)(e, t, n, s), "channelsFirst" === i && (o = (0, _tfjsCore.transpose)(o, [0, 4, 1, 2, 3])), o;
  });
}

_tfjsCore.serialization.registerClass(ZeroPadding2D);

var Pooling1D = function (e) {
  function t(t) {
    var n = this;
    if (null == t.poolSize && (t.poolSize = 2), n = e.call(this, t) || this, "number" == typeof t.poolSize) n.poolSize = [t.poolSize];else {
      if (!Array.isArray(t.poolSize) || 1 !== t.poolSize.length || "number" != typeof t.poolSize[0]) throw new ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t.poolSize));
      n.poolSize = t.poolSize;
    }
    if (assertPositiveInteger(n.poolSize, "poolSize"), null == t.strides) n.strides = n.poolSize;else if ("number" == typeof t.strides) n.strides = [t.strides];else {
      if (!Array.isArray(t.strides) || 1 !== t.strides.length || "number" != typeof t.strides[0]) throw new ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t.strides));
      n.strides = t.strides;
    }
    return assertPositiveInteger(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, checkPaddingMode(n.padding), n.inputSpec = [new InputSpec({
      ndim: 3
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    var t = convOutputLength((e = getExactlyOneShape(e))[1], this.poolSize[0], this.padding, this.strides[0]);
    return [e[0], t, e[2]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      n.invokeCallHook(e, t), e = expandDims$1(getExactlyOneTensor(e), 2);
      var r = n.poolingFunction(getExactlyOneTensor(e), [n.poolSize[0], 1], [n.strides[0], 1], n.padding, "channelsLast");
      return (0, _tfjsCore.squeeze)(r, [2]);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    MaxPooling1D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "max");
  }, t.className = "MaxPooling1D", t;
}(Pooling1D);

_tfjsCore.serialization.registerClass(MaxPooling1D);

var AveragePooling1D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "avg");
  }, t.className = "AveragePooling1D", t;
}(Pooling1D);

_tfjsCore.serialization.registerClass(AveragePooling1D);

var Pooling2D = function (e) {
  function t(t) {
    var n = this;
    if (null == t.poolSize && (t.poolSize = [2, 2]), (n = e.call(this, t) || this).poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize], null == t.strides) n.strides = n.poolSize;else if (Array.isArray(t.strides)) {
      if (2 !== t.strides.length) throw new ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " + t.strides.length + ".");
      n.strides = t.strides;
    } else n.strides = [t.strides, t.strides];
    return assertPositiveInteger(n.poolSize, "poolSize"), assertPositiveInteger(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, checkDataFormat(n.dataFormat), checkPaddingMode(n.padding), n.inputSpec = [new InputSpec({
      ndim: 4
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    e = getExactlyOneShape(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
    return t = convOutputLength(t, this.poolSize[0], this.padding, this.strides[0]), n = convOutputLength(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n] : [e[0], t, n, e[3]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return n.invokeCallHook(e, t), n.poolingFunction(getExactlyOneTensor(e), n.poolSize, n.strides, n.padding, n.dataFormat);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    MaxPooling2D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "max");
  }, t.className = "MaxPooling2D", t;
}(Pooling2D);

_tfjsCore.serialization.registerClass(MaxPooling2D);

var AveragePooling2D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "avg");
  }, t.className = "AveragePooling2D", t;
}(Pooling2D);

_tfjsCore.serialization.registerClass(AveragePooling2D);

var Pooling3D = function (e) {
  function t(t) {
    var n = this;
    if (null == t.poolSize && (t.poolSize = [2, 2, 2]), (n = e.call(this, t) || this).poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize, t.poolSize], null == t.strides) n.strides = n.poolSize;else if (Array.isArray(t.strides)) {
      if (3 !== t.strides.length) throw new ValueError("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " + t.strides.length + ".");
      n.strides = t.strides;
    } else n.strides = [t.strides, t.strides, t.strides];
    return assertPositiveInteger(n.poolSize, "poolSize"), assertPositiveInteger(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, checkDataFormat(n.dataFormat), checkPaddingMode(n.padding), n.inputSpec = [new InputSpec({
      ndim: 5
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    e = getExactlyOneShape(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
        r = "channelsFirst" === this.dataFormat ? e[4] : e[3];
    return t = convOutputLength(t, this.poolSize[0], this.padding, this.strides[0]), n = convOutputLength(n, this.poolSize[1], this.padding, this.strides[1]), r = convOutputLength(r, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n, r] : [e[0], t, n, r, e[4]];
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return n.invokeCallHook(e, t), n.poolingFunction(getExactlyOneTensor(e), n.poolSize, n.strides, n.padding, n.dataFormat);
    });
  }, t.prototype.getConfig = function () {
    var t = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    MaxPooling3D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool3d(e, t, n, r, i, "max");
  }, t.className = "MaxPooling3D", t;
}(Pooling3D);

_tfjsCore.serialization.registerClass(MaxPooling3D);

var AveragePooling3D = function (e) {
  function t(t) {
    return e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.poolingFunction = function (e, t, n, r, i) {
    return checkDataFormat(i), checkPaddingMode(r), pool3d(e, t, n, r, i, "avg");
  }, t.className = "AveragePooling3D", t;
}(Pooling3D);

_tfjsCore.serialization.registerClass(AveragePooling3D);

var GlobalPooling1D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.inputSpec = [new InputSpec({
      ndim: 3
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return [e[0], e[2]];
  }, t.prototype.call = function (e, t) {
    throw new NotImplementedError();
  }, t;
}(Layer),
    GlobalAveragePooling1D = function (e) {
  function t(t) {
    return e.call(this, t || {}) || this;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      return (0, _tfjsCore.mean)(t, 1);
    });
  }, t.className = "GlobalAveragePooling1D", t;
}(GlobalPooling1D);

_tfjsCore.serialization.registerClass(GlobalAveragePooling1D);

var GlobalMaxPooling1D = function (e) {
  function t(t) {
    return e.call(this, t || {}) || this;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      return (0, _tfjsCore.max)(t, 1);
    });
  }, t.className = "GlobalMaxPooling1D", t;
}(GlobalPooling1D);

_tfjsCore.serialization.registerClass(GlobalMaxPooling1D);

var GlobalPooling2D = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, checkDataFormat(n.dataFormat), n.inputSpec = [new InputSpec({
      ndim: 4
    })], n;
  }

  return __extends(t, e), t.prototype.computeOutputShape = function (e) {
    return e = e, "channelsLast" === this.dataFormat ? [e[0], e[3]] : [e[0], e[1]];
  }, t.prototype.call = function (e, t) {
    throw new NotImplementedError();
  }, t.prototype.getConfig = function () {
    var t = {
      dataFormat: this.dataFormat
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t;
}(Layer),
    GlobalAveragePooling2D = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      return "channelsLast" === n.dataFormat ? (0, _tfjsCore.mean)(t, [1, 2]) : (0, _tfjsCore.mean)(t, [2, 3]);
    });
  }, t.className = "GlobalAveragePooling2D", t;
}(GlobalPooling2D);

_tfjsCore.serialization.registerClass(GlobalAveragePooling2D);

var GlobalMaxPooling2D = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var t = getExactlyOneTensor(e);
      return "channelsLast" === n.dataFormat ? (0, _tfjsCore.max)(t, [1, 2]) : (0, _tfjsCore.max)(t, [2, 3]);
    });
  }, t.className = "GlobalMaxPooling2D", t;
}(GlobalPooling2D);

function standardizeArgs(e, t, n, r) {
  if (Array.isArray(e)) {
    if (null != t || null != n) throw new ValueError("When inputs is an array, neither initialState or constants should be provided");
    null != r && (n = e.slice(e.length - r, e.length), e = e.slice(0, e.length - r)), e.length > 1 && (t = e.slice(1, e.length)), e = e[0];
  }

  function i(e) {
    return null == e || Array.isArray(e) ? e : [e];
  }

  return {
    inputs: e,
    initialState: t = i(t),
    constants: n = i(n)
  };
}

function rnn(e, t, n, r, i, a, o, s) {
  return void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), (0, _tfjsCore.tidy)(function () {
    var l = t.shape.length;
    if (l < 3) throw new ValueError("Input should be at least 3D, but is " + l + "D.");
    var u = [1, 0].concat(range(2, l));
    if (t = (0, _tfjsCore.transpose)(t, u), null != a) throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
    o && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != i && ((i = i.asType("bool").asType("float32")).rank === l - 1 && (i = (0, _tfjsCore.expandDims)(i, -1)), i = (0, _tfjsCore.transpose)(i, u)), r && (t = (0, _tfjsCore.reverse)(t, 0), null != i && (i = (0, _tfjsCore.reverse)(i, 0)));
    var c,
        p,
        h = [],
        d = n,
        f = t.shape[0],
        g = (0, _tfjsCore.unstack)(t);
    null != i && (p = (0, _tfjsCore.unstack)(i));

    for (var m, y = function (t) {
      var n = g[t],
          r = (0, _tfjsCore.tidy)(function () {
        return e(n, d);
      });
      if (null == i) c = r[0], d = r[1];else {
        var a = (0, _tfjsCore.tidy)(function () {
          var e = p[t],
              n = (0, _tfjsCore.onesLike)(e).sub(e);
          return {
            output: r[0].mul(e).addStrict(d[0].mul(n)),
            newStates: d.map(function (t, i) {
              return r[1][i].mul(e).addStrict(t.mul(n));
            })
          };
        });
        c = a.output, d = a.newStates;
      }
      s && h.push(c);
    }, v = 0; v < f; ++v) y(v);

    if (s) {
      m = (0, _tfjsCore.stack)(h, 1);
    }

    return [c, m, d];
  });
}

_tfjsCore.serialization.registerClass(GlobalMaxPooling2D);

var RNN = function (e) {
  function t(t) {
    var n,
        r = e.call(this, t) || this;
    if (null == t.cell) throw new ValueError("cell property is missing for the constructor of RNN.");
    if (null == (n = Array.isArray(t.cell) ? new StackedRNNCells({
      cells: t.cell
    }) : t.cell).stateSize) throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
    return r.cell = n, r.returnSequences = null != t.returnSequences && t.returnSequences, r.returnState = null != t.returnState && t.returnState, r.goBackwards = null != t.goBackwards && t.goBackwards, r._stateful = null != t.stateful && t.stateful, r.unroll = null != t.unroll && t.unroll, r.supportsMasking = !0, r.inputSpec = [new InputSpec({
      ndim: 3
    })], r.stateSpec = null, r.states_ = null, r.numConstants = null, r.keptStates = [], r;
  }

  return __extends(t, e), t.prototype.getStates = function () {
    return null == this.states_ ? range(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function (e) {
      return null;
    }) : this.states_;
  }, t.prototype.setStates = function (e) {
    this.states_ = e;
  }, t.prototype.computeOutputShape = function (e) {
    isArrayOfShapes(e) && (e = e[0]), e = e;
    var t = this.cell.stateSize;
    Array.isArray(t) || (t = [t]);
    var n,
        r = t[0];

    if (n = this.returnSequences ? [e[0], e[1], r] : [e[0], r], this.returnState) {
      for (var i = [], a = 0, o = t; a < o.length; a++) {
        var s = o[a];
        i.push([e[0], s]);
      }

      return [n].concat(i);
    }

    return n;
  }, t.prototype.computeMask = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      Array.isArray(t) && (t = t[0]);
      var e = n.returnSequences ? t : null;

      if (n.returnState) {
        var r = n.states.map(function (e) {
          return null;
        });
        return [e].concat(r);
      }

      return e;
    });
  }, Object.defineProperty(t.prototype, "states", {
    get: function () {
      if (null == this.states_) {
        for (var e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t = [], n = 0; n < e; ++n) t.push(null);

        return t;
      }

      return this.states_;
    },
    set: function (e) {
      this.states_ = e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.build = function (e) {
    if (null != this.numConstants) throw new NotImplementedError("Constants support is not implemented in RNN yet.");
    isArrayOfShapes(e) && (e = e[0]), e = e;
    var t = this.stateful ? e[0] : null,
        n = e[e.length - 1];
    this.inputSpec[0] = new InputSpec({
      shape: [t, null, n]
    });
    var r,
        i = [e[0]].concat(e.slice(2));

    if (this.cell.build(i), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
      if (!_tfjsCore.util.arraysEqual(this.stateSpec.map(function (e) {
        return e.shape[e.shape.length - 1];
      }), r)) throw new ValueError("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=" + this.stateSpec + "; However cell.stateSize is " + this.cell.stateSize);
    } else this.stateSpec = r.map(function (e) {
      return new InputSpec({
        shape: [null, e]
      });
    });

    this.stateful && this.resetStates();
  }, t.prototype.resetStates = function (e, t) {
    var n = this;
    void 0 === t && (t = !1), (0, _tfjsCore.tidy)(function () {
      if (!n.stateful) throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
      var r = n.inputSpec[0].shape[0];
      if (null == r) throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (null == n.states_) Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function (e) {
        return (0, _tfjsCore.zeros)([r, e]);
      }) : n.states_ = [(0, _tfjsCore.zeros)([r, n.cell.stateSize])];else if (null == e) (0, _tfjsCore.dispose)(n.states_), null != n.keptStates && ((0, _tfjsCore.dispose)(n.keptStates), n.keptStates = []), Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function (e) {
        return (0, _tfjsCore.zeros)([r, e]);
      }) : n.states_[0] = (0, _tfjsCore.zeros)([r, n.cell.stateSize]);else {
        if (Array.isArray(e) || (e = [e]), e.length !== n.states_.length) throw new ValueError("Layer " + n.name + " expects " + n.states_.length + " state(s), but it received " + e.length + " state value(s). Input received: " + e);
        !0 === t ? n.keptStates.push(n.states_.slice()) : (0, _tfjsCore.dispose)(n.states_);

        for (var i = 0; i < n.states_.length; ++i) {
          var a = e[i],
              o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize[i] : n.cell.stateSize,
              s = [r, o];
          if (!_tfjsCore.util.arraysEqual(a.shape, s)) throw new ValueError("State " + i + " is incompatible with layer " + n.name + ": expected shape=" + s + ", received shape=" + a.shape);
          n.states_[i] = a;
        }
      }
      n.states_ = n.states_.map(function (e) {
        return (0, _tfjsCore.keep)(e.clone());
      });
    });
  }, t.prototype.apply = function (t, n) {
    var r = null == n ? null : n.initialState,
        i = null == n ? null : n.constants;
    null == n && (n = {});
    var a = standardizeArgs(t, r, i, this.numConstants);
    t = a.inputs, r = a.initialState, i = a.constants;
    var o = [],
        s = [];

    if (null != r) {
      n.initialState = r, o = o.concat(r), this.stateSpec = [];

      for (var l = 0, u = r; l < u.length; l++) {
        var c = u[l];
        this.stateSpec.push(new InputSpec({
          shape: c.shape
        }));
      }

      s = s.concat(this.stateSpec);
    }

    if (null != i && (n.constants = i, o = o.concat(i), this.numConstants = i.length), o[0] instanceof SymbolicTensor) {
      var p = [t].concat(o),
          h = this.inputSpec.concat(s),
          d = this.inputSpec;
      this.inputSpec = h;
      var f = e.prototype.apply.call(this, p, n);
      return this.inputSpec = d, f;
    }

    return e.prototype.apply.call(this, t, n);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r = null == t ? null : t.mask,
          i = null == t ? null : t.training,
          a = null == t ? null : t.initialState;
      e = getExactlyOneTensor(e), null == a && (a = n.stateful ? n.states_ : n.getInitialState(e));
      var o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize.length : 1;
      if (a.length !== o) throw new ValueError("RNN Layer has " + o + " state(s) but was passed " + a.length + " initial state(s).");
      n.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
      var s = {
        training: i
      },
          l = rnn(function (e, t) {
        var r = n.cell.call([e].concat(t), s);
        return [r[0], r.slice(1)];
      }, e, a, n.goBackwards, r, null, n.unroll, n.returnSequences),
          u = l[0],
          c = l[1],
          p = l[2];
      n.stateful && n.resetStates(p, i);
      var h = n.returnSequences ? c : u;
      return n.returnState ? [h].concat(p) : h;
    });
  }, t.prototype.getInitialState = function (e) {
    var t = this;
    return (0, _tfjsCore.tidy)(function () {
      var n = (0, _tfjsCore.zeros)(e.shape);
      return n = expandDims$1(n = (0, _tfjsCore.sum)(n, [1, 2])), Array.isArray(t.cell.stateSize) ? t.cell.stateSize.map(function (e) {
        return e > 1 ? tile$1(n, [1, e]) : n;
      }) : t.cell.stateSize > 1 ? [tile$1(n, [1, t.cell.stateSize])] : [n];
    });
  }, Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      return this.trainable ? this.cell.trainableWeights : [];
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.setFastWeightInitDuringBuild = function (t) {
    e.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.cell && this.cell.setFastWeightInitDuringBuild(t);
  }, t.prototype.getConfig = function () {
    var t = {
      returnSequences: this.returnSequences,
      returnState: this.returnState,
      goBackwards: this.goBackwards,
      stateful: this.stateful,
      unroll: this.unroll
    };
    null != this.numConstants && (t.numConstants = this.numConstants);
    var n = this.cell.getConfig();
    t.cell = {
      className: this.cell.getClassName(),
      config: n
    };
    var r = e.prototype.getConfig.call(this);
    return Object.assign(t, r), t;
  }, t.fromConfig = function (e, t, n) {
    void 0 === n && (n = {});
    var r = deserialize(t.cell, n);
    return new e(Object.assign(t, {
      cell: r
    }));
  }, t.className = "RNN", t;
}(Layer);

exports.RNN = RNN;

_tfjsCore.serialization.registerClass(RNN);

var RNNCell = function (e) {
  function t() {
    return null !== e && e.apply(this, arguments) || this;
  }

  return __extends(t, e), t;
}(Layer),
    SimpleRNNCell = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(null == t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = getInitializer(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.recurrentRegularizer = getRegularizer(t.recurrentRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.kernelConstraint = getConstraint(t.kernelConstraint), n.recurrentConstraint = getConstraint(t.recurrentConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.dropout = min$1([1, max$1([0, null == t.dropout ? 0 : t.dropout])]), n.recurrentDropout = min$1([1, max$1([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]), n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    e = getExactlyOneShape(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (2 !== (e = e).length) throw new ValueError("SimpleRNNCell expects 2 input Tensors, got " + e.length + ".");
      var r = e[1];
      e = e[0];
      var i,
          a = null != t.training && t.training;
      0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(e);
      }, n.dropout, a)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(r);
      }, n.recurrentDropout, a));
      var o = n.dropoutMask,
          s = n.recurrentDropoutMask;
      i = dot(null != o ? (0, _tfjsCore.mul)(e, o) : e, n.kernel.read()), null != n.bias && (i = biasAdd(i, n.bias.read())), null != s && (r = (0, _tfjsCore.mul)(r, s));
      var l = (0, _tfjsCore.add)(i, dot(r, n.recurrentKernel.read()));
      return null != n.activation && (l = n.activation.apply(l)), [l, l];
    });
  }, t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "SimpleRNNCell", t;
}(RNNCell);

_tfjsCore.serialization.registerClass(SimpleRNNCell);

var SimpleRNN = function (e) {
  function t(t) {
    return t.cell = new SimpleRNNCell(t), e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.call = function (t, n) {
    var r = this;
    return (0, _tfjsCore.tidy)(function () {
      null != r.cell.dropoutMask && ((0, _tfjsCore.dispose)(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && ((0, _tfjsCore.dispose)(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
      var i = null == n ? null : n.mask,
          a = null == n ? null : n.training,
          o = null == n ? null : n.initialState;
      return e.prototype.call.call(r, t, {
        mask: i,
        training: a,
        initialState: o
      });
    });
  }, Object.defineProperty(t.prototype, "units", {
    get: function () {
      return this.cell.units;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "activation", {
    get: function () {
      return this.cell.activation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "useBias", {
    get: function () {
      return this.cell.useBias;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelInitializer", {
    get: function () {
      return this.cell.kernelInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentInitializer", {
    get: function () {
      return this.cell.recurrentInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasInitializer", {
    get: function () {
      return this.cell.biasInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelRegularizer", {
    get: function () {
      return this.cell.kernelRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentRegularizer", {
    get: function () {
      return this.cell.recurrentRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasRegularizer", {
    get: function () {
      return this.cell.biasRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelConstraint", {
    get: function () {
      return this.cell.kernelConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentConstraint", {
    get: function () {
      return this.cell.recurrentConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasConstraint", {
    get: function () {
      return this.cell.biasConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "dropout", {
    get: function () {
      return this.cell.dropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentDropout", {
    get: function () {
      return this.cell.recurrentDropout;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout
    },
        n = e.prototype.getConfig.call(this);
    return delete n.cell, Object.assign(t, n), t;
  }, t.fromConfig = function (e, t) {
    return new e(t);
  }, t.className = "SimpleRNN", t;
}(RNN);

_tfjsCore.serialization.registerClass(SimpleRNN);

var GRUCell = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.recurrentActivation = getActivation(void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = getInitializer(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.recurrentRegularizer = getRegularizer(t.recurrentRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.kernelConstraint = getConstraint(t.kernelConstraint), n.recurrentConstraint = getConstraint(t.recurrentConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.dropout = min$1([1, max$1([0, null == t.dropout ? 0 : t.dropout])]), n.recurrentDropout = min$1([1, max$1([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]), n.implementation = t.implementation, n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t = (e = getExactlyOneShape(e))[e.length - 1];
    this.kernel = this.addWeight("kernel", [t, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      if (2 !== (e = e).length) throw new ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got " + e.length + ".");
      var r = null != t.training && t.training,
          i = e[1];
      e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(e);
      }, n.dropout, r, 3)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(i);
      }, n.recurrentDropout, r, 3));
      var a,
          o,
          s,
          l = n.dropoutMask,
          u = n.recurrentDropoutMask;
      0 < n.dropout && n.dropout < 1 && (e = (0, _tfjsCore.mul)(e, l[0]));
      var c = dot(e, n.kernel.read());
      n.useBias && (c = biasAdd(c, n.bias.read())), 0 < n.recurrentDropout && n.recurrentDropout < 1 && (i = (0, _tfjsCore.mul)(i, u[0]));
      var p = n.recurrentKernel.read(),
          h = (0, _tfjsCore.split)(p, [2 * n.units, n.units], p.rank - 1),
          d = h[0],
          f = h[1],
          g = dot(i, d),
          m = (0, _tfjsCore.split)(c, 3, c.rank - 1),
          y = m[0],
          v = m[1],
          b = m[2],
          w = (0, _tfjsCore.split)(g, 2, g.rank - 1),
          z = w[0],
          S = w[1];
      a = n.recurrentActivation.apply((0, _tfjsCore.add)(y, z)), o = n.recurrentActivation.apply((0, _tfjsCore.add)(v, S));
      var A = dot((0, _tfjsCore.mul)(o, i), f);
      s = n.activation.apply((0, _tfjsCore.add)(b, A));

      var _ = (0, _tfjsCore.add)((0, _tfjsCore.mul)(a, i), (0, _tfjsCore.mul)((0, _tfjsCore.add)(1, (0, _tfjsCore.neg)(a)), s));

      return [_, _];
    });
  }, t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "GRUCell", t;
}(RNNCell);

_tfjsCore.serialization.registerClass(GRUCell);

var GRU = function (e) {
  function t(t) {
    return 0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new GRUCell(t), e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.call = function (t, n) {
    var r = this;
    return (0, _tfjsCore.tidy)(function () {
      null != r.cell.dropoutMask && ((0, _tfjsCore.dispose)(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && ((0, _tfjsCore.dispose)(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
      var i = null == n ? null : n.mask,
          a = null == n ? null : n.training,
          o = null == n ? null : n.initialState;
      return e.prototype.call.call(r, t, {
        mask: i,
        training: a,
        initialState: o
      });
    });
  }, Object.defineProperty(t.prototype, "units", {
    get: function () {
      return this.cell.units;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "activation", {
    get: function () {
      return this.cell.activation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentActivation", {
    get: function () {
      return this.cell.recurrentActivation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "useBias", {
    get: function () {
      return this.cell.useBias;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelInitializer", {
    get: function () {
      return this.cell.kernelInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentInitializer", {
    get: function () {
      return this.cell.recurrentInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasInitializer", {
    get: function () {
      return this.cell.biasInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelRegularizer", {
    get: function () {
      return this.cell.kernelRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentRegularizer", {
    get: function () {
      return this.cell.recurrentRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasRegularizer", {
    get: function () {
      return this.cell.biasRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelConstraint", {
    get: function () {
      return this.cell.kernelConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentConstraint", {
    get: function () {
      return this.cell.recurrentConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasConstraint", {
    get: function () {
      return this.cell.biasConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "dropout", {
    get: function () {
      return this.cell.dropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentDropout", {
    get: function () {
      return this.cell.recurrentDropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "implementation", {
    get: function () {
      return this.cell.implementation;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    },
        n = e.prototype.getConfig.call(this);
    return delete n.cell, Object.assign(t, n), t;
  }, t.fromConfig = function (e, t) {
    return 0 === t.implmentation && (t.implementation = 1), new e(t);
  }, t.className = "GRU", t;
}(RNN);

_tfjsCore.serialization.registerClass(GRU);

var LSTMCell = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.recurrentActivation = getActivation(void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = getInitializer(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.unitForgetBias = t.unitForgetBias, n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.recurrentRegularizer = getRegularizer(t.recurrentRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.kernelConstraint = getConstraint(t.kernelConstraint), n.recurrentConstraint = getConstraint(t.recurrentConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.dropout = min$1([1, max$1([0, null == t.dropout ? 0 : t.dropout])]), n.recurrentDropout = min$1([1, max$1([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]), n.implementation = t.implementation, n.stateSize = [n.units, n.units], n.dropoutMask = null, n.recurrentDropoutMask = null, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    var t,
        n,
        r = (e = getExactlyOneShape(e))[e.length - 1];

    if (this.kernel = this.addWeight("kernel", [r, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
      if (this.unitForgetBias) {
        var i = this.biasInitializer,
            a = this.units;
        n = new ((t = function (e) {
          function t() {
            return null !== e && e.apply(this, arguments) || this;
          }

          return __extends(t, e), t.prototype.apply = function (e, t) {
            var n = i.apply([a]),
                r = new Ones().apply([a]),
                o = i.apply([2 * a]);
            return concatAlongFirstAxis(concatAlongFirstAxis(n, r), o);
          }, t;
        }(Initializer)).className = "CustomInit", t)();
      } else n = this.biasInitializer;

      this.bias = this.addWeight("bias", [4 * this.units], null, n, this.biasRegularizer, !0, this.biasConstraint);
    } else this.bias = null;

    this.built = !0;
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r = null != t.training && t.training;
      if (3 !== (e = e).length) throw new ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got " + e.length + ".");
      var i = e[1],
          a = e[2];
      e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(e);
      }, n.dropout, r, 4)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = generateDropoutMask(function () {
        return (0, _tfjsCore.onesLike)(i);
      }, n.recurrentDropout, r, 4));
      var o,
          s,
          l,
          u,
          c = n.dropoutMask,
          p = n.recurrentDropoutMask;
      0 < n.dropout && n.dropout < 1 && (e = (0, _tfjsCore.mul)(e, c[0]));
      var h = dot(e, n.kernel.read());
      0 < n.recurrentDropout && n.recurrentDropout < 1 && (i = (0, _tfjsCore.mul)(i, p[0])), h = (0, _tfjsCore.add)(h, dot(i, n.recurrentKernel.read())), n.useBias && (h = biasAdd(h, n.bias.read()));
      var d = (0, _tfjsCore.split)(h, 4, h.rank - 1),
          f = d[0],
          g = d[1],
          m = d[2],
          y = d[3];
      o = n.recurrentActivation.apply(f), s = n.recurrentActivation.apply(g), l = (0, _tfjsCore.add)((0, _tfjsCore.mul)(s, a), (0, _tfjsCore.mul)(o, n.activation.apply(m))), u = n.recurrentActivation.apply(y);
      var v = (0, _tfjsCore.mul)(u, n.activation.apply(l));
      return [v, v, l];
    });
  }, t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      unitForgetBias: this.unitForgetBias,
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.className = "LSTMCell", t;
}(RNNCell);

_tfjsCore.serialization.registerClass(LSTMCell);

var LSTM = function (e) {
  function t(t) {
    return 0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new LSTMCell(t), e.call(this, t) || this;
  }

  return __extends(t, e), t.prototype.call = function (t, n) {
    var r = this;
    return (0, _tfjsCore.tidy)(function () {
      null != r.cell.dropoutMask && ((0, _tfjsCore.dispose)(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && ((0, _tfjsCore.dispose)(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
      var i = null == n ? null : n.mask,
          a = null == n ? null : n.training,
          o = null == n ? null : n.initialState;
      return e.prototype.call.call(r, t, {
        mask: i,
        training: a,
        initialState: o
      });
    });
  }, Object.defineProperty(t.prototype, "units", {
    get: function () {
      return this.cell.units;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "activation", {
    get: function () {
      return this.cell.activation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentActivation", {
    get: function () {
      return this.cell.recurrentActivation;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "useBias", {
    get: function () {
      return this.cell.useBias;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelInitializer", {
    get: function () {
      return this.cell.kernelInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentInitializer", {
    get: function () {
      return this.cell.recurrentInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasInitializer", {
    get: function () {
      return this.cell.biasInitializer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "unitForgetBias", {
    get: function () {
      return this.cell.unitForgetBias;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelRegularizer", {
    get: function () {
      return this.cell.kernelRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentRegularizer", {
    get: function () {
      return this.cell.recurrentRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasRegularizer", {
    get: function () {
      return this.cell.biasRegularizer;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "kernelConstraint", {
    get: function () {
      return this.cell.kernelConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentConstraint", {
    get: function () {
      return this.cell.recurrentConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "biasConstraint", {
    get: function () {
      return this.cell.biasConstraint;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "dropout", {
    get: function () {
      return this.cell.dropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "recurrentDropout", {
    get: function () {
      return this.cell.recurrentDropout;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "implementation", {
    get: function () {
      return this.cell.implementation;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getConfig = function () {
    var t = {
      units: this.units,
      activation: serializeActivation(this.activation),
      recurrentActivation: serializeActivation(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: serializeInitializer(this.kernelInitializer),
      recurrentInitializer: serializeInitializer(this.recurrentInitializer),
      biasInitializer: serializeInitializer(this.biasInitializer),
      unitForgetBias: this.unitForgetBias,
      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
      biasRegularizer: serializeRegularizer(this.biasRegularizer),
      activityRegularizer: serializeRegularizer(this.activityRegularizer),
      kernelConstraint: serializeConstraint(this.kernelConstraint),
      recurrentConstraint: serializeConstraint(this.recurrentConstraint),
      biasConstraint: serializeConstraint(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    },
        n = e.prototype.getConfig.call(this);
    return delete n.cell, Object.assign(t, n), t;
  }, t.fromConfig = function (e, t) {
    return 0 === t.implmentation && (t.implementation = 1), new e(t);
  }, t.className = "LSTM", t;
}(RNN);

_tfjsCore.serialization.registerClass(LSTM);

var StackedRNNCells = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.cells = t.cells, n;
  }

  return __extends(t, e), Object.defineProperty(t.prototype, "stateSize", {
    get: function () {
      for (var e = [], t = 0, n = this.cells.slice().reverse(); t < n.length; t++) {
        var r = n[t];
        Array.isArray(r.stateSize) ? e.push.apply(e, r.stateSize) : e.push(r.stateSize);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      for (var r = (e = e).slice(1), i = [], a = 0, o = n.cells.slice().reverse(); a < o.length; a++) {
        var s = o[a];
        Array.isArray(s.stateSize) ? i.push(r.splice(0, s.stateSize.length)) : i.push(r.splice(0, 1));
      }

      i.reverse();

      for (var l, u = [], c = 0; c < n.cells.length; ++c) {
        s = n.cells[c];
        r = i[c], l = 0 === c ? [e[0]].concat(r) : [l[0]].concat(r), l = s.call(l, t), u.push(l.slice(1));
      }

      r = [];

      for (var p = 0, h = u.slice().reverse(); p < h.length; p++) {
        var d = h[p];
        r.push.apply(r, d);
      }

      return [l[0]].concat(r);
    });
  }, t.prototype.build = function (e) {
    var t;
    isArrayOfShapes(e) && (e = e[0]), e = e, this.cells.forEach(function (n, r) {
      nameScope("RNNCell_" + r, function () {
        n.build(e), t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, e = [e[0], t];
      });
    }), this.built = !0;
  }, t.prototype.getConfig = function () {
    for (var t = [], n = 0, r = this.cells; n < r.length; n++) {
      var i = r[n];
      t.push({
        className: i.getClassName(),
        config: i.getConfig()
      });
    }

    var a = {
      cells: t
    },
        o = e.prototype.getConfig.call(this);
    return Object.assign(a, o), a;
  }, t.fromConfig = function (e, t, n) {
    void 0 === n && (n = {});

    for (var r = [], i = 0, a = t.cells; i < a.length; i++) {
      var o = a[i];
      r.push(deserialize(o, n));
    }

    return new e({
      cells: r
    });
  }, Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      if (!this.trainable) return [];

      for (var e = [], t = 0, n = this.cells; t < n.length; t++) {
        var r = n[t];
        e.push.apply(e, r.trainableWeights);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      for (var e = [], t = 0, n = this.cells; t < n.length; t++) {
        var r = n[t];
        e.push.apply(e, r.nonTrainableWeights);
      }

      if (!this.trainable) {
        for (var i = [], a = 0, o = this.cells; a < o.length; a++) {
          r = o[a];
          i.push.apply(i, r.trainableWeights);
        }

        return i.concat(e);
      }

      return e;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getWeights = function () {
    for (var e = [], t = 0, n = this.cells; t < n.length; t++) {
      var r = n[t];
      e.push.apply(e, r.weights);
    }

    return batchGetValue(e);
  }, t.prototype.setWeights = function (e) {
    for (var t = [], n = 0, r = this.cells; n < r.length; n++) for (var i = r[n], a = i.weights.length, o = e.splice(a), s = 0; s < i.weights.length; ++s) t.push([i.weights[s], o[s]]);

    batchSetValue(t);
  }, t.className = "StackedRNNCells", t;
}(RNNCell);

function generateDropoutMask(e, t, n, r) {
  function i() {
    return dropout$1(e(), t);
  }

  if (void 0 === n && (n = null), void 0 === r && (r = 1), r > 1) {
    for (var a = [], o = 0; o < r; o++) a.push(inTrainPhase(i, e, n));

    return a.map(function (e) {
      return (0, _tfjsCore.keep)(e.clone());
    });
  }

  return (0, _tfjsCore.keep)(inTrainPhase(i, e, n).clone());
}

_tfjsCore.serialization.registerClass(StackedRNNCells);

var Wrapper = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.layer = t.layer, n;
  }

  return __extends(t, e), t.prototype.build = function (e) {
    this.built = !0;
  }, Object.defineProperty(t.prototype, "trainable", {
    get: function () {
      return null != this.layer && this.layer.trainable;
    },
    set: function (e) {
      null != this.layer && (this.layer.trainable = e);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      return this.layer.trainableWeights;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      return this.layer.nonTrainableWeights;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "updates", {
    get: function () {
      return this.layer._updates;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "losses", {
    get: function () {
      return this.layer.losses;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getWeights = function () {
    return this.layer.getWeights();
  }, t.prototype.setWeights = function (e) {
    this.layer.setWeights(e);
  }, t.prototype.getConfig = function () {
    var t = {
      layer: {
        className: this.layer.getClassName(),
        config: this.layer.getConfig()
      }
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.prototype.setFastWeightInitDuringBuild = function (t) {
    e.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.layer && this.layer.setFastWeightInitDuringBuild(t);
  }, t.fromConfig = function (e, t, n) {
    void 0 === n && (n = {});
    var r = deserialize(t.layer, n);
    delete t.layer;
    var i = {
      layer: r
    };
    return Object.assign(i, t), new e(i);
  }, t;
}(Layer),
    TimeDistributed = function (e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.supportsMasking = !0, n;
  }

  return __extends(t, e), t.prototype.build = function (t) {
    if ((t = getExactlyOneShape(t)).length < 3) throw new ValueError("TimeDistributed layer expects an input shape >= 3D, but received input shape " + JSON.stringify(t));
    this.inputSpec = [{
      shape: t
    }];
    var n = [t[0]].concat(t.slice(2));
    this.layer.built || (this.layer.build(n), this.layer.built = !0), e.prototype.build.call(this, t);
  }, t.prototype.computeOutputShape = function (e) {
    var t = [(e = getExactlyOneShape(e))[0]].concat(e.slice(2)),
        n = this.layer.computeOutputShape(t),
        r = e[1];
    return [n[0], r].concat(n.slice(1));
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      return rnn(function (e, r) {
        return [getExactlyOneTensor(n.layer.call(e, t)), []];
      }, e = getExactlyOneTensor(e), [], !1, null, null, !1, !0)[1];
    });
  }, t.className = "TimeDistributed", t;
}(Wrapper);

function checkBidirectionalMergeMode(e) {
  checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES, "BidirectionalMergeMode", e);
}

_tfjsCore.serialization.registerClass(TimeDistributed);

var DEFAULT_BIDIRECTIONAL_MERGE_MODE = "concat",
    Bidirectional = function (e) {
  function t(t) {
    var n = e.call(this, t) || this,
        r = t.layer.getConfig(),
        i = {};
    i.className = t.layer.getClassName(), i.config = r, n.forwardLayer = deserialize(i), r.goBackwards = !0 !== r.goBackwards;
    var a = {};
    if (a.className = t.layer.getClassName(), a.config = r, n.backwardLayer = deserialize(a), n.forwardLayer.name = "forward_" + n.forwardLayer.name, n.backwardLayer.name = "backward_" + n.backwardLayer.name, n.mergeMode = void 0 === t.mergeMode ? DEFAULT_BIDIRECTIONAL_MERGE_MODE : t.mergeMode, checkBidirectionalMergeMode(n.mergeMode), t.weights) throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");
    return n._stateful = t.layer.stateful, n.returnSequences = t.layer.returnSequences, n.returnState = t.layer.returnState, n.supportsMasking = !0, n._trainable = !0, n.inputSpec = t.layer.inputSpec, n.numConstants = null, n;
  }

  return __extends(t, e), Object.defineProperty(t.prototype, "trainable", {
    get: function () {
      return this._trainable;
    },
    set: function (e) {
      this._trainable = e, null != this.forwardLayer && (this.forwardLayer.trainable = e), null != this.backwardLayer && (this.backwardLayer.trainable = e);
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.getWeights = function () {
    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
  }, t.prototype.setWeights = function (e) {
    var t = e.length,
        n = Math.floor(t / 2);
    this.forwardLayer.setWeights(e.slice(0, n)), this.backwardLayer.setWeights(e.slice(n));
  }, t.prototype.computeOutputShape = function (e) {
    var t,
        n,
        r,
        i = this.forwardLayer.computeOutputShape(e);
    return Array.isArray(i) && Array.isArray(i[0]) || (i = [i]), i = i, this.returnState ? (r = i.slice(1), t = i[0]) : t = i[0], t = t, "concat" === this.mergeMode ? (t[t.length - 1] *= 2, n = [t]) : n = null == this.mergeMode ? [t, t.slice()] : [t], this.returnState ? null == this.mergeMode ? n.concat(r).concat(r.slice()) : [t].concat(r).concat(r.slice()) : singletonOrArray(n);
  }, t.prototype.apply = function (t, n) {
    var r = null == n ? null : n.initialState,
        i = null == n ? null : n.constants;
    null == n && (n = {});
    var a = standardizeArgs(t, r, i, this.numConstants);
    if (t = a.inputs, r = a.initialState, i = a.constants, Array.isArray(t) && (r = t.slice(1), t = t[0]), (null == r || 0 === r.length) && null == i) return e.prototype.apply.call(this, t, n);
    var o = [],
        s = [];

    if (null != r) {
      var l = r.length;
      if (l % 2 > 0) throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
      n.initialState = r, o.push.apply(o, r);
      var u = r.map(function (e) {
        return new InputSpec({
          shape: e.shape
        });
      });
      this.forwardLayer.stateSpec = u.slice(0, l / 2), this.backwardLayer.stateSpec = u.slice(l / 2), s.push.apply(s, u);
    }

    if (null != i) throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");

    for (var c = o[0] instanceof SymbolicTensor, p = 0, h = o; p < h.length; p++) {
      if (h[p] instanceof SymbolicTensor !== c) throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
    }

    if (c) {
      var d = [t].concat(o),
          f = this.inputSpec.concat(s),
          g = this.inputSpec;
      this.inputSpec = f;
      var m = e.prototype.apply.call(this, d, n);
      return this.inputSpec = g, m;
    }

    return e.prototype.apply.call(this, t, n);
  }, t.prototype.call = function (e, t) {
    var n = this;
    return (0, _tfjsCore.tidy)(function () {
      var r,
          i,
          a,
          o,
          s = t.initialState;
      if (null == s) r = n.forwardLayer.call(e, t), i = n.backwardLayer.call(e, t);else {
        var l = s.slice(0, s.length / 2),
            u = s.slice(s.length / 2);
        r = n.forwardLayer.call(e, Object.assign(t, {
          initialState: l
        })), i = n.backwardLayer.call(e, Object.assign(t, {
          initialState: u
        }));
      }
      return n.returnState && (Array.isArray(r) && (a = r.slice(1).concat(i.slice(1))), r = r[0], i = i[0]), n.returnSequences && (i = (0, _tfjsCore.reverse)(i, 1)), "concat" === n.mergeMode ? o = concatenate([r, i]) : "sum" === n.mergeMode ? o = (0, _tfjsCore.add)(r, i) : "ave" === n.mergeMode ? o = (0, _tfjsCore.mul)(.5, (0, _tfjsCore.add)(r, i)) : "mul" === n.mergeMode ? o = (0, _tfjsCore.mul)(r, i) : null == n.mergeMode && (o = [r, i]), n.returnState ? null == n.mergeMode ? o.concat(a) : [o].concat(a) : o;
    });
  }, t.prototype.resetStates = function (e) {
    this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
  }, t.prototype.build = function (e) {
    var t = this;
    nameScope(this.forwardLayer.name, function () {
      t.forwardLayer.build(e);
    }), nameScope(this.backwardLayer.name, function () {
      t.backwardLayer.build(e);
    }), this.built = !0;
  }, t.prototype.computeMask = function (e, t) {
    var n;

    if (Array.isArray(t) && (t = t[0]), n = this.returnSequences ? null == this.mergeMode ? [t, t] : t : null == this.mergeMode ? [null, null] : null, this.returnState) {
      var r = this.forwardLayer.states.map(function (e) {
        return null;
      });
      return Array.isArray(n) ? n.concat(r).concat(r) : [n].concat(r).concat(r);
    }

    return n;
  }, Object.defineProperty(t.prototype, "trainableWeights", {
    get: function () {
      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t.prototype, "nonTrainableWeights", {
    get: function () {
      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.setFastWeightInitDuringBuild = function (t) {
    e.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(t), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(t);
  }, t.prototype.getConfig = function () {
    var t = {
      mergeMode: this.mergeMode
    },
        n = e.prototype.getConfig.call(this);
    return Object.assign(t, n), t;
  }, t.fromConfig = function (e, t) {
    var n = deserialize(t.layer);
    if (delete t.layer, null != t.numConstants) throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
    var r = t;
    return r.layer = n, new e(r);
  }, t.className = "Bidirectional", t;
}(Wrapper);

function inputLayer(e) {
  return new InputLayer(e);
}

function elu$2(e) {
  return new ELU(e);
}

function reLU(e) {
  return new ReLU(e);
}

function leakyReLU(e) {
  return new LeakyReLU(e);
}

function prelu$1(e) {
  return new PReLU(e);
}

function softmax$1(e) {
  return new Softmax$1(e);
}

function thresholdedReLU(e) {
  return new ThresholdedReLU(e);
}

function conv1d$2(e) {
  return new Conv1D(e);
}

function conv2d$1(e) {
  return new Conv2D(e);
}

function conv2dTranspose$1(e) {
  return new Conv2DTranspose(e);
}

function conv3d$2(e) {
  return new Conv3D(e);
}

function separableConv2d$1(e) {
  return new SeparableConv2D(e);
}

function cropping2D(e) {
  return new Cropping2D(e);
}

function upSampling2d(e) {
  return new UpSampling2D(e);
}

function depthwiseConv2d$2(e) {
  return new DepthwiseConv2D(e);
}

function activation(e) {
  return new Activation$1(e);
}

function dense(e) {
  return new Dense(e);
}

function dropout$2(e) {
  return new Dropout(e);
}

function spatialDropout1d(e) {
  return new SpatialDropout1D(e);
}

function flatten$1(e) {
  return new Flatten(e);
}

function repeatVector(e) {
  return new RepeatVector(e);
}

function reshape(e) {
  return new Reshape(e);
}

function permute(e) {
  return new Permute(e);
}

function embedding(e) {
  return new Embedding(e);
}

function add$2(e) {
  return new Add(e);
}

function average$1(e) {
  return new Average(e);
}

function concatenate$2(e) {
  return new Concatenate(e);
}

function maximum$2(e) {
  return new Maximum(e);
}

function minimum$2(e) {
  return new Minimum(e);
}

function multiply$1(e) {
  return new Multiply(e);
}

function dot$1(e) {
  return new Dot(e);
}

function batchNormalization$1(e) {
  return new BatchNormalization(e);
}

function layerNormalization(e) {
  return new LayerNormalization(e);
}

function zeroPadding2d(e) {
  return new ZeroPadding2D(e);
}

function averagePooling1d(e) {
  return new AveragePooling1D(e);
}

function avgPool1d(e) {
  return averagePooling1d(e);
}

function avgPooling1d(e) {
  return averagePooling1d(e);
}

function averagePooling2d(e) {
  return new AveragePooling2D(e);
}

function avgPool2d(e) {
  return averagePooling2d(e);
}

function avgPooling2d(e) {
  return averagePooling2d(e);
}

function averagePooling3d(e) {
  return new AveragePooling3D(e);
}

function avgPool3d$1(e) {
  return averagePooling3d(e);
}

function avgPooling3d(e) {
  return averagePooling3d(e);
}

function globalAveragePooling1d(e) {
  return new GlobalAveragePooling1D(e);
}

function globalAveragePooling2d(e) {
  return new GlobalAveragePooling2D(e);
}

function globalMaxPooling1d(e) {
  return new GlobalMaxPooling1D(e);
}

function globalMaxPooling2d(e) {
  return new GlobalMaxPooling2D(e);
}

function maxPooling1d(e) {
  return new MaxPooling1D(e);
}

function maxPooling2d(e) {
  return new MaxPooling2D(e);
}

function maxPooling3d(e) {
  return new MaxPooling3D(e);
}

function gru(e) {
  return new GRU(e);
}

function gruCell(e) {
  return new GRUCell(e);
}

function lstm(e) {
  return new LSTM(e);
}

function lstmCell(e) {
  return new LSTMCell(e);
}

function simpleRNN(e) {
  return new SimpleRNN(e);
}

function simpleRNNCell(e) {
  return new SimpleRNNCell(e);
}

function rnn$1(e) {
  return new RNN(e);
}

function stackedRNNCells(e) {
  return new StackedRNNCells(e);
}

function bidirectional(e) {
  return new Bidirectional(e);
}

function timeDistributed(e) {
  return new TimeDistributed(e);
}

_tfjsCore.serialization.registerClass(Bidirectional);

var globalMaxPool1d = globalMaxPooling1d,
    globalMaxPool2d = globalMaxPooling2d,
    maxPool1d = maxPooling1d,
    maxPool2d = maxPooling2d;

function gaussianNoise(e) {
  return new GaussianNoise(e);
}

function gaussianDropout(e) {
  return new GaussianDropout(e);
}

function alphaDropout(e) {
  return new AlphaDropout(e);
}

function masking(e) {
  return new Masking(e);
}

var exports_layers = Object.freeze({
  inputLayer: inputLayer,
  elu: elu$2,
  reLU: reLU,
  leakyReLU: leakyReLU,
  prelu: prelu$1,
  softmax: softmax$1,
  thresholdedReLU: thresholdedReLU,
  conv1d: conv1d$2,
  conv2d: conv2d$1,
  conv2dTranspose: conv2dTranspose$1,
  conv3d: conv3d$2,
  separableConv2d: separableConv2d$1,
  cropping2D: cropping2D,
  upSampling2d: upSampling2d,
  depthwiseConv2d: depthwiseConv2d$2,
  activation: activation,
  dense: dense,
  dropout: dropout$2,
  spatialDropout1d: spatialDropout1d,
  flatten: flatten$1,
  repeatVector: repeatVector,
  reshape: reshape,
  permute: permute,
  embedding: embedding,
  add: add$2,
  average: average$1,
  concatenate: concatenate$2,
  maximum: maximum$2,
  minimum: minimum$2,
  multiply: multiply$1,
  dot: dot$1,
  batchNormalization: batchNormalization$1,
  layerNormalization: layerNormalization,
  zeroPadding2d: zeroPadding2d,
  averagePooling1d: averagePooling1d,
  avgPool1d: avgPool1d,
  avgPooling1d: avgPooling1d,
  averagePooling2d: averagePooling2d,
  avgPool2d: avgPool2d,
  avgPooling2d: avgPooling2d,
  averagePooling3d: averagePooling3d,
  avgPool3d: avgPool3d$1,
  avgPooling3d: avgPooling3d,
  globalAveragePooling1d: globalAveragePooling1d,
  globalAveragePooling2d: globalAveragePooling2d,
  globalMaxPooling1d: globalMaxPooling1d,
  globalMaxPooling2d: globalMaxPooling2d,
  maxPooling1d: maxPooling1d,
  maxPooling2d: maxPooling2d,
  maxPooling3d: maxPooling3d,
  gru: gru,
  gruCell: gruCell,
  lstm: lstm,
  lstmCell: lstmCell,
  simpleRNN: simpleRNN,
  simpleRNNCell: simpleRNNCell,
  rnn: rnn$1,
  stackedRNNCells: stackedRNNCells,
  bidirectional: bidirectional,
  timeDistributed: timeDistributed,
  globalMaxPool1d: globalMaxPool1d,
  globalMaxPool2d: globalMaxPool2d,
  maxPool1d: maxPool1d,
  maxPool2d: maxPool2d,
  Layer: Layer,
  RNN: RNN,
  RNNCell: RNNCell,
  input: input,
  gaussianNoise: gaussianNoise,
  gaussianDropout: gaussianDropout,
  alphaDropout: alphaDropout,
  masking: masking
});
exports.layers = exports_layers;

function binaryAccuracy$1(e, t) {
  return binaryAccuracy(e, t);
}

function binaryCrossentropy$2(e, t) {
  return binaryCrossentropy$1(e, t);
}

function sparseCategoricalAccuracy$1(e, t) {
  return sparseCategoricalAccuracy(e, t);
}

function categoricalAccuracy$1(e, t) {
  return categoricalAccuracy(e, t);
}

function categoricalCrossentropy$2(e, t) {
  return categoricalCrossentropy$1(e, t);
}

function precision$1(e, t) {
  return precision(e, t);
}

function recall$1(e, t) {
  return recall(e, t);
}

function cosineProximity$1(e, t) {
  return cosineProximity(e, t);
}

function meanAbsoluteError$1(e, t) {
  return meanAbsoluteError(e, t);
}

function meanAbsolutePercentageError$1(e, t) {
  return meanAbsolutePercentageError(e, t);
}

function MAPE$2(e, t) {
  return meanAbsolutePercentageError(e, t);
}

function mape$2(e, t) {
  return meanAbsolutePercentageError(e, t);
}

function meanSquaredError$1(e, t) {
  return meanSquaredError(e, t);
}

function MSE$2(e, t) {
  return meanSquaredError(e, t);
}

function mse$2(e, t) {
  return meanSquaredError(e, t);
}

var exports_metrics = Object.freeze({
  binaryAccuracy: binaryAccuracy$1,
  binaryCrossentropy: binaryCrossentropy$2,
  sparseCategoricalAccuracy: sparseCategoricalAccuracy$1,
  categoricalAccuracy: categoricalAccuracy$1,
  categoricalCrossentropy: categoricalCrossentropy$2,
  precision: precision$1,
  recall: recall$1,
  cosineProximity: cosineProximity$1,
  meanAbsoluteError: meanAbsoluteError$1,
  meanAbsolutePercentageError: meanAbsolutePercentageError$1,
  MAPE: MAPE$2,
  mape: mape$2,
  meanSquaredError: meanSquaredError$1,
  MSE: MSE$2,
  mse: mse$2
}),
    exports_models = Object.freeze({
  modelFromJSON: modelFromJSON
});
exports.models = exports_models;
exports.metrics = exports_metrics;

function l1l2(e) {
  return new L1L2(e);
}

function l1$1(e) {
  return l1(e);
}

function l2$1(e) {
  return l2(e);
}

var exports_regularizers = Object.freeze({
  l1l2: l1l2,
  l1: l1$1,
  l2: l2$1
}),
    Callback = function (e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.model = null, t;
  }

  return __extends(t, e), t.prototype.setModel = function (e) {
    if (!(e instanceof LayersModel)) throw new Error("model must be a LayersModel, not some other Container");
    this.model = e;
  }, t;
}(BaseCallback);

exports.Callback = Callback;
exports.regularizers = exports_regularizers;

function less(e, t) {
  return e < t;
}

function greater$1(e, t) {
  return e > t;
}

var EarlyStopping = function (e) {
  function t(t) {
    var n = e.call(this) || this;
    if (null == t && (t = {}), t.restoreBestWeights) throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");
    return n.monitor = t.monitor || "val_loss", n.minDelta = Math.abs(t.minDelta || 0), n.patience = t.patience || 0, n.verbose = t.verbose || 0, n.mode = t.mode || "auto", n.baseline = t.baseline, -1 === ["auto", "min", "max"].indexOf(n.mode) && (console.warn("EarlyStopping mode '" + n.mode + "' is invalid. Falling back to mode 'auto'."), n.mode = "auto"), "min" === n.mode ? n.monitorFunc = less : "max" === n.mode ? n.monitorFunc = greater$1 : -1 !== n.monitor.indexOf("acc") ? n.monitorFunc = greater$1 : n.monitorFunc = less, n.monitorFunc === less && (n.minDelta *= -1), n;
  }

  return __extends(t, e), t.prototype.onTrainBegin = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return this.wait = 0, this.stoppedEpoch = 0, null != this.baseline ? this.best = this.baseline : this.best = this.monitorFunc === less ? 1 / 0 : -1 / 0, [2];
      });
    });
  }, t.prototype.onEpochEnd = function (e, t) {
    return __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, resolveScalarsInLogs(t)];

          case 1:
            return r.sent(), null == (n = this.getMonitorValue(t)) ? [2] : (this.monitorFunc(n - this.minDelta, this.best) ? (this.best = n, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = e, this.model.stopTraining = !0)), [2]);
        }
      });
    });
  }, t.prototype.onTrainEnd = function (e) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return this.stoppedEpoch > 0 && this.verbose && console.log("Epoch " + this.stoppedEpoch + ": early stopping."), [2];
      });
    });
  }, t.prototype.getMonitorValue = function (e) {
    null == e && (e = {});
    var t = e[this.monitor];
    return null == t && console.warn("Metric for EarlyStopping " + this.monitor + " is not available. Available metrics are: " + Object.keys(e)), t;
  }, t;
}(Callback);

exports.EarlyStopping = EarlyStopping;

function earlyStopping(e) {
  return new EarlyStopping(e);
}

var callbacks = {
  earlyStopping: earlyStopping
};
exports.callbacks = callbacks;
},{"@tensorflow/tfjs-core":"node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js":[function(require,module,exports) {
var global = arguments[3];
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.array = array;
exports.zip = zip;
exports.csv = csv;
exports.func = func;
exports.generator = generator;
exports.microphone = microphone;
exports.webcam = webcam;
exports.version_data = exports.URLDataSource = exports.FileDataSource = exports.TextLineDataset = exports.CSVDataset = exports.Dataset = void 0;

var _tfjsCore = require("@tensorflow/tfjs-core");

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics = function (t, e) {
  return (extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (t, e) {
    t.__proto__ = e;
  } || function (t, e) {
    for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]);
  })(t, e);
};

function __extends(t, e) {
  function r() {
    this.constructor = t;
  }

  extendStatics(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r());
}

function __awaiter(t, e, r, n) {
  return new (r || (r = Promise))(function (i, o) {
    function a(t) {
      try {
        u(n.next(t));
      } catch (t) {
        o(t);
      }
    }

    function s(t) {
      try {
        u(n.throw(t));
      } catch (t) {
        o(t);
      }
    }

    function u(t) {
      t.done ? i(t.value) : new r(function (e) {
        e(t.value);
      }).then(a, s);
    }

    u((n = n.apply(t, e || [])).next());
  });
}

function __generator(t, e) {
  var r,
      n,
      i,
      o,
      a = {
    label: 0,
    sent: function () {
      if (1 & i[0]) throw i[1];
      return i[1];
    },
    trys: [],
    ops: []
  };
  return o = {
    next: s(0),
    throw: s(1),
    return: s(2)
  }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
    return this;
  }), o;

  function s(o) {
    return function (s) {
      return function (o) {
        if (r) throw new TypeError("Generator is already executing.");

        for (; a;) try {
          if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;

          switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
            case 0:
            case 1:
              i = o;
              break;

            case 4:
              return a.label++, {
                value: o[1],
                done: !1
              };

            case 5:
              a.label++, n = o[1], o = [0];
              continue;

            case 7:
              o = a.ops.pop(), a.trys.pop();
              continue;

            default:
              if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                a = 0;
                continue;
              }

              if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                a.label = o[1];
                break;
              }

              if (6 === o[0] && a.label < i[1]) {
                a.label = i[1], i = o;
                break;
              }

              if (i && a.label < i[2]) {
                a.label = i[2], a.ops.push(o);
                break;
              }

              i[2] && a.ops.pop(), a.trys.pop();
              continue;
          }

          o = e.call(t, a);
        } catch (t) {
          o = [6, t], n = 0;
        } finally {
          r = i = 0;
        }

        if (5 & o[0]) throw o[1];
        return {
          value: o[0] ? o[1] : void 0,
          done: !0
        };
      }([o, s]);
    };
  }
}

var commonjsGlobal = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function createCommonjsModule(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}

var alea = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e;
    }

    function i(t, e) {
      var r = new function (t) {
        var e,
            r = this,
            n = (e = 4022871197, function (t) {
          t = t.toString();

          for (var r = 0; r < t.length; r++) {
            var n = .02519603282416938 * (e += t.charCodeAt(r));
            n -= e = n >>> 0, e = (n *= e) >>> 0, e += 4294967296 * (n -= e);
          }

          return 2.3283064365386963e-10 * (e >>> 0);
        });
        r.next = function () {
          var t = 2091639 * r.s0 + 2.3283064365386963e-10 * r.c;
          return r.s0 = r.s1, r.s1 = r.s2, r.s2 = t - (r.c = 0 | t);
        }, r.c = 1, r.s0 = n(" "), r.s1 = n(" "), r.s2 = n(" "), r.s0 -= n(t), r.s0 < 0 && (r.s0 += 1), r.s1 -= n(t), r.s1 < 0 && (r.s1 += 1), r.s2 -= n(t), r.s2 < 0 && (r.s2 += 1), n = null;
      }(t),
          i = e && e.state,
          o = r.next;
      return o.int32 = function () {
        return 4294967296 * r.next() | 0;
      }, o.double = function () {
        return o() + 1.1102230246251565e-16 * (2097152 * o() | 0);
      }, o.quick = o, i && ("object" == typeof i && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.alea = i;
  }(0, t, !1);
}),
    xor128 = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e;
    }

    function i(t, e) {
      var r = new function (t) {
        var e = this,
            r = "";
        e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {
          var t = e.x ^ e.x << 11;
          return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;
        }, t === (0 | t) ? e.x = t : r += t;

        for (var n = 0; n < r.length + 64; n++) e.x ^= 0 | r.charCodeAt(n), e.next();
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && ("object" == typeof i && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.xor128 = i;
  }(0, t, !1);
}),
    xorwow = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e;
    }

    function i(t, e) {
      var r = new function (t) {
        var e = this,
            r = "";
        e.next = function () {
          var t = e.x ^ e.x >>> 2;
          return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;
        }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : r += t;

        for (var n = 0; n < r.length + 64; n++) e.x ^= 0 | r.charCodeAt(n), n == r.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && ("object" == typeof i && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.xorwow = i;
  }(0, t, !1);
}),
    xorshift7 = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.x = t.x.slice(), e.i = t.i, e;
    }

    function i(t, e) {
      null == t && (t = +new Date());

      var r = new function (t) {
        var e = this;
        e.next = function () {
          var t,
              r,
              n = e.x,
              i = e.i;
          return t = n[i], r = (t ^= t >>> 7) ^ t << 24, r ^= (t = n[i + 1 & 7]) ^ t >>> 10, r ^= (t = n[i + 3 & 7]) ^ t >>> 3, r ^= (t = n[i + 4 & 7]) ^ t << 7, t = n[i + 7 & 7], r ^= (t ^= t << 13) ^ t << 9, n[i] = r, e.i = i + 1 & 7, r;
        }, function (t, e) {
          var r,
              n = [];
          if (e === (0 | e)) n[0] = e;else for (e = "" + e, r = 0; r < e.length; ++r) n[7 & r] = n[7 & r] << 15 ^ e.charCodeAt(r) + n[r + 1 & 7] << 13;

          for (; n.length < 8;) n.push(0);

          for (r = 0; r < 8 && 0 === n[r]; ++r);

          for (8 == r ? n[7] = -1 : n[r], t.x = n, t.i = 0, r = 256; r > 0; --r) t.next();
        }(e, t);
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && (i.x && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.xorshift7 = i;
  }(0, t, !1);
}),
    xor4096 = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e;
    }

    function i(t, e) {
      null == t && (t = +new Date());

      var r = new function (t) {
        var e = this;
        e.next = function () {
          var t,
              r,
              n = e.w,
              i = e.X,
              o = e.i;
          return e.w = n = n + 1640531527 | 0, r = i[o + 34 & 127], t = i[o = o + 1 & 127], r ^= r << 13, t ^= t << 17, r ^= r >>> 15, t ^= t >>> 12, r = i[o] = r ^ t, e.i = o, r + (n ^ n >>> 16) | 0;
        }, function (t, e) {
          var r,
              n,
              i,
              o,
              a,
              s = [],
              u = 128;

          for (e === (0 | e) ? (n = e, e = null) : (e += "\0", n = 0, u = Math.max(u, e.length)), i = 0, o = -32; o < u; ++o) e && (n ^= e.charCodeAt((o + 32) % e.length)), 0 === o && (a = n), n ^= n << 10, n ^= n >>> 15, n ^= n << 4, n ^= n >>> 13, o >= 0 && (a = a + 1640531527 | 0, i = 0 == (r = s[127 & o] ^= n + a) ? i + 1 : 0);

          for (i >= 128 && (s[127 & (e && e.length || 0)] = -1), i = 127, o = 512; o > 0; --o) n = s[i + 34 & 127], r = s[i = i + 1 & 127], n ^= n << 13, r ^= r << 17, n ^= n >>> 15, r ^= r >>> 12, s[i] = n ^ r;

          t.w = a, t.X = s, t.i = i;
        }(e, t);
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && (i.X && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.xor4096 = i;
  }(0, t, !1);
}),
    tychei = createCommonjsModule(function (t) {
  !function (t, e, r) {
    function n(t, e) {
      return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e;
    }

    function i(t, e) {
      var r = new function (t) {
        var e = this,
            r = "";
        e.next = function () {
          var t = e.b,
              r = e.c,
              n = e.d,
              i = e.a;
          return t = t << 25 ^ t >>> 7 ^ r, r = r - n | 0, n = n << 24 ^ n >>> 8 ^ i, i = i - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ r, e.c = r = r - n | 0, e.d = n << 16 ^ r >>> 16 ^ i, e.a = i - t | 0;
        }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : r += t;

        for (var n = 0; n < r.length + 20; n++) e.b ^= 0 | r.charCodeAt(n), e.next();
      }(t),
          i = e && e.state,
          o = function () {
        return (r.next() >>> 0) / 4294967296;
      };

      return o.double = function () {
        do {
          var t = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, o.int32 = r.next, o.quick = o, i && ("object" == typeof i && n(i, r), o.state = function () {
        return n(r, {});
      }), o;
    }

    e && e.exports ? e.exports = i : r && r.amd ? r(function () {
      return i;
    }) : this.tychei = i;
  }(0, t, !1);
}),
    seedrandom = createCommonjsModule(function (t) {
  !function (e, r) {
    var n,
        i = this,
        o = 256,
        a = 6,
        s = "random",
        u = r.pow(o, a),
        c = r.pow(2, 52),
        l = 2 * c,
        h = o - 1;

    function f(t, f, v) {
      var _ = [],
          w = p(function t(e, r) {
        var n,
            i = [],
            o = typeof e;
        if (r && "object" == o) for (n in e) try {
          i.push(t(e[n], r - 1));
        } catch (t) {}
        return i.length ? i : "string" == o ? e : e + "\0";
      }((f = 1 == f ? {
        entropy: !0
      } : f || {}).entropy ? [t, m(e)] : null == t ? function () {
        try {
          var t;
          return n && (t = n.randomBytes) ? t = t(o) : (t = new Uint8Array(o), (i.crypto || i.msCrypto).getRandomValues(t)), m(t);
        } catch (t) {
          var r = i.navigator,
              a = r && r.plugins;
          return [+new Date(), i, a, i.screen, m(e)];
        }
      }() : t, 3), _),
          y = new function (t) {
        var e,
            r = t.length,
            n = this,
            i = 0,
            a = n.i = n.j = 0,
            s = n.S = [];
        r || (t = [r++]);

        for (; i < o;) s[i] = i++;

        for (i = 0; i < o; i++) s[i] = s[a = h & a + t[i % r] + (e = s[i])], s[a] = e;

        (n.g = function (t) {
          for (var e, r = 0, i = n.i, a = n.j, s = n.S; t--;) e = s[i = h & i + 1], r = r * o + s[h & (s[i] = s[a = h & a + e]) + (s[a] = e)];

          return n.i = i, n.j = a, r;
        })(o);
      }(_),
          g = function () {
        for (var t = y.g(a), e = u, r = 0; t < c;) t = (t + r) * o, e *= o, r = y.g(1);

        for (; t >= l;) t /= 2, e /= 2, r >>>= 1;

        return (t + r) / e;
      };

      return g.int32 = function () {
        return 0 | y.g(4);
      }, g.quick = function () {
        return y.g(4) / 4294967296;
      }, g.double = g, p(m(y.S), e), (f.pass || v || function (t, e, n, i) {
        return i && (i.S && d(i, y), t.state = function () {
          return d(y, {});
        }), n ? (r[s] = t, e) : t;
      })(g, w, "global" in f ? f.global : this == r, f.state);
    }

    function d(t, e) {
      return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e;
    }

    function p(t, e) {
      for (var r, n = t + "", i = 0; i < n.length;) e[h & i] = h & (r ^= 19 * e[h & i]) + n.charCodeAt(i++);

      return m(e);
    }

    function m(t) {
      return String.fromCharCode.apply(0, t);
    }

    if (r["seed" + s] = f, p(r.random(), e), t.exports) {
      t.exports = f;

      try {
        n = require("crypto");
      } catch (t) {}
    } else 0;
  }([], Math);
});
seedrandom.alea = alea, seedrandom.xor128 = xor128, seedrandom.xorwow = xorwow, seedrandom.xorshift7 = xorshift7, seedrandom.xor4096 = xor4096, seedrandom.tychei = tychei;
var seedrandom$1 = seedrandom,
    seedrandom_1 = seedrandom$1.alea;

function deepMap(t, e) {
  return deepMapInternal(t, e);
}

function deepMapInternal(t, e, r, n) {
  if (void 0 === r && (r = new Map()), void 0 === n && (n = new Set()), null == t) return null;
  if (n.has(t)) throw new Error("Circular references are not supported.");
  if (r.has(t)) return r.get(t);
  var i = e(t);
  if (i.recurse && null !== i.value) throw new Error("A deep map function may not return both a value and recurse=true.");

  if (i.recurse) {
    if (isIterable(t)) {
      var o = Array.isArray(t) ? [] : {};

      for (var a in n.add(t), t) {
        var s = deepMapInternal(t[a], e, r, n);
        o[a] = s;
      }

      return n.delete(t), o;
    }

    throw new Error("Can't recurse into non-iterable type: " + t);
  }

  return r.set(t, i.value), i.value;
}

function deepZip(t, e) {
  return void 0 === e && (e = zipToList), deepZipInternal(t, e);
}

function deepZipInternal(t, e, r) {
  void 0 === r && (r = new Set());
  var n = t[0];
  if (r.has(n)) throw new Error("Circular references are not supported.");
  var i = e(t);
  if (i.recurse && null !== i.value) throw new Error("A deep zip function may not return both a value and recurse=true.");

  if (i.recurse) {
    if (isIterable(n)) {
      var o = Array.isArray(n) ? [] : {};
      r.add(n);

      var a = function (n) {
        var i = deepZipInternal(t.map(function (t) {
          return t[n];
        }), e, r);
        o[n] = i;
      };

      for (var s in n) a(s);

      return r.delete(n), o;
    }

    throw new Error("Can't recurse into non-iterable type: " + n);
  }

  return i.value;
}

function zipToList(t) {
  return null === t ? null : isIterable(t[0]) ? {
    value: null,
    recurse: !0
  } : {
    value: t,
    recurse: !1
  };
}

function deepMapAndAwaitAll(t, e) {
  return __awaiter(this, void 0, void 0, function () {
    var r, n, i, o, a, s;
    return __generator(this, function (u) {
      switch (u.label) {
        case 0:
          r = new Map(), deepMapInternal(t, e, r), n = 0, i = Array.from(r.keys()), u.label = 1;

        case 1:
          return n < i.length ? (o = i[n], (a = r.get(o)) instanceof Promise ? [4, a] : [3, 3]) : [3, 4];

        case 2:
          s = u.sent(), r.set(o, s), u.label = 3;

        case 3:
          return n++, [3, 1];

        case 4:
          return [2, deepMapInternal(t, e, r)];
      }
    });
  });
}

function isIterable(t) {
  return null != t && !ArrayBuffer.isView(t) && (Array.isArray(t) || "object" == typeof t && !(t instanceof _tfjsCore.Tensor));
}

function canTensorify(t) {
  return null == t || isPrimitive(t) || Array.isArray(t) || "object" == typeof t && t instanceof _tfjsCore.Tensor || _tfjsCore.util.isTypedArray(t);
}

function isPrimitive(t) {
  return null === t || "object" != typeof t && "function" != typeof t;
}

function deepClone(t) {
  return deepMap(t, cloneIfTensor);
}

function cloneIfTensor(t) {
  return t instanceof _tfjsCore.Tensor ? {
    value: t.clone(),
    recurse: !1
  } : isIterable(t) ? {
    value: null,
    recurse: !0
  } : {
    value: t,
    recurse: !1
  };
}

var RingBuffer = function () {
  function t(t) {
    if (this.capacity = t, this.begin = 0, this.end = 0, null == t) throw new RangeError("Can't create a ring buffer of unknown capacity.");
    if (t < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
    this.data = new Array(t), this.doubledCapacity = 2 * t;
  }

  return t.prototype.wrap = function (t) {
    for (; t < 0;) t += this.doubledCapacity;

    return t % this.doubledCapacity;
  }, t.prototype.get = function (t) {
    if (t < 0) throw new RangeError("Can't get item at a negative index.");
    return this.data[t % this.capacity];
  }, t.prototype.set = function (t, e) {
    if (t < 0) throw new RangeError("Can't set item at a negative index.");
    this.data[t % this.capacity] = e;
  }, t.prototype.length = function () {
    var t = this.end - this.begin;
    return t < 0 && (t = this.doubledCapacity + t), t;
  }, t.prototype.isFull = function () {
    return this.length() === this.capacity;
  }, t.prototype.isEmpty = function () {
    return 0 === this.length();
  }, t.prototype.push = function (t) {
    if (this.isFull()) throw new RangeError("Ring buffer is full.");
    this.set(this.end, t), this.end = this.wrap(this.end + 1);
  }, t.prototype.pushAll = function (t) {
    for (var e = 0, r = t; e < r.length; e++) {
      var n = r[e];
      this.push(n);
    }
  }, t.prototype.pop = function () {
    if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
    this.end = this.wrap(this.end - 1);
    var t = this.get(this.end);
    return this.set(this.end, void 0), t;
  }, t.prototype.unshift = function (t) {
    if (this.isFull()) throw new RangeError("Ring buffer is full.");
    this.begin = this.wrap(this.begin - 1), this.set(this.begin, t);
  }, t.prototype.shift = function () {
    if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
    var t = this.get(this.begin);
    return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), t;
  }, t.prototype.shuffleExcise = function (t) {
    if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
    var e = this.wrap(this.begin + t),
        r = this.get(e);
    return this.set(e, this.pop()), r;
  }, t;
}(),
    GrowingRingBuffer = function (t) {
  function e() {
    return t.call(this, e.INITIAL_CAPACITY) || this;
  }

  return __extends(e, t), e.prototype.isFull = function () {
    return !1;
  }, e.prototype.push = function (e) {
    t.prototype.isFull.call(this) && this.expand(), t.prototype.push.call(this, e);
  }, e.prototype.unshift = function (e) {
    t.prototype.isFull.call(this) && this.expand(), t.prototype.unshift.call(this, e);
  }, e.prototype.expand = function () {
    for (var t = 2 * this.capacity, e = new Array(t), r = this.length(), n = 0; n < r; n++) e[n] = this.get(this.wrap(this.begin + n));

    this.data = e, this.capacity = t, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = r;
  }, e.INITIAL_CAPACITY = 32, e;
}(RingBuffer);

function iteratorFromItems(t) {
  return new ArrayIterator(t);
}

function iteratorFromFunction(t) {
  return new FunctionCallIterator(t);
}

function iteratorFromConcatenated(t, e) {
  return new ChainedIterator(t, e);
}

function iteratorFromZipped(t, e) {
  return void 0 === e && (e = ZipMismatchMode.FAIL), new ZipIterator(t, e);
}

var ZipMismatchMode,
    LazyIterator = function () {
  function t() {}

  return t.prototype.toArray = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return t = [], [4, this.next()];

          case 1:
            e = r.sent(), r.label = 2;

          case 2:
            return e.done ? [3, 4] : (t.push(e.value), [4, this.next()]);

          case 3:
            return e = r.sent(), [3, 2];

          case 4:
            return [2, t];
        }
      });
    });
  }, t.prototype.toArrayForTest = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return t = this.prefetch(100), e = [], [4, t.next()];

          case 1:
            r = n.sent(), n.label = 2;

          case 2:
            return r.done ? [3, 4] : (e.push(r.value), [4, t.next()]);

          case 3:
            return r = n.sent(), [3, 2];

          case 4:
            return [2, e];
        }
      });
    });
  }, t.prototype.resolveFully = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.next()];

          case 1:
            t = e.sent(), e.label = 2;

          case 2:
            return t.done ? [3, 4] : [4, this.next()];

          case 3:
            return t = e.sent(), [3, 2];

          case 4:
            return [2];
        }
      });
    });
  }, t.prototype.resolveWhile = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      var e, r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.next()];

          case 1:
            e = n.sent(), r = t(e.value), n.label = 2;

          case 2:
            return e.done || !r ? [3, 4] : [4, this.next()];

          case 3:
            return e = n.sent(), r = t(e.value), [3, 2];

          case 4:
            return [2];
        }
      });
    });
  }, t.prototype.handleErrors = function (t) {
    return new ErrorHandlingLazyIterator(this, t);
  }, t.prototype.filter = function (t) {
    return new FilterIterator(this, t);
  }, t.prototype.map = function (t) {
    return new MapIterator(this, t);
  }, t.prototype.mapAsync = function (t) {
    return new AsyncMapIterator(this, t);
  }, t.prototype.serialMapAsync = function (t) {
    return new AsyncMapIterator(this, t).serial();
  }, t.prototype.flatmap = function (t) {
    return new FlatmapIterator(this, t);
  }, t.prototype.forEachAsync = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2, this.map(t).resolveFully()];
      });
    });
  }, t.prototype.serialForEach = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2, this.serialMapAsync(t).resolveWhile(function (t) {
          return !0 === t;
        })];
      });
    });
  }, t.prototype.rowMajorBatch = function (t, e) {
    return void 0 === e && (e = !0), new RowMajorBatchIterator(this, t, e);
  }, t.prototype.columnMajorBatch = function (t, e, r) {
    return void 0 === e && (e = !0), void 0 === r && (r = zipToList), this.rowMajorBatch(t, e).map(function (t) {
      return deepZip(t, r);
    });
  }, t.prototype.concatenate = function (t, e) {
    return new ChainedIterator(iteratorFromItems([this, t]), e);
  }, t.prototype.take = function (t) {
    return t < 0 || null == t ? this : new TakeIterator(this, t);
  }, t.prototype.skip = function (t) {
    return t < 0 || null == t ? this : new SkipIterator(this, t);
  }, t.prototype.prefetch = function (t) {
    return new PrefetchIterator(this, t);
  }, t.prototype.shuffle = function (t, e) {
    return new ShuffleIterator(this, t, e);
  }, t.prototype.serial = function () {
    return new SerialIterator(this);
  }, t;
}(),
    ArrayIterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.items = e, r.trav = 0, r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "Array of " + this.items.length + " items";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        return this.trav >= this.items.length ? [2, {
          value: null,
          done: !0
        }] : (t = this.items[this.trav], this.trav++, [2, {
          value: deepClone(t),
          done: !1
        }]);
      });
    });
  }, e;
}(LazyIterator),
    FunctionCallIterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.nextFn = e, r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "Function call";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        try {
          return [2, this.nextFn()];
        } catch (t) {
          throw t.message = "Error thrown while iterating through a dataset: " + t.message, t;
        }

        return [2];
      });
    });
  }, e;
}(LazyIterator),
    SerialIterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.upstream = e, r.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Serial";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return [2, this.upstream.next()];
      });
    });
  }, e;
}(LazyIterator),
    SkipIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.maxCount = r, n.count = 0, n.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Skip";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return this.count++ < this.maxCount ? [4, this.upstream.next()] : [3, 2];

          case 1:
            return (t = e.sent()).done ? [2, t] : ((0, _tfjsCore.dispose)(t.value), [3, 0]);

          case 2:
            return [2, this.upstream.next()];
        }
      });
    });
  }, e;
}(LazyIterator),
    TakeIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.maxCount = r, n.count = 0, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Take";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return this.count++ >= this.maxCount ? [2, {
          value: null,
          done: !0
        }] : [2, this.upstream.next()];
      });
    });
  }, e;
}(LazyIterator),
    RowMajorBatchIterator = function (t) {
  function e(e, r, n) {
    void 0 === n && (n = !0);
    var i = t.call(this) || this;
    return i.upstream = e, i.batchSize = r, i.enableSmallLastBatch = n, i.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), i;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> RowMajorBatch";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            t = [], r.label = 1;

          case 1:
            return t.length < this.batchSize ? [4, this.upstream.next()] : [3, 3];

          case 2:
            return (e = r.sent()).done ? this.enableSmallLastBatch && t.length > 0 ? [2, {
              value: t,
              done: !1
            }] : [2, {
              value: null,
              done: !0
            }] : (t.push(e.value), [3, 1]);

          case 3:
            return [2, {
              value: t,
              done: !1
            }];
        }
      });
    });
  }, e;
}(LazyIterator),
    FilterIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.predicate = r, n.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Filter";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            return (t = e.sent()).done || this.predicate(t.value) ? [2, t] : ((0, _tfjsCore.dispose)(t.value), [3, 0]);

          case 2:
            return [2];
        }
      });
    });
  }, e;
}(LazyIterator),
    MapIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.transform = r, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Map";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i, o, a;
      return __generator(this, function (s) {
        switch (s.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            if ((t = s.sent()).done) return [2, {
              value: null,
              done: !0
            }];

            for (e = _tfjsCore.tensor_util.getTensorsInContainer(t.value), r = this.transform(t.value), n = _tfjsCore.tensor_util.getTensorsInContainer(r), i = 0, o = e; i < o.length; i++) a = o[i], _tfjsCore.tensor_util.isTensorInList(a, n) || a.dispose();

            return [2, {
              value: r,
              done: !1
            }];
        }
      });
    });
  }, e;
}(LazyIterator),
    ErrorHandlingLazyIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.handler = r, n.count = 0, n.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> handleErrors";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            e.label = 1;

          case 1:
            return e.trys.push([1, 3,, 4]), [4, this.upstream.next()];

          case 2:
            return [2, e.sent()];

          case 3:
            return t = e.sent(), this.handler(t) ? [3, 4] : [2, {
              value: null,
              done: !0
            }];

          case 4:
            return [3, 0];

          case 5:
            return [2];
        }
      });
    });
  }, e;
}(LazyIterator),
    AsyncMapIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.transform = r, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> AsyncMap";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i, o, a;
      return __generator(this, function (s) {
        switch (s.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            return (t = s.sent()).done ? [2, {
              value: null,
              done: !0
            }] : (e = _tfjsCore.tensor_util.getTensorsInContainer(t.value), [4, this.transform(t.value)]);

          case 2:
            for (r = s.sent(), n = _tfjsCore.tensor_util.getTensorsInContainer(r), i = 0, o = e; i < o.length; i++) a = o[i], _tfjsCore.tensor_util.isTensorInList(a, n) || a.dispose();

            return [2, {
              value: r,
              done: !1
            }];
        }
      });
    });
  }, e;
}(LazyIterator),
    OneToManyIterator = function (t) {
  function e() {
    var e = t.call(this) || this;
    return e.outputQueue = new GrowingRingBuffer(), e.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), e;
  }

  return __extends(e, t), e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return 0 !== this.outputQueue.length() ? [3, 2] : [4, this.pump()];

          case 1:
            return t.sent() ? [3, 0] : [2, {
              value: null,
              done: !0
            }];

          case 2:
            return [2, {
              value: this.outputQueue.shift(),
              done: !1
            }];
        }
      });
    });
  }, e;
}(LazyIterator),
    FlatmapIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.transform = r, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Flatmap";
  }, e.prototype.pump = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i, o, a;
      return __generator(this, function (s) {
        switch (s.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            if ((t = s.sent()).done) return [2, !1];

            for (e = _tfjsCore.tensor_util.getTensorsInContainer(t.value), r = this.transform(t.value), n = _tfjsCore.tensor_util.getTensorsInContainer(r), this.outputQueue.pushAll(r), i = 0, o = e; i < o.length; i++) a = o[i], _tfjsCore.tensor_util.isTensorInList(a, n) || a.dispose();

            return [2, !0];
        }
      });
    });
  }, e;
}(OneToManyIterator),
    ChainedIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.baseErrorHandler = r, n.lastRead = null, n.iterator = null, n.moreIterators = e, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "TODO: fill in upstream of chained summaries -> Chained";
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return this.lastRead = this.readFromChain(this.lastRead), [2, this.lastRead];
      });
    });
  }, e.prototype.readFromChain = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      var e, r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, t];

          case 1:
            return n.sent(), null != this.iterator ? [3, 3] : [4, this.moreIterators.next()];

          case 2:
            if ((e = n.sent()).done) return [2, {
              value: null,
              done: !0
            }];
            this.iterator = e.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler)), n.label = 3;

          case 3:
            return [4, this.iterator.next()];

          case 4:
            return (r = n.sent()).done ? (this.iterator = null, [2, this.readFromChain(t)]) : [2, r];
        }
      });
    });
  }, e;
}(LazyIterator);

!function (t) {
  t[t.FAIL = 0] = "FAIL", t[t.SHORTEST = 1] = "SHORTEST", t[t.LONGEST = 2] = "LONGEST";
}(ZipMismatchMode || (ZipMismatchMode = {}));

var ZipIterator = function (t) {
  function e(e, r) {
    void 0 === r && (r = ZipMismatchMode.FAIL);
    var n = t.call(this) || this;
    return n.iterators = e, n.mismatchMode = r, n.count = 0, n.currentPromise = null, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "{TODO: fill in upstream of zip summaries} -> Zip";
  }, e.prototype.nextState = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      function e(t) {
        return t instanceof LazyIterator ? {
          value: t.next().then(function (t) {
            return r++, t.done && n++, t.value;
          }),
          recurse: !1
        } : {
          value: null,
          recurse: !0
        };
      }

      var r, n, i;
      return __generator(this, function (o) {
        switch (o.label) {
          case 0:
            return [4, t];

          case 1:
            return o.sent(), r = 0, n = 0, [4, deepMapAndAwaitAll(this.iterators, e)];

          case 2:
            if (i = o.sent(), r === n) return [2, {
              value: null,
              done: !0
            }];
            if (n > 0) switch (this.mismatchMode) {
              case ZipMismatchMode.FAIL:
                throw new Error("Zipped streams should have the same length. Mismatched at element " + this.count + ".");

              case ZipMismatchMode.SHORTEST:
                return [2, {
                  value: null,
                  done: !0
                }];

              case ZipMismatchMode.LONGEST:
            }
            return this.count++, [2, {
              value: i,
              done: !1
            }];
        }
      });
    });
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return this.currentPromise = this.nextState(this.currentPromise), [2, this.currentPromise];
      });
    });
  }, e;
}(LazyIterator),
    PrefetchIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.bufferSize = r, n.buffer = new RingBuffer(r), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Prefetch";
  }, e.prototype.refill = function () {
    for (; !this.buffer.isFull();) {
      var t = this.upstream.next();
      this.buffer.push(t);
    }
  }, e.prototype.next = function () {
    return this.refill(), this.buffer.shift();
  }, e;
}(LazyIterator),
    ShuffleIterator = function (t) {
  function e(e, r, n) {
    var i = t.call(this, e, r) || this;
    return i.upstream = e, i.windowSize = r, i.upstreamExhausted = !1, i.random = seedrandom_1(n || _tfjsCore.util.now().toString()), i.lastRead = Promise.resolve({
      value: null,
      done: !1
    }), i;
  }

  return __extends(e, t), e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t = this;
      return __generator(this, function (e) {
        return this.lastRead = this.lastRead.then(function () {
          return t.serialNext();
        }), [2, this.lastRead];
      });
    });
  }, e.prototype.randomInt = function (t) {
    return Math.floor(this.random() * t);
  }, e.prototype.chooseIndex = function () {
    return this.randomInt(this.buffer.length());
  }, e.prototype.serialNext = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            this.upstreamExhausted || this.refill(), r.label = 1;

          case 1:
            return this.buffer.isEmpty() ? [3, 3] : (t = this.chooseIndex(), [4, this.buffer.shuffleExcise(t)]);

          case 2:
            return (e = r.sent()).done ? (this.upstreamExhausted = !0, [3, 1]) : (this.refill(), [2, e]);

          case 3:
            return [2, {
              value: null,
              done: !0
            }];
        }
      });
    });
  }, e;
}(PrefetchIterator),
    Dataset = function () {
  function t() {
    this.size = null;
  }

  return t.prototype.batch = function (t, e) {
    var r = this;
    void 0 === e && (e = !0);
    var n = this;
    return _tfjsCore.util.assert(t > 0, function () {
      return "batchSize needs to be positive, but it is\n      " + t;
    }), datasetFromIteratorFn(function () {
      return __awaiter(r, void 0, void 0, function () {
        return __generator(this, function (r) {
          switch (r.label) {
            case 0:
              return [4, n.iterator()];

            case 1:
              return [2, r.sent().columnMajorBatch(t, e, deepBatchConcat)];
          }
        });
      });
    }, this.size === 1 / 0 || null == this.size ? this.size : e ? Math.ceil(this.size / t) : Math.floor(this.size / t));
  }, t.prototype.concatenate = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        var e, n;
        return __generator(this, function (i) {
          switch (i.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return n = (e = i.sent()).concatenate, [4, t.iterator()];

            case 2:
              return [2, n.apply(e, [i.sent()])];
          }
        });
      });
    }, this.size === 1 / 0 || t.size === 1 / 0 ? 1 / 0 : null != this.size && null != t.size ? this.size + t.size : null);
  }, t.prototype.filter = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().filter(function (e) {
                return (0, _tfjsCore.tidy)(function () {
                  return t(e);
                });
              })];
          }
        });
      });
    }, this.size === 1 / 0 ? 1 / 0 : null);
  }, t.prototype.forEachAsync = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.iterator()];

          case 1:
            return [2, e.sent().forEachAsync(t)];
        }
      });
    });
  }, t.prototype.forEach = function (t) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (e) {
        return (0, _tfjsCore.deprecationWarn)("dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"), [2, this.forEachAsync(t)];
      });
    });
  }, t.prototype.map = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().map(function (e) {
                return (0, _tfjsCore.tidy)(function () {
                  return t(e);
                });
              })];
          }
        });
      });
    }, this.size);
  }, t.prototype.mapAsync = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().mapAsync(t)];
          }
        });
      });
    }, this.size);
  }, t.prototype.prefetch = function (t) {
    var e = this;
    if (null == t) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
    var r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().prefetch(t)];
          }
        });
      });
    }, this.size);
  }, t.prototype.repeat = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        var e = this;
        return __generator(this, function (n) {
          return [2, iteratorFromConcatenated(iteratorFromFunction(function () {
            return __awaiter(e, void 0, void 0, function () {
              var t;
              return __generator(this, function (e) {
                switch (e.label) {
                  case 0:
                    return t = {}, [4, r.iterator()];

                  case 1:
                    return [2, (t.value = e.sent(), t.done = !1, t)];
                }
              });
            });
          }).take(t))];
        });
      });
    }, null != this.size && t > 0 ? this.size * t : 0 === t ? 0 : null != this.size && (void 0 === t || t < 0) ? 1 / 0 : null);
  }, t.prototype.skip = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().skip(t)];
          }
        });
      });
    }, null != this.size && t >= 0 && this.size >= t ? this.size - t : null != this.size && (this.size < t || void 0 === t || t < 0) ? 0 : null);
  }, t.prototype.shuffle = function (t, e, r) {
    var n = this;
    if (void 0 === r && (r = !0), null == t || t < 0) throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (" + this.size + " elements)");
    var i = this,
        o = seedrandom_1(e || _tfjsCore.util.now().toString());
    return datasetFromIteratorFn(function () {
      return __awaiter(n, void 0, void 0, function () {
        var e;
        return __generator(this, function (n) {
          switch (n.label) {
            case 0:
              return e = o.int32(), r && (e += o.int32()), [4, i.iterator()];

            case 1:
              return [2, n.sent().shuffle(t, e.toString())];
          }
        });
      });
    }, this.size);
  }, t.prototype.take = function (t) {
    var e = this,
        r = this;
    return datasetFromIteratorFn(function () {
      return __awaiter(e, void 0, void 0, function () {
        return __generator(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, r.iterator()];

            case 1:
              return [2, e.sent().take(t)];
          }
        });
      });
    }, null != this.size && this.size > t ? t : null != this.size && this.size <= t ? this.size : null);
  }, t.prototype.toArray = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
            return [4, this.iterator()];

          case 1:
            return [2, t.sent().toArray()];
        }
      });
    });
  }, t.prototype.toArrayForTest = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
            return [4, this.iterator()];

          case 1:
            return [2, t.sent().toArrayForTest()];
        }
      });
    });
  }, t.MAX_BUFFER_SIZE = 1e4, t;
}();

exports.Dataset = Dataset;

function datasetFromIteratorFn(t, e) {
  return void 0 === e && (e = null), new (function (r) {
    function n() {
      var t = null !== r && r.apply(this, arguments) || this;
      return t.size = e, t;
    }

    return __extends(n, r), n.prototype.iterator = function () {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (e) {
          return [2, t()];
        });
      });
    }, n;
  }(Dataset))();
}

function array(t) {
  var e = this;
  return datasetFromIteratorFn(function () {
    return __awaiter(e, void 0, void 0, function () {
      return __generator(this, function (e) {
        return [2, iteratorFromItems(t)];
      });
    });
  }, t.length);
}

function zip(t) {
  var e,
      r = this;
  if (!isIterable(t)) throw new Error("The argument to zip() must be an object or array.");
  if (Array.isArray(t)) for (var n = 0; n < t.length; n++) e = null == e ? t[n].size : Math.min(e, t[n].size);else if (t instanceof Object) for (var i in t) e = null == e ? t[i].size : Math.min(e, t[i].size);
  return datasetFromIteratorFn(function () {
    return __awaiter(r, void 0, void 0, function () {
      return __generator(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, deepMapAndAwaitAll(t, function (t) {
              if (t instanceof Dataset) return {
                value: t.iterator(),
                recurse: !1
              };
              if (isIterable(t)) return {
                value: null,
                recurse: !0
              };
              throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
            })];

          case 1:
            return [2, iteratorFromZipped(e.sent(), ZipMismatchMode.SHORTEST)];
        }
      });
    });
  }, e);
}

function deepBatchConcat(t) {
  return null === t ? null : canTensorify(t[0]) ? {
    value: batchConcat(t),
    recurse: !1
  } : {
    value: null,
    recurse: !0
  };
}

function batchConcat(t) {
  if (0 === t.length) throw new Error("Can't make a batch of zero elements.");
  return t[0] instanceof _tfjsCore.Tensor ? (0, _tfjsCore.stack)(t) : (0, _tfjsCore.tensor)(t);
}

var TextLineDataset = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.input = e, r;
  }

  return __extends(e, t), e.prototype.iterator = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, this.input.iterator()];

          case 1:
            return t = r.sent(), e = t.decodeUTF8(), [2, e.split("\n").map(function (t) {
              return t.endsWith("\r") && (t = t.slice(0, -1)), t;
            })];
        }
      });
    });
  }, e;
}(Dataset),
    CODE_QUOTE = '"',
    STATE_OUT = Symbol("out"),
    STATE_FIELD = Symbol("field"),
    STATE_QUOTE = Symbol("quote"),
    STATE_QUOTE_AFTER_QUOTE = Symbol("quoteafterquote"),
    STATE_WITHIN_QUOTE_IN_QUOTE = Symbol("quoteinquote"),
    CSVDataset = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.input = e, n.hasHeader = !0, n.fullColumnNames = null, n.columnNamesValidated = !1, n.columnConfigs = null, n.configuredColumnsOnly = !1, n.delimiter = ",", n.delimWhitespace = !1, n.base = new TextLineDataset(e), r || (r = {}), n.hasHeader = !1 !== r.hasHeader, n.fullColumnNames = r.columnNames, n.columnConfigs = r.columnConfigs, n.configuredColumnsOnly = r.configuredColumnsOnly, r.delimWhitespace ? (_tfjsCore.util.assert(null == r.delimiter, function () {
      return "Delimiter should not be provided when delimWhitespace is true.";
    }), n.delimWhitespace = !0, n.delimiter = " ") : n.delimiter = r.delimiter ? r.delimiter : ",", n;
  }

  return __extends(e, t), e.prototype.columnNames = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];

          case 1:
            t.sent(), t.label = 2;

          case 2:
            return [2, this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames];
        }
      });
    });
  }, e.prototype.setColumnNames = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e,
          r,
          n,
          i,
          o,
          a = this;
      return __generator(this, function (s) {
        switch (s.label) {
          case 0:
            return [4, this.maybeReadHeaderLine()];

          case 1:
            if (t = s.sent(), !this.fullColumnNames && !t) throw new Error("Column names must be provided if there is no header line.");
            if (this.fullColumnNames && t && _tfjsCore.util.assert(t.length === this.fullColumnNames.length, function () {
              return "The length of provided columnNames (" + a.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t.length.toString() + ").";
            }), this.fullColumnNames || (this.fullColumnNames = t), e = this.fullColumnNames.reduce(function (t, e) {
              return t[e] = t[e] + 1 || 1, t;
            }, {}), r = Object.keys(e).filter(function (t) {
              return e[t] > 1;
            }), _tfjsCore.util.assert(0 === r.length, function () {
              return "Duplicate column names found: " + r.toString();
            }), this.columnConfigs) for (n = 0, i = Object.keys(this.columnConfigs); n < i.length; n++) if (o = i[n], -1 === this.fullColumnNames.indexOf(o)) throw new Error('The key "' + o + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
            return this.columnNamesValidated = !0, [2];
        }
      });
    });
  }, e.prototype.maybeReadHeaderLine = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return this.hasHeader ? [4, this.base.iterator()] : [3, 3];

          case 1:
            return [4, r.sent().next()];

          case 2:
            if ((t = r.sent()).done) throw new Error("No data was found for CSV parsing.");
            return e = t.value, [2, this.parseRow(e, !1)];

          case 3:
            return [2, null];
        }
      });
    });
  }, e.prototype.iterator = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e = this;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];

          case 1:
            r.sent(), r.label = 2;

          case 2:
            return [4, this.base.iterator()];

          case 3:
            return t = r.sent(), this.hasHeader && (t = t.skip(1)), [2, t.map(function (t) {
              return e.makeDataElement(t);
            })];
        }
      });
    });
  }, e.prototype.makeDataElement = function (t) {
    for (var e = this.parseRow(t), r = {}, n = {}, i = 0; i < this.fullColumnNames.length; i++) {
      var o = this.fullColumnNames[i],
          a = this.columnConfigs ? this.columnConfigs[o] : null;

      if (!this.configuredColumnsOnly || a) {
        var s = e[i],
            u = null;
        if ("" === s) {
          if (a && void 0 !== a.default) u = a.default;else {
            if (a && (a.required || a.isLabel)) throw new Error("Required column " + o + " is empty in this line: " + t);
            u = void 0;
          }
        } else {
          var c = Number(s);
          if (isNaN(c)) u = a && "bool" === a.dtype ? this.getBoolean(s) : s;else if (a && a.dtype) switch (a.dtype) {
            case "float32":
              u = c;
              break;

            case "int32":
              u = Math.floor(c);
              break;

            case "bool":
              u = this.getBoolean(s);
              break;

            default:
              u = c;
          } else u = c;
        }
        a && a.isLabel ? n[o] = u : r[o] = u;
      }
    }

    return 0 === Object.keys(n).length ? r : {
      xs: r,
      ys: n
    };
  }, e.prototype.getBoolean = function (t) {
    return "1" === t || "true" === t.toLowerCase() ? 1 : 0;
  }, e.prototype.parseRow = function (t, e) {
    void 0 === e && (e = !0);

    for (var r = [], n = 0, i = t.length, o = STATE_OUT, a = 0; a < i; a++) switch (o) {
      case STATE_OUT:
        switch (t.charAt(a)) {
          case CODE_QUOTE:
            n = a + 1, o = STATE_QUOTE;
            break;

          case this.delimiter:
            if (n = a + 1, " " === this.delimiter && this.delimWhitespace) break;
            r.push(""), o = STATE_OUT;
            break;

          default:
            o = STATE_FIELD, n = a;
        }

        break;

      case STATE_FIELD:
        switch (t.charAt(a)) {
          case this.delimiter:
            r.push(t.substring(n, a)), o = STATE_OUT, n = a + 1;
        }

        break;

      case STATE_QUOTE:
        switch (t.charAt(a)) {
          case CODE_QUOTE:
            o = STATE_QUOTE_AFTER_QUOTE;
        }

        break;

      case STATE_QUOTE_AFTER_QUOTE:
        switch (t.charAt(a)) {
          case this.delimiter:
            r.push(t.substring(n, a - 1)), o = STATE_OUT, n = a + 1;
            break;

          case CODE_QUOTE:
            o = STATE_QUOTE;
            break;

          default:
            o = STATE_WITHIN_QUOTE_IN_QUOTE;
        }

        break;

      case STATE_WITHIN_QUOTE_IN_QUOTE:
        switch (t.charAt(a)) {
          case CODE_QUOTE:
            o = STATE_QUOTE;
        }

    }

    if (o === STATE_QUOTE_AFTER_QUOTE ? r.push(t.substring(n, i - 1)) : r.push(t.substring(n)), e && r.length !== this.fullColumnNames.length) throw new Error("Invalid row in csv file. Should have " + this.fullColumnNames.length + " elements in a row, but got " + r);
    return r;
  }, e;
}(Dataset),
    MicrophoneIterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    r.microphoneConfig = e, r.isClosed = !1, r.fftSize = e.fftSize || 1024;
    var n = Math.log2(r.fftSize);
    if (r.fftSize < 0 || n < 4 || n > 14 || !Number.isInteger(n)) throw new Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got " + r.fftSize);
    if (r.numFrames = e.numFramesPerSpectrogram || 43, r.sampleRateHz = e.sampleRateHz, r.columnTruncateLength = e.columnTruncateLength || r.fftSize, r.audioTrackConstraints = e.audioTrackConstraints, r.smoothingTimeConstant = e.smoothingTimeConstant || 0, r.includeSpectrogram = !1 !== e.includeSpectrogram, r.includeWaveform = !0 === e.includeWaveform, !r.includeSpectrogram && !r.includeWaveform) throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
    return r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "microphone";
  }, e.create = function (t) {
    return void 0 === t && (t = {}), __awaiter(this, void 0, void 0, function () {
      var r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            if ((0, _tfjsCore.env)().get("IS_NODE")) throw new Error("microphone API is only supported in browser environment.");
            return [4, (r = new e(t)).start()];

          case 1:
            return n.sent(), [2, r];
        }
      });
    });
  }, e.prototype.start = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            return i.trys.push([0, 2,, 3]), t = this, [4, navigator.mediaDevices.getUserMedia({
              audio: null == this.audioTrackConstraints || this.audioTrackConstraints,
              video: !1
            })];

          case 1:
            return t.stream = i.sent(), [3, 3];

          case 2:
            throw e = i.sent(), new Error("Error thrown while initializing video stream: " + e.message);

          case 3:
            if (!this.stream) throw new Error("Could not obtain audio from microphone.");

            if (r = window.AudioContext || window.webkitAudioContext, this.audioContext = new r(), this.sampleRateHz) {
              if (this.audioContext.sampleRate !== this.sampleRateHz) throw new Error("Mismatch in sampling rate: Expected: " + this.sampleRateHz + "; Actual: " + this.audioContext.sampleRate);
            } else this.sampleRateHz = this.audioContext.sampleRate;

            return n = this.audioContext.createMediaStreamSource(this.stream), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2 * this.fftSize, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, n.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize), [2];
        }
      });
    });
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i;
      return __generator(this, function (o) {
        switch (o.label) {
          case 0:
            return this.isClosed ? [2, {
              value: null,
              done: !0
            }] : [4, this.getAudioData()];

          case 1:
            return r = o.sent(), this.includeSpectrogram && (n = this.flattenQueue(r.freqDataQueue), t = this.getTensorFromAudioDataArray(n, [this.numFrames, this.columnTruncateLength, 1])), this.includeWaveform && (i = this.flattenQueue(r.timeDataQueue), e = this.getTensorFromAudioDataArray(i, [this.numFrames * this.fftSize, 1])), [2, {
              value: {
                spectrogram: t,
                waveform: e
              },
              done: !1
            }];
        }
      });
    });
  }, e.prototype.capture = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.next()];

          case 1:
            return [2, t.sent().value];
        }
      });
    });
  }, e.prototype.getAudioData = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e,
          r,
          n = this;
      return __generator(this, function (i) {
        return t = [], e = [], r = 0, [2, new Promise(function (i) {
          var o = setInterval(function () {
            n.includeSpectrogram && (n.analyser.getFloatFrequencyData(n.freqData), n.freqData[0] === -1 / 0 && i({
              freqDataQueue: t,
              timeDataQueue: e
            }), t.push(n.freqData.slice(0, n.columnTruncateLength))), n.includeWaveform && (n.analyser.getFloatTimeDomainData(n.timeData), e.push(n.timeData.slice())), ++r === n.numFrames && (clearInterval(o), i({
              freqDataQueue: t,
              timeDataQueue: e
            }));
          }, n.fftSize / n.sampleRateHz * 1e3);
        })];
      });
    });
  }, e.prototype.stop = function () {
    this.isClosed || (this.isClosed = !0, this.analyser.disconnect(), this.audioContext.close(), null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop());
  }, e.prototype.toArray = function () {
    throw new Error("Can not convert infinite audio stream to array.");
  }, e.prototype.getSampleRate = function () {
    return this.sampleRateHz;
  }, e.prototype.flattenQueue = function (t) {
    var e = t[0].length,
        r = new Float32Array(t.length * e);
    return t.forEach(function (t, n) {
      return r.set(t, n * e);
    }), r;
  }, e.prototype.getTensorFromAudioDataArray = function (t, e) {
    var r = new Float32Array(_tfjsCore.util.sizeFromShape(e));
    return r.set(t, r.length - t.length), (0, _tfjsCore.tensor)(r, e);
  }, e;
}(LazyIterator),
    WebcamIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    if (n.webcamVideoElement = e, n.webcamConfig = r, n.isClosed = !0, n.resize = !1, n.needToResize()) if (n.resize = !0, n.cropSize = [n.webcamConfig.resizeHeight, n.webcamConfig.resizeWidth], n.cropBoxInd = (0, _tfjsCore.tensor1d)([0], "int32"), n.webcamConfig.centerCrop) {
      var i = 1 * n.webcamConfig.resizeWidth / n.webcamVideoElement.width,
          o = 1 * n.webcamConfig.resizeHeight / n.webcamVideoElement.height,
          a = (1 - i) / 2,
          s = (1 - o) / 2,
          u = a + i,
          c = o + s;
      n.cropBox = (0, _tfjsCore.tensor2d)([s, a, c, u], [1, 4]);
    } else n.cropBox = (0, _tfjsCore.tensor2d)([0, 0, 1, 1], [1, 4]);
    return n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "webcam";
  }, e.create = function (t, r) {
    return void 0 === r && (r = {}), __awaiter(this, void 0, void 0, function () {
      var n;
      return __generator(this, function (i) {
        switch (i.label) {
          case 0:
            if ((0, _tfjsCore.env)().get("IS_NODE")) throw new Error("tf.data.webcam is only supported in browser environment.");

            if (!t) {
              if (t = document.createElement("video"), !r.resizeWidth || !r.resizeHeight) throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
              t.width = r.resizeWidth, t.height = r.resizeHeight;
            }

            return [4, (n = new e(t, r)).start()];

          case 1:
            return i.sent(), [2, n];
        }
      });
    });
  }, e.prototype.start = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e,
          r = this;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            this.webcamConfig.facingMode && _tfjsCore.util.assert("user" === this.webcamConfig.facingMode || "environment" === this.webcamConfig.facingMode, function () {
              return "Invalid webcam facing mode: " + r.webcamConfig.facingMode + ". Please provide 'user' or 'environment'";
            }), n.label = 1;

          case 1:
            return n.trys.push([1, 3,, 4]), t = this, [4, navigator.mediaDevices.getUserMedia({
              video: {
                deviceId: this.webcamConfig.deviceId,
                facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
                width: this.webcamVideoElement.width,
                height: this.webcamVideoElement.height
              }
            })];

          case 2:
            return t.stream = n.sent(), [3, 4];

          case 3:
            throw (e = n.sent()).message = "Error thrown while initializing video stream: " + e.message, e;

          case 4:
            if (!this.stream) throw new Error("Could not obtain video from webcam.");

            try {
              this.webcamVideoElement.srcObject = this.stream;
            } catch (t) {
              console.log(t), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
            }

            return this.webcamVideoElement.play(), this.isClosed = !1, [2, new Promise(function (t) {
              r.webcamVideoElement.onloadedmetadata = function () {
                t();
              };
            })];
        }
      });
    });
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        if (this.isClosed) return [2, {
          value: null,
          done: !0
        }];

        try {
          t = _tfjsCore.browser.fromPixels(this.webcamVideoElement);
        } catch (t) {
          throw new Error("Error thrown converting video to pixels: " + JSON.stringify(t));
        }

        if (!this.resize) return [2, {
          value: t,
          done: !1
        }];

        try {
          return [2, {
            value: this.cropAndResizeFrame(t),
            done: !1
          }];
        } catch (t) {
          throw new Error("Error thrown cropping the video: " + t.message);
        } finally {
          t.dispose();
        }

        return [2];
      });
    });
  }, e.prototype.needToResize = function () {
    return !(!this.webcamConfig.resizeWidth || !this.webcamConfig.resizeHeight || this.webcamVideoElement.width === this.webcamConfig.resizeWidth && this.webcamVideoElement.height === this.webcamConfig.resizeHeight);
  }, e.prototype.cropAndResizeFrame = function (t) {
    var e = this;
    return (0, _tfjsCore.tidy)(function () {
      var r,
          n = t.toFloat().expandDims(0),
          i = (r = _tfjsCore.image.cropAndResize(n, e.cropBox, e.cropBoxInd, e.cropSize, "bilinear")).shape;

      return r.reshape(i.slice(1));
    });
  }, e.prototype.capture = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.next()];

          case 1:
            return [2, t.sent().value];
        }
      });
    });
  }, e.prototype.stop = function () {
    this.stream.getTracks().forEach(function (t) {
      return t.stop();
    });

    try {
      this.webcamVideoElement.srcObject = null;
    } catch (t) {
      console.log(t), this.webcamVideoElement.src = null;
    }

    this.isClosed = !0;
  }, e.prototype.toArray = function () {
    throw new Error("Can not convert infinite video stream to array.");
  }, e;
}(LazyIterator),
    DataSource = function () {
  return function () {};
}(),
    StringIterator = function (t) {
  function e() {
    return null !== t && t.apply(this, arguments) || this;
  }

  return __extends(e, t), e.prototype.split = function (t) {
    return new SplitIterator(this, t);
  }, e;
}(LazyIterator),
    SplitIterator = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.impl = new SplitIteratorImpl(e, r), n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.impl.summary();
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return [2, this.impl.next()];
      });
    });
  }, e;
}(StringIterator),
    SplitIteratorImpl = function (t) {
  function e(e, r) {
    var n = t.call(this) || this;
    return n.upstream = e, n.separator = r, n.carryover = "", n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Split('" + this.separator + "')";
  }, e.prototype.pump = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r, n, i;
      return __generator(this, function (o) {
        switch (o.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            if ((t = o.sent()).done) return "" === this.carryover ? [2, !1] : (this.outputQueue.push(this.carryover), this.carryover = "", [2, !0]);

            for ((e = t.value.split(this.separator))[0] = this.carryover + e[0], r = 0, n = e.slice(0, -1); r < n.length; r++) i = n[r], this.outputQueue.push(i);

            return this.carryover = e[e.length - 1], [2, !0];
        }
      });
    });
  }, e;
}(OneToManyIterator),
    ByteChunkIterator = function (t) {
  function e() {
    return null !== t && t.apply(this, arguments) || this;
  }

  return __extends(e, t), e.prototype.decodeUTF8 = function () {
    return new Utf8Iterator(this);
  }, e;
}(LazyIterator),
    Utf8Iterator = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    return r.upstream = e, r.impl = new Utf8IteratorImpl(e), r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.impl.summary();
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return [2, this.impl.next()];
      });
    });
  }, e;
}(StringIterator),
    Utf8IteratorImpl = function (t) {
  function e(e) {
    var r = t.call(this) || this;
    if (r.upstream = e, (0, _tfjsCore.env)().get("IS_BROWSER")) r.decoder = new TextDecoder("utf-8");else {
      var n = require("string_decoder").StringDecoder;

      r.decoder = new n("utf8");
    }
    return r;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return this.upstream.summary() + " -> Utf8";
  }, e.prototype.pump = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t, e, r;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.upstream.next()];

          case 1:
            return (t = n.sent()).done ? [2, !1] : (e = t.value, r = (0, _tfjsCore.env)().get("IS_BROWSER") ? this.decoder.decode(e, {
              stream: !0
            }) : this.decoder.write(Buffer.from(e.buffer)), this.outputQueue.push(r), [2, !0]);
        }
      });
    });
  }, e;
}(OneToManyIterator),
    FileChunkIterator = function (t) {
  function e(e, r) {
    void 0 === r && (r = {});
    var n = t.call(this) || this;
    return n.file = e, n.options = r, _tfjsCore.util.assert(e instanceof Uint8Array || !!(0, _tfjsCore.env)().get("IS_BROWSER") && (e instanceof File || e instanceof Blob), function () {
      return "FileChunkIterator only supports File, Blob and Uint8Array right now.";
    }), n.offset = r.offset || 0, n.chunkSize = r.chunkSize || 1048576, n;
  }

  return __extends(e, t), e.prototype.summary = function () {
    return "FileChunks " + this.file;
  }, e.prototype.next = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t,
          e,
          r = this;
      return __generator(this, function (n) {
        switch (n.label) {
          case 0:
            return this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size) ? [2, {
              value: null,
              done: !0
            }] : (t = new Promise(function (t, e) {
              var n = r.offset + r.chunkSize;
              if (r.file instanceof Uint8Array) t(new Uint8Array(r.file.slice(r.offset, n)));else {
                var i = new FileReader();
                i.onload = function (r) {
                  var n = i.result;
                  if (n instanceof ArrayBuffer && (n = new Uint8Array(n)), !(n instanceof Uint8Array)) return e(new TypeError("FileReader returned unknown type."));
                  t(n);
                }, i.onabort = function (t) {
                  return e(new Error("Aborted"));
                }, i.onerror = function (t) {
                  return e(new Error(t.type));
                };
                var o = r.file.slice(r.offset, n);
                i.readAsArrayBuffer(o);
              }
              r.offset = n;
            }), e = {}, [4, t]);

          case 1:
            return [2, (e.value = n.sent(), e.done = !1, e)];
        }
      });
    });
  }, e;
}(ByteChunkIterator);

exports.CSVDataset = CSVDataset;
exports.TextLineDataset = TextLineDataset;

function urlChunkIterator(t, e) {
  return void 0 === e && (e = {}), __awaiter(this, void 0, void 0, function () {
    var r, n, i, o, a;
    return __generator(this, function (s) {
      switch (s.label) {
        case 0:
          return "string" == typeof t ? r = t : (r = t.url, n = getRequestInitFromRequest(t)), [4, _tfjsCore.util.fetch(r, n)];

        case 1:
          return (i = s.sent()).ok ? (a = Uint8Array.bind, [4, i.arrayBuffer()]) : [3, 3];

        case 2:
          return o = new (a.apply(Uint8Array, [void 0, s.sent()]))(), [2, new FileChunkIterator(o, e)];

        case 3:
          throw new Error(i.statusText);
      }
    });
  });
}

var getRequestInitFromRequest = function (t) {
  return {
    method: t.method,
    headers: t.headers,
    body: t.body,
    mode: t.mode,
    credentials: t.credentials,
    cache: t.cache,
    redirect: t.redirect,
    referrer: t.referrer,
    integrity: t.integrity
  };
};

function isLocalPath(t) {
  return "string" == typeof t && "file://" === t.substr(0, 7);
}

var FileDataSource = function (t) {
  function e(e, r) {
    void 0 === r && (r = {});
    var n = t.call(this) || this;
    return n.input = e, n.options = r, n;
  }

  return __extends(e, t), e.prototype.iterator = function () {
    return __awaiter(this, void 0, void 0, function () {
      var t;
      return __generator(this, function (e) {
        return isLocalPath(this.input) && (0, _tfjsCore.env)().get("IS_NODE") && (t = require("fs"), this.input = t.readFileSync(this.input.substr(7))), [2, new FileChunkIterator(this.input, this.options)];
      });
    });
  }, e;
}(DataSource),
    URLDataSource = function (t) {
  function e(e, r) {
    void 0 === r && (r = {});
    var n = t.call(this) || this;
    return n.url = e, n.fileOptions = r, n;
  }

  return __extends(e, t), e.prototype.iterator = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (t) {
        return isLocalPath(this.url) ? [2, new FileDataSource(this.url, this.fileOptions).iterator()] : [2, urlChunkIterator(this.url, this.fileOptions)];
      });
    });
  }, e;
}(DataSource);

exports.URLDataSource = URLDataSource;
exports.FileDataSource = FileDataSource;

function csv(t, e) {
  return void 0 === e && (e = {}), new CSVDataset(new URLDataSource(t), e);
}

function func(t) {
  var e = this,
      r = iteratorFromFunction(t);
  return datasetFromIteratorFn(function () {
    return __awaiter(e, void 0, void 0, function () {
      return __generator(this, function (t) {
        return [2, r];
      });
    });
  });
}

function generator(t) {
  var e = this;
  return datasetFromIteratorFn(function () {
    return __awaiter(e, void 0, void 0, function () {
      var e;
      return __generator(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, t()];

          case 1:
            return e = r.sent(), [2, iteratorFromFunction(function () {
              return e.next();
            })];
        }
      });
    });
  });
}

function webcam(t, e) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (r) {
      return [2, WebcamIterator.create(t, e)];
    });
  });
}

function microphone(t) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (e) {
      return [2, MicrophoneIterator.create(t)];
    });
  });
}

var version = "1.7.1";
exports.version_data = version;
},{"@tensorflow/tfjs-core":"node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","crypto":"node_modules/parcel-bundler/src/builtins/_empty.js","string_decoder":"node_modules/parcel-bundler/src/builtins/_empty.js","fs":"node_modules/parcel-bundler/src/builtins/_empty.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@tensorflow/tfjs/dist/tf.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true,
  data: true
};
exports.data = exports.version = void 0;

var _tfjsCore = require("@tensorflow/tfjs-core");

Object.keys(_tfjsCore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tfjsCore[key];
    }
  });
});

var _tfjsLayers = require("@tensorflow/tfjs-layers");

Object.keys(_tfjsLayers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tfjsLayers[key];
    }
  });
});

var _tfjsConverter = require("@tensorflow/tfjs-converter");

Object.keys(_tfjsConverter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tfjsConverter[key];
    }
  });
});

var tfjsData = _interopRequireWildcard(require("@tensorflow/tfjs-data"));

exports.data = tfjsData;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// @tensorflow/tfjs Copyright 2020 Google
var version = "1.7.1",
    version$1 = {
  "tfjs-core": _tfjsCore.version_core,
  "tfjs-data": tfjsData.version_data,
  "tfjs-layers": _tfjsLayers.version_layers,
  "tfjs-converter": _tfjsConverter.version_converter,
  tfjs: version
};
exports.version = version$1;
},{"@tensorflow/tfjs-core":"node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","@tensorflow/tfjs-layers":"node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js","@tensorflow/tfjs-converter":"node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js","@tensorflow/tfjs-data":"node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js"}],"node_modules/acorn/dist/acorn.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;
exports.addLooseExports = addLooseExports;
exports.getLineInfo = getLineInfo;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierStart = isIdentifierStart;
exports.isNewLine = isNewLine;
exports.nonASCIIwhitespace = exports.lineBreakG = exports.lineBreak = exports.Token = exports.tokContexts = exports.TokContext = exports.keywordTypes = exports.tokTypes = exports.TokenType = exports.Node = exports.SourceLocation = exports.Position = exports.defaultOptions = exports.plugins = exports.Parser = exports.pluginsLoose = exports.LooseParser = exports.parse_dammit = exports.version = void 0;
// Reserved word lists for various dialects of the language
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}; // And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/; // ## Character categories
// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js
// eslint-disable-next-line comma-spacing

var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541]; // eslint-disable-next-line comma-spacing

var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; // This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.

function isInAstralSet(code, set) {
  var pos = 0x10000;

  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];

    if (pos > code) {
      return false;
    }

    pos += set[i + 1];

    if (pos >= code) {
      return true;
    }
  }
} // Test whether a given character code starts an identifier.


function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }

  if (code < 91) {
    return true;
  }

  if (code < 97) {
    return code === 95;
  }

  if (code < 123) {
    return true;
  }

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  if (astral === false) {
    return false;
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
} // Test whether a given character is part of an identifier.


function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }

  if (code < 58) {
    return true;
  }

  if (code < 65) {
    return false;
  }

  if (code < 91) {
    return true;
  }

  if (code < 97) {
    return code === 95;
  }

  if (code < 123) {
    return true;
  }

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  if (astral === false) {
    return false;
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
} // ## Token types
// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.
// All token type variables start with an underscore, to make them
// easy to recognize.
// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.


var TokenType = function TokenType(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

exports.TokenType = TokenType;

function binop(name, prec) {
  return new TokenType(name, {
    beforeExpr: true,
    binop: prec
  });
}

var beforeExpr = {
  beforeExpr: true
};
var startsExpr = {
  startsExpr: true
}; // Map keyword names to token types.

var keywords$1 = {}; // Succinct definitions of keyword token types

exports.keywordTypes = keywords$1;

function kw(name, options) {
  if (options === void 0) options = {};
  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options);
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", {
    beforeExpr: true,
    startsExpr: true
  }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {
    beforeExpr: true,
    startsExpr: true
  }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {
    beforeExpr: true,
    startsExpr: true
  }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {
    beforeExpr: true,
    startsExpr: true
  }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", {
    beforeExpr: true,
    isAssign: true
  }),
  assign: new TokenType("_=", {
    beforeExpr: true,
    isAssign: true
  }),
  incDec: new TokenType("++/--", {
    prefix: true,
    postfix: true,
    startsExpr: true
  }),
  prefix: new TokenType("!/~", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {
    beforeExpr: true,
    binop: 9,
    prefix: true,
    startsExpr: true
  }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {
    beforeExpr: true
  }),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {
    isLoop: true,
    beforeExpr: true
  }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {
    isLoop: true
  }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {
    isLoop: true
  }),
  _with: kw("with"),
  _new: kw("new", {
    beforeExpr: true,
    startsExpr: true
  }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {
    beforeExpr: true,
    binop: 7
  }),
  _instanceof: kw("instanceof", {
    beforeExpr: true,
    binop: 7
  }),
  _typeof: kw("typeof", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  _void: kw("void", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  _delete: kw("delete", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  })
}; // Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

exports.tokTypes = types;
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");
exports.lineBreakG = lineBreakG;

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || !ecma2019String && (code === 0x2028 || code === 0x2029);
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
exports.nonASCIIwhitespace = nonASCIIwhitespace;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString; // Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName);
}

var isArray = Array.isArray || function (obj) {
  return toString.call(obj) === "[object Array]";
}; // These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.


var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

exports.Position = Position;

Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;

  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
}; // The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.


exports.SourceLocation = SourceLocation;

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);

    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
} // A second optional argument can be given to further configure
// the parser process. These options are recognized:


var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
  // for strict mode, the set of reserved words, and support for
  // new syntax features. The default is 7.
  ecmaVersion: 7,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
}; // Interpret and default an options object

exports.defaultOptions = defaultOptions;

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions) {
    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }

  if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;

    options.onToken = function (token) {
      return tokens.push(token);
    };
  }

  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };

    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }

    if (options.ranges) {
      comment.range = [start, end];
    }

    array.push(comment);
  };
} // Registered plugins


var plugins = {};
exports.plugins = plugins;

function keywordRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
  var reserved = "";

  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--) {
      if (reserved = reservedWords[v]) {
        break;
      }
    }

    if (options.sourceType === "module") {
      reserved += " await";
    }
  }

  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input); // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.

  this.containsEsc = false; // Load plugins

  this.loadPlugins(options.plugins); // Set up token state
  // The current position of the tokenizer in the input.

  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  } // Properties of the current token:
  // Its type


  this.type = types.eof; // For tokens that include more information than their type, the value

  this.value = null; // Its start and end offset

  this.start = this.end = this.pos; // And, if locations are used, the {line, column} object
  // corresponding to those offsets

  this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token

  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.

  this.context = this.initialContext();
  this.exprAllowed = true; // Figure out if it's a module code.

  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos); // Used to signify the start of a potential arrow function

  this.potentialArrowAt = -1; // Flags to track whether we are in a function, a generator, an async function.

  this.inFunction = this.inGenerator = this.inAsync = false; // Positions to delayed-check that yield/await does not exist in default parameters.

  this.yieldPos = this.awaitPos = 0; // Labels in scope.

  this.labels = []; // If enabled, skip leading hashbang line.

  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  } // Scope tracking for duplicate variable names (see scope.js)


  this.scopeStack = [];
  this.enterFunctionScope(); // For RegExp validation

  this.regexpState = null;
}; // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them


exports.Parser = Parser;

Parser.prototype.isKeyword = function isKeyword(word) {
  return this.keywords.test(word);
};

Parser.prototype.isReservedWord = function isReservedWord(word) {
  return this.reservedWords.test(word);
};

Parser.prototype.extend = function extend(name, f) {
  this[name] = f(this[name]);
};

Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
  var this$1 = this;

  for (var name in pluginConfigs) {
    var plugin = plugins[name];

    if (!plugin) {
      throw new Error("Plugin '" + name + "' not found");
    }

    plugin(this$1, pluginConfigs[name]);
  }
};

Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};

var pp = Parser.prototype; // ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;

pp.strictDirective = function (start) {
  var this$1 = this;

  for (;;) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this$1.input)[0].length;
    var match = literal.exec(this$1.input.slice(start));

    if (!match) {
      return false;
    }

    if ((match[1] || match[2]) === "use strict") {
      return true;
    }

    start += match[0].length;
  }
}; // Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.


pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
}; // Tests whether parsed token is a contextual keyword.


pp.isContextual = function (name) {
  return this.type === types.name && this.value === name && !this.containsEsc;
}; // Consumes contextual keyword if possible.


pp.eatContextual = function (name) {
  if (!this.isContextual(name)) {
    return false;
  }

  this.next();
  return true;
}; // Asserts that following token is given contextual keyword.


pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
}; // Test whether a semicolon can be inserted at the current position.


pp.canInsertSemicolon = function () {
  return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }

    return true;
  }
}; // Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.


pp.semicolon = function () {
  if (!this.eat(types.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};

pp.afterTrailingComma = function (tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }

    if (!notNext) {
      this.next();
    }

    return true;
  }
}; // Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.


pp.expect = function (type) {
  this.eat(type) || this.unexpected();
}; // Raise an unexpected token error.


pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}

pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }

  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }

  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;

  if (parens > -1) {
    this.raiseRecoverable(parens, "Parenthesized pattern");
  }
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }

  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;

  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }

  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }

  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};

pp.checkYieldAwaitInDefaultParams = function () {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }

  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};

pp.isSimpleAssignTarget = function (expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }

  return expr.type === "Identifier" || expr.type === "MemberExpression";
};

var pp$1 = Parser.prototype; // ### Statement parsing
// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function (node) {
  var this$1 = this;
  var exports = {};

  if (!node.body) {
    node.body = [];
  }

  while (this.type !== types.eof) {
    var stmt = this$1.parseStatement(true, true, exports);
    node.body.push(stmt);
  }

  this.adaptDirectivePrologue(node.body);
  this.next();

  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }

  return this.finishNode(node, "Program");
};

var loopLabel = {
  kind: "loop"
};
var switchLabel = {
  kind: "switch"
};

pp$1.isLet = function () {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
      nextCh = this.input.charCodeAt(next);

  if (nextCh === 91 || nextCh === 123) {
    return true;
  } // '{' and '['


  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;

    while (isIdentifierChar(this.input.charCodeAt(pos), true)) {
      ++pos;
    }

    var ident = this.input.slice(next, pos);

    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }

  return false;
}; // check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.


pp$1.isAsyncFunction = function () {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
}; // Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.


pp$1.parseStatement = function (declaration, topLevel, exports) {
  var starttype = this.type,
      node = this.startNode(),
      kind;

  if (this.isLet()) {
    starttype = types._var;
    kind = "let";
  } // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.


  switch (starttype) {
    case types._break:
    case types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);

    case types._debugger:
      return this.parseDebuggerStatement(node);

    case types._do:
      return this.parseDoStatement(node);

    case types._for:
      return this.parseForStatement(node);

    case types._function:
      if (!declaration && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }

      return this.parseFunctionStatement(node, false);

    case types._class:
      if (!declaration) {
        this.unexpected();
      }

      return this.parseClass(node, true);

    case types._if:
      return this.parseIfStatement(node);

    case types._return:
      return this.parseReturnStatement(node);

    case types._switch:
      return this.parseSwitchStatement(node);

    case types._throw:
      return this.parseThrowStatement(node);

    case types._try:
      return this.parseTryStatement(node);

    case types._const:
    case types._var:
      kind = kind || this.value;

      if (!declaration && kind !== "var") {
        this.unexpected();
      }

      return this.parseVarStatement(node, kind);

    case types._while:
      return this.parseWhileStatement(node);

    case types._with:
      return this.parseWithStatement(node);

    case types.braceL:
      return this.parseBlock();

    case types.semi:
      return this.parseEmptyStatement(node);

    case types._export:
    case types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }

        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }

      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.

    default:
      if (this.isAsyncFunction()) {
        if (!declaration) {
          this.unexpected();
        }

        this.next();
        return this.parseFunctionStatement(node, true);
      }

      var maybeName = this.value,
          expr = this.parseExpression();

      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr);
      } else {
        return this.parseExpressionStatement(node, expr);
      }

  }
};

pp$1.parseBreakContinueStatement = function (node, keyword) {
  var this$1 = this;
  var isBreak = keyword === "break";
  this.next();

  if (this.eat(types.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  } // Verify that there is an actual destination to break or
  // continue to.


  var i = 0;

  for (; i < this.labels.length; ++i) {
    var lab = this$1.labels[i];

    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }

      if (node.label && isBreak) {
        break;
      }
    }
  }

  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }

  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp$1.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp$1.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();

  if (this.options.ecmaVersion >= 6) {
    this.eat(types.semi);
  } else {
    this.semicolon();
  }

  return this.finishNode(node, "DoWhileStatement");
}; // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.


pp$1.parseForStatement = function (node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterLexicalScope();
  this.expect(types.parenL);

  if (this.type === types.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }

    return this.parseFor(node, null);
  }

  var isLet = this.isLet();

  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(),
        kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");

    if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1 && !(kind !== "var" && init$1.declarations[0].init)) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }

      return this.parseForIn(node, init$1);
    }

    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }

    return this.parseFor(node, init$1);
  }

  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(true, refDestructuringErrors);

  if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }

    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }

  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }

  return this.parseFor(node, init);
};

pp$1.parseFunctionStatement = function (node, isAsync) {
  this.next();
  return this.parseFunction(node, true, false, isAsync);
};

pp$1.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression(); // allow function declarations in branches, but only in non-strict mode

  node.consequent = this.parseStatement(!this.strict && this.type === types._function);
  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;
  return this.finishNode(node, "IfStatement");
};

pp$1.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }

  this.next(); // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }

  return this.finishNode(node, "ReturnStatement");
};

pp$1.parseSwitchStatement = function (node) {
  var this$1 = this;
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterLexicalScope(); // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;

  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this$1.type === types._case || this$1.type === types._default) {
      var isCase = this$1.type === types._case;

      if (cur) {
        this$1.finishNode(cur, "SwitchCase");
      }

      node.cases.push(cur = this$1.startNode());
      cur.consequent = [];
      this$1.next();

      if (isCase) {
        cur.test = this$1.parseExpression();
      } else {
        if (sawDefault) {
          this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses");
        }

        sawDefault = true;
        cur.test = null;
      }

      this$1.expect(types.colon);
    } else {
      if (!cur) {
        this$1.unexpected();
      }

      cur.consequent.push(this$1.parseStatement(true));
    }
  }

  this.exitLexicalScope();

  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }

  this.next(); // Closing brace

  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp$1.parseThrowStatement = function (node) {
  this.next();

  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }

  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
}; // Reused empty array added for node fields that are always empty.


var empty = [];

pp$1.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;

  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();

    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      this.enterLexicalScope();
      this.checkLVal(clause.param, "let");
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }

      clause.param = null;
      this.enterLexicalScope();
    }

    clause.body = this.parseBlock(false);
    this.exitLexicalScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }

  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }

  return this.finishNode(node, "TryStatement");
};

pp$1.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp$1.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp$1.parseWithStatement = function (node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }

  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp$1.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp$1.parseLabeledStatement = function (node, maybeName, expr) {
  var this$1 = this;

  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1) {
    var label = list[i$1];

    if (label.name === maybeName) {
      this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }

  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;

  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this$1.labels[i];

    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this$1.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }

  this.labels.push({
    name: maybeName,
    kind: kind,
    statementStart: this.start
  });
  node.body = this.parseStatement(true);

  if (node.body.type === "ClassDeclaration" || node.body.type === "VariableDeclaration" && node.body.kind !== "var" || node.body.type === "FunctionDeclaration" && (this.strict || node.body.generator || node.body.async)) {
    this.raiseRecoverable(node.body.start, "Invalid labeled declaration");
  }

  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp$1.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
}; // Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).


pp$1.parseBlock = function (createNewLexicalScope) {
  var this$1 = this;
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  var node = this.startNode();
  node.body = [];
  this.expect(types.braceL);

  if (createNewLexicalScope) {
    this.enterLexicalScope();
  }

  while (!this.eat(types.braceR)) {
    var stmt = this$1.parseStatement(true);
    node.body.push(stmt);
  }

  if (createNewLexicalScope) {
    this.exitLexicalScope();
  }

  return this.finishNode(node, "BlockStatement");
}; // Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.


pp$1.parseFor = function (node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
}; // Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.


pp$1.parseForIn = function (node, init) {
  var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
  this.next();

  if (type === "ForInStatement") {
    if (init.type === "AssignmentPattern" || init.type === "VariableDeclaration" && init.declarations[0].init != null && (this.strict || init.declarations[0].id.type !== "Identifier")) {
      this.raise(init.start, "Invalid assignment in for-in loop head");
    }
  }

  node.left = init;
  node.right = type === "ForInStatement" ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
}; // Parse a list of variable declarations.


pp$1.parseVar = function (node, isFor, kind) {
  var this$1 = this;
  node.declarations = [];
  node.kind = kind;

  for (;;) {
    var decl = this$1.startNode();
    this$1.parseVarId(decl, kind);

    if (this$1.eat(types.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this$1.type === types._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual("of"))) {
      this$1.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
      this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }

    node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));

    if (!this$1.eat(types.comma)) {
      break;
    }
  }

  return node;
};

pp$1.parseVarId = function (decl, kind) {
  decl.id = this.parseBindingAtom(kind);
  this.checkLVal(decl.id, kind, false);
}; // Parse a function declaration or literal (depending on the
// `isStatement` parameter).


pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node);

  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    node.generator = this.eat(types.star);
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  if (isStatement) {
    node.id = isStatement === "nullableID" && this.type !== types.name ? null : this.parseIdent();

    if (node.id) {
      this.checkLVal(node.id, this.inModule && !this.inFunction ? "let" : "var");
    }
  }

  var oldInGen = this.inGenerator,
      oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldInFunc = this.inFunction;
  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  if (!isStatement) {
    node.id = this.type === types.name ? this.parseIdent() : null;
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);
  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp$1.parseFunctionParams = function (node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
}; // Parse a class declaration or literal (depending on the
// `isStatement` parameter).


pp$1.parseClass = function (node, isStatement) {
  var this$1 = this;
  this.next();
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    var member = this$1.parseClassMember(classBody);

    if (member && member.type === "MethodDefinition" && member.kind === "constructor") {
      if (hadConstructor) {
        this$1.raise(member.start, "Duplicate constructor in the same class");
      }

      hadConstructor = true;
    }
  }

  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp$1.parseClassMember = function (classBody) {
  var this$1 = this;

  if (this.eat(types.semi)) {
    return null;
  }

  var method = this.startNode();

  var tryContextual = function (k, noLineBreak) {
    if (noLineBreak === void 0) noLineBreak = false;
    var start = this$1.start,
        startLoc = this$1.startLoc;

    if (!this$1.eatContextual(k)) {
      return false;
    }

    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {
      return true;
    }

    if (method.key) {
      this$1.unexpected();
    }

    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false;
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;

  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }

  if (!method.key) {
    this.parsePropertyName(method);
  }

  var key = method.key;

  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") {
      this.raise(key.start, "Constructor can't have get/set modifier");
    }

    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }

    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }

    method.kind = "constructor";
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }

  this.parseClassMethod(classBody, method, isGenerator, isAsync);

  if (method.kind === "get" && method.value.params.length !== 0) {
    this.raiseRecoverable(method.value.start, "getter should have no params");
  }

  if (method.kind === "set" && method.value.params.length !== 1) {
    this.raiseRecoverable(method.value.start, "setter should have exactly one param");
  }

  if (method.kind === "set" && method.value.params[0].type === "RestElement") {
    this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
  }

  return method;
};

pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp$1.parseClassId = function (node, isStatement) {
  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
};

pp$1.parseClassSuper = function (node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
}; // Parses module export declaration.


pp$1.parseExport = function (node, exports) {
  var this$1 = this;
  this.next(); // export * from '...'

  if (this.eat(types.star)) {
    this.expectContextual("from");

    if (this.type !== types.string) {
      this.unexpected();
    }

    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }

  if (this.eat(types._default)) {
    // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;

    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();

      if (isAsync) {
        this.next();
      }

      node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }

    return this.finishNode(node, "ExportDefaultDeclaration");
  } // export var|const|let|function|class ...


  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);

    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
    }

    node.specifiers = [];
    node.source = null;
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);

    if (this.eatContextual("from")) {
      if (this.type !== types.string) {
        this.unexpected();
      }

      node.source = this.parseExprAtom();
    } else {
      // check for keywords used as local names
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        this$1.checkUnreserved(spec.local);
      }

      node.source = null;
    }

    this.semicolon();
  }

  return this.finishNode(node, "ExportNamedDeclaration");
};

pp$1.checkExport = function (exports, name, pos) {
  if (!exports) {
    return;
  }

  if (has(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }

  exports[name] = true;
};

pp$1.checkPatternExport = function (exports, pat) {
  var this$1 = this;
  var type = pat.type;

  if (type === "Identifier") {
    this.checkExport(exports, pat.name, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list = pat.properties; i < list.length; i += 1) {
      var prop = list[i];
      this$1.checkPatternExport(exports, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

      if (elt) {
        this$1.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports, pat.expression);
  }
};

pp$1.checkVariableExport = function (exports, decls) {
  var this$1 = this;

  if (!exports) {
    return;
  }

  for (var i = 0, list = decls; i < list.length; i += 1) {
    var decl = list[i];
    this$1.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function () {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
}; // Parses a comma-separated list of module exports.


pp$1.parseExportSpecifiers = function (exports) {
  var this$1 = this;
  var nodes = [],
      first = true; // export { x, y as z } [from '...']

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);

      if (this$1.afterTrailingComma(types.braceR)) {
        break;
      }
    } else {
      first = false;
    }

    var node = this$1.startNode();
    node.local = this$1.parseIdent(true);
    node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
    this$1.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this$1.finishNode(node, "ExportSpecifier"));
  }

  return nodes;
}; // Parses import declaration.


pp$1.parseImport = function (node) {
  this.next(); // import '...'

  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }

  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
}; // Parses a comma-separated list of module imports.


pp$1.parseImportSpecifiers = function () {
  var this$1 = this;
  var nodes = [],
      first = true;

  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, "let");
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));

    if (!this.eat(types.comma)) {
      return nodes;
    }
  }

  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, "let");
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes;
  }

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);

      if (this$1.afterTrailingComma(types.braceR)) {
        break;
      }
    } else {
      first = false;
    }

    var node$2 = this$1.startNode();
    node$2.imported = this$1.parseIdent(true);

    if (this$1.eatContextual("as")) {
      node$2.local = this$1.parseIdent();
    } else {
      this$1.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }

    this$1.checkLVal(node$2.local, "let");
    nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
  }

  return nodes;
}; // Set `ExpressionStatement#directive` property for directive prologues.


pp$1.adaptDirectivePrologue = function (statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};

pp$1.isDirectiveCandidate = function (statement) {
  return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && ( // Reject parenthesized strings.
  this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};

var pp$2 = Parser.prototype; // Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {
  var this$1 = this;

  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Can not use 'await' as identifier inside an async function");
        }

        break;

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";

        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }

        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          this$1.toAssignable(prop, isBinding); // Early error:
          //   AssignmentRestProperty[Yield, Await] :
          //     `...` DestructuringAssignmentTarget[Yield, Await]
          //
          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.

          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this$1.raise(prop.argument.start, "Unexpected token");
          }
        }

        break;

      case "Property":
        // AssignmentProperty has type === "Property"
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }

        this.toAssignable(node.value, isBinding);
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";

        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }

        this.toAssignableList(node.elements, isBinding);
        break;

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);

        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }

        break;

      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }

        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

      case "AssignmentPattern":
        break;

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding);
        break;

      case "MemberExpression":
        if (!isBinding) {
          break;
        }

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }

  return node;
}; // Convert list of expression atoms to binding list.


pp$2.toAssignableList = function (exprList, isBinding) {
  var this$1 = this;
  var end = exprList.length;

  for (var i = 0; i < end; i++) {
    var elt = exprList[i];

    if (elt) {
      this$1.toAssignable(elt, isBinding);
    }
  }

  if (end) {
    var last = exprList[end - 1];

    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }

  return exprList;
}; // Parses spread element.


pp$2.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp$2.parseRestBinding = function () {
  var node = this.startNode();
  this.next(); // RestElement inside of a function parameter must be an identifier

  if (this.options.ecmaVersion === 6 && this.type !== types.name) {
    this.unexpected();
  }

  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
}; // Parses lvalue (assignable) atom.


pp$2.parseBindingAtom = function () {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");

      case types.braceL:
        return this.parseObj(true);
    }
  }

  return this.parseIdent();
};

pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
  var this$1 = this;
  var elts = [],
      first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this$1.expect(types.comma);
    }

    if (allowEmpty && this$1.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
      break;
    } else if (this$1.type === types.ellipsis) {
      var rest = this$1.parseRestBinding();
      this$1.parseBindingListItem(rest);
      elts.push(rest);

      if (this$1.type === types.comma) {
        this$1.raise(this$1.start, "Comma is not permitted after the rest element");
      }

      this$1.expect(close);
      break;
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
      this$1.parseBindingListItem(elem);
      elts.push(elem);
    }
  }

  return elts;
};

pp$2.parseBindingListItem = function (param) {
  return param;
}; // Parses assignment pattern around given atom if possible.


pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();

  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
    return left;
  }

  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
}; // Verify that a node is an lval  something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references


pp$2.checkLVal = function (expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }

      if (checkClashes) {
        if (has(checkClashes, expr.name)) {
          this.raiseRecoverable(expr.start, "Argument name clash");
        }

        checkClashes[expr.name] = true;
      }

      if (bindingType && bindingType !== "none") {
        if (bindingType === "var" && !this.canDeclareVarName(expr.name) || bindingType !== "var" && !this.canDeclareLexicalName(expr.name)) {
          this.raiseRecoverable(expr.start, "Identifier '" + expr.name + "' has already been declared");
        }

        if (bindingType === "var") {
          this.declareVarName(expr.name);
        } else {
          this.declareLexicalName(expr.name);
        }
      }

      break;

    case "MemberExpression":
      if (bindingType) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }

      break;

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];
        this$1.checkLVal(prop, bindingType, checkClashes);
      }

      break;

    case "Property":
      // AssignmentProperty has type === "Property"
      this.checkLVal(expr.value, bindingType, checkClashes);
      break;

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

        if (elem) {
          this$1.checkLVal(elem, bindingType, checkClashes);
        }
      }

      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break;

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
}; // A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


var pp$3 = Parser.prototype; // Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function (prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }

  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }

  var key = prop.key;
  var name;

  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;

    case "Literal":
      name = String(key.value);
      break;

    default:
      return;
  }

  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) {
          refDestructuringErrors.doubleProto = key.start;
        } // Backwards-compat kludge. Can be removed in version 6.0
        else {
            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
          }
      }

      propHash.proto = true;
    }

    return;
  }

  name = "$" + name;
  var other = propHash[name];

  if (other) {
    var redefinition;

    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }

    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }

  other[kind] = true;
}; // ### Expression parsing
// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).


pp$3.parseExpression = function (noIn, refDestructuringErrors) {
  var this$1 = this;
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);

  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];

    while (this.eat(types.comma)) {
      node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));
    }

    return this.finishNode(node, "SequenceExpression");
  }

  return expr;
}; // Parse an assignment expression. This includes applications of
// operators like `+=`.


pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) {
    return this.parseYield();
  }

  var ownDestructuringErrors = false,
      oldParenAssign = -1,
      oldTrailingComma = -1;

  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }

  var startPos = this.start,
      startLoc = this.startLoc;

  if (this.type === types.parenL || this.type === types.name) {
    this.potentialArrowAt = this.start;
  }

  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);

  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }

  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;

    if (!ownDestructuringErrors) {
      DestructuringErrors.call(refDestructuringErrors);
    }

    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly

    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }

  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }

  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }

  return left;
}; // Parse a ternary conditional (`?:`) operator.


pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);

  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }

  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }

  return expr;
}; // Start the precedence parser.


pp$3.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);

  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }

  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
}; // Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.


pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;

  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }

  return left;
};

pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
}; // Parse unary operators, both prefix and postfix.


pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var this$1 = this;
  var startPos = this.start,
      startLoc = this.startLoc,
      expr;

  if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (update) {
      this.checkLVal(node.argument);
    } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else {
      sawUnary = true;
    }

    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);

    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }

    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.operator = this$1.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this$1.checkLVal(expr);
      this$1.next();
      expr = this$1.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar)) {
    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
  } else {
    return expr;
  }
}; // Parse call, dot, and `[]`-subscript expressions.


pp$3.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";

  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {
    return expr;
  }

  var result = this.parseSubscripts(expr, startPos, startLoc);

  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }

    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
  }

  return result;
};

pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  var this$1 = this;
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";

  for (var computed = void 0;;) {
    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
      node.computed = !!computed;

      if (computed) {
        this$1.expect(types.bracketR);
      }

      base = this$1.finishNode(node, "MemberExpression");
    } else if (!noCalls && this$1.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors(),
          oldYieldPos = this$1.yieldPos,
          oldAwaitPos = this$1.awaitPos;
      this$1.yieldPos = 0;
      this$1.awaitPos = 0;
      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);

      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false);
        this$1.checkYieldAwaitInDefaultParams();
        this$1.yieldPos = oldYieldPos;
        this$1.awaitPos = oldAwaitPos;
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true);
      }

      this$1.checkExpressionErrors(refDestructuringErrors, true);
      this$1.yieldPos = oldYieldPos || this$1.yieldPos;
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this$1.finishNode(node$1, "CallExpression");
    } else if (this$1.type === types.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this$1.parseTemplate({
        isTagged: true
      });
      base = this$1.finishNode(node$2, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
}; // Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.


pp$3.parseExprAtom = function (refDestructuringErrors) {
  var node,
      canBeArrow = this.potentialArrowAt === this.start;

  switch (this.type) {
    case types._super:
      if (!this.inFunction) {
        this.raise(this.start, "'super' outside of function or class");
      }

      node = this.startNode();
      this.next(); // The `super` keyword can appear at below:
      // SuperProperty:
      //     super [ Expression ]
      //     super . IdentifierName
      // SuperCall:
      //     super Arguments

      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
        this.unexpected();
      }

      return this.finishNode(node, "Super");

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");

    case types.name:
      var startPos = this.start,
          startLoc = this.startLoc,
          containsEsc = this.containsEsc;
      var id = this.parseIdent(this.type !== types.name);

      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
        return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true);
      }

      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
        }

        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent();

          if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
            this.unexpected();
          }

          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
        }
      }

      return id;

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {
        pattern: value.pattern,
        flags: value.flags
      };
      return node;

    case types.num:
    case types.string:
      return this.parseLiteral(this.value);

    case types._null:
    case types._true:
    case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case types.parenL:
      var start = this.start,
          expr = this.parseParenAndDistinguishExpression(canBeArrow);

      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }

        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }

      return expr;

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case types._class:
      return this.parseClass(this.startNode(), false);

    case types._new:
      return this.parseNew();

    case types.backQuote:
      return this.parseTemplate();

    default:
      this.unexpected();
  }
};

pp$3.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp$3.parseParenExpression = function () {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val;
};

pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {
  var this$1 = this;
  var startPos = this.start,
      startLoc = this.startLoc,
      val,
      allowTrailingComma = this.options.ecmaVersion >= 8;

  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true,
        lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(),
        oldYieldPos = this.yieldPos,
        oldAwaitPos = this.awaitPos,
        spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;

    while (this.type !== types.parenR) {
      first ? first = false : this$1.expect(types.comma);

      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this$1.type === types.ellipsis) {
        spreadStart = this$1.start;
        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));

        if (this$1.type === types.comma) {
          this$1.raise(this$1.start, "Comma is not permitted after the rest element");
        }

        break;
      } else {
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
      }
    }

    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }

    if (spreadStart) {
      this.unexpected(spreadStart);
    }

    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp$3.parseParenItem = function (item) {
  return item;
};

pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
}; // New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call  at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.


var empty$1 = [];

pp$3.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);

  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "target" || containsEsc) {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
    }

    if (!this.inFunction) {
      this.raiseRecoverable(node.start, "new.target can only be used in functions");
    }

    return this.finishNode(node, "MetaProperty");
  }

  var startPos = this.start,
      startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);

  if (this.eat(types.parenL)) {
    node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty$1;
  }

  return this.finishNode(node, "NewExpression");
}; // Parse template expression.


pp$3.parseTemplateElement = function (ref) {
  var isTagged = ref.isTagged;
  var elem = this.startNode();

  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }

    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }

  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp$3.parseTemplate = function (ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var isTagged = ref.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({
    isTagged: isTagged
  });
  node.quasis = [curElt];

  while (!curElt.tail) {
    if (this$1.type === types.eof) {
      this$1.raise(this$1.pos, "Unterminated template literal");
    }

    this$1.expect(types.dollarBraceL);
    node.expressions.push(this$1.parseExpression());
    this$1.expect(types.braceR);
    node.quasis.push(curElt = this$1.parseTemplateElement({
      isTagged: isTagged
    }));
  }

  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

pp$3.isAsyncProp = function (prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
}; // Parse an object literal or binding pattern.


pp$3.parseObj = function (isPattern, refDestructuringErrors) {
  var this$1 = this;
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();

  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);

      if (this$1.afterTrailingComma(types.braceR)) {
        break;
      }
    } else {
      first = false;
    }

    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);

    if (!isPattern) {
      this$1.checkPropClash(prop, propHash, refDestructuringErrors);
    }

    node.properties.push(prop);
  }

  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp$3.parseProperty = function (isPattern, refDestructuringErrors) {
  var prop = this.startNode(),
      isGenerator,
      isAsync,
      startPos,
      startLoc;

  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);

      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }

      return this.finishNode(prop, "RestElement");
    } // To disallow parenthesized identifier via `this.toAssignable()`.


    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }

      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    } // Parse argument.


    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors); // To disallow trailing comma via `this.toAssignable()`.

    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    } // Finish


    return this.finishNode(prop, "SpreadElement");
  }

  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;

    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }

    if (!isPattern) {
      isGenerator = this.eat(types.star);
    }
  }

  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);

  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }

  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};

pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon) {
    this.unexpected();
  }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) {
      this.unexpected();
    }

    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types.comma && this.type !== types.braceR) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }

    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;

    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;

      if (prop.kind === "get") {
        this.raiseRecoverable(start, "getter should have no params");
      } else {
        this.raiseRecoverable(start, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    this.checkUnreserved(prop.key);
    prop.kind = "init";

    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }

      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }

    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};

pp$3.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }

  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true);
}; // Initialize empty function node.


pp$3.initFunction = function (node) {
  node.id = null;

  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
}; // Parse object or class method.


pp$3.parseMethod = function (isGenerator, isAsync) {
  var node = this.startNode(),
      oldInGen = this.inGenerator,
      oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldInFunc = this.inFunction;
  this.initFunction(node);

  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);
  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "FunctionExpression");
}; // Parse arrow function expression with given parameters.


pp$3.parseArrowExpression = function (node, params, isAsync) {
  var oldInGen = this.inGenerator,
      oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldInFunc = this.inFunction;
  this.enterFunctionScope();
  this.initFunction(node);

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  this.inGenerator = false;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "ArrowFunctionExpression");
}; // Parse function body and check parameters.


pp$3.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict,
      useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);

    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end); // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.

      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    } // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).


    var oldLabels = this.labels;
    this.labels = [];

    if (useStrict) {
      this.strict = true;
    } // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.


    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }

  this.exitFunctionScope();

  if (this.strict && node.id) {
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    this.checkLVal(node.id, "none");
  }

  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function (params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
    var param = list[i];

    if (param.type !== "Identifier") {
      return false;
    }
  }

  return true;
}; // Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.


pp$3.checkParams = function (node, allowDuplicates) {
  var this$1 = this;
  var nameHash = {};

  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    this$1.checkLVal(param, "var", allowDuplicates ? null : nameHash);
  }
}; // Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).


pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;
  var elts = [],
      first = true;

  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(types.comma);

      if (allowTrailingComma && this$1.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }

    var elt = void 0;

    if (allowEmpty && this$1.type === types.comma) {
      elt = null;
    } else if (this$1.type === types.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors);

      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this$1.start;
      }
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
    }

    elts.push(elt);
  }

  return elts;
};

pp$3.checkUnreserved = function (ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator");
  }

  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function");
  }

  if (this.isKeyword(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }

  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }

  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;

  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Can not use keyword 'await' outside an async function");
    }

    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
}; // Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.


pp$3.parseIdent = function (liberal, isBinding) {
  var node = this.startNode();

  if (liberal && this.options.allowReserved === "never") {
    liberal = false;
  }

  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword; // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword

    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }

  this.next();
  this.finishNode(node, "Identifier");

  if (!liberal) {
    this.checkUnreserved(node);
  }

  return node;
}; // Parses yield expression inside generator.


pp$3.parseYield = function () {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }

  var node = this.startNode();
  this.next();

  if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }

  return this.finishNode(node, "YieldExpression");
};

pp$3.parseAwait = function () {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression");
};

var pp$4 = Parser.prototype; // This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function () {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};

var pp$5 = Parser.prototype; // Object.assign polyfill

var assign = Object.assign || function (target) {
  var sources = [],
      len = arguments.length - 1;

  while (len-- > 0) sources[len] = arguments[len + 1];

  for (var i = 0, list = sources; i < list.length; i += 1) {
    var source = list[i];

    for (var key in source) {
      if (has(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}; // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.


pp$5.enterFunctionScope = function () {
  // var: a hash of var-declared names in the current lexical scope
  // lexical: a hash of lexically-declared names in the current lexical scope
  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)
  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)
  this.scopeStack.push({
    var: {},
    lexical: {},
    childVar: {},
    parentLexical: {}
  });
};

pp$5.exitFunctionScope = function () {
  this.scopeStack.pop();
};

pp$5.enterLexicalScope = function () {
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  var childScope = {
    var: {},
    lexical: {},
    childVar: {},
    parentLexical: {}
  };
  this.scopeStack.push(childScope);
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
};

pp$5.exitLexicalScope = function () {
  var childScope = this.scopeStack.pop();
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  assign(parentScope.childVar, childScope.var, childScope.childVar);
};
/**
 * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`
 * in the current lexical scope or any of the parent lexical scopes in this function.
 */


pp$5.canDeclareVarName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];
  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name);
};
/**
 * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`
 * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in
 * any child lexical scopes in this function.
 */


pp$5.canDeclareLexicalName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];
  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name);
};

pp$5.declareVarName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
};

pp$5.declareLexicalName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;

  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }

  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }

  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
}; // Start an AST node, attaching a start offset.


exports.Node = Node;
var pp$6 = Parser.prototype;

pp$6.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp$6.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
}; // Finish an AST node, adding `type` and `end` properties.


function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;

  if (this.options.locations) {
    node.loc.end = loc;
  }

  if (this.options.ranges) {
    node.range[1] = pos;
  }

  return node;
}

pp$6.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
}; // Finish node at given position


pp$6.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
}; // The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design


var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

exports.TokContext = TokContext;
var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
exports.tokContexts = types$1;
var pp$7 = Parser.prototype;

pp$7.initialContext = function () {
  return [types$1.b_stat];
};

pp$7.braceIsBlock = function (prevType) {
  var parent = this.curContext();

  if (parent === types$1.f_expr || parent === types$1.f_stat) {
    return true;
  }

  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
    return !parent.isExpr;
  } // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.


  if (prevType === types._return || prevType === types.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }

  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
    return true;
  }

  if (prevType === types.braceL) {
    return parent === types$1.b_stat;
  }

  if (prevType === types._var || prevType === types.name) {
    return false;
  }

  return !this.exprAllowed;
};

pp$7.inGeneratorContext = function () {
  var this$1 = this;

  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this$1.context[i];

    if (context.token === "function") {
      return context.generator;
    }
  }

  return false;
};

pp$7.updateContext = function (prevType) {
  var update,
      type = this.type;

  if (type.keyword && prevType === types.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
}; // Token-specific context update code


types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }

  var out = this.context.pop();

  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }

  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function () {// tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function (prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
    this.context.push(types$1.f_expr);
  } else {
    this.context.push(types$1.f_stat);
  }

  this.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types$1.q_tmpl);
  }

  this.exprAllowed = false;
};

types.star.updateContext = function (prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;

    if (this.context[index] === types$1.f_expr) {
      this.context[index] = types$1.f_expr_gen;
    } else {
      this.context[index] = types$1.f_gen;
    }
  }

  this.exprAllowed = true;
};

types.name.updateContext = function (prevType) {
  var allowed = false;

  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }

  this.exprAllowed = allowed;
};

var data = {
  "$LONE": ["ASCII", "ASCII_Hex_Digit", "AHex", "Alphabetic", "Alpha", "Any", "Assigned", "Bidi_Control", "Bidi_C", "Bidi_Mirrored", "Bidi_M", "Case_Ignorable", "CI", "Cased", "Changes_When_Casefolded", "CWCF", "Changes_When_Casemapped", "CWCM", "Changes_When_Lowercased", "CWL", "Changes_When_NFKC_Casefolded", "CWKCF", "Changes_When_Titlecased", "CWT", "Changes_When_Uppercased", "CWU", "Dash", "Default_Ignorable_Code_Point", "DI", "Deprecated", "Dep", "Diacritic", "Dia", "Emoji", "Emoji_Component", "Emoji_Modifier", "Emoji_Modifier_Base", "Emoji_Presentation", "Extender", "Ext", "Grapheme_Base", "Gr_Base", "Grapheme_Extend", "Gr_Ext", "Hex_Digit", "Hex", "IDS_Binary_Operator", "IDSB", "IDS_Trinary_Operator", "IDST", "ID_Continue", "IDC", "ID_Start", "IDS", "Ideographic", "Ideo", "Join_Control", "Join_C", "Logical_Order_Exception", "LOE", "Lowercase", "Lower", "Math", "Noncharacter_Code_Point", "NChar", "Pattern_Syntax", "Pat_Syn", "Pattern_White_Space", "Pat_WS", "Quotation_Mark", "QMark", "Radical", "Regional_Indicator", "RI", "Sentence_Terminal", "STerm", "Soft_Dotted", "SD", "Terminal_Punctuation", "Term", "Unified_Ideograph", "UIdeo", "Uppercase", "Upper", "Variation_Selector", "VS", "White_Space", "space", "XID_Continue", "XIDC", "XID_Start", "XIDS"],
  "General_Category": ["Cased_Letter", "LC", "Close_Punctuation", "Pe", "Connector_Punctuation", "Pc", "Control", "Cc", "cntrl", "Currency_Symbol", "Sc", "Dash_Punctuation", "Pd", "Decimal_Number", "Nd", "digit", "Enclosing_Mark", "Me", "Final_Punctuation", "Pf", "Format", "Cf", "Initial_Punctuation", "Pi", "Letter", "L", "Letter_Number", "Nl", "Line_Separator", "Zl", "Lowercase_Letter", "Ll", "Mark", "M", "Combining_Mark", "Math_Symbol", "Sm", "Modifier_Letter", "Lm", "Modifier_Symbol", "Sk", "Nonspacing_Mark", "Mn", "Number", "N", "Open_Punctuation", "Ps", "Other", "C", "Other_Letter", "Lo", "Other_Number", "No", "Other_Punctuation", "Po", "Other_Symbol", "So", "Paragraph_Separator", "Zp", "Private_Use", "Co", "Punctuation", "P", "punct", "Separator", "Z", "Space_Separator", "Zs", "Spacing_Mark", "Mc", "Surrogate", "Cs", "Symbol", "S", "Titlecase_Letter", "Lt", "Unassigned", "Cn", "Uppercase_Letter", "Lu"],
  "Script": ["Adlam", "Adlm", "Ahom", "Anatolian_Hieroglyphs", "Hluw", "Arabic", "Arab", "Armenian", "Armn", "Avestan", "Avst", "Balinese", "Bali", "Bamum", "Bamu", "Bassa_Vah", "Bass", "Batak", "Batk", "Bengali", "Beng", "Bhaiksuki", "Bhks", "Bopomofo", "Bopo", "Brahmi", "Brah", "Braille", "Brai", "Buginese", "Bugi", "Buhid", "Buhd", "Canadian_Aboriginal", "Cans", "Carian", "Cari", "Caucasian_Albanian", "Aghb", "Chakma", "Cakm", "Cham", "Cherokee", "Cher", "Common", "Zyyy", "Coptic", "Copt", "Qaac", "Cuneiform", "Xsux", "Cypriot", "Cprt", "Cyrillic", "Cyrl", "Deseret", "Dsrt", "Devanagari", "Deva", "Duployan", "Dupl", "Egyptian_Hieroglyphs", "Egyp", "Elbasan", "Elba", "Ethiopic", "Ethi", "Georgian", "Geor", "Glagolitic", "Glag", "Gothic", "Goth", "Grantha", "Gran", "Greek", "Grek", "Gujarati", "Gujr", "Gurmukhi", "Guru", "Han", "Hani", "Hangul", "Hang", "Hanunoo", "Hano", "Hatran", "Hatr", "Hebrew", "Hebr", "Hiragana", "Hira", "Imperial_Aramaic", "Armi", "Inherited", "Zinh", "Qaai", "Inscriptional_Pahlavi", "Phli", "Inscriptional_Parthian", "Prti", "Javanese", "Java", "Kaithi", "Kthi", "Kannada", "Knda", "Katakana", "Kana", "Kayah_Li", "Kali", "Kharoshthi", "Khar", "Khmer", "Khmr", "Khojki", "Khoj", "Khudawadi", "Sind", "Lao", "Laoo", "Latin", "Latn", "Lepcha", "Lepc", "Limbu", "Limb", "Linear_A", "Lina", "Linear_B", "Linb", "Lisu", "Lycian", "Lyci", "Lydian", "Lydi", "Mahajani", "Mahj", "Malayalam", "Mlym", "Mandaic", "Mand", "Manichaean", "Mani", "Marchen", "Marc", "Masaram_Gondi", "Gonm", "Meetei_Mayek", "Mtei", "Mende_Kikakui", "Mend", "Meroitic_Cursive", "Merc", "Meroitic_Hieroglyphs", "Mero", "Miao", "Plrd", "Modi", "Mongolian", "Mong", "Mro", "Mroo", "Multani", "Mult", "Myanmar", "Mymr", "Nabataean", "Nbat", "New_Tai_Lue", "Talu", "Newa", "Nko", "Nkoo", "Nushu", "Nshu", "Ogham", "Ogam", "Ol_Chiki", "Olck", "Old_Hungarian", "Hung", "Old_Italic", "Ital", "Old_North_Arabian", "Narb", "Old_Permic", "Perm", "Old_Persian", "Xpeo", "Old_South_Arabian", "Sarb", "Old_Turkic", "Orkh", "Oriya", "Orya", "Osage", "Osge", "Osmanya", "Osma", "Pahawh_Hmong", "Hmng", "Palmyrene", "Palm", "Pau_Cin_Hau", "Pauc", "Phags_Pa", "Phag", "Phoenician", "Phnx", "Psalter_Pahlavi", "Phlp", "Rejang", "Rjng", "Runic", "Runr", "Samaritan", "Samr", "Saurashtra", "Saur", "Sharada", "Shrd", "Shavian", "Shaw", "Siddham", "Sidd", "SignWriting", "Sgnw", "Sinhala", "Sinh", "Sora_Sompeng", "Sora", "Soyombo", "Soyo", "Sundanese", "Sund", "Syloti_Nagri", "Sylo", "Syriac", "Syrc", "Tagalog", "Tglg", "Tagbanwa", "Tagb", "Tai_Le", "Tale", "Tai_Tham", "Lana", "Tai_Viet", "Tavt", "Takri", "Takr", "Tamil", "Taml", "Tangut", "Tang", "Telugu", "Telu", "Thaana", "Thaa", "Thai", "Tibetan", "Tibt", "Tifinagh", "Tfng", "Tirhuta", "Tirh", "Ugaritic", "Ugar", "Vai", "Vaii", "Warang_Citi", "Wara", "Yi", "Yiii", "Zanabazar_Square", "Zanb"]
};
Array.prototype.push.apply(data.$LONE, data.General_Category);
data.gc = data.General_Category;
data.sc = data.Script_Extensions = data.scx = data.Script;
var pp$9 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
}; // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).


RegExpValidationState.prototype.at = function at(i) {
  var s = this.source;
  var l = s.length;

  if (i >= l) {
    return -1;
  }

  var c = s.charCodeAt(i);

  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c;
  }

  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;
};

RegExpValidationState.prototype.nextIndex = function nextIndex(i) {
  var s = this.source;
  var l = s.length;

  if (i >= l) {
    return l;
  }

  var c = s.charCodeAt(i),
      next;

  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1;
  }

  return i + 2;
};

RegExpValidationState.prototype.current = function current() {
  return this.at(this.pos);
};

RegExpValidationState.prototype.lookahead = function lookahead() {
  return this.at(this.nextIndex(this.pos));
};

RegExpValidationState.prototype.advance = function advance() {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat(ch) {
  if (this.current() === ch) {
    this.advance();
    return true;
  }

  return false;
};

function codePointToString$1(ch) {
  if (ch <= 0xFFFF) {
    return String.fromCharCode(ch);
  }

  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00);
}
/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */


pp$9.validateRegExpFlags = function (state) {
  var this$1 = this;
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);

    if (validFlags.indexOf(flag) === -1) {
      this$1.raise(state.start, "Invalid regular expression flag");
    }

    if (flags.indexOf(flag, i + 1) > -1) {
      this$1.raise(state.start, "Duplicate regular expression flag");
    }
  }
};
/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */


pp$9.validateRegExpPattern = function (state) {
  this.regexp_pattern(state); // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.

  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern


pp$9.regexp_pattern = function (state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29
    /* ) */
    )) {
      state.raise("Unmatched ')'");
    }

    if (state.eat(0x5D
    /* [ */
    ) || state.eat(0x7D
    /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }

  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }

  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction


pp$9.regexp_disjunction = function (state) {
  var this$1 = this;
  this.regexp_alternative(state);

  while (state.eat(0x7C
  /* | */
  )) {
    this$1.regexp_alternative(state);
  } // Make the same message as V8.


  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }

  if (state.eat(0x7B
  /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative


pp$9.regexp_alternative = function (state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term


pp$9.regexp_eatTerm = function (state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }

    return true;
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion


pp$9.regexp_eatAssertion = function (state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false; // ^, $

  if (state.eat(0x5E
  /* ^ */
  ) || state.eat(0x24
  /* $ */
  )) {
    return true;
  } // \b \B


  if (state.eat(0x5C
  /* \ */
  )) {
    if (state.eat(0x42
    /* B */
    ) || state.eat(0x62
    /* b */
    )) {
      return true;
    }

    state.pos = start;
  } // Lookahead / Lookbehind


  if (state.eat(0x28
  /* ( */
  ) && state.eat(0x3F
  /* ? */
  )) {
    var lookbehind = false;

    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C
      /* < */
      );
    }

    if (state.eat(0x3D
    /* = */
    ) || state.eat(0x21
    /* ! */
    )) {
      this.regexp_disjunction(state);

      if (!state.eat(0x29
      /* ) */
      )) {
        state.raise("Unterminated group");
      }

      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }

  state.pos = start;
  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier


pp$9.regexp_eatQuantifier = function (state, noError) {
  if (noError === void 0) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F
    /* ? */
    );
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix


pp$9.regexp_eatQuantifierPrefix = function (state, noError) {
  return state.eat(0x2A
  /* * */
  ) || state.eat(0x2B
  /* + */
  ) || state.eat(0x3F
  /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};

pp$9.regexp_eatBracedQuantifier = function (state, noError) {
  var start = state.pos;

  if (state.eat(0x7B
  /* { */
  )) {
    var min = 0,
        max = -1;

    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;

      if (state.eat(0x2C
      /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }

      if (state.eat(0x7D
      /* } */
      )) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }

        return true;
      }
    }

    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }

    state.pos = start;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom


pp$9.regexp_eatAtom = function (state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(0x2E
  /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};

pp$9.regexp_eatReverseSolidusAtomEscape = function (state) {
  var start = state.pos;

  if (state.eat(0x5C
  /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }

    state.pos = start;
  }

  return false;
};

pp$9.regexp_eatUncapturingGroup = function (state) {
  var start = state.pos;

  if (state.eat(0x28
  /* ( */
  )) {
    if (state.eat(0x3F
    /* ? */
    ) && state.eat(0x3A
    /* : */
    )) {
      this.regexp_disjunction(state);

      if (state.eat(0x29
      /* ) */
      )) {
        return true;
      }

      state.raise("Unterminated group");
    }

    state.pos = start;
  }

  return false;
};

pp$9.regexp_eatCapturingGroup = function (state) {
  if (state.eat(0x28
  /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F
    /* ? */
    ) {
        state.raise("Invalid group");
      }

    this.regexp_disjunction(state);

    if (state.eat(0x29
    /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }

    state.raise("Unterminated group");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom


pp$9.regexp_eatExtendedAtom = function (state) {
  return state.eat(0x2E
  /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier


pp$9.regexp_eatInvalidBracedQuantifier = function (state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter


pp$9.regexp_eatSyntaxCharacter = function (state) {
  var ch = state.current();

  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }

  return false;
};

function isSyntaxCharacter(ch) {
  return ch === 0x24
  /* $ */
  || ch >= 0x28
  /* ( */
  && ch <= 0x2B
  /* + */
  || ch === 0x2E
  /* . */
  || ch === 0x3F
  /* ? */
  || ch >= 0x5B
  /* [ */
  && ch <= 0x5E
  /* ^ */
  || ch >= 0x7B
  /* { */
  && ch <= 0x7D
  /* } */
  ;
} // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.


pp$9.regexp_eatPatternCharacters = function (state) {
  var start = state.pos;
  var ch = 0;

  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }

  return state.pos !== start;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter


pp$9.regexp_eatExtendedPatternCharacter = function (state) {
  var ch = state.current();

  if (ch !== -1 && ch !== 0x24
  /* $ */
  && !(ch >= 0x28
  /* ( */
  && ch <= 0x2B
  /* + */
  ) && ch !== 0x2E
  /* . */
  && ch !== 0x3F
  /* ? */
  && ch !== 0x5B
  /* [ */
  && ch !== 0x5E
  /* ^ */
  && ch !== 0x7C
  /* | */
  ) {
      state.advance();
      return true;
    }

  return false;
}; // GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]


pp$9.regexp_groupSpecifier = function (state) {
  if (state.eat(0x3F
  /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }

      state.groupNames.push(state.lastStringValue);
      return;
    }

    state.raise("Invalid group");
  }
}; // GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.


pp$9.regexp_eatGroupName = function (state) {
  state.lastStringValue = "";

  if (state.eat(0x3C
  /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E
    /* > */
    )) {
      return true;
    }

    state.raise("Invalid capture group name");
  }

  return false;
}; // RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.


pp$9.regexp_eatRegExpIdentifierName = function (state) {
  state.lastStringValue = "";

  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString$1(state.lastIntValue);

    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString$1(state.lastIntValue);
    }

    return true;
  }

  return false;
}; // RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]


pp$9.regexp_eatRegExpIdentifierStart = function (state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C
  /* \ */
  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }

  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }

  state.pos = start;
  return false;
};

function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24
  /* $ */
  || ch === 0x5F;
  /* _ */
} // RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>


pp$9.regexp_eatRegExpIdentifierPart = function (state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C
  /* \ */
  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }

  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }

  state.pos = start;
  return false;
};

function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24
  /* $ */
  || ch === 0x5F
  /* _ */
  || ch === 0x200C
  /* <ZWNJ> */
  || ch === 0x200D;
  /* <ZWJ> */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape


pp$9.regexp_eatAtomEscape = function (state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }

  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63
    /* c */
    ) {
        state.raise("Invalid unicode escape");
      }

    state.raise("Invalid escape");
  }

  return false;
};

pp$9.regexp_eatBackReference = function (state) {
  var start = state.pos;

  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;

    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }

      return true;
    }

    if (n <= state.numCapturingParens) {
      return true;
    }

    state.pos = start;
  }

  return false;
};

pp$9.regexp_eatKGroupName = function (state) {
  if (state.eat(0x6B
  /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }

    state.raise("Invalid named reference");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape


pp$9.regexp_eatCharacterEscape = function (state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};

pp$9.regexp_eatCControlLetter = function (state) {
  var start = state.pos;

  if (state.eat(0x63
  /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }

    state.pos = start;
  }

  return false;
};

pp$9.regexp_eatZero = function (state) {
  if (state.current() === 0x30
  /* 0 */
  && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape


pp$9.regexp_eatControlEscape = function (state) {
  var ch = state.current();

  if (ch === 0x74
  /* t */
  ) {
      state.lastIntValue = 0x09;
      /* \t */

      state.advance();
      return true;
    }

  if (ch === 0x6E
  /* n */
  ) {
      state.lastIntValue = 0x0A;
      /* \n */

      state.advance();
      return true;
    }

  if (ch === 0x76
  /* v */
  ) {
      state.lastIntValue = 0x0B;
      /* \v */

      state.advance();
      return true;
    }

  if (ch === 0x66
  /* f */
  ) {
      state.lastIntValue = 0x0C;
      /* \f */

      state.advance();
      return true;
    }

  if (ch === 0x72
  /* r */
  ) {
      state.lastIntValue = 0x0D;
      /* \r */

      state.advance();
      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter


pp$9.regexp_eatControlLetter = function (state) {
  var ch = state.current();

  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true;
  }

  return false;
};

function isControlLetter(ch) {
  return ch >= 0x41
  /* A */
  && ch <= 0x5A
  /* Z */
  || ch >= 0x61
  /* a */
  && ch <= 0x7A
  /* z */
  ;
} // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence


pp$9.regexp_eatRegExpUnicodeEscapeSequence = function (state) {
  var start = state.pos;

  if (state.eat(0x75
  /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;

      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;

        if (state.eat(0x5C
        /* \ */
        ) && state.eat(0x75
        /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;

          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true;
          }
        }

        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }

      return true;
    }

    if (state.switchU && state.eat(0x7B
    /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(0x7D
    /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }

    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }

    state.pos = start;
  }

  return false;
};

function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF;
} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape


pp$9.regexp_eatIdentityEscape = function (state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }

    if (state.eat(0x2F
    /* / */
    )) {
      state.lastIntValue = 0x2F;
      /* / */

      return true;
    }

    return false;
  }

  var ch = state.current();

  if (ch !== 0x63
  /* c */
  && (!state.switchN || ch !== 0x6B
  /* k */
  )) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape


pp$9.regexp_eatDecimalEscape = function (state) {
  state.lastIntValue = 0;
  var ch = state.current();

  if (ch >= 0x31
  /* 1 */
  && ch <= 0x39
  /* 9 */
  ) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30
        /* 0 */
        );
        state.advance();
      } while ((ch = state.current()) >= 0x30
      /* 0 */
      && ch <= 0x39
      /* 9 */
      );

      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape


pp$9.regexp_eatCharacterClassEscape = function (state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true;
  }

  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50
  /* P */
  || ch === 0x70
  /* p */
  )) {
    state.lastIntValue = -1;
    state.advance();

    if (state.eat(0x7B
    /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D
    /* } */
    )) {
      return true;
    }

    state.raise("Invalid property name");
  }

  return false;
};

function isCharacterClassEscape(ch) {
  return ch === 0x64
  /* d */
  || ch === 0x44
  /* D */
  || ch === 0x73
  /* s */
  || ch === 0x53
  /* S */
  || ch === 0x77
  /* w */
  || ch === 0x57
  /* W */
  ;
} // UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue


pp$9.regexp_eatUnicodePropertyValueExpression = function (state) {
  var start = state.pos; // UnicodePropertyName `=` UnicodePropertyValue

  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D
  /* = */
  )) {
    var name = state.lastStringValue;

    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true;
    }
  }

  state.pos = start; // LoneUnicodePropertyNameOrValue

  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true;
  }

  return false;
};

pp$9.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {
    state.raise("Invalid property name");
  }
};

pp$9.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
  if (data.$LONE.indexOf(nameOrValue) === -1) {
    state.raise("Invalid property name");
  }
}; // UnicodePropertyName ::
//   UnicodePropertyNameCharacters


pp$9.regexp_eatUnicodePropertyName = function (state) {
  var ch = 0;
  state.lastStringValue = "";

  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }

  return state.lastStringValue !== "";
};

function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F;
  /* _ */
} // UnicodePropertyValue ::
//   UnicodePropertyValueCharacters


pp$9.regexp_eatUnicodePropertyValue = function (state) {
  var ch = 0;
  state.lastStringValue = "";

  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }

  return state.lastStringValue !== "";
};

function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
} // LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters


pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
  return this.regexp_eatUnicodePropertyValue(state);
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass


pp$9.regexp_eatCharacterClass = function (state) {
  if (state.eat(0x5B
  /* [ */
  )) {
    state.eat(0x5E
    /* ^ */
    );
    this.regexp_classRanges(state);

    if (state.eat(0x5D
    /* [ */
    )) {
      return true;
    } // Unreachable since it threw "unterminated regular expression" error before.


    state.raise("Unterminated character class");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash


pp$9.regexp_classRanges = function (state) {
  var this$1 = this;

  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;

    if (state.eat(0x2D
    /* - */
    ) && this$1.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;

      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }

      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash


pp$9.regexp_eatClassAtom = function (state) {
  var start = state.pos;

  if (state.eat(0x5C
  /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }

    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();

      if (ch$1 === 0x63
      /* c */
      || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }

      state.raise("Invalid escape");
    }

    state.pos = start;
  }

  var ch = state.current();

  if (ch !== 0x5D
  /* [ */
  ) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape


pp$9.regexp_eatClassEscape = function (state) {
  var start = state.pos;

  if (state.eat(0x62
  /* b */
  )) {
    state.lastIntValue = 0x08;
    /* <BS> */

    return true;
  }

  if (state.switchU && state.eat(0x2D
  /* - */
  )) {
    state.lastIntValue = 0x2D;
    /* - */

    return true;
  }

  if (!state.switchU && state.eat(0x63
  /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }

    state.pos = start;
  }

  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter


pp$9.regexp_eatClassControlLetter = function (state) {
  var ch = state.current();

  if (isDecimalDigit(ch) || ch === 0x5F
  /* _ */
  ) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence


pp$9.regexp_eatHexEscapeSequence = function (state) {
  var start = state.pos;

  if (state.eat(0x78
  /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }

    if (state.switchU) {
      state.raise("Invalid escape");
    }

    state.pos = start;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits


pp$9.regexp_eatDecimalDigits = function (state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;

  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30
    /* 0 */
    );
    state.advance();
  }

  return state.pos !== start;
};

function isDecimalDigit(ch) {
  return ch >= 0x30
  /* 0 */
  && ch <= 0x39;
  /* 9 */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits


pp$9.regexp_eatHexDigits = function (state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;

  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }

  return state.pos !== start;
};

function isHexDigit(ch) {
  return ch >= 0x30
  /* 0 */
  && ch <= 0x39
  /* 9 */
  || ch >= 0x41
  /* A */
  && ch <= 0x46
  /* F */
  || ch >= 0x61
  /* a */
  && ch <= 0x66
  /* f */
  ;
}

function hexToInt(ch) {
  if (ch >= 0x41
  /* A */
  && ch <= 0x46
  /* F */
  ) {
      return 10 + (ch - 0x41
      /* A */
      );
    }

  if (ch >= 0x61
  /* a */
  && ch <= 0x66
  /* f */
  ) {
      return 10 + (ch - 0x61
      /* a */
      );
    }

  return ch - 0x30;
  /* 0 */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).


pp$9.regexp_eatLegacyOctalEscapeSequence = function (state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;

    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;

      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }

    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit


pp$9.regexp_eatOctalDigit = function (state) {
  var ch = state.current();

  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30;
    /* 0 */

    state.advance();
    return true;
  }

  state.lastIntValue = 0;
  return false;
};

function isOctalDigit(ch) {
  return ch >= 0x30
  /* 0 */
  && ch <= 0x37;
  /* 7 */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence


pp$9.regexp_eatFixedHexDigits = function (state, length) {
  var start = state.pos;
  state.lastIntValue = 0;

  for (var i = 0; i < length; ++i) {
    var ch = state.current();

    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }

    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }

  return true;
}; // Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.


var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;

  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }

  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
}; // ## Tokenizer


exports.Token = Token;
var pp$8 = Parser.prototype; // Move to the next token

pp$8.next = function () {
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$8.getToken = function () {
  this.next();
  return new Token(this);
}; // If we're in an ES6 environment, make parsers iterable


if (typeof Symbol !== "undefined") {
  pp$8[Symbol.iterator] = function () {
    var this$1 = this;
    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        };
      }
    };
  };
} // Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).


pp$8.curContext = function () {
  return this.context[this.context.length - 1];
}; // Read a single token, updating the parser object's token-related
// properties.


pp$8.nextToken = function () {
  var curContext = this.curContext();

  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }

  this.start = this.pos;

  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }

  if (this.pos >= this.input.length) {
    return this.finishToken(types.eof);
  }

  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};

pp$8.readToken = function (code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92
  /* '\' */
  ) {
      return this.readWord();
    }

  return this.getTokenFromCode(code);
};

pp$8.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);

  if (code <= 0xd7ff || code >= 0xe000) {
    return code;
  }

  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp$8.skipBlockComment = function () {
  var this$1 = this;
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);

  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }

  this.pos = end + 2;

  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;

    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this$1.curLine;
      this$1.lineStart = match.index + match[0].length;
    }
  }

  if (this.options.onComment) {
    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
  }
};

pp$8.skipLineComment = function (startSkip) {
  var this$1 = this;
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);

  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this$1.input.charCodeAt(++this$1.pos);
  }

  if (this.options.onComment) {
    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
  }
}; // Called at the start of the parse and after every token. Skips
// whitespace and comments, and.


pp$8.skipSpace = function () {
  var this$1 = this;

  loop: while (this.pos < this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos);

    switch (ch) {
      case 32:
      case 160:
        // ' '
        ++this$1.pos;
        break;

      case 13:
        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
          ++this$1.pos;
        }

      case 10:
      case 8232:
      case 8233:
        ++this$1.pos;

        if (this$1.options.locations) {
          ++this$1.curLine;
          this$1.lineStart = this$1.pos;
        }

        break;

      case 47:
        // '/'
        switch (this$1.input.charCodeAt(this$1.pos + 1)) {
          case 42:
            // '*'
            this$1.skipBlockComment();
            break;

          case 47:
            this$1.skipLineComment(2);
            break;

          default:
            break loop;
        }

        break;

      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this$1.pos;
        } else {
          break loop;
        }

    }
  }
}; // Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.


pp$8.finishToken = function (type, val) {
  this.end = this.pos;

  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }

  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
}; // ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//


pp$8.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);

  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }

  var next2 = this.input.charCodeAt(this.pos + 2);

  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types.dot);
  }
};

pp$8.readToken_slash = function () {
  // '/'
  var next = this.input.charCodeAt(this.pos + 1);

  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(types.slash, 1);
};

pp$8.readToken_mult_modulo_exp = function (code) {
  // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo; // exponentiation operator ** and **=

  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) {
    return this.finishOp(types.assign, size + 1);
  }

  return this.finishOp(tokentype, size);
};

pp$8.readToken_pipe_amp = function (code) {
  // '|&'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === code) {
    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
  }

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
};

pp$8.readToken_caret = function () {
  // '^'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(types.bitwiseXOR, 1);
};

pp$8.readToken_plus_min = function (code) {
  // '+-'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }

    return this.finishOp(types.incDec, 2);
  }

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(types.plusMin, 1);
};

pp$8.readToken_lt_gt = function (code) {
  // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;

  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;

    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types.assign, size + 1);
    }

    return this.finishOp(types.bitShift, size);
  }

  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }

  if (next === 61) {
    size = 2;
  }

  return this.finishOp(types.relational, size);
};

pp$8.readToken_eq_excl = function (code) {
  // '=!'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === 61) {
    return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }

  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow);
  }

  return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
};

pp$8.getTokenFromCode = function (code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      // '.'
      return this.readToken_dot();
    // Punctuation tokens.

    case 40:
      ++this.pos;
      return this.finishToken(types.parenL);

    case 41:
      ++this.pos;
      return this.finishToken(types.parenR);

    case 59:
      ++this.pos;
      return this.finishToken(types.semi);

    case 44:
      ++this.pos;
      return this.finishToken(types.comma);

    case 91:
      ++this.pos;
      return this.finishToken(types.bracketL);

    case 93:
      ++this.pos;
      return this.finishToken(types.bracketR);

    case 123:
      ++this.pos;
      return this.finishToken(types.braceL);

    case 125:
      ++this.pos;
      return this.finishToken(types.braceR);

    case 58:
      ++this.pos;
      return this.finishToken(types.colon);

    case 63:
      ++this.pos;
      return this.finishToken(types.question);

    case 96:
      // '`'
      if (this.options.ecmaVersion < 6) {
        break;
      }

      ++this.pos;
      return this.finishToken(types.backQuote);

    case 48:
      // '0'
      var next = this.input.charCodeAt(this.pos + 1);

      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      } // '0x', '0X' - hex number


      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        } // '0o', '0O' - octal number


        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        } // '0b', '0B' - binary number

      }

    // Anything else beginning with a digit is an integer, octal
    // number, or float.

    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      // 1-9
      return this.readNumber(false);
    // Quotes produce strings.

    case 34:
    case 39:
      // '"', "'"
      return this.readString(code);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47:
      // '/'
      return this.readToken_slash();

    case 37:
    case 42:
      // '%*'
      return this.readToken_mult_modulo_exp(code);

    case 124:
    case 38:
      // '|&'
      return this.readToken_pipe_amp(code);

    case 94:
      // '^'
      return this.readToken_caret();

    case 43:
    case 45:
      // '+-'
      return this.readToken_plus_min(code);

    case 60:
    case 62:
      // '<>'
      return this.readToken_lt_gt(code);

    case 61:
    case 33:
      // '=!'
      return this.readToken_eq_excl(code);

    case 126:
      // '~'
      return this.finishOp(types.prefix, 1);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp$8.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};

pp$8.readRegexp = function () {
  var this$1 = this;
  var escaped,
      inClass,
      start = this.pos;

  for (;;) {
    if (this$1.pos >= this$1.input.length) {
      this$1.raise(start, "Unterminated regular expression");
    }

    var ch = this$1.input.charAt(this$1.pos);

    if (lineBreak.test(ch)) {
      this$1.raise(start, "Unterminated regular expression");
    }

    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }

      escaped = ch === "\\";
    } else {
      escaped = false;
    }

    ++this$1.pos;
  }

  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();

  if (this.containsEsc) {
    this.unexpected(flagsStart);
  } // Validate pattern


  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state); // Create Literal#value property value.

  var value = null;

  try {
    value = new RegExp(pattern, flags);
  } catch (e) {// ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {
    pattern: pattern,
    flags: flags,
    value: value
  });
}; // Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.


pp$8.readInt = function (radix, len) {
  var this$1 = this;
  var start = this.pos,
      total = 0;

  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos),
        val = void 0;

    if (code >= 97) {
      val = code - 97 + 10;
    } // a
    else if (code >= 65) {
        val = code - 65 + 10;
      } // A
      else if (code >= 48 && code <= 57) {
          val = code - 48;
        } // 0-9
        else {
            val = Infinity;
          }

    if (val >= radix) {
      break;
    }

    ++this$1.pos;
    total = total * radix + val;
  }

  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }

  return total;
};

pp$8.readRadixNumber = function (radix) {
  this.pos += 2; // 0x

  var val = this.readInt(radix);

  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }

  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }

  return this.finishToken(types.num, val);
}; // Read an integer, octal integer, or floating-point number.


pp$8.readNumber = function (startsWithDot) {
  var start = this.pos;

  if (!startsWithDot && this.readInt(10) === null) {
    this.raise(start, "Invalid number");
  }

  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;

  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }

  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }

  var next = this.input.charCodeAt(this.pos);

  if (next === 46 && !octal) {
    // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }

  if ((next === 69 || next === 101) && !octal) {
    // 'eE'
    next = this.input.charCodeAt(++this.pos);

    if (next === 43 || next === 45) {
      ++this.pos;
    } // '+-'


    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }

  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val);
}; // Read a string value, interpreting backslash-escapes.


pp$8.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code;

  if (ch === 123) {
    // '{'
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }

    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;

    if (code > 0x10FFFF) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }

  return code;
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  }

  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp$8.readString = function (quote) {
  var this$1 = this;
  var out = "",
      chunkStart = ++this.pos;

  for (;;) {
    if (this$1.pos >= this$1.input.length) {
      this$1.raise(this$1.start, "Unterminated string constant");
    }

    var ch = this$1.input.charCodeAt(this$1.pos);

    if (ch === quote) {
      break;
    }

    if (ch === 92) {
      // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(false);
      chunkStart = this$1.pos;
    } else {
      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) {
        this$1.raise(this$1.start, "Unterminated string constant");
      }

      ++this$1.pos;
    }
  }

  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out);
}; // Reads template string tokens.


var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$8.tryReadTemplateToken = function () {
  this.inTemplateElement = true;

  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }

  this.inTemplateElement = false;
};

pp$8.invalidStringToken = function (position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};

pp$8.readTmplToken = function () {
  var this$1 = this;
  var out = "",
      chunkStart = this.pos;

  for (;;) {
    if (this$1.pos >= this$1.input.length) {
      this$1.raise(this$1.start, "Unterminated template");
    }

    var ch = this$1.input.charCodeAt(this$1.pos);

    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {
      // '`', '${'
      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
        if (ch === 36) {
          this$1.pos += 2;
          return this$1.finishToken(types.dollarBraceL);
        } else {
          ++this$1.pos;
          return this$1.finishToken(types.backQuote);
        }
      }

      out += this$1.input.slice(chunkStart, this$1.pos);
      return this$1.finishToken(types.template, out);
    }

    if (ch === 92) {
      // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(true);
      chunkStart = this$1.pos;
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos);
      ++this$1.pos;

      switch (ch) {
        case 13:
          if (this$1.input.charCodeAt(this$1.pos) === 10) {
            ++this$1.pos;
          }

        case 10:
          out += "\n";
          break;

        default:
          out += String.fromCharCode(ch);
          break;
      }

      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }

      chunkStart = this$1.pos;
    } else {
      ++this$1.pos;
    }
  }
}; // Reads a template token to search for the end, without validating any escape sequences


pp$8.readInvalidTemplateToken = function () {
  var this$1 = this;

  for (; this.pos < this.input.length; this.pos++) {
    switch (this$1.input[this$1.pos]) {
      case "\\":
        ++this$1.pos;
        break;

      case "$":
        if (this$1.input[this$1.pos + 1] !== "{") {
          break;
        }

      // falls through

      case "`":
        return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos));
      // no default
    }
  }

  this.raise(this.start, "Unterminated template");
}; // Used to read escaped characters


pp$8.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;

  switch (ch) {
    case 110:
      return "\n";
    // 'n' -> '\n'

    case 114:
      return "\r";
    // 'r' -> '\r'

    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'

    case 117:
      return codePointToString(this.readCodePoint());
    // 'u'

    case 116:
      return "\t";
    // 't' -> '\t'

    case 98:
      return "\b";
    // 'b' -> '\b'

    case 118:
      return "\u000b";
    // 'v' -> '\u000b'

    case 102:
      return "\f";
    // 'f' -> '\f'

    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }

    // '\r\n'

    case 10:
      // ' \n'
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }

      return "";

    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);

        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }

        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);

        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
        }

        return String.fromCharCode(octal);
      }

      return String.fromCharCode(ch);
  }
}; // Used to read character escape sequences ('\x', '\u', '\U').


pp$8.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);

  if (n === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }

  return n;
}; // Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.


pp$8.readWord1 = function () {
  var this$1 = this;
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;

  while (this.pos < this.input.length) {
    var ch = this$1.fullCharCodeAtPos();

    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      // "\"
      this$1.containsEsc = true;
      word += this$1.input.slice(chunkStart, this$1.pos);
      var escStart = this$1.pos;

      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // "u"
        {
          this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX");
        }

      ++this$1.pos;
      var esc = this$1.readCodePoint();

      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this$1.invalidStringToken(escStart, "Invalid Unicode escape");
      }

      word += codePointToString(esc);
      chunkStart = this$1.pos;
    } else {
      break;
    }

    first = false;
  }

  return word + this.input.slice(chunkStart, this.pos);
}; // Read an identifier or keyword token. Will check for reserved
// words when necessary.


pp$8.readWord = function () {
  var word = this.readWord1();
  var type = types.name;

  if (this.keywords.test(word)) {
    if (this.containsEsc) {
      this.raiseRecoverable(this.start, "Escape sequence in keyword " + word);
    }

    type = keywords$1[word];
  }

  return this.finishToken(type, word);
}; // Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js


var version = "5.7.3"; // The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

exports.version = version;

function parse(input, options) {
  return new Parser(options, input).parse();
} // This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.


function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
} // Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.


function tokenizer(input, options) {
  return new Parser(options, input);
} // This is a terrible kludge to support the existing, pre-ES6
// interface where the loose parser module retroactively adds exports
// to this module.


var parse_dammit;
exports.parse_dammit = parse_dammit;
var LooseParser;
exports.LooseParser = LooseParser;
var pluginsLoose; // eslint-disable-line camelcase

exports.pluginsLoose = pluginsLoose;

function addLooseExports(parse, Parser$$1, plugins$$1) {
  exports.parse_dammit = parse_dammit = parse; // eslint-disable-line camelcase

  exports.LooseParser = LooseParser = Parser$$1;
  exports.pluginsLoose = pluginsLoose = plugins$$1;
}
},{}],"node_modules/paper/dist/paper-full.js":[function(require,module,exports) {
var define;
var process = require("process");
var global = arguments[3];
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * Paper.js v0.12.11 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jrg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Fri Jun 19 19:14:33 2020 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jrg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */
var paper = function (self, undefined) {
  self = self || require('./node/self.js');
  var window = self.window,
      document = self.document;
  var Base = new function () {
    var hidden = /^(statics|enumerable|beans|preserve)$/,
        array = [],
        _slice = array.slice,
        create = Object.create,
        describe = Object.getOwnPropertyDescriptor,
        define = Object.defineProperty,
        forEach = array.forEach || function (iter, bind) {
      for (var i = 0, l = this.length; i < l; i++) {
        iter.call(bind, this[i], i, this);
      }
    },
        forIn = function forIn(iter, bind) {
      for (var i in this) {
        if (this.hasOwnProperty(i)) iter.call(bind, this[i], i, this);
      }
    },
        set = Object.assign || function (dst) {
      for (var i = 1, l = arguments.length; i < l; i++) {
        var src = arguments[i];

        for (var key in src) {
          if (src.hasOwnProperty(key)) dst[key] = src[key];
        }
      }

      return dst;
    },
        _each = function each(obj, iter, bind) {
      if (obj) {
        var desc = describe(obj, 'length');
        (desc && typeof desc.value === 'number' ? forEach : forIn).call(obj, iter, bind = bind || obj);
      }

      return bind;
    };

    function _inject(dest, src, enumerable, beans, preserve) {
      var beansNames = {};

      function field(name, val) {
        val = val || (val = describe(src, name)) && (val.get ? val : val.value);
        if (typeof val === 'string' && val[0] === '#') val = dest[val.substring(1)] || val;
        var isFunc = typeof val === 'function',
            res = val,
            prev = preserve || isFunc && !val.base ? val && val.get ? name in dest : dest[name] : null,
            bean;

        if (!preserve || !prev) {
          if (isFunc && prev) val.base = prev;
          if (isFunc && beans !== false && (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/))) beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];

          if (!res || isFunc || !res.get || typeof res.get !== 'function' || !Base.isPlainObject(res)) {
            res = {
              value: res,
              writable: true
            };
          }

          if ((describe(dest, name) || {
            configurable: true
          }).configurable) {
            res.configurable = true;
            res.enumerable = enumerable != null ? enumerable : !bean;
          }

          define(dest, name, res);
        }
      }

      if (src) {
        for (var name in src) {
          if (src.hasOwnProperty(name) && !hidden.test(name)) field(name);
        }

        for (var name in beansNames) {
          var part = beansNames[name],
              set = dest['set' + part],
              get = dest['get' + part] || set && dest['is' + part];
          if (get && (beans === true || get.length === 0)) field(name, {
            get: get,
            set: set
          });
        }
      }

      return dest;
    }

    function Base() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        var src = arguments[i];
        if (src) set(this, src);
      }

      return this;
    }

    return _inject(Base, {
      inject: function inject(src) {
        if (src) {
          var statics = src.statics === true ? src : src.statics,
              beans = src.beans,
              preserve = src.preserve;
          if (statics !== src) _inject(this.prototype, src, src.enumerable, beans, preserve);

          _inject(this, statics, null, beans, preserve);
        }

        for (var i = 1, l = arguments.length; i < l; i++) {
          this.inject(arguments[i]);
        }

        return this;
      },
      extend: function extend() {
        var base = this,
            ctor,
            proto;

        for (var i = 0, obj, l = arguments.length; i < l && !(ctor && proto); i++) {
          obj = arguments[i];
          ctor = ctor || obj.initialize;
          proto = proto || obj.prototype;
        }

        ctor = ctor || function () {
          base.apply(this, arguments);
        };

        proto = ctor.prototype = proto || create(this.prototype);
        define(proto, 'constructor', {
          value: ctor,
          writable: true,
          configurable: true
        });

        _inject(ctor, this);

        if (arguments.length) this.inject.apply(ctor, arguments);
        ctor.base = base;
        return ctor;
      }
    }).inject({
      enumerable: false,
      initialize: Base,
      set: Base,
      inject: function inject() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          var src = arguments[i];

          if (src) {
            _inject(this, src, src.enumerable, src.beans, src.preserve);
          }
        }

        return this;
      },
      extend: function extend() {
        var res = create(this);
        return res.inject.apply(res, arguments);
      },
      each: function each(iter, bind) {
        return _each(this, iter, bind);
      },
      clone: function clone() {
        return new this.constructor(this);
      },
      statics: {
        set: set,
        each: _each,
        create: create,
        define: define,
        describe: describe,
        clone: function clone(obj) {
          return set(new obj.constructor(), obj);
        },
        isPlainObject: function isPlainObject(obj) {
          var ctor = obj != null && obj.constructor;
          return ctor && (ctor === Object || ctor === Base || ctor.name === 'Object');
        },
        pick: function pick(a, b) {
          return a !== undefined ? a : b;
        },
        slice: function slice(list, begin, end) {
          return _slice.call(list, begin, end);
        }
      }
    });
  }();
  if (typeof module !== 'undefined') module.exports = Base;
  Base.inject({
    enumerable: false,
    toString: function toString() {
      return this._id != null ? (this._class || 'Object') + (this._name ? " '" + this._name + "'" : ' @' + this._id) : '{ ' + Base.each(this, function (value, key) {
        if (!/^_/.test(key)) {
          var type = _typeof(value);

          this.push(key + ': ' + (type === 'number' ? Formatter.instance.number(value) : type === 'string' ? "'" + value + "'" : value));
        }
      }, []).join(', ') + ' }';
    },
    getClassName: function getClassName() {
      return this._class || '';
    },
    importJSON: function importJSON(json) {
      return Base.importJSON(json, this);
    },
    exportJSON: function exportJSON(options) {
      return Base.exportJSON(this, options);
    },
    toJSON: function toJSON() {
      return Base.serialize(this);
    },
    set: function set(props, exclude) {
      if (props) Base.filter(this, props, exclude, this._prioritize);
      return this;
    }
  }, {
    beans: false,
    statics: {
      exports: {},
      extend: function extend() {
        var res = extend.base.apply(this, arguments),
            name = res.prototype._class;
        if (name && !Base.exports[name]) Base.exports[name] = res;
        return res;
      },
      equals: function equals(obj1, obj2) {
        if (obj1 === obj2) return true;
        if (obj1 && obj1.equals) return obj1.equals(obj2);
        if (obj2 && obj2.equals) return obj2.equals(obj1);

        if (obj1 && obj2 && _typeof(obj1) === 'object' && _typeof(obj2) === 'object') {
          if (Array.isArray(obj1) && Array.isArray(obj2)) {
            var length = obj1.length;
            if (length !== obj2.length) return false;

            while (length--) {
              if (!Base.equals(obj1[length], obj2[length])) return false;
            }
          } else {
            var keys = Object.keys(obj1),
                length = keys.length;
            if (length !== Object.keys(obj2).length) return false;

            while (length--) {
              var key = keys[length];
              if (!(obj2.hasOwnProperty(key) && Base.equals(obj1[key], obj2[key]))) return false;
            }
          }

          return true;
        }

        return false;
      },
      read: function read(list, start, options, amount) {
        if (this === Base) {
          var value = this.peek(list, start);
          list.__index++;
          return value;
        }

        var proto = this.prototype,
            readIndex = proto._readIndex,
            begin = start || readIndex && list.__index || 0,
            length = list.length,
            obj = list[begin];
        amount = amount || length - begin;

        if (obj instanceof this || options && options.readNull && obj == null && amount <= 1) {
          if (readIndex) list.__index = begin + 1;
          return obj && options && options.clone ? obj.clone() : obj;
        }

        obj = Base.create(proto);
        if (readIndex) obj.__read = true;
        obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length ? Base.slice(list, begin, begin + amount) : list) || obj;

        if (readIndex) {
          list.__index = begin + obj.__read;
          var filtered = obj.__filtered;

          if (filtered) {
            list.__filtered = filtered;
            obj.__filtered = undefined;
          }

          obj.__read = undefined;
        }

        return obj;
      },
      peek: function peek(list, start) {
        return list[list.__index = start || list.__index || 0];
      },
      remain: function remain(list) {
        return list.length - (list.__index || 0);
      },
      readList: function readList(list, start, options, amount) {
        var res = [],
            entry,
            begin = start || 0,
            end = amount ? begin + amount : list.length;

        for (var i = begin; i < end; i++) {
          res.push(Array.isArray(entry = list[i]) ? this.read(entry, 0, options) : this.read(list, i, options, 1));
        }

        return res;
      },
      readNamed: function readNamed(list, name, start, options, amount) {
        var value = this.getNamed(list, name),
            hasValue = value !== undefined;

        if (hasValue) {
          var filtered = list.__filtered;

          if (!filtered) {
            var source = this.getSource(list);
            filtered = list.__filtered = Base.create(source);
            filtered.__unfiltered = source;
          }

          filtered[name] = undefined;
        }

        return this.read(hasValue ? [value] : list, start, options, amount);
      },
      readSupported: function readSupported(list, dest) {
        var source = this.getSource(list),
            that = this,
            read = false;

        if (source) {
          Object.keys(source).forEach(function (key) {
            if (key in dest) {
              var value = that.readNamed(list, key);

              if (value !== undefined) {
                dest[key] = value;
              }

              read = true;
            }
          });
        }

        return read;
      },
      getSource: function getSource(list) {
        var source = list.__source;

        if (source === undefined) {
          var arg = list.length === 1 && list[0];
          source = list.__source = arg && Base.isPlainObject(arg) ? arg : null;
        }

        return source;
      },
      getNamed: function getNamed(list, name) {
        var source = this.getSource(list);

        if (source) {
          return name ? source[name] : list.__filtered || source;
        }
      },
      hasNamed: function hasNamed(list, name) {
        return !!this.getNamed(list, name);
      },
      filter: function filter(dest, source, exclude, prioritize) {
        var processed;

        function handleKey(key) {
          if (!(exclude && key in exclude) && !(processed && key in processed)) {
            var value = source[key];
            if (value !== undefined) dest[key] = value;
          }
        }

        if (prioritize) {
          var keys = {};

          for (var i = 0, key, l = prioritize.length; i < l; i++) {
            if ((key = prioritize[i]) in source) {
              handleKey(key);
              keys[key] = true;
            }
          }

          processed = keys;
        }

        Object.keys(source.__unfiltered || source).forEach(handleKey);
        return dest;
      },
      isPlainValue: function isPlainValue(obj, asString) {
        return Base.isPlainObject(obj) || Array.isArray(obj) || asString && typeof obj === 'string';
      },
      serialize: function serialize(obj, options, compact, dictionary) {
        options = options || {};
        var isRoot = !dictionary,
            res;

        if (isRoot) {
          options.formatter = new Formatter(options.precision);
          dictionary = {
            length: 0,
            definitions: {},
            references: {},
            add: function add(item, create) {
              var id = '#' + item._id,
                  ref = this.references[id];

              if (!ref) {
                this.length++;
                var res = create.call(item),
                    name = item._class;
                if (name && res[0] !== name) res.unshift(name);
                this.definitions[id] = res;
                ref = this.references[id] = [id];
              }

              return ref;
            }
          };
        }

        if (obj && obj._serialize) {
          res = obj._serialize(options, dictionary);
          var name = obj._class;

          if (name && !obj._compactSerialize && (isRoot || !compact) && res[0] !== name) {
            res.unshift(name);
          }
        } else if (Array.isArray(obj)) {
          res = [];

          for (var i = 0, l = obj.length; i < l; i++) {
            res[i] = Base.serialize(obj[i], options, compact, dictionary);
          }
        } else if (Base.isPlainObject(obj)) {
          res = {};
          var keys = Object.keys(obj);

          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            res[key] = Base.serialize(obj[key], options, compact, dictionary);
          }
        } else if (typeof obj === 'number') {
          res = options.formatter.number(obj, options.precision);
        } else {
          res = obj;
        }

        return isRoot && dictionary.length > 0 ? [['dictionary', dictionary.definitions], res] : res;
      },
      deserialize: function deserialize(json, create, _data, _setDictionary, _isRoot) {
        var res = json,
            isFirst = !_data,
            hasDictionary = isFirst && json && json.length && json[0][0] === 'dictionary';
        _data = _data || {};

        if (Array.isArray(json)) {
          var type = json[0],
              isDictionary = type === 'dictionary';

          if (json.length == 1 && /^#/.test(type)) {
            return _data.dictionary[type];
          }

          type = Base.exports[type];
          res = [];

          for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
            res.push(Base.deserialize(json[i], create, _data, isDictionary, hasDictionary));
          }

          if (type) {
            var args = res;

            if (create) {
              res = create(type, args, isFirst || _isRoot);
            } else {
              res = new type(args);
            }
          }
        } else if (Base.isPlainObject(json)) {
          res = {};
          if (_setDictionary) _data.dictionary = res;

          for (var key in json) {
            res[key] = Base.deserialize(json[key], create, _data);
          }
        }

        return hasDictionary ? res[1] : res;
      },
      exportJSON: function exportJSON(obj, options) {
        var json = Base.serialize(obj, options);
        return options && options.asString == false ? json : JSON.stringify(json);
      },
      importJSON: function importJSON(json, target) {
        return Base.deserialize(typeof json === 'string' ? JSON.parse(json) : json, function (ctor, args, isRoot) {
          var useTarget = isRoot && target && target.constructor === ctor,
              obj = useTarget ? target : Base.create(ctor.prototype);

          if (args.length === 1 && obj instanceof Item && (useTarget || !(obj instanceof Layer))) {
            var arg = args[0];

            if (Base.isPlainObject(arg)) {
              arg.insert = false;

              if (useTarget) {
                args = args.concat([{
                  insert: true
                }]);
              }
            }
          }

          (useTarget ? obj.set : ctor).apply(obj, args);
          if (useTarget) target = null;
          return obj;
        });
      },
      push: function push(list, items) {
        var itemsLength = items.length;

        if (itemsLength < 4096) {
          list.push.apply(list, items);
        } else {
          var startLength = list.length;
          list.length += itemsLength;

          for (var i = 0; i < itemsLength; i++) {
            list[startLength + i] = items[i];
          }
        }

        return list;
      },
      splice: function splice(list, items, index, remove) {
        var amount = items && items.length,
            append = index === undefined;
        index = append ? list.length : index;
        if (index > list.length) index = list.length;

        for (var i = 0; i < amount; i++) {
          items[i]._index = index + i;
        }

        if (append) {
          Base.push(list, items);
          return [];
        } else {
          var args = [index, remove];
          if (items) Base.push(args, items);
          var removed = list.splice.apply(list, args);

          for (var i = 0, l = removed.length; i < l; i++) {
            removed[i]._index = undefined;
          }

          for (var i = index + amount, l = list.length; i < l; i++) {
            list[i]._index = i;
          }

          return removed;
        }
      },
      capitalize: function capitalize(str) {
        return str.replace(/\b[a-z]/g, function (match) {
          return match.toUpperCase();
        });
      },
      camelize: function camelize(str) {
        return str.replace(/-(.)/g, function (match, chr) {
          return chr.toUpperCase();
        });
      },
      hyphenate: function hyphenate(str) {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
      }
    }
  });
  var Emitter = {
    on: function on(type, func) {
      if (typeof type !== 'string') {
        Base.each(type, function (value, key) {
          this.on(key, value);
        }, this);
      } else {
        var types = this._eventTypes,
            entry = types && types[type],
            handlers = this._callbacks = this._callbacks || {};
        handlers = handlers[type] = handlers[type] || [];

        if (handlers.indexOf(func) === -1) {
          handlers.push(func);
          if (entry && entry.install && handlers.length === 1) entry.install.call(this, type);
        }
      }

      return this;
    },
    off: function off(type, func) {
      if (typeof type !== 'string') {
        Base.each(type, function (value, key) {
          this.off(key, value);
        }, this);
        return;
      }

      var types = this._eventTypes,
          entry = types && types[type],
          handlers = this._callbacks && this._callbacks[type],
          index;

      if (handlers) {
        if (!func || (index = handlers.indexOf(func)) !== -1 && handlers.length === 1) {
          if (entry && entry.uninstall) entry.uninstall.call(this, type);
          delete this._callbacks[type];
        } else if (index !== -1) {
          handlers.splice(index, 1);
        }
      }

      return this;
    },
    once: function once(type, func) {
      return this.on(type, function handler() {
        func.apply(this, arguments);
        this.off(type, handler);
      });
    },
    emit: function emit(type, event) {
      var handlers = this._callbacks && this._callbacks[type];
      if (!handlers) return false;
      var args = Base.slice(arguments, 1),
          setTarget = event && event.target && !event.currentTarget;
      handlers = handlers.slice();
      if (setTarget) event.currentTarget = this;

      for (var i = 0, l = handlers.length; i < l; i++) {
        if (handlers[i].apply(this, args) == false) {
          if (event && event.stop) event.stop();
          break;
        }
      }

      if (setTarget) delete event.currentTarget;
      return true;
    },
    responds: function responds(type) {
      return !!(this._callbacks && this._callbacks[type]);
    },
    attach: '#on',
    detach: '#off',
    fire: '#emit',
    _installEvents: function _installEvents(install) {
      var types = this._eventTypes,
          handlers = this._callbacks,
          key = install ? 'install' : 'uninstall';

      if (types) {
        for (var type in handlers) {
          if (handlers[type].length > 0) {
            var entry = types[type],
                func = entry && entry[key];
            if (func) func.call(this, type);
          }
        }
      }
    },
    statics: {
      inject: function inject(src) {
        var events = src._events;

        if (events) {
          var types = {};
          Base.each(events, function (entry, key) {
            var isString = typeof entry === 'string',
                name = isString ? entry : key,
                part = Base.capitalize(name),
                type = name.substring(2).toLowerCase();
            types[type] = isString ? {} : entry;
            name = '_' + name;

            src['get' + part] = function () {
              return this[name];
            };

            src['set' + part] = function (func) {
              var prev = this[name];
              if (prev) this.off(type, prev);
              if (func) this.on(type, func);
              this[name] = func;
            };
          });
          src._eventTypes = types;
        }

        return inject.base.apply(this, arguments);
      }
    }
  };
  var PaperScope = Base.extend({
    _class: 'PaperScope',
    initialize: function PaperScope() {
      paper = this;
      this.settings = new Base({
        applyMatrix: true,
        insertItems: true,
        handleSize: 4,
        hitTolerance: 0
      });
      this.project = null;
      this.projects = [];
      this.tools = [];
      this._id = PaperScope._id++;
      PaperScope._scopes[this._id] = this;
      var proto = PaperScope.prototype;

      if (!this.support) {
        var ctx = CanvasProvider.getContext(1, 1) || {};
        proto.support = {
          nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
          nativeBlendModes: BlendMode.nativeModes
        };
        CanvasProvider.release(ctx);
      }

      if (!this.agent) {
        var user = self.navigator.userAgent.toLowerCase(),
            os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user) || [])[0],
            platform = os === 'darwin' ? 'mac' : os,
            agent = proto.agent = proto.browser = {
          platform: platform
        };
        if (platform) agent[platform] = true;
        user.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g, function (match, n, v1, v2, rv) {
          if (!agent.chrome) {
            var v = n === 'opera' ? v2 : /^(node|trident)$/.test(n) ? rv : v1;
            agent.version = v;
            agent.versionNumber = parseFloat(v);
            n = {
              trident: 'msie',
              jsdom: 'node'
            }[n] || n;
            agent.name = n;
            agent[n] = true;
          }
        });
        if (agent.chrome) delete agent.webkit;
        if (agent.atom) delete agent.chrome;
      }
    },
    version: "0.12.11",
    getView: function getView() {
      var project = this.project;
      return project && project._view;
    },
    getPaper: function getPaper() {
      return this;
    },
    execute: function execute(code, options) {
      var exports = paper.PaperScript.execute(code, this, options);
      View.updateFocus();
      return exports;
    },
    install: function install(scope) {
      var that = this;
      Base.each(['project', 'view', 'tool'], function (key) {
        Base.define(scope, key, {
          configurable: true,
          get: function get() {
            return that[key];
          }
        });
      });

      for (var key in this) {
        if (!/^_/.test(key) && this[key]) scope[key] = this[key];
      }
    },
    setup: function setup(element) {
      paper = this;
      this.project = new Project(element);
      return this;
    },
    createCanvas: function createCanvas(width, height) {
      return CanvasProvider.getCanvas(width, height);
    },
    activate: function activate() {
      paper = this;
    },
    clear: function clear() {
      var projects = this.projects,
          tools = this.tools;

      for (var i = projects.length - 1; i >= 0; i--) {
        projects[i].remove();
      }

      for (var i = tools.length - 1; i >= 0; i--) {
        tools[i].remove();
      }
    },
    remove: function remove() {
      this.clear();
      delete PaperScope._scopes[this._id];
    },
    statics: new function () {
      function handleAttribute(name) {
        name += 'Attribute';
        return function (el, attr) {
          return el[name](attr) || el[name]('data-paper-' + attr);
        };
      }

      return {
        _scopes: {},
        _id: 0,
        get: function get(id) {
          return this._scopes[id] || null;
        },
        getAttribute: handleAttribute('get'),
        hasAttribute: handleAttribute('has')
      };
    }()
  });
  var PaperScopeItem = Base.extend(Emitter, {
    initialize: function initialize(activate) {
      this._scope = paper;
      this._index = this._scope[this._list].push(this) - 1;
      if (activate || !this._scope[this._reference]) this.activate();
    },
    activate: function activate() {
      if (!this._scope) return false;
      var prev = this._scope[this._reference];
      if (prev && prev !== this) prev.emit('deactivate');
      this._scope[this._reference] = this;
      this.emit('activate', prev);
      return true;
    },
    isActive: function isActive() {
      return this._scope[this._reference] === this;
    },
    remove: function remove() {
      if (this._index == null) return false;
      Base.splice(this._scope[this._list], null, this._index, 1);
      if (this._scope[this._reference] == this) this._scope[this._reference] = null;
      this._scope = null;
      return true;
    },
    getView: function getView() {
      return this._scope.getView();
    }
  });
  var CollisionDetection = {
    findItemBoundsCollisions: function findItemBoundsCollisions(items1, items2, tolerance) {
      function getBounds(items) {
        var bounds = new Array(items.length);

        for (var i = 0; i < items.length; i++) {
          var rect = items[i].getBounds();
          bounds[i] = [rect.left, rect.top, rect.right, rect.bottom];
        }

        return bounds;
      }

      var bounds1 = getBounds(items1),
          bounds2 = !items2 || items2 === items1 ? bounds1 : getBounds(items2);
      return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
    },
    findCurveBoundsCollisions: function findCurveBoundsCollisions(curves1, curves2, tolerance, bothAxis) {
      function getBounds(curves) {
        var min = Math.min,
            max = Math.max,
            bounds = new Array(curves.length);

        for (var i = 0; i < curves.length; i++) {
          var v = curves[i];
          bounds[i] = [min(v[0], v[2], v[4], v[6]), min(v[1], v[3], v[5], v[7]), max(v[0], v[2], v[4], v[6]), max(v[1], v[3], v[5], v[7])];
        }

        return bounds;
      }

      var bounds1 = getBounds(curves1),
          bounds2 = !curves2 || curves2 === curves1 ? bounds1 : getBounds(curves2);

      if (bothAxis) {
        var hor = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, false, true),
            ver = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, true, true),
            list = [];

        for (var i = 0, l = hor.length; i < l; i++) {
          list[i] = {
            hor: hor[i],
            ver: ver[i]
          };
        }

        return list;
      }

      return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
    },
    findBoundsCollisions: function findBoundsCollisions(boundsA, boundsB, tolerance, sweepVertical, onlySweepAxisCollisions) {
      var self = !boundsB || boundsA === boundsB,
          allBounds = self ? boundsA : boundsA.concat(boundsB),
          lengthA = boundsA.length,
          lengthAll = allBounds.length;

      function binarySearch(indices, coord, value) {
        var lo = 0,
            hi = indices.length;

        while (lo < hi) {
          var mid = hi + lo >>> 1;

          if (allBounds[indices[mid]][coord] < value) {
            lo = mid + 1;
          } else {
            hi = mid;
          }
        }

        return lo - 1;
      }

      var pri0 = sweepVertical ? 1 : 0,
          pri1 = pri0 + 2,
          sec0 = sweepVertical ? 0 : 1,
          sec1 = sec0 + 2;
      var allIndicesByPri0 = new Array(lengthAll);

      for (var i = 0; i < lengthAll; i++) {
        allIndicesByPri0[i] = i;
      }

      allIndicesByPri0.sort(function (i1, i2) {
        return allBounds[i1][pri0] - allBounds[i2][pri0];
      });
      var activeIndicesByPri1 = [],
          allCollisions = new Array(lengthA);

      for (var i = 0; i < lengthAll; i++) {
        var curIndex = allIndicesByPri0[i],
            curBounds = allBounds[curIndex],
            origIndex = self ? curIndex : curIndex - lengthA,
            isCurrentA = curIndex < lengthA,
            isCurrentB = self || !isCurrentA,
            curCollisions = isCurrentA ? [] : null;

        if (activeIndicesByPri1.length) {
          var pruneCount = binarySearch(activeIndicesByPri1, pri1, curBounds[pri0] - tolerance) + 1;
          activeIndicesByPri1.splice(0, pruneCount);

          if (self && onlySweepAxisCollisions) {
            curCollisions = curCollisions.concat(activeIndicesByPri1);

            for (var j = 0; j < activeIndicesByPri1.length; j++) {
              var activeIndex = activeIndicesByPri1[j];
              allCollisions[activeIndex].push(origIndex);
            }
          } else {
            var curSec1 = curBounds[sec1],
                curSec0 = curBounds[sec0];

            for (var j = 0; j < activeIndicesByPri1.length; j++) {
              var activeIndex = activeIndicesByPri1[j],
                  activeBounds = allBounds[activeIndex],
                  isActiveA = activeIndex < lengthA,
                  isActiveB = self || activeIndex >= lengthA;

              if (onlySweepAxisCollisions || (isCurrentA && isActiveB || isCurrentB && isActiveA) && curSec1 >= activeBounds[sec0] - tolerance && curSec0 <= activeBounds[sec1] + tolerance) {
                if (isCurrentA && isActiveB) {
                  curCollisions.push(self ? activeIndex : activeIndex - lengthA);
                }

                if (isCurrentB && isActiveA) {
                  allCollisions[activeIndex].push(origIndex);
                }
              }
            }
          }
        }

        if (isCurrentA) {
          if (boundsA === boundsB) {
            curCollisions.push(curIndex);
          }

          allCollisions[curIndex] = curCollisions;
        }

        if (activeIndicesByPri1.length) {
          var curPri1 = curBounds[pri1],
              index = binarySearch(activeIndicesByPri1, pri1, curPri1);
          activeIndicesByPri1.splice(index + 1, 0, curIndex);
        } else {
          activeIndicesByPri1.push(curIndex);
        }
      }

      for (var i = 0; i < allCollisions.length; i++) {
        var collisions = allCollisions[i];

        if (collisions) {
          collisions.sort(function (i1, i2) {
            return i1 - i2;
          });
        }
      }

      return allCollisions;
    }
  };
  var Formatter = Base.extend({
    initialize: function initialize(precision) {
      this.precision = Base.pick(precision, 5);
      this.multiplier = Math.pow(10, this.precision);
    },
    number: function number(val) {
      return this.precision < 16 ? Math.round(val * this.multiplier) / this.multiplier : val;
    },
    pair: function pair(val1, val2, separator) {
      return this.number(val1) + (separator || ',') + this.number(val2);
    },
    point: function point(val, separator) {
      return this.number(val.x) + (separator || ',') + this.number(val.y);
    },
    size: function size(val, separator) {
      return this.number(val.width) + (separator || ',') + this.number(val.height);
    },
    rectangle: function rectangle(val, separator) {
      return this.point(val, separator) + (separator || ',') + this.size(val, separator);
    }
  });
  Formatter.instance = new Formatter();
  var Numerical = new function () {
    var abscissas = [[0.5773502691896257645091488], [0, 0.7745966692414833770358531], [0.3399810435848562648026658, 0.8611363115940525752239465], [0, 0.5384693101056830910363144, 0.9061798459386639927976269], [0.2386191860831969086305017, 0.6612093864662645136613996, 0.9324695142031520278123016], [0, 0.4058451513773971669066064, 0.7415311855993944398638648, 0.9491079123427585245261897], [0.1834346424956498049394761, 0.5255324099163289858177390, 0.7966664774136267395915539, 0.9602898564975362316835609], [0, 0.3242534234038089290385380, 0.6133714327005903973087020, 0.8360311073266357942994298, 0.9681602395076260898355762], [0.1488743389816312108848260, 0.4333953941292471907992659, 0.6794095682990244062343274, 0.8650633666889845107320967, 0.9739065285171717200779640], [0, 0.2695431559523449723315320, 0.5190961292068118159257257, 0.7301520055740493240934163, 0.8870625997680952990751578, 0.9782286581460569928039380], [0.1252334085114689154724414, 0.3678314989981801937526915, 0.5873179542866174472967024, 0.7699026741943046870368938, 0.9041172563704748566784659, 0.9815606342467192506905491], [0, 0.2304583159551347940655281, 0.4484927510364468528779129, 0.6423493394403402206439846, 0.8015780907333099127942065, 0.9175983992229779652065478, 0.9841830547185881494728294], [0.1080549487073436620662447, 0.3191123689278897604356718, 0.5152486363581540919652907, 0.6872929048116854701480198, 0.8272013150697649931897947, 0.9284348836635735173363911, 0.9862838086968123388415973], [0, 0.2011940939974345223006283, 0.3941513470775633698972074, 0.5709721726085388475372267, 0.7244177313601700474161861, 0.8482065834104272162006483, 0.9372733924007059043077589, 0.9879925180204854284895657], [0.0950125098376374401853193, 0.2816035507792589132304605, 0.4580167776572273863424194, 0.6178762444026437484466718, 0.7554044083550030338951012, 0.8656312023878317438804679, 0.9445750230732325760779884, 0.9894009349916499325961542]];
    var weights = [[1], [0.8888888888888888888888889, 0.5555555555555555555555556], [0.6521451548625461426269361, 0.3478548451374538573730639], [0.5688888888888888888888889, 0.4786286704993664680412915, 0.2369268850561890875142640], [0.4679139345726910473898703, 0.3607615730481386075698335, 0.1713244923791703450402961], [0.4179591836734693877551020, 0.3818300505051189449503698, 0.2797053914892766679014678, 0.1294849661688696932706114], [0.3626837833783619829651504, 0.3137066458778872873379622, 0.2223810344533744705443560, 0.1012285362903762591525314], [0.3302393550012597631645251, 0.3123470770400028400686304, 0.2606106964029354623187429, 0.1806481606948574040584720, 0.0812743883615744119718922], [0.2955242247147528701738930, 0.2692667193099963550912269, 0.2190863625159820439955349, 0.1494513491505805931457763, 0.0666713443086881375935688], [0.2729250867779006307144835, 0.2628045445102466621806889, 0.2331937645919904799185237, 0.1862902109277342514260976, 0.1255803694649046246346943, 0.0556685671161736664827537], [0.2491470458134027850005624, 0.2334925365383548087608499, 0.2031674267230659217490645, 0.1600783285433462263346525, 0.1069393259953184309602547, 0.0471753363865118271946160], [0.2325515532308739101945895, 0.2262831802628972384120902, 0.2078160475368885023125232, 0.1781459807619457382800467, 0.1388735102197872384636018, 0.0921214998377284479144218, 0.0404840047653158795200216], [0.2152638534631577901958764, 0.2051984637212956039659241, 0.1855383974779378137417166, 0.1572031671581935345696019, 0.1215185706879031846894148, 0.0801580871597602098056333, 0.0351194603317518630318329], [0.2025782419255612728806202, 0.1984314853271115764561183, 0.1861610000155622110268006, 0.1662692058169939335532009, 0.1395706779261543144478048, 0.1071592204671719350118695, 0.0703660474881081247092674, 0.0307532419961172683546284], [0.1894506104550684962853967, 0.1826034150449235888667637, 0.1691565193950025381893121, 0.1495959888165767320815017, 0.1246289712555338720524763, 0.0951585116824927848099251, 0.0622535239386478928628438, 0.0271524594117540948517806]];

    var abs = Math.abs,
        sqrt = Math.sqrt,
        pow = Math.pow,
        log2 = Math.log2 || function (x) {
      return Math.log(x) * Math.LOG2E;
    },
        EPSILON = 1e-12,
        MACHINE_EPSILON = 1.12e-16;

    function clamp(value, min, max) {
      return value < min ? min : value > max ? max : value;
    }

    function getDiscriminant(a, b, c) {
      function split(v) {
        var x = v * 134217729,
            y = v - x,
            hi = y + x,
            lo = v - hi;
        return [hi, lo];
      }

      var D = b * b - a * c,
          E = b * b + a * c;

      if (abs(D) * 3 < E) {
        var ad = split(a),
            bd = split(b),
            cd = split(c),
            p = b * b,
            dp = bd[0] * bd[0] - p + 2 * bd[0] * bd[1] + bd[1] * bd[1],
            q = a * c,
            dq = ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0] + ad[1] * cd[1];
        D = p - q + (dp - dq);
      }

      return D;
    }

    function getNormalizationFactor() {
      var norm = Math.max.apply(Math, arguments);
      return norm && (norm < 1e-8 || norm > 1e8) ? pow(2, -Math.round(log2(norm))) : 0;
    }

    return {
      EPSILON: EPSILON,
      MACHINE_EPSILON: MACHINE_EPSILON,
      CURVETIME_EPSILON: 1e-8,
      GEOMETRIC_EPSILON: 1e-7,
      TRIGONOMETRIC_EPSILON: 1e-8,
      KAPPA: 4 * (sqrt(2) - 1) / 3,
      isZero: function isZero(val) {
        return val >= -EPSILON && val <= EPSILON;
      },
      isMachineZero: function isMachineZero(val) {
        return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;
      },
      clamp: clamp,
      integrate: function integrate(f, a, b, n) {
        var x = abscissas[n - 2],
            w = weights[n - 2],
            A = (b - a) * 0.5,
            B = A + a,
            i = 0,
            m = n + 1 >> 1,
            sum = n & 1 ? w[i++] * f(B) : 0;

        while (i < m) {
          var Ax = A * x[i];
          sum += w[i++] * (f(B + Ax) + f(B - Ax));
        }

        return A * sum;
      },
      findRoot: function findRoot(f, df, x, a, b, n, tolerance) {
        for (var i = 0; i < n; i++) {
          var fx = f(x),
              dx = fx / df(x),
              nx = x - dx;

          if (abs(dx) < tolerance) {
            x = nx;
            break;
          }

          if (fx > 0) {
            b = x;
            x = nx <= a ? (a + b) * 0.5 : nx;
          } else {
            a = x;
            x = nx >= b ? (a + b) * 0.5 : nx;
          }
        }

        return clamp(x, a, b);
      },
      solveQuadratic: function solveQuadratic(a, b, c, roots, min, max) {
        var x1,
            x2 = Infinity;

        if (abs(a) < EPSILON) {
          if (abs(b) < EPSILON) return abs(c) < EPSILON ? -1 : 0;
          x1 = -c / b;
        } else {
          b *= -0.5;
          var D = getDiscriminant(a, b, c);

          if (D && abs(D) < MACHINE_EPSILON) {
            var f = getNormalizationFactor(abs(a), abs(b), abs(c));

            if (f) {
              a *= f;
              b *= f;
              c *= f;
              D = getDiscriminant(a, b, c);
            }
          }

          if (D >= -MACHINE_EPSILON) {
            var Q = D < 0 ? 0 : sqrt(D),
                R = b + (b < 0 ? -Q : Q);

            if (R === 0) {
              x1 = c / a;
              x2 = -x1;
            } else {
              x1 = R / a;
              x2 = c / R;
            }
          }
        }

        var count = 0,
            boundless = min == null,
            minB = min - EPSILON,
            maxB = max + EPSILON;
        if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB)) roots[count++] = boundless ? x1 : clamp(x1, min, max);
        if (x2 !== x1 && isFinite(x2) && (boundless || x2 > minB && x2 < maxB)) roots[count++] = boundless ? x2 : clamp(x2, min, max);
        return count;
      },
      solveCubic: function solveCubic(a, b, c, d, roots, min, max) {
        var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
            x,
            b1,
            c2,
            qd,
            q;

        if (f) {
          a *= f;
          b *= f;
          c *= f;
          d *= f;
        }

        function evaluate(x0) {
          x = x0;
          var tmp = a * x;
          b1 = tmp + b;
          c2 = b1 * x + c;
          qd = (tmp + b1) * x + c2;
          q = c2 * x + d;
        }

        if (abs(a) < EPSILON) {
          a = b;
          b1 = c;
          c2 = d;
          x = Infinity;
        } else if (abs(d) < EPSILON) {
          b1 = b;
          c2 = c;
          x = 0;
        } else {
          evaluate(-(b / a) / 3);
          var t = q / a,
              r = pow(abs(t), 1 / 3),
              s = t < 0 ? -1 : 1,
              td = -qd / a,
              rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
              x0 = x - s * rd;

          if (x0 !== x) {
            do {
              evaluate(x0);
              x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
            } while (s * x0 > s * x);

            if (abs(a) * x * x > abs(d / x)) {
              c2 = -d / x;
              b1 = (c2 - c) / x;
            }
          }
        }

        var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
            boundless = min == null;
        if (isFinite(x) && (count === 0 || count > 0 && x !== roots[0] && x !== roots[1]) && (boundless || x > min - EPSILON && x < max + EPSILON)) roots[count++] = boundless ? x : clamp(x, min, max);
        return count;
      }
    };
  }();
  var UID = {
    _id: 1,
    _pools: {},
    get: function get(name) {
      if (name) {
        var pool = this._pools[name];
        if (!pool) pool = this._pools[name] = {
          _id: 1
        };
        return pool._id++;
      } else {
        return this._id++;
      }
    }
  };
  var Point = Base.extend({
    _class: 'Point',
    _readIndex: true,
    initialize: function Point(arg0, arg1) {
      var type = _typeof(arg0),
          reading = this.__read,
          read = 0;

      if (type === 'number') {
        var hasY = typeof arg1 === 'number';

        this._set(arg0, hasY ? arg1 : arg0);

        if (reading) read = hasY ? 2 : 1;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0);

        if (reading) read = arg0 === null ? 1 : 0;
      } else {
        var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
        read = 1;

        if (Array.isArray(obj)) {
          this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
        } else if ('x' in obj) {
          this._set(obj.x || 0, obj.y || 0);
        } else if ('width' in obj) {
          this._set(obj.width || 0, obj.height || 0);
        } else if ('angle' in obj) {
          this._set(obj.length || 0, 0);

          this.setAngle(obj.angle || 0);
        } else {
          this._set(0, 0);

          read = 0;
        }
      }

      if (reading) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function _set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    },
    equals: function equals(point) {
      return this === point || point && (this.x === point.x && this.y === point.y || Array.isArray(point) && this.x === point[0] && this.y === point[1]) || false;
    },
    clone: function clone() {
      return new Point(this.x, this.y);
    },
    toString: function toString() {
      var f = Formatter.instance;
      return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
    },
    _serialize: function _serialize(options) {
      var f = options.formatter;
      return [f.number(this.x), f.number(this.y)];
    },
    getLength: function getLength() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    setLength: function setLength(length) {
      if (this.isZero()) {
        var angle = this._angle || 0;

        this._set(Math.cos(angle) * length, Math.sin(angle) * length);
      } else {
        var scale = length / this.getLength();
        if (Numerical.isZero(scale)) this.getAngle();

        this._set(this.x * scale, this.y * scale);
      }
    },
    getAngle: function getAngle() {
      return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
    },
    setAngle: function setAngle(angle) {
      this.setAngleInRadians.call(this, angle * Math.PI / 180);
    },
    getAngleInDegrees: '#getAngle',
    setAngleInDegrees: '#setAngle',
    getAngleInRadians: function getAngleInRadians() {
      if (!arguments.length) {
        return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
      } else {
        var point = Point.read(arguments),
            div = this.getLength() * point.getLength();

        if (Numerical.isZero(div)) {
          return NaN;
        } else {
          var a = this.dot(point) / div;
          return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
        }
      }
    },
    setAngleInRadians: function setAngleInRadians(angle) {
      this._angle = angle;

      if (!this.isZero()) {
        var length = this.getLength();

        this._set(Math.cos(angle) * length, Math.sin(angle) * length);
      }
    },
    getQuadrant: function getQuadrant() {
      return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
    }
  }, {
    beans: false,
    getDirectedAngle: function getDirectedAngle() {
      var point = Point.read(arguments);
      return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
    },
    getDistance: function getDistance() {
      var args = arguments,
          point = Point.read(args),
          x = point.x - this.x,
          y = point.y - this.y,
          d = x * x + y * y,
          squared = Base.read(args);
      return squared ? d : Math.sqrt(d);
    },
    normalize: function normalize(length) {
      if (length === undefined) length = 1;
      var current = this.getLength(),
          scale = current !== 0 ? length / current : 0,
          point = new Point(this.x * scale, this.y * scale);
      if (scale >= 0) point._angle = this._angle;
      return point;
    },
    rotate: function rotate(angle, center) {
      if (angle === 0) return this.clone();
      angle = angle * Math.PI / 180;
      var point = center ? this.subtract(center) : this,
          sin = Math.sin(angle),
          cos = Math.cos(angle);
      point = new Point(point.x * cos - point.y * sin, point.x * sin + point.y * cos);
      return center ? point.add(center) : point;
    },
    transform: function transform(matrix) {
      return matrix ? matrix._transformPoint(this) : this;
    },
    add: function add() {
      var point = Point.read(arguments);
      return new Point(this.x + point.x, this.y + point.y);
    },
    subtract: function subtract() {
      var point = Point.read(arguments);
      return new Point(this.x - point.x, this.y - point.y);
    },
    multiply: function multiply() {
      var point = Point.read(arguments);
      return new Point(this.x * point.x, this.y * point.y);
    },
    divide: function divide() {
      var point = Point.read(arguments);
      return new Point(this.x / point.x, this.y / point.y);
    },
    modulo: function modulo() {
      var point = Point.read(arguments);
      return new Point(this.x % point.x, this.y % point.y);
    },
    negate: function negate() {
      return new Point(-this.x, -this.y);
    },
    isInside: function isInside() {
      return _Rectangle.read(arguments).contains(this);
    },
    isClose: function isClose() {
      var args = arguments,
          point = Point.read(args),
          tolerance = Base.read(args);
      return this.getDistance(point) <= tolerance;
    },
    isCollinear: function isCollinear() {
      var point = Point.read(arguments);
      return Point.isCollinear(this.x, this.y, point.x, point.y);
    },
    isColinear: '#isCollinear',
    isOrthogonal: function isOrthogonal() {
      var point = Point.read(arguments);
      return Point.isOrthogonal(this.x, this.y, point.x, point.y);
    },
    isZero: function isZero() {
      var isZero = Numerical.isZero;
      return isZero(this.x) && isZero(this.y);
    },
    isNaN: function (_isNaN) {
      function isNaN() {
        return _isNaN.apply(this, arguments);
      }

      isNaN.toString = function () {
        return _isNaN.toString();
      };

      return isNaN;
    }(function () {
      return isNaN(this.x) || isNaN(this.y);
    }),
    isInQuadrant: function isInQuadrant(q) {
      return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0 && this.y * (q > 2 ? -1 : 1) >= 0;
    },
    dot: function dot() {
      var point = Point.read(arguments);
      return this.x * point.x + this.y * point.y;
    },
    cross: function cross() {
      var point = Point.read(arguments);
      return this.x * point.y - this.y * point.x;
    },
    project: function project() {
      var point = Point.read(arguments),
          scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
      return new Point(point.x * scale, point.y * scale);
    },
    statics: {
      min: function min() {
        var args = arguments,
            point1 = Point.read(args),
            point2 = Point.read(args);
        return new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y));
      },
      max: function max() {
        var args = arguments,
            point1 = Point.read(args),
            point2 = Point.read(args);
        return new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y));
      },
      random: function random() {
        return new Point(Math.random(), Math.random());
      },
      isCollinear: function isCollinear(x1, y1, x2, y2) {
        return Math.abs(x1 * y2 - y1 * x2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
      },
      isOrthogonal: function isOrthogonal(x1, y1, x2, y2) {
        return Math.abs(x1 * x2 + y1 * y2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;
      }
    }
  }, Base.each(['round', 'ceil', 'floor', 'abs'], function (key) {
    var op = Math[key];

    this[key] = function () {
      return new Point(op(this.x), op(this.y));
    };
  }, {}));
  var LinkedPoint = Point.extend({
    initialize: function Point(x, y, owner, setter) {
      this._x = x;
      this._y = y;
      this._owner = owner;
      this._setter = setter;
    },
    _set: function _set(x, y, _dontNotify) {
      this._x = x;
      this._y = y;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    },
    getX: function getX() {
      return this._x;
    },
    setX: function setX(x) {
      this._x = x;

      this._owner[this._setter](this);
    },
    getY: function getY() {
      return this._y;
    },
    setY: function setY(y) {
      this._y = y;

      this._owner[this._setter](this);
    },
    isSelected: function isSelected() {
      return !!(this._owner._selection & this._getSelection());
    },
    setSelected: function setSelected(selected) {
      this._owner._changeSelection(this._getSelection(), selected);
    },
    _getSelection: function _getSelection() {
      return this._setter === 'setPosition' ? 4 : 0;
    }
  });
  var Size = Base.extend({
    _class: 'Size',
    _readIndex: true,
    initialize: function Size(arg0, arg1) {
      var type = _typeof(arg0),
          reading = this.__read,
          read = 0;

      if (type === 'number') {
        var hasHeight = typeof arg1 === 'number';

        this._set(arg0, hasHeight ? arg1 : arg0);

        if (reading) read = hasHeight ? 2 : 1;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0);

        if (reading) read = arg0 === null ? 1 : 0;
      } else {
        var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
        read = 1;

        if (Array.isArray(obj)) {
          this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
        } else if ('width' in obj) {
          this._set(obj.width || 0, obj.height || 0);
        } else if ('x' in obj) {
          this._set(obj.x || 0, obj.y || 0);
        } else {
          this._set(0, 0);

          read = 0;
        }
      }

      if (reading) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function _set(width, height) {
      this.width = width;
      this.height = height;
      return this;
    },
    equals: function equals(size) {
      return size === this || size && (this.width === size.width && this.height === size.height || Array.isArray(size) && this.width === size[0] && this.height === size[1]) || false;
    },
    clone: function clone() {
      return new Size(this.width, this.height);
    },
    toString: function toString() {
      var f = Formatter.instance;
      return '{ width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
    },
    _serialize: function _serialize(options) {
      var f = options.formatter;
      return [f.number(this.width), f.number(this.height)];
    },
    add: function add() {
      var size = Size.read(arguments);
      return new Size(this.width + size.width, this.height + size.height);
    },
    subtract: function subtract() {
      var size = Size.read(arguments);
      return new Size(this.width - size.width, this.height - size.height);
    },
    multiply: function multiply() {
      var size = Size.read(arguments);
      return new Size(this.width * size.width, this.height * size.height);
    },
    divide: function divide() {
      var size = Size.read(arguments);
      return new Size(this.width / size.width, this.height / size.height);
    },
    modulo: function modulo() {
      var size = Size.read(arguments);
      return new Size(this.width % size.width, this.height % size.height);
    },
    negate: function negate() {
      return new Size(-this.width, -this.height);
    },
    isZero: function isZero() {
      var isZero = Numerical.isZero;
      return isZero(this.width) && isZero(this.height);
    },
    isNaN: function (_isNaN2) {
      function isNaN() {
        return _isNaN2.apply(this, arguments);
      }

      isNaN.toString = function () {
        return _isNaN2.toString();
      };

      return isNaN;
    }(function () {
      return isNaN(this.width) || isNaN(this.height);
    }),
    statics: {
      min: function min(size1, size2) {
        return new Size(Math.min(size1.width, size2.width), Math.min(size1.height, size2.height));
      },
      max: function max(size1, size2) {
        return new Size(Math.max(size1.width, size2.width), Math.max(size1.height, size2.height));
      },
      random: function random() {
        return new Size(Math.random(), Math.random());
      }
    }
  }, Base.each(['round', 'ceil', 'floor', 'abs'], function (key) {
    var op = Math[key];

    this[key] = function () {
      return new Size(op(this.width), op(this.height));
    };
  }, {}));
  var LinkedSize = Size.extend({
    initialize: function Size(width, height, owner, setter) {
      this._width = width;
      this._height = height;
      this._owner = owner;
      this._setter = setter;
    },
    _set: function _set(width, height, _dontNotify) {
      this._width = width;
      this._height = height;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    },
    getWidth: function getWidth() {
      return this._width;
    },
    setWidth: function setWidth(width) {
      this._width = width;

      this._owner[this._setter](this);
    },
    getHeight: function getHeight() {
      return this._height;
    },
    setHeight: function setHeight(height) {
      this._height = height;

      this._owner[this._setter](this);
    }
  });

  var _Rectangle = Base.extend({
    _class: 'Rectangle',
    _readIndex: true,
    beans: true,
    initialize: function Rectangle(arg0, arg1, arg2, arg3) {
      var args = arguments,
          type = _typeof(arg0),
          read;

      if (type === 'number') {
        this._set(arg0, arg1, arg2, arg3);

        read = 4;
      } else if (type === 'undefined' || arg0 === null) {
        this._set(0, 0, 0, 0);

        read = arg0 === null ? 1 : 0;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          this._set.apply(this, arg0);

          read = 1;
        } else if (arg0.x !== undefined || arg0.width !== undefined) {
          this._set(arg0.x || 0, arg0.y || 0, arg0.width || 0, arg0.height || 0);

          read = 1;
        } else if (arg0.from === undefined && arg0.to === undefined) {
          this._set(0, 0, 0, 0);

          if (Base.readSupported(args, this)) {
            read = 1;
          }
        }
      }

      if (read === undefined) {
        var frm = Point.readNamed(args, 'from'),
            next = Base.peek(args),
            x = frm.x,
            y = frm.y,
            width,
            height;

        if (next && next.x !== undefined || Base.hasNamed(args, 'to')) {
          var to = Point.readNamed(args, 'to');
          width = to.x - x;
          height = to.y - y;

          if (width < 0) {
            x = to.x;
            width = -width;
          }

          if (height < 0) {
            y = to.y;
            height = -height;
          }
        } else {
          var size = Size.read(args);
          width = size.width;
          height = size.height;
        }

        this._set(x, y, width, height);

        read = args.__index;
      }

      var filtered = args.__filtered;
      if (filtered) this.__filtered = filtered;
      if (this.__read) this.__read = read;
      return this;
    },
    set: '#initialize',
    _set: function _set(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    },
    clone: function clone() {
      return new _Rectangle(this.x, this.y, this.width, this.height);
    },
    equals: function equals(rect) {
      var rt = Base.isPlainValue(rect) ? _Rectangle.read(arguments) : rect;
      return rt === this || rt && this.x === rt.x && this.y === rt.y && this.width === rt.width && this.height === rt.height || false;
    },
    toString: function toString() {
      var f = Formatter.instance;
      return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ', width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
    },
    _serialize: function _serialize(options) {
      var f = options.formatter;
      return [f.number(this.x), f.number(this.y), f.number(this.width), f.number(this.height)];
    },
    getPoint: function getPoint(_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this.x, this.y, this, 'setPoint');
    },
    setPoint: function setPoint() {
      var point = Point.read(arguments);
      this.x = point.x;
      this.y = point.y;
    },
    getSize: function getSize(_dontLink) {
      var ctor = _dontLink ? Size : LinkedSize;
      return new ctor(this.width, this.height, this, 'setSize');
    },
    _fw: 1,
    _fh: 1,
    setSize: function setSize() {
      var size = Size.read(arguments),
          sx = this._sx,
          sy = this._sy,
          w = size.width,
          h = size.height;

      if (sx) {
        this.x += (this.width - w) * sx;
      }

      if (sy) {
        this.y += (this.height - h) * sy;
      }

      this.width = w;
      this.height = h;
      this._fw = this._fh = 1;
    },
    getLeft: function getLeft() {
      return this.x;
    },
    setLeft: function setLeft(left) {
      if (!this._fw) {
        var amount = left - this.x;
        this.width -= this._sx === 0.5 ? amount * 2 : amount;
      }

      this.x = left;
      this._sx = this._fw = 0;
    },
    getTop: function getTop() {
      return this.y;
    },
    setTop: function setTop(top) {
      if (!this._fh) {
        var amount = top - this.y;
        this.height -= this._sy === 0.5 ? amount * 2 : amount;
      }

      this.y = top;
      this._sy = this._fh = 0;
    },
    getRight: function getRight() {
      return this.x + this.width;
    },
    setRight: function setRight(right) {
      if (!this._fw) {
        var amount = right - this.x;
        this.width = this._sx === 0.5 ? amount * 2 : amount;
      }

      this.x = right - this.width;
      this._sx = 1;
      this._fw = 0;
    },
    getBottom: function getBottom() {
      return this.y + this.height;
    },
    setBottom: function setBottom(bottom) {
      if (!this._fh) {
        var amount = bottom - this.y;
        this.height = this._sy === 0.5 ? amount * 2 : amount;
      }

      this.y = bottom - this.height;
      this._sy = 1;
      this._fh = 0;
    },
    getCenterX: function getCenterX() {
      return this.x + this.width / 2;
    },
    setCenterX: function setCenterX(x) {
      if (this._fw || this._sx === 0.5) {
        this.x = x - this.width / 2;
      } else {
        if (this._sx) {
          this.x += (x - this.x) * 2 * this._sx;
        }

        this.width = (x - this.x) * 2;
      }

      this._sx = 0.5;
      this._fw = 0;
    },
    getCenterY: function getCenterY() {
      return this.y + this.height / 2;
    },
    setCenterY: function setCenterY(y) {
      if (this._fh || this._sy === 0.5) {
        this.y = y - this.height / 2;
      } else {
        if (this._sy) {
          this.y += (y - this.y) * 2 * this._sy;
        }

        this.height = (y - this.y) * 2;
      }

      this._sy = 0.5;
      this._fh = 0;
    },
    getCenter: function getCenter(_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
    },
    setCenter: function setCenter() {
      var point = Point.read(arguments);
      this.setCenterX(point.x);
      this.setCenterY(point.y);
      return this;
    },
    getArea: function getArea() {
      return this.width * this.height;
    },
    isEmpty: function isEmpty() {
      return this.width === 0 || this.height === 0;
    },
    contains: function contains(arg) {
      return arg && arg.width !== undefined || (Array.isArray(arg) ? arg : arguments).length === 4 ? this._containsRectangle(_Rectangle.read(arguments)) : this._containsPoint(Point.read(arguments));
    },
    _containsPoint: function _containsPoint(point) {
      var x = point.x,
          y = point.y;
      return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height;
    },
    _containsRectangle: function _containsRectangle(rect) {
      var x = rect.x,
          y = rect.y;
      return x >= this.x && y >= this.y && x + rect.width <= this.x + this.width && y + rect.height <= this.y + this.height;
    },
    intersects: function intersects() {
      var rect = _Rectangle.read(arguments),
          epsilon = Base.read(arguments) || 0;

      return rect.x + rect.width > this.x - epsilon && rect.y + rect.height > this.y - epsilon && rect.x < this.x + this.width + epsilon && rect.y < this.y + this.height + epsilon;
    },
    intersect: function intersect() {
      var rect = _Rectangle.read(arguments),
          x1 = Math.max(this.x, rect.x),
          y1 = Math.max(this.y, rect.y),
          x2 = Math.min(this.x + this.width, rect.x + rect.width),
          y2 = Math.min(this.y + this.height, rect.y + rect.height);

      return new _Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    unite: function unite() {
      var rect = _Rectangle.read(arguments),
          x1 = Math.min(this.x, rect.x),
          y1 = Math.min(this.y, rect.y),
          x2 = Math.max(this.x + this.width, rect.x + rect.width),
          y2 = Math.max(this.y + this.height, rect.y + rect.height);

      return new _Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    include: function include() {
      var point = Point.read(arguments);
      var x1 = Math.min(this.x, point.x),
          y1 = Math.min(this.y, point.y),
          x2 = Math.max(this.x + this.width, point.x),
          y2 = Math.max(this.y + this.height, point.y);
      return new _Rectangle(x1, y1, x2 - x1, y2 - y1);
    },
    expand: function expand() {
      var amount = Size.read(arguments),
          hor = amount.width,
          ver = amount.height;
      return new _Rectangle(this.x - hor / 2, this.y - ver / 2, this.width + hor, this.height + ver);
    },
    scale: function scale(hor, ver) {
      return this.expand(this.width * hor - this.width, this.height * (ver === undefined ? hor : ver) - this.height);
    }
  }, Base.each([['Top', 'Left'], ['Top', 'Right'], ['Bottom', 'Left'], ['Bottom', 'Right'], ['Left', 'Center'], ['Top', 'Center'], ['Right', 'Center'], ['Bottom', 'Center']], function (parts, index) {
    var part = parts.join(''),
        xFirst = /^[RL]/.test(part);
    if (index >= 4) parts[1] += xFirst ? 'Y' : 'X';
    var x = parts[xFirst ? 0 : 1],
        y = parts[xFirst ? 1 : 0],
        getX = 'get' + x,
        getY = 'get' + y,
        setX = 'set' + x,
        setY = 'set' + y,
        get = 'get' + part,
        set = 'set' + part;

    this[get] = function (_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;
      return new ctor(this[getX](), this[getY](), this, set);
    };

    this[set] = function () {
      var point = Point.read(arguments);
      this[setX](point.x);
      this[setY](point.y);
    };
  }, {
    beans: true
  }));

  var LinkedRectangle = _Rectangle.extend({
    initialize: function Rectangle(x, y, width, height, owner, setter) {
      this._set(x, y, width, height, true);

      this._owner = owner;
      this._setter = setter;
    },
    _set: function _set(x, y, width, height, _dontNotify) {
      this._x = x;
      this._y = y;
      this._width = width;
      this._height = height;
      if (!_dontNotify) this._owner[this._setter](this);
      return this;
    }
  }, new function () {
    var proto = _Rectangle.prototype;
    return Base.each(['x', 'y', 'width', 'height'], function (key) {
      var part = Base.capitalize(key),
          internal = '_' + key;

      this['get' + part] = function () {
        return this[internal];
      };

      this['set' + part] = function (value) {
        this[internal] = value;
        if (!this._dontNotify) this._owner[this._setter](this);
      };
    }, Base.each(['Point', 'Size', 'Center', 'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY', 'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'], function (key) {
      var name = 'set' + key;

      this[name] = function () {
        this._dontNotify = true;
        proto[name].apply(this, arguments);
        this._dontNotify = false;

        this._owner[this._setter](this);
      };
    }, {
      isSelected: function isSelected() {
        return !!(this._owner._selection & 2);
      },
      setSelected: function setSelected(selected) {
        var owner = this._owner;

        if (owner._changeSelection) {
          owner._changeSelection(2, selected);
        }
      }
    }));
  }());

  var Matrix = Base.extend({
    _class: 'Matrix',
    initialize: function Matrix(arg, _dontNotify) {
      var args = arguments,
          count = args.length,
          ok = true;

      if (count >= 6) {
        this._set.apply(this, args);
      } else if (count === 1 || count === 2) {
        if (arg instanceof Matrix) {
          this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty, _dontNotify);
        } else if (Array.isArray(arg)) {
          this._set.apply(this, _dontNotify ? arg.concat([_dontNotify]) : arg);
        } else {
          ok = false;
        }
      } else if (!count) {
        this.reset();
      } else {
        ok = false;
      }

      if (!ok) {
        throw new Error('Unsupported matrix parameters');
      }

      return this;
    },
    set: '#initialize',
    _set: function _set(a, b, c, d, tx, ty, _dontNotify) {
      this._a = a;
      this._b = b;
      this._c = c;
      this._d = d;
      this._tx = tx;
      this._ty = ty;
      if (!_dontNotify) this._changed();
      return this;
    },
    _serialize: function _serialize(options, dictionary) {
      return Base.serialize(this.getValues(), options, true, dictionary);
    },
    _changed: function _changed() {
      var owner = this._owner;

      if (owner) {
        if (owner._applyMatrix) {
          owner.transform(null, true);
        } else {
          owner._changed(25);
        }
      }
    },
    clone: function clone() {
      return new Matrix(this._a, this._b, this._c, this._d, this._tx, this._ty);
    },
    equals: function equals(mx) {
      return mx === this || mx && this._a === mx._a && this._b === mx._b && this._c === mx._c && this._d === mx._d && this._tx === mx._tx && this._ty === mx._ty;
    },
    toString: function toString() {
      var f = Formatter.instance;
      return '[[' + [f.number(this._a), f.number(this._c), f.number(this._tx)].join(', ') + '], [' + [f.number(this._b), f.number(this._d), f.number(this._ty)].join(', ') + ']]';
    },
    reset: function reset(_dontNotify) {
      this._a = this._d = 1;
      this._b = this._c = this._tx = this._ty = 0;
      if (!_dontNotify) this._changed();
      return this;
    },
    apply: function apply(recursively, _setApplyMatrix) {
      var owner = this._owner;

      if (owner) {
        owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);
        return this.isIdentity();
      }

      return false;
    },
    translate: function translate() {
      var point = Point.read(arguments),
          x = point.x,
          y = point.y;
      this._tx += x * this._a + y * this._c;
      this._ty += x * this._b + y * this._d;

      this._changed();

      return this;
    },
    scale: function scale() {
      var args = arguments,
          scale = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      if (center) this.translate(center);
      this._a *= scale.x;
      this._b *= scale.x;
      this._c *= scale.y;
      this._d *= scale.y;
      if (center) this.translate(center.negate());

      this._changed();

      return this;
    },
    rotate: function rotate(angle) {
      angle *= Math.PI / 180;
      var center = Point.read(arguments, 1),
          x = center.x,
          y = center.y,
          cos = Math.cos(angle),
          sin = Math.sin(angle),
          tx = x - x * cos + y * sin,
          ty = y - x * sin - y * cos,
          a = this._a,
          b = this._b,
          c = this._c,
          d = this._d;
      this._a = cos * a + sin * c;
      this._b = cos * b + sin * d;
      this._c = -sin * a + cos * c;
      this._d = -sin * b + cos * d;
      this._tx += tx * a + ty * c;
      this._ty += tx * b + ty * d;

      this._changed();

      return this;
    },
    shear: function shear() {
      var args = arguments,
          shear = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      if (center) this.translate(center);
      var a = this._a,
          b = this._b;
      this._a += shear.y * this._c;
      this._b += shear.y * this._d;
      this._c += shear.x * a;
      this._d += shear.x * b;
      if (center) this.translate(center.negate());

      this._changed();

      return this;
    },
    skew: function skew() {
      var args = arguments,
          skew = Point.read(args),
          center = Point.read(args, 0, {
        readNull: true
      }),
          toRadians = Math.PI / 180,
          shear = new Point(Math.tan(skew.x * toRadians), Math.tan(skew.y * toRadians));
      return this.shear(shear, center);
    },
    append: function append(mx, _dontNotify) {
      if (mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            a2 = mx._a,
            b2 = mx._c,
            c2 = mx._b,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + c2 * c1;
        this._c = b2 * a1 + d2 * c1;
        this._b = a2 * b1 + c2 * d1;
        this._d = b2 * b1 + d2 * d1;
        this._tx += tx2 * a1 + ty2 * c1;
        this._ty += tx2 * b1 + ty2 * d1;
        if (!_dontNotify) this._changed();
      }

      return this;
    },
    prepend: function prepend(mx, _dontNotify) {
      if (mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            tx1 = this._tx,
            ty1 = this._ty,
            a2 = mx._a,
            b2 = mx._c,
            c2 = mx._b,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + b2 * b1;
        this._c = a2 * c1 + b2 * d1;
        this._b = c2 * a1 + d2 * b1;
        this._d = c2 * c1 + d2 * d1;
        this._tx = a2 * tx1 + b2 * ty1 + tx2;
        this._ty = c2 * tx1 + d2 * ty1 + ty2;
        if (!_dontNotify) this._changed();
      }

      return this;
    },
    appended: function appended(mx) {
      return this.clone().append(mx);
    },
    prepended: function prepended(mx) {
      return this.clone().prepend(mx);
    },
    invert: function invert() {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          tx = this._tx,
          ty = this._ty,
          det = a * d - b * c,
          res = null;

      if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
        this._a = d / det;
        this._b = -b / det;
        this._c = -c / det;
        this._d = a / det;
        this._tx = (c * ty - d * tx) / det;
        this._ty = (b * tx - a * ty) / det;
        res = this;
      }

      return res;
    },
    inverted: function inverted() {
      return this.clone().invert();
    },
    concatenate: '#append',
    preConcatenate: '#prepend',
    chain: '#appended',
    _shiftless: function _shiftless() {
      return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
    },
    _orNullIfIdentity: function _orNullIfIdentity() {
      return this.isIdentity() ? null : this;
    },
    isIdentity: function isIdentity() {
      return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;
    },
    isInvertible: function isInvertible() {
      var det = this._a * this._d - this._c * this._b;
      return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
    },
    isSingular: function isSingular() {
      return !this.isInvertible();
    },
    transform: function transform(src, dst, count) {
      return arguments.length < 3 ? this._transformPoint(Point.read(arguments)) : this._transformCoordinates(src, dst, count);
    },
    _transformPoint: function _transformPoint(point, dest, _dontNotify) {
      var x = point.x,
          y = point.y;
      if (!dest) dest = new Point();
      return dest._set(x * this._a + y * this._c + this._tx, x * this._b + y * this._d + this._ty, _dontNotify);
    },
    _transformCoordinates: function _transformCoordinates(src, dst, count) {
      for (var i = 0, max = 2 * count; i < max; i += 2) {
        var x = src[i],
            y = src[i + 1];
        dst[i] = x * this._a + y * this._c + this._tx;
        dst[i + 1] = x * this._b + y * this._d + this._ty;
      }

      return dst;
    },
    _transformCorners: function _transformCorners(rect) {
      var x1 = rect.x,
          y1 = rect.y,
          x2 = x1 + rect.width,
          y2 = y1 + rect.height,
          coords = [x1, y1, x2, y1, x2, y2, x1, y2];
      return this._transformCoordinates(coords, coords, 4);
    },
    _transformBounds: function _transformBounds(bounds, dest, _dontNotify) {
      var coords = this._transformCorners(bounds),
          min = coords.slice(0, 2),
          max = min.slice();

      for (var i = 2; i < 8; i++) {
        var val = coords[i],
            j = i & 1;

        if (val < min[j]) {
          min[j] = val;
        } else if (val > max[j]) {
          max[j] = val;
        }
      }

      if (!dest) dest = new _Rectangle();
      return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1], _dontNotify);
    },
    inverseTransform: function inverseTransform() {
      return this._inverseTransform(Point.read(arguments));
    },
    _inverseTransform: function _inverseTransform(point, dest, _dontNotify) {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          tx = this._tx,
          ty = this._ty,
          det = a * d - b * c,
          res = null;

      if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
        var x = point.x - this._tx,
            y = point.y - this._ty;
        if (!dest) dest = new Point();
        res = dest._set((x * d - y * c) / det, (y * a - x * b) / det, _dontNotify);
      }

      return res;
    },
    decompose: function decompose() {
      var a = this._a,
          b = this._b,
          c = this._c,
          d = this._d,
          det = a * d - b * c,
          sqrt = Math.sqrt,
          atan2 = Math.atan2,
          degrees = 180 / Math.PI,
          rotate,
          scale,
          skew;

      if (a !== 0 || b !== 0) {
        var r = sqrt(a * a + b * b);
        rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
        scale = [r, det / r];
        skew = [atan2(a * c + b * d, r * r), 0];
      } else if (c !== 0 || d !== 0) {
        var s = sqrt(c * c + d * d);
        rotate = Math.asin(c / s) * (d > 0 ? 1 : -1);
        scale = [det / s, s];
        skew = [0, atan2(a * c + b * d, s * s)];
      } else {
        rotate = 0;
        skew = scale = [0, 0];
      }

      return {
        translation: this.getTranslation(),
        rotation: rotate * degrees,
        scaling: new Point(scale),
        skewing: new Point(skew[0] * degrees, skew[1] * degrees)
      };
    },
    getValues: function getValues() {
      return [this._a, this._b, this._c, this._d, this._tx, this._ty];
    },
    getTranslation: function getTranslation() {
      return new Point(this._tx, this._ty);
    },
    getScaling: function getScaling() {
      return this.decompose().scaling;
    },
    getRotation: function getRotation() {
      return this.decompose().rotation;
    },
    applyToContext: function applyToContext(ctx) {
      if (!this.isIdentity()) {
        ctx.transform(this._a, this._b, this._c, this._d, this._tx, this._ty);
      }
    }
  }, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function (key) {
    var part = Base.capitalize(key),
        prop = '_' + key;

    this['get' + part] = function () {
      return this[prop];
    };

    this['set' + part] = function (value) {
      this[prop] = value;

      this._changed();
    };
  }, {}));
  var Line = Base.extend({
    _class: 'Line',
    initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
      var asVector = false;

      if (arguments.length >= 4) {
        this._px = arg0;
        this._py = arg1;
        this._vx = arg2;
        this._vy = arg3;
        asVector = arg4;
      } else {
        this._px = arg0.x;
        this._py = arg0.y;
        this._vx = arg1.x;
        this._vy = arg1.y;
        asVector = arg2;
      }

      if (!asVector) {
        this._vx -= this._px;
        this._vy -= this._py;
      }
    },
    getPoint: function getPoint() {
      return new Point(this._px, this._py);
    },
    getVector: function getVector() {
      return new Point(this._vx, this._vy);
    },
    getLength: function getLength() {
      return this.getVector().getLength();
    },
    intersect: function intersect(line, isInfinite) {
      return Line.intersect(this._px, this._py, this._vx, this._vy, line._px, line._py, line._vx, line._vy, true, isInfinite);
    },
    getSide: function getSide(point, isInfinite) {
      return Line.getSide(this._px, this._py, this._vx, this._vy, point.x, point.y, true, isInfinite);
    },
    getDistance: function getDistance(point) {
      return Math.abs(this.getSignedDistance(point));
    },
    getSignedDistance: function getSignedDistance(point) {
      return Line.getSignedDistance(this._px, this._py, this._vx, this._vy, point.x, point.y, true);
    },
    isCollinear: function isCollinear(line) {
      return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
    },
    isOrthogonal: function isOrthogonal(line) {
      return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
    },
    statics: {
      intersect: function intersect(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector, isInfinite) {
        if (!asVector) {
          v1x -= p1x;
          v1y -= p1y;
          v2x -= p2x;
          v2y -= p2y;
        }

        var cross = v1x * v2y - v1y * v2x;

        if (!Numerical.isMachineZero(cross)) {
          var dx = p1x - p2x,
              dy = p1y - p2y,
              u1 = (v2x * dy - v2y * dx) / cross,
              u2 = (v1x * dy - v1y * dx) / cross,
              epsilon = 1e-12,
              uMin = -epsilon,
              uMax = 1 + epsilon;

          if (isInfinite || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
            if (!isInfinite) {
              u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
            }

            return new Point(p1x + u1 * v1x, p1y + u1 * v1y);
          }
        }
      },
      getSide: function getSide(px, py, vx, vy, x, y, asVector, isInfinite) {
        if (!asVector) {
          vx -= px;
          vy -= py;
        }

        var v2x = x - px,
            v2y = y - py,
            ccw = v2x * vy - v2y * vx;

        if (!isInfinite && Numerical.isMachineZero(ccw)) {
          ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
          if (ccw >= 0 && ccw <= 1) ccw = 0;
        }

        return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
      },
      getSignedDistance: function getSignedDistance(px, py, vx, vy, x, y, asVector) {
        if (!asVector) {
          vx -= px;
          vy -= py;
        }

        return vx === 0 ? vy > 0 ? x - px : px - x : vy === 0 ? vx < 0 ? y - py : py - y : ((x - px) * vy - (y - py) * vx) / (vy > vx ? vy * Math.sqrt(1 + vx * vx / (vy * vy)) : vx * Math.sqrt(1 + vy * vy / (vx * vx)));
      },
      getDistance: function getDistance(px, py, vx, vy, x, y, asVector) {
        return Math.abs(Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
      }
    }
  });
  var Project = PaperScopeItem.extend({
    _class: 'Project',
    _list: 'projects',
    _reference: 'project',
    _compactSerialize: true,
    initialize: function Project(element) {
      PaperScopeItem.call(this, true);
      this._children = [];
      this._namedChildren = {};
      this._activeLayer = null;
      this._currentStyle = new Style(null, null, this);
      this._view = View.create(this, element || CanvasProvider.getCanvas(1, 1));
      this._selectionItems = {};
      this._selectionCount = 0;
      this._updateVersion = 0;
    },
    _serialize: function _serialize(options, dictionary) {
      return Base.serialize(this._children, options, true, dictionary);
    },
    _changed: function _changed(flags, item) {
      if (flags & 1) {
        var view = this._view;

        if (view) {
          view._needsUpdate = true;
          if (!view._requested && view._autoUpdate) view.requestUpdate();
        }
      }

      var changes = this._changes;

      if (changes && item) {
        var changesById = this._changesById,
            id = item._id,
            entry = changesById[id];

        if (entry) {
          entry.flags |= flags;
        } else {
          changes.push(changesById[id] = {
            item: item,
            flags: flags
          });
        }
      }
    },
    clear: function clear() {
      var children = this._children;

      for (var i = children.length - 1; i >= 0; i--) {
        children[i].remove();
      }
    },
    isEmpty: function isEmpty() {
      return !this._children.length;
    },
    remove: function remove() {
      if (!remove.base.call(this)) return false;
      if (this._view) this._view.remove();
      return true;
    },
    getView: function getView() {
      return this._view;
    },
    getCurrentStyle: function getCurrentStyle() {
      return this._currentStyle;
    },
    setCurrentStyle: function setCurrentStyle(style) {
      this._currentStyle.set(style);
    },
    getIndex: function getIndex() {
      return this._index;
    },
    getOptions: function getOptions() {
      return this._scope.settings;
    },
    getLayers: function getLayers() {
      return this._children;
    },
    getActiveLayer: function getActiveLayer() {
      return this._activeLayer || new Layer({
        project: this,
        insert: true
      });
    },
    getSymbolDefinitions: function getSymbolDefinitions() {
      var definitions = [],
          ids = {};
      this.getItems({
        class: SymbolItem,
        match: function match(item) {
          var definition = item._definition,
              id = definition._id;

          if (!ids[id]) {
            ids[id] = true;
            definitions.push(definition);
          }

          return false;
        }
      });
      return definitions;
    },
    getSymbols: 'getSymbolDefinitions',
    getSelectedItems: function getSelectedItems() {
      var selectionItems = this._selectionItems,
          items = [];

      for (var id in selectionItems) {
        var item = selectionItems[id],
            selection = item._selection;

        if (selection & 1 && item.isInserted()) {
          items.push(item);
        } else if (!selection) {
          this._updateSelection(item);
        }
      }

      return items;
    },
    _updateSelection: function _updateSelection(item) {
      var id = item._id,
          selectionItems = this._selectionItems;

      if (item._selection) {
        if (selectionItems[id] !== item) {
          this._selectionCount++;
          selectionItems[id] = item;
        }
      } else if (selectionItems[id] === item) {
        this._selectionCount--;
        delete selectionItems[id];
      }
    },
    selectAll: function selectAll() {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].setFullySelected(true);
      }
    },
    deselectAll: function deselectAll() {
      var selectionItems = this._selectionItems;

      for (var i in selectionItems) {
        selectionItems[i].setFullySelected(false);
      }
    },
    addLayer: function addLayer(layer) {
      return this.insertLayer(undefined, layer);
    },
    insertLayer: function insertLayer(index, layer) {
      if (layer instanceof Layer) {
        layer._remove(false, true);

        Base.splice(this._children, [layer], index, 0);

        layer._setProject(this, true);

        var name = layer._name;
        if (name) layer.setName(name);
        if (this._changes) layer._changed(5);
        if (!this._activeLayer) this._activeLayer = layer;
      } else {
        layer = null;
      }

      return layer;
    },
    _insertItem: function _insertItem(index, item, _created) {
      item = this.insertLayer(index, item) || (this._activeLayer || this._insertItem(undefined, new Layer(Item.NO_INSERT), true)).insertChild(index, item);
      if (_created && item.activate) item.activate();
      return item;
    },
    getItems: function getItems(options) {
      return Item._getItems(this, options);
    },
    getItem: function getItem(options) {
      return Item._getItems(this, options, null, null, true)[0] || null;
    },
    importJSON: function importJSON(json) {
      this.activate();
      var layer = this._activeLayer;
      return Base.importJSON(json, layer && layer.isEmpty() && layer);
    },
    removeOn: function removeOn(type) {
      var sets = this._removeSets;

      if (sets) {
        if (type === 'mouseup') sets.mousedrag = null;
        var set = sets[type];

        if (set) {
          for (var id in set) {
            var item = set[id];

            for (var key in sets) {
              var other = sets[key];
              if (other && other != set) delete other[item._id];
            }

            item.remove();
          }

          sets[type] = null;
        }
      }
    },
    draw: function draw(ctx, matrix, pixelRatio) {
      this._updateVersion++;
      ctx.save();
      matrix.applyToContext(ctx);
      var children = this._children,
          param = new Base({
        offset: new Point(0, 0),
        pixelRatio: pixelRatio,
        viewMatrix: matrix.isIdentity() ? null : matrix,
        matrices: [new Matrix()],
        updateMatrix: true
      });

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].draw(ctx, param);
      }

      ctx.restore();

      if (this._selectionCount > 0) {
        ctx.save();
        ctx.strokeWidth = 1;
        var items = this._selectionItems,
            size = this._scope.settings.handleSize,
            version = this._updateVersion;

        for (var id in items) {
          items[id]._drawSelection(ctx, matrix, size, items, version);
        }

        ctx.restore();
      }
    }
  });
  var Item = Base.extend(Emitter, {
    statics: {
      extend: function extend(src) {
        if (src._serializeFields) src._serializeFields = Base.set({}, this.prototype._serializeFields, src._serializeFields);
        return extend.base.apply(this, arguments);
      },
      NO_INSERT: {
        insert: false
      }
    },
    _class: 'Item',
    _name: null,
    _applyMatrix: true,
    _canApplyMatrix: true,
    _canScaleStroke: false,
    _pivot: null,
    _visible: true,
    _blendMode: 'normal',
    _opacity: 1,
    _locked: false,
    _guide: false,
    _clipMask: false,
    _selection: 0,
    _selectBounds: true,
    _selectChildren: false,
    _serializeFields: {
      name: null,
      applyMatrix: null,
      matrix: new Matrix(),
      pivot: null,
      visible: true,
      blendMode: 'normal',
      opacity: 1,
      locked: false,
      guide: false,
      clipMask: false,
      selected: false,
      data: {}
    },
    _prioritize: ['applyMatrix']
  }, new function () {
    var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick', 'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
    return Base.each(handlers, function (name) {
      this._events[name] = {
        install: function install(type) {
          this.getView()._countItemEvent(type, 1);
        },
        uninstall: function uninstall(type) {
          this.getView()._countItemEvent(type, -1);
        }
      };
    }, {
      _events: {
        onFrame: {
          install: function install() {
            this.getView()._animateItem(this, true);
          },
          uninstall: function uninstall() {
            this.getView()._animateItem(this, false);
          }
        },
        onLoad: {},
        onError: {}
      },
      statics: {
        _itemHandlers: handlers
      }
    });
  }(), {
    initialize: function Item() {},
    _initialize: function _initialize(props, point) {
      var hasProps = props && Base.isPlainObject(props),
          internal = hasProps && props.internal === true,
          matrix = this._matrix = new Matrix(),
          project = hasProps && props.project || paper.project,
          settings = paper.settings;
      this._id = internal ? null : UID.get();
      this._parent = this._index = null;
      this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
      if (point) matrix.translate(point);
      matrix._owner = this;
      this._style = new Style(project._currentStyle, this, project);

      if (internal || hasProps && props.insert == false || !settings.insertItems && !(hasProps && props.insert === true)) {
        this._setProject(project);
      } else {
        (hasProps && props.parent || project)._insertItem(undefined, this, true);
      }

      if (hasProps && props !== Item.NO_INSERT) {
        this.set(props, {
          internal: true,
          insert: true,
          project: true,
          parent: true
        });
      }

      return hasProps;
    },
    _serialize: function _serialize(options, dictionary) {
      var props = {},
          that = this;

      function serialize(fields) {
        for (var key in fields) {
          var value = that[key];

          if (!Base.equals(value, key === 'leading' ? fields.fontSize * 1.2 : fields[key])) {
            props[key] = Base.serialize(value, options, key !== 'data', dictionary);
          }
        }
      }

      serialize(this._serializeFields);
      if (!(this instanceof Group)) serialize(this._style._defaults);
      return [this._class, props];
    },
    _changed: function _changed(flags) {
      var symbol = this._symbol,
          cacheParent = this._parent || symbol,
          project = this._project;

      if (flags & 8) {
        this._bounds = this._position = this._decomposed = undefined;
      }

      if (flags & 16) {
        this._globalMatrix = undefined;
      }

      if (cacheParent && flags & 72) {
        Item._clearBoundsCache(cacheParent);
      }

      if (flags & 2) {
        Item._clearBoundsCache(this);
      }

      if (project) project._changed(flags, this);
      if (symbol) symbol._changed(flags);
    },
    getId: function getId() {
      return this._id;
    },
    getName: function getName() {
      return this._name;
    },
    setName: function setName(name) {
      if (this._name) this._removeNamed();
      if (name === +name + '') throw new Error('Names consisting only of numbers are not supported.');

      var owner = this._getOwner();

      if (name && owner) {
        var children = owner._children,
            namedChildren = owner._namedChildren;
        (namedChildren[name] = namedChildren[name] || []).push(this);
        if (!(name in children)) children[name] = this;
      }

      this._name = name || undefined;

      this._changed(256);
    },
    getStyle: function getStyle() {
      return this._style;
    },
    setStyle: function setStyle(style) {
      this.getStyle().set(style);
    }
  }, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'], function (name) {
    var part = Base.capitalize(name),
        key = '_' + name,
        flags = {
      locked: 256,
      visible: 265
    };

    this['get' + part] = function () {
      return this[key];
    };

    this['set' + part] = function (value) {
      if (value != this[key]) {
        this[key] = value;

        this._changed(flags[name] || 257);
      }
    };
  }, {}), {
    beans: true,
    getSelection: function getSelection() {
      return this._selection;
    },
    setSelection: function setSelection(selection) {
      if (selection !== this._selection) {
        this._selection = selection;
        var project = this._project;

        if (project) {
          project._updateSelection(this);

          this._changed(257);
        }
      }
    },
    _changeSelection: function _changeSelection(flag, selected) {
      var selection = this._selection;
      this.setSelection(selected ? selection | flag : selection & ~flag);
    },
    isSelected: function isSelected() {
      if (this._selectChildren) {
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) {
          if (children[i].isSelected()) return true;
        }
      }

      return !!(this._selection & 1);
    },
    setSelected: function setSelected(selected) {
      if (this._selectChildren) {
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) {
          children[i].setSelected(selected);
        }
      }

      this._changeSelection(1, selected);
    },
    isFullySelected: function isFullySelected() {
      var children = this._children,
          selected = !!(this._selection & 1);

      if (children && selected) {
        for (var i = 0, l = children.length; i < l; i++) {
          if (!children[i].isFullySelected()) return false;
        }

        return true;
      }

      return selected;
    },
    setFullySelected: function setFullySelected(selected) {
      var children = this._children;

      if (children) {
        for (var i = 0, l = children.length; i < l; i++) {
          children[i].setFullySelected(selected);
        }
      }

      this._changeSelection(1, selected);
    },
    isClipMask: function isClipMask() {
      return this._clipMask;
    },
    setClipMask: function setClipMask(clipMask) {
      if (this._clipMask != (clipMask = !!clipMask)) {
        this._clipMask = clipMask;

        if (clipMask) {
          this.setFillColor(null);
          this.setStrokeColor(null);
        }

        this._changed(257);

        if (this._parent) this._parent._changed(2048);
      }
    },
    getData: function getData() {
      if (!this._data) this._data = {};
      return this._data;
    },
    setData: function setData(data) {
      this._data = data;
    },
    getPosition: function getPosition(_dontLink) {
      var ctor = _dontLink ? Point : LinkedPoint;

      var position = this._position || (this._position = this._getPositionFromBounds());

      return new ctor(position.x, position.y, this, 'setPosition');
    },
    setPosition: function setPosition() {
      this.translate(Point.read(arguments).subtract(this.getPosition(true)));
    },
    _getPositionFromBounds: function _getPositionFromBounds(bounds) {
      return this._pivot ? this._matrix._transformPoint(this._pivot) : (bounds || this.getBounds()).getCenter(true);
    },
    getPivot: function getPivot() {
      var pivot = this._pivot;
      return pivot ? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot') : null;
    },
    setPivot: function setPivot() {
      this._pivot = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });
      this._position = undefined;
    }
  }, Base.each({
    getStrokeBounds: {
      stroke: true
    },
    getHandleBounds: {
      handle: true
    },
    getInternalBounds: {
      internal: true
    }
  }, function (options, key) {
    this[key] = function (matrix) {
      return this.getBounds(matrix, options);
    };
  }, {
    beans: true,
    getBounds: function getBounds(matrix, options) {
      var hasMatrix = options || matrix instanceof Matrix,
          opts = Base.set({}, hasMatrix ? options : matrix, this._boundsOptions);
      if (!opts.stroke || this.getStrokeScaling()) opts.cacheItem = this;

      var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;

      return !arguments.length ? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height, this, 'setBounds') : rect;
    },
    setBounds: function setBounds() {
      var rect = _Rectangle.read(arguments),
          bounds = this.getBounds(),
          _matrix = this._matrix,
          matrix = new Matrix(),
          center = rect.getCenter();

      matrix.translate(center);

      if (rect.width != bounds.width || rect.height != bounds.height) {
        if (!_matrix.isInvertible()) {
          _matrix.set(_matrix._backup || new Matrix().translate(_matrix.getTranslation()));

          bounds = this.getBounds();
        }

        matrix.scale(bounds.width !== 0 ? rect.width / bounds.width : 0, bounds.height !== 0 ? rect.height / bounds.height : 0);
      }

      center = bounds.getCenter();
      matrix.translate(-center.x, -center.y);
      this.transform(matrix);
    },
    _getBounds: function _getBounds(matrix, options) {
      var children = this._children;
      if (!children || !children.length) return new _Rectangle();

      Item._updateBoundsCache(this, options.cacheItem);

      return Item._getBounds(children, matrix, options);
    },
    _getBoundsCacheKey: function _getBoundsCacheKey(options, internal) {
      return [options.stroke ? 1 : 0, options.handle ? 1 : 0, internal ? 1 : 0].join('');
    },
    _getCachedBounds: function _getCachedBounds(matrix, options, noInternal) {
      matrix = matrix && matrix._orNullIfIdentity();

      var internal = options.internal && !noInternal,
          cacheItem = options.cacheItem,
          _matrix = internal ? null : this._matrix._orNullIfIdentity(),
          cacheKey = cacheItem && (!matrix || matrix.equals(_matrix)) && this._getBoundsCacheKey(options, internal),
          bounds = this._bounds;

      Item._updateBoundsCache(this._parent || this._symbol, cacheItem);

      if (cacheKey && bounds && cacheKey in bounds) {
        var cached = bounds[cacheKey];
        return {
          rect: cached.rect.clone(),
          nonscaling: cached.nonscaling
        };
      }

      var res = this._getBounds(matrix || _matrix, options),
          rect = res.rect || res,
          style = this._style,
          nonscaling = res.nonscaling || style.hasStroke() && !style.getStrokeScaling();

      if (cacheKey) {
        if (!bounds) {
          this._bounds = bounds = {};
        }

        var cached = bounds[cacheKey] = {
          rect: rect.clone(),
          nonscaling: nonscaling,
          internal: internal
        };
      }

      return {
        rect: rect,
        nonscaling: nonscaling
      };
    },
    _getStrokeMatrix: function _getStrokeMatrix(matrix, options) {
      var parent = this.getStrokeScaling() ? null : options && options.internal ? this : this._parent || this._symbol && this._symbol._item,
          mx = parent ? parent.getViewMatrix().invert() : matrix;
      return mx && mx._shiftless();
    },
    statics: {
      _updateBoundsCache: function _updateBoundsCache(parent, item) {
        if (parent && item) {
          var id = item._id,
              ref = parent._boundsCache = parent._boundsCache || {
            ids: {},
            list: []
          };

          if (!ref.ids[id]) {
            ref.list.push(item);
            ref.ids[id] = item;
          }
        }
      },
      _clearBoundsCache: function _clearBoundsCache(item) {
        var cache = item._boundsCache;

        if (cache) {
          item._bounds = item._position = item._boundsCache = undefined;

          for (var i = 0, list = cache.list, l = list.length; i < l; i++) {
            var other = list[i];

            if (other !== item) {
              other._bounds = other._position = undefined;
              if (other._boundsCache) Item._clearBoundsCache(other);
            }
          }
        }
      },
      _getBounds: function _getBounds(items, matrix, options) {
        var x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2,
            nonscaling = false;
        options = options || {};

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i];

          if (item._visible && !item.isEmpty(true)) {
            var bounds = item._getCachedBounds(matrix && matrix.appended(item._matrix), options, true),
                rect = bounds.rect;

            x1 = Math.min(rect.x, x1);
            y1 = Math.min(rect.y, y1);
            x2 = Math.max(rect.x + rect.width, x2);
            y2 = Math.max(rect.y + rect.height, y2);
            if (bounds.nonscaling) nonscaling = true;
          }
        }

        return {
          rect: isFinite(x1) ? new _Rectangle(x1, y1, x2 - x1, y2 - y1) : new _Rectangle(),
          nonscaling: nonscaling
        };
      }
    }
  }), {
    beans: true,
    _decompose: function _decompose() {
      return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose());
    },
    getRotation: function getRotation() {
      var decomposed = this._decompose();

      return decomposed ? decomposed.rotation : 0;
    },
    setRotation: function setRotation(rotation) {
      var current = this.getRotation();

      if (current != null && rotation != null) {
        var decomposed = this._decomposed;
        this.rotate(rotation - current);

        if (decomposed) {
          decomposed.rotation = rotation;
          this._decomposed = decomposed;
        }
      }
    },
    getScaling: function getScaling() {
      var decomposed = this._decompose(),
          s = decomposed && decomposed.scaling;

      return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
    },
    setScaling: function setScaling() {
      var current = this.getScaling(),
          scaling = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });

      if (current && scaling && !current.equals(scaling)) {
        var rotation = this.getRotation(),
            decomposed = this._decomposed,
            matrix = new Matrix(),
            isZero = Numerical.isZero;

        if (isZero(current.x) || isZero(current.y)) {
          matrix.translate(decomposed.translation);

          if (rotation) {
            matrix.rotate(rotation);
          }

          matrix.scale(scaling.x, scaling.y);

          this._matrix.set(matrix);
        } else {
          var center = this.getPosition(true);
          matrix.translate(center);
          if (rotation) matrix.rotate(rotation);
          matrix.scale(scaling.x / current.x, scaling.y / current.y);
          if (rotation) matrix.rotate(-rotation);
          matrix.translate(center.negate());
          this.transform(matrix);
        }

        if (decomposed) {
          decomposed.scaling = scaling;
          this._decomposed = decomposed;
        }
      }
    },
    getMatrix: function getMatrix() {
      return this._matrix;
    },
    setMatrix: function setMatrix() {
      var matrix = this._matrix;
      matrix.set.apply(matrix, arguments);
    },
    getGlobalMatrix: function getGlobalMatrix(_dontClone) {
      var matrix = this._globalMatrix;

      if (matrix) {
        var parent = this._parent;
        var parents = [];

        while (parent) {
          if (!parent._globalMatrix) {
            matrix = null;

            for (var i = 0, l = parents.length; i < l; i++) {
              parents[i]._globalMatrix = null;
            }

            break;
          }

          parents.push(parent);
          parent = parent._parent;
        }
      }

      if (!matrix) {
        matrix = this._globalMatrix = this._matrix.clone();
        var parent = this._parent;
        if (parent) matrix.prepend(parent.getGlobalMatrix(true));
      }

      return _dontClone ? matrix : matrix.clone();
    },
    getViewMatrix: function getViewMatrix() {
      return this.getGlobalMatrix().prepend(this.getView()._matrix);
    },
    getApplyMatrix: function getApplyMatrix() {
      return this._applyMatrix;
    },
    setApplyMatrix: function setApplyMatrix(apply) {
      if (this._applyMatrix = this._canApplyMatrix && !!apply) this.transform(null, true);
    },
    getTransformContent: '#getApplyMatrix',
    setTransformContent: '#setApplyMatrix'
  }, {
    getProject: function getProject() {
      return this._project;
    },
    _setProject: function _setProject(project, installEvents) {
      if (this._project !== project) {
        if (this._project) this._installEvents(false);
        this._project = project;
        var children = this._children;

        for (var i = 0, l = children && children.length; i < l; i++) {
          children[i]._setProject(project);
        }

        installEvents = true;
      }

      if (installEvents) this._installEvents(true);
    },
    getView: function getView() {
      return this._project._view;
    },
    _installEvents: function _installEvents(install) {
      _installEvents.base.call(this, install);

      var children = this._children;

      for (var i = 0, l = children && children.length; i < l; i++) {
        children[i]._installEvents(install);
      }
    },
    getLayer: function getLayer() {
      var parent = this;

      while (parent = parent._parent) {
        if (parent instanceof Layer) return parent;
      }

      return null;
    },
    getParent: function getParent() {
      return this._parent;
    },
    setParent: function setParent(item) {
      return item.addChild(this);
    },
    _getOwner: '#getParent',
    getChildren: function getChildren() {
      return this._children;
    },
    setChildren: function setChildren(items) {
      this.removeChildren();
      this.addChildren(items);
    },
    getFirstChild: function getFirstChild() {
      return this._children && this._children[0] || null;
    },
    getLastChild: function getLastChild() {
      return this._children && this._children[this._children.length - 1] || null;
    },
    getNextSibling: function getNextSibling() {
      var owner = this._getOwner();

      return owner && owner._children[this._index + 1] || null;
    },
    getPreviousSibling: function getPreviousSibling() {
      var owner = this._getOwner();

      return owner && owner._children[this._index - 1] || null;
    },
    getIndex: function getIndex() {
      return this._index;
    },
    equals: function equals(item) {
      return item === this || item && this._class === item._class && this._style.equals(item._style) && this._matrix.equals(item._matrix) && this._locked === item._locked && this._visible === item._visible && this._blendMode === item._blendMode && this._opacity === item._opacity && this._clipMask === item._clipMask && this._guide === item._guide && this._equals(item) || false;
    },
    _equals: function _equals(item) {
      return Base.equals(this._children, item._children);
    },
    clone: function clone(options) {
      var copy = new this.constructor(Item.NO_INSERT),
          children = this._children,
          insert = Base.pick(options ? options.insert : undefined, options === undefined || options === true),
          deep = Base.pick(options ? options.deep : undefined, true);
      if (children) copy.copyAttributes(this);
      if (!children || deep) copy.copyContent(this);
      if (!children) copy.copyAttributes(this);
      if (insert) copy.insertAbove(this);
      var name = this._name,
          parent = this._parent;

      if (name && parent) {
        var children = parent._children,
            orig = name,
            i = 1;

        while (children[name]) {
          name = orig + ' ' + i++;
        }

        if (name !== orig) copy.setName(name);
      }

      return copy;
    },
    copyContent: function copyContent(source) {
      var children = source._children;

      for (var i = 0, l = children && children.length; i < l; i++) {
        this.addChild(children[i].clone(false), true);
      }
    },
    copyAttributes: function copyAttributes(source, excludeMatrix) {
      this.setStyle(source._style);
      var keys = ['_locked', '_visible', '_blendMode', '_opacity', '_clipMask', '_guide'];

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        if (source.hasOwnProperty(key)) this[key] = source[key];
      }

      if (!excludeMatrix) this._matrix.set(source._matrix, true);
      this.setApplyMatrix(source._applyMatrix);
      this.setPivot(source._pivot);
      this.setSelection(source._selection);
      var data = source._data,
          name = source._name;
      this._data = data ? Base.clone(data) : null;
      if (name) this.setName(name);
    },
    rasterize: function rasterize(resolution, insert) {
      var bounds = this.getStrokeBounds(),
          scale = (resolution || this.getView().getResolution()) / 72,
          topLeft = bounds.getTopLeft().floor(),
          bottomRight = bounds.getBottomRight().ceil(),
          size = new Size(bottomRight.subtract(topLeft)),
          raster = new Raster(Item.NO_INSERT);

      if (!size.isZero()) {
        var canvas = CanvasProvider.getCanvas(size.multiply(scale)),
            ctx = canvas.getContext('2d'),
            matrix = new Matrix().scale(scale).translate(topLeft.negate());
        ctx.save();
        matrix.applyToContext(ctx);
        this.draw(ctx, new Base({
          matrices: [matrix]
        }));
        ctx.restore();
        raster.setCanvas(canvas);
      }

      raster.transform(new Matrix().translate(topLeft.add(size.divide(2))).scale(1 / scale));
      if (insert === undefined || insert) raster.insertAbove(this);
      return raster;
    },
    contains: function contains() {
      var matrix = this._matrix;
      return matrix.isInvertible() && !!this._contains(matrix._inverseTransform(Point.read(arguments)));
    },
    _contains: function _contains(point) {
      var children = this._children;

      if (children) {
        for (var i = children.length - 1; i >= 0; i--) {
          if (children[i].contains(point)) return true;
        }

        return false;
      }

      return point.isInside(this.getInternalBounds());
    },
    isInside: function isInside() {
      return _Rectangle.read(arguments).contains(this.getBounds());
    },
    _asPathItem: function _asPathItem() {
      return new Path.Rectangle({
        rectangle: this.getInternalBounds(),
        matrix: this._matrix,
        insert: false
      });
    },
    intersects: function intersects(item, _matrix) {
      if (!(item instanceof Item)) return false;
      return this._asPathItem().getIntersections(item._asPathItem(), null, _matrix, true).length > 0;
    }
  }, new function () {
    function hitTest() {
      var args = arguments;
      return this._hitTest(Point.read(args), HitResult.getOptions(args));
    }

    function hitTestAll() {
      var args = arguments,
          point = Point.read(args),
          options = HitResult.getOptions(args),
          all = [];

      this._hitTest(point, new Base({
        all: all
      }, options));

      return all;
    }

    function hitTestChildren(point, options, viewMatrix, _exclude) {
      var children = this._children;

      if (children) {
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];

          var res = child !== _exclude && child._hitTest(point, options, viewMatrix);

          if (res && !options.all) return res;
        }
      }

      return null;
    }

    Project.inject({
      hitTest: hitTest,
      hitTestAll: hitTestAll,
      _hitTest: hitTestChildren
    });
    return {
      hitTest: hitTest,
      hitTestAll: hitTestAll,
      _hitTestChildren: hitTestChildren
    };
  }(), {
    _hitTest: function _hitTest(point, options, parentViewMatrix) {
      if (this._locked || !this._visible || this._guide && !options.guides || this.isEmpty()) {
        return null;
      }

      var matrix = this._matrix,
          viewMatrix = parentViewMatrix ? parentViewMatrix.appended(matrix) : this.getGlobalMatrix().prepend(this.getView()._matrix),
          tolerance = Math.max(options.tolerance, 1e-12),
          tolerancePadding = options._tolerancePadding = new Size(Path._getStrokePadding(tolerance, matrix._shiftless().invert()));
      point = matrix._inverseTransform(point);

      if (!point || !this._children && !this.getBounds({
        internal: true,
        stroke: true,
        handle: true
      }).expand(tolerancePadding.multiply(2))._containsPoint(point)) {
        return null;
      }

      var checkSelf = !(options.guides && !this._guide || options.selected && !this.isSelected() || options.type && options.type !== Base.hyphenate(this._class) || options.class && !(this instanceof options.class)),
          match = options.match,
          that = this,
          bounds,
          res;

      function filter(hit) {
        if (hit && match && !match(hit)) hit = null;
        if (hit && options.all) options.all.push(hit);
        return hit;
      }

      function checkPoint(type, part) {
        var pt = part ? bounds['get' + part]() : that.getPosition();

        if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
          return new HitResult(type, that, {
            name: part ? Base.hyphenate(part) : type,
            point: pt
          });
        }
      }

      var checkPosition = options.position,
          checkCenter = options.center,
          checkBounds = options.bounds;

      if (checkSelf && this._parent && (checkPosition || checkCenter || checkBounds)) {
        if (checkCenter || checkBounds) {
          bounds = this.getInternalBounds();
        }

        res = checkPosition && checkPoint('position') || checkCenter && checkPoint('center', 'Center');

        if (!res && checkBounds) {
          var points = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'];

          for (var i = 0; i < 8 && !res; i++) {
            res = checkPoint('bounds', points[i]);
          }
        }

        res = filter(res);
      }

      if (!res) {
        res = this._hitTestChildren(point, options, viewMatrix) || checkSelf && filter(this._hitTestSelf(point, options, viewMatrix, this.getStrokeScaling() ? null : viewMatrix._shiftless().invert())) || null;
      }

      if (res && res.point) {
        res.point = matrix.transform(res.point);
      }

      return res;
    },
    _hitTestSelf: function _hitTestSelf(point, options) {
      if (options.fill && this.hasFill() && this._contains(point)) return new HitResult('fill', this);
    },
    matches: function matches(name, compare) {
      function matchObject(obj1, obj2) {
        for (var i in obj1) {
          if (obj1.hasOwnProperty(i)) {
            var val1 = obj1[i],
                val2 = obj2[i];

            if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
              if (!matchObject(val1, val2)) return false;
            } else if (!Base.equals(val1, val2)) {
              return false;
            }
          }
        }

        return true;
      }

      var type = _typeof(name);

      if (type === 'object') {
        for (var key in name) {
          if (name.hasOwnProperty(key) && !this.matches(key, name[key])) return false;
        }

        return true;
      } else if (type === 'function') {
        return name(this);
      } else if (name === 'match') {
        return compare(this);
      } else {
        var value = /^(empty|editable)$/.test(name) ? this['is' + Base.capitalize(name)]() : name === 'type' ? Base.hyphenate(this._class) : this[name];

        if (name === 'class') {
          if (typeof compare === 'function') return this instanceof compare;
          value = this._class;
        }

        if (typeof compare === 'function') {
          return !!compare(value);
        } else if (compare) {
          if (compare.test) {
            return compare.test(value);
          } else if (Base.isPlainObject(compare)) {
            return matchObject(compare, value);
          }
        }

        return Base.equals(value, compare);
      }
    },
    getItems: function getItems(options) {
      return Item._getItems(this, options, this._matrix);
    },
    getItem: function getItem(options) {
      return Item._getItems(this, options, this._matrix, null, true)[0] || null;
    },
    statics: {
      _getItems: function _getItems(item, options, matrix, param, firstOnly) {
        if (!param) {
          var obj = _typeof(options) === 'object' && options,
              overlapping = obj && obj.overlapping,
              inside = obj && obj.inside,
              bounds = overlapping || inside,
              rect = bounds && _Rectangle.read([bounds]);

          param = {
            items: [],
            recursive: obj && obj.recursive !== false,
            inside: !!inside,
            overlapping: !!overlapping,
            rect: rect,
            path: overlapping && new Path.Rectangle({
              rectangle: rect,
              insert: false
            })
          };

          if (obj) {
            options = Base.filter({}, options, {
              recursive: true,
              inside: true,
              overlapping: true
            });
          }
        }

        var children = item._children,
            items = param.items,
            rect = param.rect;
        matrix = rect && (matrix || new Matrix());

        for (var i = 0, l = children && children.length; i < l; i++) {
          var child = children[i],
              childMatrix = matrix && matrix.appended(child._matrix),
              add = true;

          if (rect) {
            var bounds = child.getBounds(childMatrix);
            if (!rect.intersects(bounds)) continue;
            if (!(rect.contains(bounds) || param.overlapping && (bounds.contains(rect) || param.path.intersects(child, childMatrix)))) add = false;
          }

          if (add && child.matches(options)) {
            items.push(child);
            if (firstOnly) break;
          }

          if (param.recursive !== false) {
            _getItems(child, options, childMatrix, param, firstOnly);
          }

          if (firstOnly && items.length > 0) break;
        }

        return items;
      }
    }
  }, {
    importJSON: function importJSON(json) {
      var res = Base.importJSON(json, this);
      return res !== this ? this.addChild(res) : res;
    },
    addChild: function addChild(item) {
      return this.insertChild(undefined, item);
    },
    insertChild: function insertChild(index, item) {
      var res = item ? this.insertChildren(index, [item]) : null;
      return res && res[0];
    },
    addChildren: function addChildren(items) {
      return this.insertChildren(this._children.length, items);
    },
    insertChildren: function insertChildren(index, items) {
      var children = this._children;

      if (children && items && items.length > 0) {
        items = Base.slice(items);
        var inserted = {};

        for (var i = items.length - 1; i >= 0; i--) {
          var item = items[i],
              id = item && item._id;

          if (!item || inserted[id]) {
            items.splice(i, 1);
          } else {
            item._remove(false, true);

            inserted[id] = true;
          }
        }

        Base.splice(children, items, index, 0);
        var project = this._project,
            notifySelf = project._changes;

        for (var i = 0, l = items.length; i < l; i++) {
          var item = items[i],
              name = item._name;
          item._parent = this;

          item._setProject(project, true);

          if (name) item.setName(name);
          if (notifySelf) item._changed(5);
        }

        this._changed(11);
      } else {
        items = null;
      }

      return items;
    },
    _insertItem: '#insertChild',
    _insertAt: function _insertAt(item, offset) {
      var owner = item && item._getOwner(),
          res = item !== this && owner ? this : null;

      if (res) {
        res._remove(false, true);

        owner._insertItem(item._index + offset, res);
      }

      return res;
    },
    insertAbove: function insertAbove(item) {
      return this._insertAt(item, 1);
    },
    insertBelow: function insertBelow(item) {
      return this._insertAt(item, 0);
    },
    sendToBack: function sendToBack() {
      var owner = this._getOwner();

      return owner ? owner._insertItem(0, this) : null;
    },
    bringToFront: function bringToFront() {
      var owner = this._getOwner();

      return owner ? owner._insertItem(undefined, this) : null;
    },
    appendTop: '#addChild',
    appendBottom: function appendBottom(item) {
      return this.insertChild(0, item);
    },
    moveAbove: '#insertAbove',
    moveBelow: '#insertBelow',
    addTo: function addTo(owner) {
      return owner._insertItem(undefined, this);
    },
    copyTo: function copyTo(owner) {
      return this.clone(false).addTo(owner);
    },
    reduce: function reduce(options) {
      var children = this._children;

      if (children && children.length === 1) {
        var child = children[0].reduce(options);

        if (this._parent) {
          child.insertAbove(this);
          this.remove();
        } else {
          child.remove();
        }

        return child;
      }

      return this;
    },
    _removeNamed: function _removeNamed() {
      var owner = this._getOwner();

      if (owner) {
        var children = owner._children,
            namedChildren = owner._namedChildren,
            name = this._name,
            namedArray = namedChildren[name],
            index = namedArray ? namedArray.indexOf(this) : -1;

        if (index !== -1) {
          if (children[name] == this) delete children[name];
          namedArray.splice(index, 1);

          if (namedArray.length) {
            children[name] = namedArray[0];
          } else {
            delete namedChildren[name];
          }
        }
      }
    },
    _remove: function _remove(notifySelf, notifyParent) {
      var owner = this._getOwner(),
          project = this._project,
          index = this._index;

      if (this._style) this._style._dispose();

      if (owner) {
        if (this._name) this._removeNamed();

        if (index != null) {
          if (project._activeLayer === this) project._activeLayer = this.getNextSibling() || this.getPreviousSibling();
          Base.splice(owner._children, null, index, 1);
        }

        this._installEvents(false);

        if (notifySelf && project._changes) this._changed(5);
        if (notifyParent) owner._changed(11, this);
        this._parent = null;
        return true;
      }

      return false;
    },
    remove: function remove() {
      return this._remove(true, true);
    },
    replaceWith: function replaceWith(item) {
      var ok = item && item.insertBelow(this);
      if (ok) this.remove();
      return ok;
    },
    removeChildren: function removeChildren(start, end) {
      if (!this._children) return null;
      start = start || 0;
      end = Base.pick(end, this._children.length);
      var removed = Base.splice(this._children, null, start, end - start);

      for (var i = removed.length - 1; i >= 0; i--) {
        removed[i]._remove(true, false);
      }

      if (removed.length > 0) this._changed(11);
      return removed;
    },
    clear: '#removeChildren',
    reverseChildren: function reverseChildren() {
      if (this._children) {
        this._children.reverse();

        for (var i = 0, l = this._children.length; i < l; i++) {
          this._children[i]._index = i;
        }

        this._changed(11);
      }
    },
    isEmpty: function isEmpty(recursively) {
      var children = this._children;
      var numChildren = children ? children.length : 0;

      if (recursively) {
        for (var i = 0; i < numChildren; i++) {
          if (!children[i].isEmpty(recursively)) {
            return false;
          }
        }

        return true;
      }

      return !numChildren;
    },
    isEditable: function isEditable() {
      var item = this;

      while (item) {
        if (!item._visible || item._locked) return false;
        item = item._parent;
      }

      return true;
    },
    hasFill: function hasFill() {
      return this.getStyle().hasFill();
    },
    hasStroke: function hasStroke() {
      return this.getStyle().hasStroke();
    },
    hasShadow: function hasShadow() {
      return this.getStyle().hasShadow();
    },
    _getOrder: function _getOrder(item) {
      function getList(item) {
        var list = [];

        do {
          list.unshift(item);
        } while (item = item._parent);

        return list;
      }

      var list1 = getList(this),
          list2 = getList(item);

      for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
        if (list1[i] != list2[i]) {
          return list1[i]._index < list2[i]._index ? 1 : -1;
        }
      }

      return 0;
    },
    hasChildren: function hasChildren() {
      return this._children && this._children.length > 0;
    },
    isInserted: function isInserted() {
      return this._parent ? this._parent.isInserted() : false;
    },
    isAbove: function isAbove(item) {
      return this._getOrder(item) === -1;
    },
    isBelow: function isBelow(item) {
      return this._getOrder(item) === 1;
    },
    isParent: function isParent(item) {
      return this._parent === item;
    },
    isChild: function isChild(item) {
      return item && item._parent === this;
    },
    isDescendant: function isDescendant(item) {
      var parent = this;

      while (parent = parent._parent) {
        if (parent === item) return true;
      }

      return false;
    },
    isAncestor: function isAncestor(item) {
      return item ? item.isDescendant(this) : false;
    },
    isSibling: function isSibling(item) {
      return this._parent === item._parent;
    },
    isGroupedWith: function isGroupedWith(item) {
      var parent = this._parent;

      while (parent) {
        if (parent._parent && /^(Group|Layer|CompoundPath)$/.test(parent._class) && item.isDescendant(parent)) return true;
        parent = parent._parent;
      }

      return false;
    }
  }, Base.each(['rotate', 'scale', 'shear', 'skew'], function (key) {
    var rotate = key === 'rotate';

    this[key] = function () {
      var args = arguments,
          value = (rotate ? Base : Point).read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      return this.transform(new Matrix()[key](value, center || this.getPosition(true)));
    };
  }, {
    translate: function translate() {
      var mx = new Matrix();
      return this.transform(mx.translate.apply(mx, arguments));
    },
    transform: function transform(matrix, _applyRecursively, _setApplyMatrix) {
      var _matrix = this._matrix,
          transformMatrix = matrix && !matrix.isIdentity(),
          applyMatrix = _setApplyMatrix && this._canApplyMatrix || this._applyMatrix && (transformMatrix || !_matrix.isIdentity() || _applyRecursively && this._children);
      if (!transformMatrix && !applyMatrix) return this;

      if (transformMatrix) {
        if (!matrix.isInvertible() && _matrix.isInvertible()) _matrix._backup = _matrix.getValues();

        _matrix.prepend(matrix, true);

        var style = this._style,
            fillColor = style.getFillColor(true),
            strokeColor = style.getStrokeColor(true);
        if (fillColor) fillColor.transform(matrix);
        if (strokeColor) strokeColor.transform(matrix);
      }

      if (applyMatrix && (applyMatrix = this._transformContent(_matrix, _applyRecursively, _setApplyMatrix))) {
        var pivot = this._pivot;
        if (pivot) _matrix._transformPoint(pivot, pivot, true);

        _matrix.reset(true);

        if (_setApplyMatrix && this._canApplyMatrix) this._applyMatrix = true;
      }

      var bounds = this._bounds,
          position = this._position;

      if (transformMatrix || applyMatrix) {
        this._changed(25);
      }

      var decomp = transformMatrix && bounds && matrix.decompose();

      if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
        for (var key in bounds) {
          var cache = bounds[key];

          if (cache.nonscaling) {
            delete bounds[key];
          } else if (applyMatrix || !cache.internal) {
            var rect = cache.rect;

            matrix._transformBounds(rect, rect);
          }
        }

        this._bounds = bounds;

        var cached = bounds[this._getBoundsCacheKey(this._boundsOptions || {})];

        if (cached) {
          this._position = this._getPositionFromBounds(cached.rect);
        }
      } else if (transformMatrix && position && this._pivot) {
        this._position = matrix._transformPoint(position, position);
      }

      return this;
    },
    _transformContent: function _transformContent(matrix, applyRecursively, setApplyMatrix) {
      var children = this._children;

      if (children) {
        for (var i = 0, l = children.length; i < l; i++) {
          children[i].transform(matrix, applyRecursively, setApplyMatrix);
        }

        return true;
      }
    },
    globalToLocal: function globalToLocal() {
      return this.getGlobalMatrix(true)._inverseTransform(Point.read(arguments));
    },
    localToGlobal: function localToGlobal() {
      return this.getGlobalMatrix(true)._transformPoint(Point.read(arguments));
    },
    parentToLocal: function parentToLocal() {
      return this._matrix._inverseTransform(Point.read(arguments));
    },
    localToParent: function localToParent() {
      return this._matrix._transformPoint(Point.read(arguments));
    },
    fitBounds: function fitBounds(rectangle, fill) {
      rectangle = _Rectangle.read(arguments);
      var bounds = this.getBounds(),
          itemRatio = bounds.height / bounds.width,
          rectRatio = rectangle.height / rectangle.width,
          scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio) ? rectangle.width / bounds.width : rectangle.height / bounds.height,
          newBounds = new _Rectangle(new Point(), new Size(bounds.width * scale, bounds.height * scale));
      newBounds.setCenter(rectangle.getCenter());
      this.setBounds(newBounds);
    }
  }), {
    _setStyles: function _setStyles(ctx, param, viewMatrix) {
      var style = this._style,
          matrix = this._matrix;

      if (style.hasFill()) {
        ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
      }

      if (style.hasStroke()) {
        ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
        ctx.lineWidth = style.getStrokeWidth();
        var strokeJoin = style.getStrokeJoin(),
            strokeCap = style.getStrokeCap(),
            miterLimit = style.getMiterLimit();
        if (strokeJoin) ctx.lineJoin = strokeJoin;
        if (strokeCap) ctx.lineCap = strokeCap;
        if (miterLimit) ctx.miterLimit = miterLimit;

        if (paper.support.nativeDash) {
          var dashArray = style.getDashArray(),
              dashOffset = style.getDashOffset();

          if (dashArray && dashArray.length) {
            if ('setLineDash' in ctx) {
              ctx.setLineDash(dashArray);
              ctx.lineDashOffset = dashOffset;
            } else {
              ctx.mozDash = dashArray;
              ctx.mozDashOffset = dashOffset;
            }
          }
        }
      }

      if (style.hasShadow()) {
        var pixelRatio = param.pixelRatio || 1,
            mx = viewMatrix._shiftless().prepend(new Matrix().scale(pixelRatio, pixelRatio)),
            blur = mx.transform(new Point(style.getShadowBlur(), 0)),
            offset = mx.transform(this.getShadowOffset());

        ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
        ctx.shadowBlur = blur.getLength();
        ctx.shadowOffsetX = offset.x;
        ctx.shadowOffsetY = offset.y;
      }
    },
    draw: function draw(ctx, param, parentStrokeMatrix) {
      var updateVersion = this._updateVersion = this._project._updateVersion;
      if (!this._visible || this._opacity === 0) return;
      var matrices = param.matrices,
          viewMatrix = param.viewMatrix,
          matrix = this._matrix,
          globalMatrix = matrices[matrices.length - 1].appended(matrix);
      if (!globalMatrix.isInvertible()) return;
      viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix) : globalMatrix;
      matrices.push(globalMatrix);

      if (param.updateMatrix) {
        this._globalMatrix = globalMatrix;
      }

      var blendMode = this._blendMode,
          opacity = Numerical.clamp(this._opacity, 0, 1),
          normalBlend = blendMode === 'normal',
          nativeBlend = BlendMode.nativeModes[blendMode],
          direct = normalBlend && opacity === 1 || param.dontStart || param.clip || (nativeBlend || normalBlend && opacity < 1) && this._canComposite(),
          pixelRatio = param.pixelRatio || 1,
          mainCtx,
          itemOffset,
          prevOffset;

      if (!direct) {
        var bounds = this.getStrokeBounds(viewMatrix);

        if (!bounds.width || !bounds.height) {
          matrices.pop();
          return;
        }

        prevOffset = param.offset;
        itemOffset = param.offset = bounds.getTopLeft().floor();
        mainCtx = ctx;
        ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1).multiply(pixelRatio));
        if (pixelRatio !== 1) ctx.scale(pixelRatio, pixelRatio);
      }

      ctx.save();
      var strokeMatrix = parentStrokeMatrix ? parentStrokeMatrix.appended(matrix) : this._canScaleStroke && !this.getStrokeScaling(true) && viewMatrix,
          clip = !direct && param.clipItem,
          transform = !strokeMatrix || clip;

      if (direct) {
        ctx.globalAlpha = opacity;
        if (nativeBlend) ctx.globalCompositeOperation = blendMode;
      } else if (transform) {
        ctx.translate(-itemOffset.x, -itemOffset.y);
      }

      if (transform) {
        (direct ? matrix : viewMatrix).applyToContext(ctx);
      }

      if (clip) {
        param.clipItem.draw(ctx, param.extend({
          clip: true
        }));
      }

      if (strokeMatrix) {
        ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        var offset = param.offset;
        if (offset) ctx.translate(-offset.x, -offset.y);
      }

      this._draw(ctx, param, viewMatrix, strokeMatrix);

      ctx.restore();
      matrices.pop();

      if (param.clip && !param.dontFinish) {
        ctx.clip(this.getFillRule());
      }

      if (!direct) {
        BlendMode.process(blendMode, ctx, mainCtx, opacity, itemOffset.subtract(prevOffset).multiply(pixelRatio));
        CanvasProvider.release(ctx);
        param.offset = prevOffset;
      }
    },
    _isUpdated: function _isUpdated(updateVersion) {
      var parent = this._parent;
      if (parent instanceof CompoundPath) return parent._isUpdated(updateVersion);
      var updated = this._updateVersion === updateVersion;

      if (!updated && parent && parent._visible && parent._isUpdated(updateVersion)) {
        this._updateVersion = updateVersion;
        updated = true;
      }

      return updated;
    },
    _drawSelection: function _drawSelection(ctx, matrix, size, selectionItems, updateVersion) {
      var selection = this._selection,
          itemSelected = selection & 1,
          boundsSelected = selection & 2 || itemSelected && this._selectBounds,
          positionSelected = selection & 4;
      if (!this._drawSelected) itemSelected = false;

      if ((itemSelected || boundsSelected || positionSelected) && this._isUpdated(updateVersion)) {
        var layer,
            color = this.getSelectedColor(true) || (layer = this.getLayer()) && layer.getSelectedColor(true),
            mx = matrix.appended(this.getGlobalMatrix(true)),
            half = size / 2;
        ctx.strokeStyle = ctx.fillStyle = color ? color.toCanvasStyle(ctx) : '#009dec';
        if (itemSelected) this._drawSelected(ctx, mx, selectionItems);

        if (positionSelected) {
          var pos = this.getPosition(true),
              parent = this._parent,
              point = parent ? parent.localToGlobal(pos) : pos,
              x = point.x,
              y = point.y;
          ctx.beginPath();
          ctx.arc(x, y, half, 0, Math.PI * 2, true);
          ctx.stroke();
          var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
              start = half,
              end = size + 1;

          for (var i = 0; i < 4; i++) {
            var delta = deltas[i],
                dx = delta[0],
                dy = delta[1];
            ctx.moveTo(x + dx * start, y + dy * start);
            ctx.lineTo(x + dx * end, y + dy * end);
            ctx.stroke();
          }
        }

        if (boundsSelected) {
          var coords = mx._transformCorners(this.getInternalBounds());

          ctx.beginPath();

          for (var i = 0; i < 8; i++) {
            ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
          }

          ctx.closePath();
          ctx.stroke();

          for (var i = 0; i < 8; i++) {
            ctx.fillRect(coords[i] - half, coords[++i] - half, size, size);
          }
        }
      }
    },
    _canComposite: function _canComposite() {
      return false;
    }
  }, Base.each(['down', 'drag', 'up', 'move'], function (key) {
    this['removeOn' + Base.capitalize(key)] = function () {
      var hash = {};
      hash[key] = true;
      return this.removeOn(hash);
    };
  }, {
    removeOn: function removeOn(obj) {
      for (var name in obj) {
        if (obj[name]) {
          var key = 'mouse' + name,
              project = this._project,
              sets = project._removeSets = project._removeSets || {};
          sets[key] = sets[key] || {};
          sets[key][this._id] = this;
        }
      }

      return this;
    }
  }), {
    tween: function tween(from, to, options) {
      if (!options) {
        options = to;
        to = from;
        from = null;

        if (!options) {
          options = to;
          to = null;
        }
      }

      var easing = options && options.easing,
          start = options && options.start,
          duration = options != null && (typeof options === 'number' ? options : options.duration),
          tween = new Tween(this, from, to, duration, easing, start);

      function onFrame(event) {
        tween._handleFrame(event.time * 1000);

        if (!tween.running) {
          this.off('frame', onFrame);
        }
      }

      if (duration) {
        this.on('frame', onFrame);
      }

      return tween;
    },
    tweenTo: function tweenTo(to, options) {
      return this.tween(null, to, options);
    },
    tweenFrom: function tweenFrom(from, options) {
      return this.tween(from, null, options);
    }
  });
  var Group = Item.extend({
    _class: 'Group',
    _selectBounds: false,
    _selectChildren: true,
    _serializeFields: {
      children: []
    },
    initialize: function Group(arg) {
      this._children = [];
      this._namedChildren = {};
      if (!this._initialize(arg)) this.addChildren(Array.isArray(arg) ? arg : arguments);
    },
    _changed: function _changed(flags) {
      _changed.base.call(this, flags);

      if (flags & 2050) {
        this._clipItem = undefined;
      }
    },
    _getClipItem: function _getClipItem() {
      var clipItem = this._clipItem;

      if (clipItem === undefined) {
        clipItem = null;
        var children = this._children;

        for (var i = 0, l = children.length; i < l; i++) {
          if (children[i]._clipMask) {
            clipItem = children[i];
            break;
          }
        }

        this._clipItem = clipItem;
      }

      return clipItem;
    },
    isClipped: function isClipped() {
      return !!this._getClipItem();
    },
    setClipped: function setClipped(clipped) {
      var child = this.getFirstChild();
      if (child) child.setClipMask(clipped);
    },
    _getBounds: function _getBounds(matrix, options) {
      var clipItem = this._getClipItem();

      return clipItem ? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix), Base.set({}, options, {
        stroke: false
      })) : _getBounds.base.call(this, matrix, options);
    },
    _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
      var clipItem = this._getClipItem();

      return (!clipItem || clipItem.contains(point)) && _hitTestChildren.base.call(this, point, options, viewMatrix, clipItem);
    },
    _draw: function _draw(ctx, param) {
      var clip = param.clip,
          clipItem = !clip && this._getClipItem();

      param = param.extend({
        clipItem: clipItem,
        clip: false
      });

      if (clip) {
        ctx.beginPath();
        param.dontStart = param.dontFinish = true;
      } else if (clipItem) {
        clipItem.draw(ctx, param.extend({
          clip: true
        }));
      }

      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        var item = children[i];
        if (item !== clipItem) item.draw(ctx, param);
      }
    }
  });
  var Layer = Group.extend({
    _class: 'Layer',
    initialize: function Layer() {
      Group.apply(this, arguments);
    },
    _getOwner: function _getOwner() {
      return this._parent || this._index != null && this._project;
    },
    isInserted: function isInserted() {
      return this._parent ? isInserted.base.call(this) : this._index != null;
    },
    activate: function activate() {
      this._project._activeLayer = this;
    },
    _hitTestSelf: function _hitTestSelf() {}
  });
  var Shape = Item.extend({
    _class: 'Shape',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _canScaleStroke: true,
    _serializeFields: {
      type: null,
      size: null,
      radius: null
    },
    initialize: function Shape(props, point) {
      this._initialize(props, point);
    },
    _equals: function _equals(item) {
      return this._type === item._type && this._size.equals(item._size) && Base.equals(this._radius, item._radius);
    },
    copyContent: function copyContent(source) {
      this.setType(source._type);
      this.setSize(source._size);
      this.setRadius(source._radius);
    },
    getType: function getType() {
      return this._type;
    },
    setType: function setType(type) {
      this._type = type;
    },
    getShape: '#getType',
    setShape: '#setType',
    getSize: function getSize() {
      var size = this._size;
      return new LinkedSize(size.width, size.height, this, 'setSize');
    },
    setSize: function setSize() {
      var size = Size.read(arguments);

      if (!this._size) {
        this._size = size.clone();
      } else if (!this._size.equals(size)) {
        var type = this._type,
            width = size.width,
            height = size.height;

        if (type === 'rectangle') {
          this._radius.set(Size.min(this._radius, size.divide(2).abs()));
        } else if (type === 'circle') {
          width = height = (width + height) / 2;
          this._radius = width / 2;
        } else if (type === 'ellipse') {
          this._radius._set(width / 2, height / 2);
        }

        this._size._set(width, height);

        this._changed(9);
      }
    },
    getRadius: function getRadius() {
      var rad = this._radius;
      return this._type === 'circle' ? rad : new LinkedSize(rad.width, rad.height, this, 'setRadius');
    },
    setRadius: function setRadius(radius) {
      var type = this._type;

      if (type === 'circle') {
        if (radius === this._radius) return;
        var size = radius * 2;
        this._radius = radius;

        this._size._set(size, size);
      } else {
        radius = Size.read(arguments);

        if (!this._radius) {
          this._radius = radius.clone();
        } else {
          if (this._radius.equals(radius)) return;

          this._radius.set(radius);

          if (type === 'rectangle') {
            var size = Size.max(this._size, radius.multiply(2));

            this._size.set(size);
          } else if (type === 'ellipse') {
            this._size._set(radius.width * 2, radius.height * 2);
          }
        }
      }

      this._changed(9);
    },
    isEmpty: function isEmpty() {
      return false;
    },
    toPath: function toPath(insert) {
      var path = new Path[Base.capitalize(this._type)]({
        center: new Point(),
        size: this._size,
        radius: this._radius,
        insert: false
      });
      path.copyAttributes(this);
      if (paper.settings.applyMatrix) path.setApplyMatrix(true);
      if (insert === undefined || insert) path.insertAbove(this);
      return path;
    },
    toShape: '#clone',
    _asPathItem: function _asPathItem() {
      return this.toPath(false);
    },
    _draw: function _draw(ctx, param, viewMatrix, strokeMatrix) {
      var style = this._style,
          hasFill = style.hasFill(),
          hasStroke = style.hasStroke(),
          dontPaint = param.dontFinish || param.clip,
          untransformed = !strokeMatrix;

      if (hasFill || hasStroke || dontPaint) {
        var type = this._type,
            radius = this._radius,
            isCircle = type === 'circle';
        if (!param.dontStart) ctx.beginPath();

        if (untransformed && isCircle) {
          ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
        } else {
          var rx = isCircle ? radius : radius.width,
              ry = isCircle ? radius : radius.height,
              size = this._size,
              width = size.width,
              height = size.height;

          if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
            ctx.rect(-width / 2, -height / 2, width, height);
          } else {
            var x = width / 2,
                y = height / 2,
                kappa = 1 - 0.5522847498307936,
                cx = rx * kappa,
                cy = ry * kappa,
                c = [-x, -y + ry, -x, -y + cy, -x + cx, -y, -x + rx, -y, x - rx, -y, x - cx, -y, x, -y + cy, x, -y + ry, x, y - ry, x, y - cy, x - cx, y, x - rx, y, -x + rx, y, -x + cx, y, -x, y - cy, -x, y - ry];
            if (strokeMatrix) strokeMatrix.transform(c, c, 32);
            ctx.moveTo(c[0], c[1]);
            ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
            if (x !== rx) ctx.lineTo(c[8], c[9]);
            ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
            if (y !== ry) ctx.lineTo(c[16], c[17]);
            ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
            if (x !== rx) ctx.lineTo(c[24], c[25]);
            ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
          }
        }

        ctx.closePath();
      }

      if (!dontPaint && (hasFill || hasStroke)) {
        this._setStyles(ctx, param, viewMatrix);

        if (hasFill) {
          ctx.fill(style.getFillRule());
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (hasStroke) ctx.stroke();
      }
    },
    _canComposite: function _canComposite() {
      return !(this.hasFill() && this.hasStroke());
    },
    _getBounds: function _getBounds(matrix, options) {
      var rect = new _Rectangle(this._size).setCenter(0, 0),
          style = this._style,
          strokeWidth = options.stroke && style.hasStroke() && style.getStrokeWidth();
      if (matrix) rect = matrix._transformBounds(rect);
      return strokeWidth ? rect.expand(Path._getStrokePadding(strokeWidth, this._getStrokeMatrix(matrix, options))) : rect;
    }
  }, new function () {
    function getCornerCenter(that, point, expand) {
      var radius = that._radius;

      if (!radius.isZero()) {
        var halfSize = that._size.divide(2);

        for (var q = 1; q <= 4; q++) {
          var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
              corner = dir.multiply(halfSize),
              center = corner.subtract(dir.multiply(radius)),
              rect = new _Rectangle(expand ? corner.add(dir.multiply(expand)) : corner, center);
          if (rect.contains(point)) return {
            point: center,
            quadrant: q
          };
        }
      }
    }

    function isOnEllipseStroke(point, radius, padding, quadrant) {
      var vector = point.divide(radius);
      return (!quadrant || vector.isInQuadrant(quadrant)) && vector.subtract(vector.normalize()).multiply(radius).divide(padding).length <= 1;
    }

    return {
      _contains: function _contains(point) {
        if (this._type === 'rectangle') {
          var center = getCornerCenter(this, point);
          return center ? point.subtract(center.point).divide(this._radius).getLength() <= 1 : _contains.base.call(this, point);
        } else {
          return point.divide(this.size).getLength() <= 0.5;
        }
      },
      _hitTestSelf: function _hitTestSelf(point, options, viewMatrix, strokeMatrix) {
        var hit = false,
            style = this._style,
            hitStroke = options.stroke && style.hasStroke(),
            hitFill = options.fill && style.hasFill();

        if (hitStroke || hitFill) {
          var type = this._type,
              radius = this._radius,
              strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
              strokePadding = options._tolerancePadding.add(Path._getStrokePadding(strokeRadius, !style.getStrokeScaling() && strokeMatrix));

          if (type === 'rectangle') {
            var padding = strokePadding.multiply(2),
                center = getCornerCenter(this, point, padding);

            if (center) {
              hit = isOnEllipseStroke(point.subtract(center.point), radius, strokePadding, center.quadrant);
            } else {
              var rect = new _Rectangle(this._size).setCenter(0, 0),
                  outer = rect.expand(padding),
                  inner = rect.expand(padding.negate());
              hit = outer._containsPoint(point) && !inner._containsPoint(point);
            }
          } else {
            hit = isOnEllipseStroke(point, radius, strokePadding);
          }
        }

        return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this) : _hitTestSelf.base.apply(this, arguments);
      }
    };
  }(), {
    statics: new function () {
      function createShape(type, point, size, radius, args) {
        var item = Base.create(Shape.prototype);
        item._type = type;
        item._size = size;
        item._radius = radius;

        item._initialize(Base.getNamed(args), point);

        return item;
      }

      return {
        Circle: function Circle() {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              radius = Base.readNamed(args, 'radius');
          return createShape('circle', center, new Size(radius * 2), radius, args);
        },
        Rectangle: function Rectangle() {
          var args = arguments,
              rect = _Rectangle.readNamed(args, 'rectangle'),
              radius = Size.min(Size.readNamed(args, 'radius'), rect.getSize(true).divide(2));

          return createShape('rectangle', rect.getCenter(true), rect.getSize(true), radius, args);
        },
        Ellipse: function Ellipse() {
          var args = arguments,
              ellipse = Shape._readEllipse(args),
              radius = ellipse.radius;

          return createShape('ellipse', ellipse.center, radius.multiply(2), radius, args);
        },
        _readEllipse: function _readEllipse(args) {
          var center, radius;

          if (Base.hasNamed(args, 'radius')) {
            center = Point.readNamed(args, 'center');
            radius = Size.readNamed(args, 'radius');
          } else {
            var rect = _Rectangle.readNamed(args, 'rectangle');

            center = rect.getCenter(true);
            radius = rect.getSize(true).divide(2);
          }

          return {
            center: center,
            radius: radius
          };
        }
      };
    }()
  });
  var Raster = Item.extend({
    _class: 'Raster',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsOptions: {
      stroke: false,
      handle: false
    },
    _serializeFields: {
      crossOrigin: null,
      source: null
    },
    _prioritize: ['crossOrigin'],
    _smoothing: true,
    beans: true,
    initialize: function Raster(source, position) {
      if (!this._initialize(source, position !== undefined && Point.read(arguments))) {
        var image,
            type = _typeof(source),
            object = type === 'string' ? document.getElementById(source) : type === 'object' ? source : null;

        if (object && object !== Item.NO_INSERT) {
          if (object.getContext || object.naturalHeight != null) {
            image = object;
          } else if (object) {
            var size = Size.read(arguments);

            if (!size.isZero()) {
              image = CanvasProvider.getCanvas(size);
            }
          }
        }

        if (image) {
          this.setImage(image);
        } else {
          this.setSource(source);
        }
      }

      if (!this._size) {
        this._size = new Size();
        this._loaded = false;
      }
    },
    _equals: function _equals(item) {
      return this.getSource() === item.getSource();
    },
    copyContent: function copyContent(source) {
      var image = source._image,
          canvas = source._canvas;

      if (image) {
        this._setImage(image);
      } else if (canvas) {
        var copyCanvas = CanvasProvider.getCanvas(source._size);
        copyCanvas.getContext('2d').drawImage(canvas, 0, 0);

        this._setImage(copyCanvas);
      }

      this._crossOrigin = source._crossOrigin;
    },
    getSize: function getSize() {
      var size = this._size;
      return new LinkedSize(size ? size.width : 0, size ? size.height : 0, this, 'setSize');
    },
    setSize: function setSize() {
      var size = Size.read(arguments);

      if (!size.equals(this._size)) {
        if (size.width > 0 && size.height > 0) {
          var element = this.getElement();

          this._setImage(CanvasProvider.getCanvas(size));

          if (element) this.getContext(true).drawImage(element, 0, 0, size.width, size.height);
        } else {
          if (this._canvas) CanvasProvider.release(this._canvas);
          this._size = size.clone();
        }
      }
    },
    getWidth: function getWidth() {
      return this._size ? this._size.width : 0;
    },
    setWidth: function setWidth(width) {
      this.setSize(width, this.getHeight());
    },
    getHeight: function getHeight() {
      return this._size ? this._size.height : 0;
    },
    setHeight: function setHeight(height) {
      this.setSize(this.getWidth(), height);
    },
    getLoaded: function getLoaded() {
      return this._loaded;
    },
    isEmpty: function isEmpty() {
      var size = this._size;
      return !size || size.width === 0 && size.height === 0;
    },
    getResolution: function getResolution() {
      var matrix = this._matrix,
          orig = new Point(0, 0).transform(matrix),
          u = new Point(1, 0).transform(matrix).subtract(orig),
          v = new Point(0, 1).transform(matrix).subtract(orig);
      return new Size(72 / u.getLength(), 72 / v.getLength());
    },
    getPpi: '#getResolution',
    getImage: function getImage() {
      return this._image;
    },
    setImage: function setImage(image) {
      var that = this;

      function emit(event) {
        var view = that.getView(),
            type = event && event.type || 'load';

        if (view && that.responds(type)) {
          paper = view._scope;
          that.emit(type, new Event(event));
        }
      }

      this._setImage(image);

      if (this._loaded) {
        setTimeout(emit, 0);
      } else if (image) {
        DomEvent.add(image, {
          load: function load(event) {
            that._setImage(image);

            emit(event);
          },
          error: emit
        });
      }
    },
    _setImage: function _setImage(image) {
      if (this._canvas) CanvasProvider.release(this._canvas);

      if (image && image.getContext) {
        this._image = null;
        this._canvas = image;
        this._loaded = true;
      } else {
        this._image = image;
        this._canvas = null;
        this._loaded = !!(image && image.src && image.complete);
      }

      this._size = new Size(image ? image.naturalWidth || image.width : 0, image ? image.naturalHeight || image.height : 0);
      this._context = null;

      this._changed(1033);
    },
    getCanvas: function getCanvas() {
      if (!this._canvas) {
        var ctx = CanvasProvider.getContext(this._size);

        try {
          if (this._image) ctx.drawImage(this._image, 0, 0);
          this._canvas = ctx.canvas;
        } catch (e) {
          CanvasProvider.release(ctx);
        }
      }

      return this._canvas;
    },
    setCanvas: '#setImage',
    getContext: function getContext(_change) {
      if (!this._context) this._context = this.getCanvas().getContext('2d');

      if (_change) {
        this._image = null;

        this._changed(1025);
      }

      return this._context;
    },
    setContext: function setContext(context) {
      this._context = context;
    },
    getSource: function getSource() {
      var image = this._image;
      return image && image.src || this.toDataURL();
    },
    setSource: function setSource(src) {
      var image = new self.Image(),
          crossOrigin = this._crossOrigin;
      if (crossOrigin) image.crossOrigin = crossOrigin;
      if (src) image.src = src;
      this.setImage(image);
    },
    getCrossOrigin: function getCrossOrigin() {
      var image = this._image;
      return image && image.crossOrigin || this._crossOrigin || '';
    },
    setCrossOrigin: function setCrossOrigin(crossOrigin) {
      this._crossOrigin = crossOrigin;
      var image = this._image;
      if (image) image.crossOrigin = crossOrigin;
    },
    getSmoothing: function getSmoothing() {
      return this._smoothing;
    },
    setSmoothing: function setSmoothing(smoothing) {
      this._smoothing = smoothing;

      this._changed(257);
    },
    getElement: function getElement() {
      return this._canvas || this._loaded && this._image;
    }
  }, {
    beans: false,
    getSubCanvas: function getSubCanvas() {
      var rect = _Rectangle.read(arguments),
          ctx = CanvasProvider.getContext(rect.getSize());

      ctx.drawImage(this.getCanvas(), rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
      return ctx.canvas;
    },
    getSubRaster: function getSubRaster() {
      var rect = _Rectangle.read(arguments),
          raster = new Raster(Item.NO_INSERT);

      raster._setImage(this.getSubCanvas(rect));

      raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));

      raster._matrix.prepend(this._matrix);

      raster.insertAbove(this);
      return raster;
    },
    toDataURL: function toDataURL() {
      var image = this._image,
          src = image && image.src;
      if (/^data:/.test(src)) return src;
      var canvas = this.getCanvas();
      return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
    },
    drawImage: function drawImage(image) {
      var point = Point.read(arguments, 1);
      this.getContext(true).drawImage(image, point.x, point.y);
    },
    getAverageColor: function getAverageColor(object) {
      var bounds, path;

      if (!object) {
        bounds = this.getBounds();
      } else if (object instanceof PathItem) {
        path = object;
        bounds = object.getBounds();
      } else if (_typeof(object) === 'object') {
        if ('width' in object) {
          bounds = new _Rectangle(object);
        } else if ('x' in object) {
          bounds = new _Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
        }
      }

      if (!bounds) return null;
      var sampleSize = 32,
          width = Math.min(bounds.width, sampleSize),
          height = Math.min(bounds.height, sampleSize);
      var ctx = Raster._sampleContext;

      if (!ctx) {
        ctx = Raster._sampleContext = CanvasProvider.getContext(new Size(sampleSize));
      } else {
        ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
      }

      ctx.save();
      var matrix = new Matrix().scale(width / bounds.width, height / bounds.height).translate(-bounds.x, -bounds.y);
      matrix.applyToContext(ctx);
      if (path) path.draw(ctx, new Base({
        clip: true,
        matrices: [matrix]
      }));

      this._matrix.applyToContext(ctx);

      var element = this.getElement(),
          size = this._size;
      if (element) ctx.drawImage(element, -size.width / 2, -size.height / 2);
      ctx.restore();
      var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width), Math.ceil(height)).data,
          channels = [0, 0, 0],
          total = 0;

      for (var i = 0, l = pixels.length; i < l; i += 4) {
        var alpha = pixels[i + 3];
        total += alpha;
        alpha /= 255;
        channels[0] += pixels[i] * alpha;
        channels[1] += pixels[i + 1] * alpha;
        channels[2] += pixels[i + 2] * alpha;
      }

      for (var i = 0; i < 3; i++) {
        channels[i] /= total;
      }

      return total ? Color.read(channels) : null;
    },
    getPixel: function getPixel() {
      var point = Point.read(arguments);
      var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
      return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255], data[3] / 255);
    },
    setPixel: function setPixel() {
      var args = arguments,
          point = Point.read(args),
          color = Color.read(args),
          components = color._convert('rgb'),
          alpha = color._alpha,
          ctx = this.getContext(true),
          imageData = ctx.createImageData(1, 1),
          data = imageData.data;

      data[0] = components[0] * 255;
      data[1] = components[1] * 255;
      data[2] = components[2] * 255;
      data[3] = alpha != null ? alpha * 255 : 255;
      ctx.putImageData(imageData, point.x, point.y);
    },
    clear: function clear() {
      var size = this._size;
      this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
    },
    createImageData: function createImageData() {
      var size = Size.read(arguments);
      return this.getContext().createImageData(size.width, size.height);
    },
    getImageData: function getImageData() {
      var rect = _Rectangle.read(arguments);

      if (rect.isEmpty()) rect = new _Rectangle(this._size);
      return this.getContext().getImageData(rect.x, rect.y, rect.width, rect.height);
    },
    setImageData: function setImageData(data) {
      var point = Point.read(arguments, 1);
      this.getContext(true).putImageData(data, point.x, point.y);
    },
    _getBounds: function _getBounds(matrix, options) {
      var rect = new _Rectangle(this._size).setCenter(0, 0);
      return matrix ? matrix._transformBounds(rect) : rect;
    },
    _hitTestSelf: function _hitTestSelf(point) {
      if (this._contains(point)) {
        var that = this;
        return new HitResult('pixel', that, {
          offset: point.add(that._size.divide(2)).round(),
          color: {
            get: function get() {
              return that.getPixel(this.offset);
            }
          }
        });
      }
    },
    _draw: function _draw(ctx, param, viewMatrix) {
      var element = this.getElement();

      if (element && element.width > 0 && element.height > 0) {
        ctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);

        this._setStyles(ctx, param, viewMatrix);

        DomElement.setPrefixed(ctx, 'imageSmoothingEnabled', this._smoothing);
        ctx.drawImage(element, -this._size.width / 2, -this._size.height / 2);
      }
    },
    _canComposite: function _canComposite() {
      return true;
    }
  });
  var SymbolItem = Item.extend({
    _class: 'SymbolItem',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsOptions: {
      stroke: true
    },
    _serializeFields: {
      symbol: null
    },
    initialize: function SymbolItem(arg0, arg1) {
      if (!this._initialize(arg0, arg1 !== undefined && Point.read(arguments, 1))) this.setDefinition(arg0 instanceof SymbolDefinition ? arg0 : new SymbolDefinition(arg0));
    },
    _equals: function _equals(item) {
      return this._definition === item._definition;
    },
    copyContent: function copyContent(source) {
      this.setDefinition(source._definition);
    },
    getDefinition: function getDefinition() {
      return this._definition;
    },
    setDefinition: function setDefinition(definition) {
      this._definition = definition;

      this._changed(9);
    },
    getSymbol: '#getDefinition',
    setSymbol: '#setDefinition',
    isEmpty: function isEmpty() {
      return this._definition._item.isEmpty();
    },
    _getBounds: function _getBounds(matrix, options) {
      var item = this._definition._item;
      return item._getCachedBounds(item._matrix.prepended(matrix), options);
    },
    _hitTestSelf: function _hitTestSelf(point, options, viewMatrix) {
      var opts = options.extend({
        all: false
      });

      var res = this._definition._item._hitTest(point, opts, viewMatrix);

      if (res) res.item = this;
      return res;
    },
    _draw: function _draw(ctx, param) {
      this._definition._item.draw(ctx, param);
    }
  });
  var SymbolDefinition = Base.extend({
    _class: 'SymbolDefinition',
    initialize: function SymbolDefinition(item, dontCenter) {
      this._id = UID.get();
      this.project = paper.project;
      if (item) this.setItem(item, dontCenter);
    },
    _serialize: function _serialize(options, dictionary) {
      return dictionary.add(this, function () {
        return Base.serialize([this._class, this._item], options, false, dictionary);
      });
    },
    _changed: function _changed(flags) {
      if (flags & 8) Item._clearBoundsCache(this);
      if (flags & 1) this.project._changed(flags);
    },
    getItem: function getItem() {
      return this._item;
    },
    setItem: function setItem(item, _dontCenter) {
      if (item._symbol) item = item.clone();
      if (this._item) this._item._symbol = null;
      this._item = item;
      item.remove();
      item.setSelected(false);
      if (!_dontCenter) item.setPosition(new Point());
      item._symbol = this;

      this._changed(9);
    },
    getDefinition: '#getItem',
    setDefinition: '#setItem',
    place: function place(position) {
      return new SymbolItem(this, position);
    },
    clone: function clone() {
      return new SymbolDefinition(this._item.clone(false));
    },
    equals: function equals(symbol) {
      return symbol === this || symbol && this._item.equals(symbol._item) || false;
    }
  });
  var HitResult = Base.extend({
    _class: 'HitResult',
    initialize: function HitResult(type, item, values) {
      this.type = type;
      this.item = item;
      if (values) this.inject(values);
    },
    statics: {
      getOptions: function getOptions(args) {
        var options = args && Base.read(args);
        return new Base({
          type: null,
          tolerance: paper.settings.hitTolerance,
          fill: !options,
          stroke: !options,
          segments: !options,
          handles: false,
          ends: false,
          position: false,
          center: false,
          bounds: false,
          guides: false,
          selected: false
        }, options);
      }
    }
  });
  var Segment = Base.extend({
    _class: 'Segment',
    beans: true,
    _selection: 0,
    initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
      var count = arguments.length,
          point,
          handleIn,
          handleOut,
          selection;

      if (count > 0) {
        if (arg0 == null || _typeof(arg0) === 'object') {
          if (count === 1 && arg0 && 'point' in arg0) {
            point = arg0.point;
            handleIn = arg0.handleIn;
            handleOut = arg0.handleOut;
            selection = arg0.selection;
          } else {
            point = arg0;
            handleIn = arg1;
            handleOut = arg2;
            selection = arg3;
          }
        } else {
          point = [arg0, arg1];
          handleIn = arg2 !== undefined ? [arg2, arg3] : null;
          handleOut = arg4 !== undefined ? [arg4, arg5] : null;
        }
      }

      new SegmentPoint(point, this, '_point');
      new SegmentPoint(handleIn, this, '_handleIn');
      new SegmentPoint(handleOut, this, '_handleOut');
      if (selection) this.setSelection(selection);
    },
    _serialize: function _serialize(options, dictionary) {
      var point = this._point,
          selection = this._selection,
          obj = selection || this.hasHandles() ? [point, this._handleIn, this._handleOut] : point;
      if (selection) obj.push(selection);
      return Base.serialize(obj, options, true, dictionary);
    },
    _changed: function _changed(point) {
      var path = this._path;
      if (!path) return;
      var curves = path._curves,
          index = this._index,
          curve;

      if (curves) {
        if ((!point || point === this._point || point === this._handleIn) && (curve = index > 0 ? curves[index - 1] : path._closed ? curves[curves.length - 1] : null)) curve._changed();
        if ((!point || point === this._point || point === this._handleOut) && (curve = curves[index])) curve._changed();
      }

      path._changed(41);
    },
    getPoint: function getPoint() {
      return this._point;
    },
    setPoint: function setPoint() {
      this._point.set(Point.read(arguments));
    },
    getHandleIn: function getHandleIn() {
      return this._handleIn;
    },
    setHandleIn: function setHandleIn() {
      this._handleIn.set(Point.read(arguments));
    },
    getHandleOut: function getHandleOut() {
      return this._handleOut;
    },
    setHandleOut: function setHandleOut() {
      this._handleOut.set(Point.read(arguments));
    },
    hasHandles: function hasHandles() {
      return !this._handleIn.isZero() || !this._handleOut.isZero();
    },
    isSmooth: function isSmooth() {
      var handleIn = this._handleIn,
          handleOut = this._handleOut;
      return !handleIn.isZero() && !handleOut.isZero() && handleIn.isCollinear(handleOut);
    },
    clearHandles: function clearHandles() {
      this._handleIn._set(0, 0);

      this._handleOut._set(0, 0);
    },
    getSelection: function getSelection() {
      return this._selection;
    },
    setSelection: function setSelection(selection) {
      var oldSelection = this._selection,
          path = this._path;
      this._selection = selection = selection || 0;

      if (path && selection !== oldSelection) {
        path._updateSelection(this, oldSelection, selection);

        path._changed(257);
      }
    },
    _changeSelection: function _changeSelection(flag, selected) {
      var selection = this._selection;
      this.setSelection(selected ? selection | flag : selection & ~flag);
    },
    isSelected: function isSelected() {
      return !!(this._selection & 7);
    },
    setSelected: function setSelected(selected) {
      this._changeSelection(7, selected);
    },
    getIndex: function getIndex() {
      return this._index !== undefined ? this._index : null;
    },
    getPath: function getPath() {
      return this._path || null;
    },
    getCurve: function getCurve() {
      var path = this._path,
          index = this._index;

      if (path) {
        if (index > 0 && !path._closed && index === path._segments.length - 1) index--;
        return path.getCurves()[index] || null;
      }

      return null;
    },
    getLocation: function getLocation() {
      var curve = this.getCurve();
      return curve ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1) : null;
    },
    getNext: function getNext() {
      var segments = this._path && this._path._segments;
      return segments && (segments[this._index + 1] || this._path._closed && segments[0]) || null;
    },
    smooth: function smooth(options, _first, _last) {
      var opts = options || {},
          type = opts.type,
          factor = opts.factor,
          prev = this.getPrevious(),
          next = this.getNext(),
          p0 = (prev || this)._point,
          p1 = this._point,
          p2 = (next || this)._point,
          d1 = p0.getDistance(p1),
          d2 = p1.getDistance(p2);

      if (!type || type === 'catmull-rom') {
        var a = factor === undefined ? 0.5 : factor,
            d1_a = Math.pow(d1, a),
            d1_2a = d1_a * d1_a,
            d2_a = Math.pow(d2, a),
            d2_2a = d2_a * d2_a;

        if (!_first && prev) {
          var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
              N = 3 * d2_a * (d2_a + d1_a);
          this.setHandleIn(N !== 0 ? new Point((d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x, (d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y) : new Point());
        }

        if (!_last && next) {
          var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
              N = 3 * d1_a * (d1_a + d2_a);
          this.setHandleOut(N !== 0 ? new Point((d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x, (d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y) : new Point());
        }
      } else if (type === 'geometric') {
        if (prev && next) {
          var vector = p0.subtract(p2),
              t = factor === undefined ? 0.4 : factor,
              k = t * d1 / (d1 + d2);
          if (!_first) this.setHandleIn(vector.multiply(k));
          if (!_last) this.setHandleOut(vector.multiply(k - t));
        }
      } else {
        throw new Error('Smoothing method \'' + type + '\' not supported.');
      }
    },
    getPrevious: function getPrevious() {
      var segments = this._path && this._path._segments;
      return segments && (segments[this._index - 1] || this._path._closed && segments[segments.length - 1]) || null;
    },
    isFirst: function isFirst() {
      return !this._index;
    },
    isLast: function isLast() {
      var path = this._path;
      return path && this._index === path._segments.length - 1 || false;
    },
    reverse: function reverse() {
      var handleIn = this._handleIn,
          handleOut = this._handleOut,
          tmp = handleIn.clone();
      handleIn.set(handleOut);
      handleOut.set(tmp);
    },
    reversed: function reversed() {
      return new Segment(this._point, this._handleOut, this._handleIn);
    },
    remove: function remove() {
      return this._path ? !!this._path.removeSegment(this._index) : false;
    },
    clone: function clone() {
      return new Segment(this._point, this._handleIn, this._handleOut);
    },
    equals: function equals(segment) {
      return segment === this || segment && this._class === segment._class && this._point.equals(segment._point) && this._handleIn.equals(segment._handleIn) && this._handleOut.equals(segment._handleOut) || false;
    },
    toString: function toString() {
      var parts = ['point: ' + this._point];
      if (!this._handleIn.isZero()) parts.push('handleIn: ' + this._handleIn);
      if (!this._handleOut.isZero()) parts.push('handleOut: ' + this._handleOut);
      return '{ ' + parts.join(', ') + ' }';
    },
    transform: function transform(matrix) {
      this._transformCoordinates(matrix, new Array(6), true);

      this._changed();
    },
    interpolate: function interpolate(from, to, factor) {
      var u = 1 - factor,
          v = factor,
          point1 = from._point,
          point2 = to._point,
          handleIn1 = from._handleIn,
          handleIn2 = to._handleIn,
          handleOut2 = to._handleOut,
          handleOut1 = from._handleOut;

      this._point._set(u * point1._x + v * point2._x, u * point1._y + v * point2._y, true);

      this._handleIn._set(u * handleIn1._x + v * handleIn2._x, u * handleIn1._y + v * handleIn2._y, true);

      this._handleOut._set(u * handleOut1._x + v * handleOut2._x, u * handleOut1._y + v * handleOut2._y, true);

      this._changed();
    },
    _transformCoordinates: function _transformCoordinates(matrix, coords, change) {
      var point = this._point,
          handleIn = !change || !this._handleIn.isZero() ? this._handleIn : null,
          handleOut = !change || !this._handleOut.isZero() ? this._handleOut : null,
          x = point._x,
          y = point._y,
          i = 2;
      coords[0] = x;
      coords[1] = y;

      if (handleIn) {
        coords[i++] = handleIn._x + x;
        coords[i++] = handleIn._y + y;
      }

      if (handleOut) {
        coords[i++] = handleOut._x + x;
        coords[i++] = handleOut._y + y;
      }

      if (matrix) {
        matrix._transformCoordinates(coords, coords, i / 2);

        x = coords[0];
        y = coords[1];

        if (change) {
          point._x = x;
          point._y = y;
          i = 2;

          if (handleIn) {
            handleIn._x = coords[i++] - x;
            handleIn._y = coords[i++] - y;
          }

          if (handleOut) {
            handleOut._x = coords[i++] - x;
            handleOut._y = coords[i++] - y;
          }
        } else {
          if (!handleIn) {
            coords[i++] = x;
            coords[i++] = y;
          }

          if (!handleOut) {
            coords[i++] = x;
            coords[i++] = y;
          }
        }
      }

      return coords;
    }
  });
  var SegmentPoint = Point.extend({
    initialize: function SegmentPoint(point, owner, key) {
      var x, y, selected;

      if (!point) {
        x = y = 0;
      } else if ((x = point[0]) !== undefined) {
        y = point[1];
      } else {
        var pt = point;

        if ((x = pt.x) === undefined) {
          pt = Point.read(arguments);
          x = pt.x;
        }

        y = pt.y;
        selected = pt.selected;
      }

      this._x = x;
      this._y = y;
      this._owner = owner;
      owner[key] = this;
      if (selected) this.setSelected(true);
    },
    _set: function _set(x, y) {
      this._x = x;
      this._y = y;

      this._owner._changed(this);

      return this;
    },
    getX: function getX() {
      return this._x;
    },
    setX: function setX(x) {
      this._x = x;

      this._owner._changed(this);
    },
    getY: function getY() {
      return this._y;
    },
    setY: function setY(y) {
      this._y = y;

      this._owner._changed(this);
    },
    isZero: function isZero() {
      var isZero = Numerical.isZero;
      return isZero(this._x) && isZero(this._y);
    },
    isSelected: function isSelected() {
      return !!(this._owner._selection & this._getSelection());
    },
    setSelected: function setSelected(selected) {
      this._owner._changeSelection(this._getSelection(), selected);
    },
    _getSelection: function _getSelection() {
      var owner = this._owner;
      return this === owner._point ? 1 : this === owner._handleIn ? 2 : this === owner._handleOut ? 4 : 0;
    }
  });
  var Curve = Base.extend({
    _class: 'Curve',
    beans: true,
    initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      var count = arguments.length,
          seg1,
          seg2,
          point1,
          point2,
          handle1,
          handle2;

      if (count === 3) {
        this._path = arg0;
        seg1 = arg1;
        seg2 = arg2;
      } else if (!count) {
        seg1 = new Segment();
        seg2 = new Segment();
      } else if (count === 1) {
        if ('segment1' in arg0) {
          seg1 = new Segment(arg0.segment1);
          seg2 = new Segment(arg0.segment2);
        } else if ('point1' in arg0) {
          point1 = arg0.point1;
          handle1 = arg0.handle1;
          handle2 = arg0.handle2;
          point2 = arg0.point2;
        } else if (Array.isArray(arg0)) {
          point1 = [arg0[0], arg0[1]];
          point2 = [arg0[6], arg0[7]];
          handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
          handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
        }
      } else if (count === 2) {
        seg1 = new Segment(arg0);
        seg2 = new Segment(arg1);
      } else if (count === 4) {
        point1 = arg0;
        handle1 = arg1;
        handle2 = arg2;
        point2 = arg3;
      } else if (count === 8) {
        point1 = [arg0, arg1];
        point2 = [arg6, arg7];
        handle1 = [arg2 - arg0, arg3 - arg1];
        handle2 = [arg4 - arg6, arg5 - arg7];
      }

      this._segment1 = seg1 || new Segment(point1, null, handle1);
      this._segment2 = seg2 || new Segment(point2, handle2, null);
    },
    _serialize: function _serialize(options, dictionary) {
      return Base.serialize(this.hasHandles() ? [this.getPoint1(), this.getHandle1(), this.getHandle2(), this.getPoint2()] : [this.getPoint1(), this.getPoint2()], options, true, dictionary);
    },
    _changed: function _changed() {
      this._length = this._bounds = undefined;
    },
    clone: function clone() {
      return new Curve(this._segment1, this._segment2);
    },
    toString: function toString() {
      var parts = ['point1: ' + this._segment1._point];
      if (!this._segment1._handleOut.isZero()) parts.push('handle1: ' + this._segment1._handleOut);
      if (!this._segment2._handleIn.isZero()) parts.push('handle2: ' + this._segment2._handleIn);
      parts.push('point2: ' + this._segment2._point);
      return '{ ' + parts.join(', ') + ' }';
    },
    classify: function classify() {
      return Curve.classify(this.getValues());
    },
    remove: function remove() {
      var removed = false;

      if (this._path) {
        var segment2 = this._segment2,
            handleOut = segment2._handleOut;
        removed = segment2.remove();
        if (removed) this._segment1._handleOut.set(handleOut);
      }

      return removed;
    },
    getPoint1: function getPoint1() {
      return this._segment1._point;
    },
    setPoint1: function setPoint1() {
      this._segment1._point.set(Point.read(arguments));
    },
    getPoint2: function getPoint2() {
      return this._segment2._point;
    },
    setPoint2: function setPoint2() {
      this._segment2._point.set(Point.read(arguments));
    },
    getHandle1: function getHandle1() {
      return this._segment1._handleOut;
    },
    setHandle1: function setHandle1() {
      this._segment1._handleOut.set(Point.read(arguments));
    },
    getHandle2: function getHandle2() {
      return this._segment2._handleIn;
    },
    setHandle2: function setHandle2() {
      this._segment2._handleIn.set(Point.read(arguments));
    },
    getSegment1: function getSegment1() {
      return this._segment1;
    },
    getSegment2: function getSegment2() {
      return this._segment2;
    },
    getPath: function getPath() {
      return this._path;
    },
    getIndex: function getIndex() {
      return this._segment1._index;
    },
    getNext: function getNext() {
      var curves = this._path && this._path._curves;
      return curves && (curves[this._segment1._index + 1] || this._path._closed && curves[0]) || null;
    },
    getPrevious: function getPrevious() {
      var curves = this._path && this._path._curves;
      return curves && (curves[this._segment1._index - 1] || this._path._closed && curves[curves.length - 1]) || null;
    },
    isFirst: function isFirst() {
      return !this._segment1._index;
    },
    isLast: function isLast() {
      var path = this._path;
      return path && this._segment1._index === path._curves.length - 1 || false;
    },
    isSelected: function isSelected() {
      return this.getPoint1().isSelected() && this.getHandle1().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
    },
    setSelected: function setSelected(selected) {
      this.getPoint1().setSelected(selected);
      this.getHandle1().setSelected(selected);
      this.getHandle2().setSelected(selected);
      this.getPoint2().setSelected(selected);
    },
    getValues: function getValues(matrix) {
      return Curve.getValues(this._segment1, this._segment2, matrix);
    },
    getPoints: function getPoints() {
      var coords = this.getValues(),
          points = [];

      for (var i = 0; i < 8; i += 2) {
        points.push(new Point(coords[i], coords[i + 1]));
      }

      return points;
    }
  }, {
    getLength: function getLength() {
      if (this._length == null) this._length = Curve.getLength(this.getValues(), 0, 1);
      return this._length;
    },
    getArea: function getArea() {
      return Curve.getArea(this.getValues());
    },
    getLine: function getLine() {
      return new Line(this._segment1._point, this._segment2._point);
    },
    getPart: function getPart(from, to) {
      return new Curve(Curve.getPart(this.getValues(), from, to));
    },
    getPartLength: function getPartLength(from, to) {
      return Curve.getLength(this.getValues(), from, to);
    },
    divideAt: function divideAt(location) {
      return this.divideAtTime(location && location.curve === this ? location.time : this.getTimeAt(location));
    },
    divideAtTime: function divideAtTime(time, _setHandles) {
      var tMin = 1e-8,
          tMax = 1 - tMin,
          res = null;

      if (time >= tMin && time <= tMax) {
        var parts = Curve.subdivide(this.getValues(), time),
            left = parts[0],
            right = parts[1],
            setHandles = _setHandles || this.hasHandles(),
            seg1 = this._segment1,
            seg2 = this._segment2,
            path = this._path;

        if (setHandles) {
          seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);

          seg2._handleIn._set(right[4] - right[6], right[5] - right[7]);
        }

        var x = left[6],
            y = left[7],
            segment = new Segment(new Point(x, y), setHandles && new Point(left[4] - x, left[5] - y), setHandles && new Point(right[2] - x, right[3] - y));

        if (path) {
          path.insert(seg1._index + 1, segment);
          res = this.getNext();
        } else {
          this._segment2 = segment;

          this._changed();

          res = new Curve(segment, seg2);
        }
      }

      return res;
    },
    splitAt: function splitAt(location) {
      var path = this._path;
      return path ? path.splitAt(location) : null;
    },
    splitAtTime: function splitAtTime(time) {
      return this.splitAt(this.getLocationAtTime(time));
    },
    divide: function divide(offset, isTime) {
      return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));
    },
    split: function split(offset, isTime) {
      return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));
    },
    reversed: function reversed() {
      return new Curve(this._segment2.reversed(), this._segment1.reversed());
    },
    clearHandles: function clearHandles() {
      this._segment1._handleOut._set(0, 0);

      this._segment2._handleIn._set(0, 0);
    },
    statics: {
      getValues: function getValues(segment1, segment2, matrix, straight) {
        var p1 = segment1._point,
            h1 = segment1._handleOut,
            h2 = segment2._handleIn,
            p2 = segment2._point,
            x1 = p1.x,
            y1 = p1.y,
            x2 = p2.x,
            y2 = p2.y,
            values = straight ? [x1, y1, x1, y1, x2, y2, x2, y2] : [x1, y1, x1 + h1._x, y1 + h1._y, x2 + h2._x, y2 + h2._y, x2, y2];
        if (matrix) matrix._transformCoordinates(values, values, 4);
        return values;
      },
      subdivide: function subdivide(v, t) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7];
        if (t === undefined) t = 0.5;
        var u = 1 - t,
            x4 = u * x0 + t * x1,
            y4 = u * y0 + t * y1,
            x5 = u * x1 + t * x2,
            y5 = u * y1 + t * y2,
            x6 = u * x2 + t * x3,
            y6 = u * y2 + t * y3,
            x7 = u * x4 + t * x5,
            y7 = u * y4 + t * y5,
            x8 = u * x5 + t * x6,
            y8 = u * y5 + t * y6,
            x9 = u * x7 + t * x8,
            y9 = u * y7 + t * y8;
        return [[x0, y0, x4, y4, x7, y7, x9, y9], [x9, y9, x8, y8, x6, y6, x3, y3]];
      },
      getMonoCurves: function getMonoCurves(v, dir) {
        var curves = [],
            io = dir ? 0 : 1,
            o0 = v[io + 0],
            o1 = v[io + 2],
            o2 = v[io + 4],
            o3 = v[io + 6];

        if (o0 >= o1 === o1 >= o2 && o1 >= o2 === o2 >= o3 || Curve.isStraight(v)) {
          curves.push(v);
        } else {
          var a = 3 * (o1 - o2) - o0 + o3,
              b = 2 * (o0 + o2) - 4 * o1,
              c = o1 - o0,
              tMin = 1e-8,
              tMax = 1 - tMin,
              roots = [],
              n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);

          if (!n) {
            curves.push(v);
          } else {
            roots.sort();
            var t = roots[0],
                parts = Curve.subdivide(v, t);
            curves.push(parts[0]);

            if (n > 1) {
              t = (roots[1] - t) / (1 - t);
              parts = Curve.subdivide(parts[1], t);
              curves.push(parts[0]);
            }

            curves.push(parts[1]);
          }
        }

        return curves;
      },
      solveCubic: function solveCubic(v, coord, val, roots, min, max) {
        var v0 = v[coord],
            v1 = v[coord + 2],
            v2 = v[coord + 4],
            v3 = v[coord + 6],
            res = 0;

        if (!(v0 < val && v3 < val && v1 < val && v2 < val || v0 > val && v3 > val && v1 > val && v2 > val)) {
          var c = 3 * (v1 - v0),
              b = 3 * (v2 - v1) - c,
              a = v3 - v0 - c - b;
          res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
        }

        return res;
      },
      getTimeOf: function getTimeOf(v, point) {
        var p0 = new Point(v[0], v[1]),
            p3 = new Point(v[6], v[7]),
            epsilon = 1e-12,
            geomEpsilon = 1e-7,
            t = point.isClose(p0, epsilon) ? 0 : point.isClose(p3, epsilon) ? 1 : null;

        if (t === null) {
          var coords = [point.x, point.y],
              roots = [];

          for (var c = 0; c < 2; c++) {
            var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);

            for (var i = 0; i < count; i++) {
              var u = roots[i];
              if (point.isClose(Curve.getPoint(v, u), geomEpsilon)) return u;
            }
          }
        }

        return point.isClose(p0, geomEpsilon) ? 0 : point.isClose(p3, geomEpsilon) ? 1 : null;
      },
      getNearestTime: function getNearestTime(v, point) {
        if (Curve.isStraight(v)) {
          var x0 = v[0],
              y0 = v[1],
              x3 = v[6],
              y3 = v[7],
              vx = x3 - x0,
              vy = y3 - y0,
              det = vx * vx + vy * vy;
          if (det === 0) return 0;
          var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
          return u < 1e-12 ? 0 : u > 0.999999999999 ? 1 : Curve.getTimeOf(v, new Point(x0 + u * vx, y0 + u * vy));
        }

        var count = 100,
            minDist = Infinity,
            minT = 0;

        function refine(t) {
          if (t >= 0 && t <= 1) {
            var dist = point.getDistance(Curve.getPoint(v, t), true);

            if (dist < minDist) {
              minDist = dist;
              minT = t;
              return true;
            }
          }
        }

        for (var i = 0; i <= count; i++) {
          refine(i / count);
        }

        var step = 1 / (count * 2);

        while (step > 1e-8) {
          if (!refine(minT - step) && !refine(minT + step)) step /= 2;
        }

        return minT;
      },
      getPart: function getPart(v, from, to) {
        var flip = from > to;

        if (flip) {
          var tmp = from;
          from = to;
          to = tmp;
        }

        if (from > 0) v = Curve.subdivide(v, from)[1];
        if (to < 1) v = Curve.subdivide(v, (to - from) / (1 - from))[0];
        return flip ? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]] : v;
      },
      isFlatEnough: function isFlatEnough(v, flatness) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7],
            ux = 3 * x1 - 2 * x0 - x3,
            uy = 3 * y1 - 2 * y0 - y3,
            vx = 3 * x2 - 2 * x3 - x0,
            vy = 3 * y2 - 2 * y3 - y0;
        return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) <= 16 * flatness * flatness;
      },
      getArea: function getArea(v) {
        var x0 = v[0],
            y0 = v[1],
            x1 = v[2],
            y1 = v[3],
            x2 = v[4],
            y2 = v[5],
            x3 = v[6],
            y3 = v[7];
        return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2) + y1 * (x0 - x2) - x1 * (y0 - y2) + y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
      },
      getBounds: function getBounds(v) {
        var min = v.slice(0, 2),
            max = min.slice(),
            roots = [0, 0];

        for (var i = 0; i < 2; i++) {
          Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6], i, 0, min, max, roots);
        }

        return new _Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      _addBounds: function _addBounds(v0, v1, v2, v3, coord, padding, min, max, roots) {
        function add(value, padding) {
          var left = value - padding,
              right = value + padding;
          if (left < min[coord]) min[coord] = left;
          if (right > max[coord]) max[coord] = right;
        }

        padding /= 2;
        var minPad = min[coord] + padding,
            maxPad = max[coord] - padding;

        if (v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad || v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
          if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
            add(v0, 0);
            add(v3, 0);
          } else {
            var a = 3 * (v1 - v2) - v0 + v3,
                b = 2 * (v0 + v2) - 4 * v1,
                c = v1 - v0,
                count = Numerical.solveQuadratic(a, b, c, roots),
                tMin = 1e-8,
                tMax = 1 - tMin;
            add(v3, 0);

            for (var i = 0; i < count; i++) {
              var t = roots[i],
                  u = 1 - t;
              if (tMin <= t && t <= tMax) add(u * u * u * v0 + 3 * u * u * t * v1 + 3 * u * t * t * v2 + t * t * t * v3, padding);
            }
          }
        }
      }
    }
  }, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds'], function (name) {
    this[name] = function () {
      if (!this._bounds) this._bounds = {};
      var bounds = this._bounds[name];

      if (!bounds) {
        bounds = this._bounds[name] = Path[name]([this._segment1, this._segment2], false, this._path);
      }

      return bounds.clone();
    };
  }, {}), Base.each({
    isStraight: function isStraight(p1, h1, h2, p2) {
      if (h1.isZero() && h2.isZero()) {
        return true;
      } else {
        var v = p2.subtract(p1);

        if (v.isZero()) {
          return false;
        } else if (v.isCollinear(h1) && v.isCollinear(h2)) {
          var l = new Line(p1, p2),
              epsilon = 1e-7;

          if (l.getDistance(p1.add(h1)) < epsilon && l.getDistance(p2.add(h2)) < epsilon) {
            var div = v.dot(v),
                s1 = v.dot(h1) / div,
                s2 = v.dot(h2) / div;
            return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
          }
        }
      }

      return false;
    },
    isLinear: function isLinear(p1, h1, h2, p2) {
      var third = p2.subtract(p1).divide(3);
      return h1.equals(third) && h2.negate().equals(third);
    }
  }, function (test, name) {
    this[name] = function (epsilon) {
      var seg1 = this._segment1,
          seg2 = this._segment2;
      return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point, epsilon);
    };

    this.statics[name] = function (v, epsilon) {
      var x0 = v[0],
          y0 = v[1],
          x3 = v[6],
          y3 = v[7];
      return test(new Point(x0, y0), new Point(v[2] - x0, v[3] - y0), new Point(v[4] - x3, v[5] - y3), new Point(x3, y3), epsilon);
    };
  }, {
    statics: {},
    hasHandles: function hasHandles() {
      return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero();
    },
    hasLength: function hasLength(epsilon) {
      return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (epsilon || 0);
    },
    isCollinear: function isCollinear(curve) {
      return curve && this.isStraight() && curve.isStraight() && this.getLine().isCollinear(curve.getLine());
    },
    isHorizontal: function isHorizontal() {
      return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y) < 1e-8;
    },
    isVertical: function isVertical() {
      return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x) < 1e-8;
    }
  }), {
    beans: false,
    getLocationAt: function getLocationAt(offset, _isTime) {
      return this.getLocationAtTime(_isTime ? offset : this.getTimeAt(offset));
    },
    getLocationAtTime: function getLocationAtTime(t) {
      return t != null && t >= 0 && t <= 1 ? new CurveLocation(this, t) : null;
    },
    getTimeAt: function getTimeAt(offset, start) {
      return Curve.getTimeAt(this.getValues(), offset, start);
    },
    getParameterAt: '#getTimeAt',
    getTimesWithTangent: function getTimesWithTangent() {
      var tangent = Point.read(arguments);
      return tangent.isZero() ? [] : Curve.getTimesWithTangent(this.getValues(), tangent);
    },
    getOffsetAtTime: function getOffsetAtTime(t) {
      return this.getPartLength(0, t);
    },
    getLocationOf: function getLocationOf() {
      return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
    },
    getOffsetOf: function getOffsetOf() {
      var loc = this.getLocationOf.apply(this, arguments);
      return loc ? loc.getOffset() : null;
    },
    getTimeOf: function getTimeOf() {
      return Curve.getTimeOf(this.getValues(), Point.read(arguments));
    },
    getParameterOf: '#getTimeOf',
    getNearestLocation: function getNearestLocation() {
      var point = Point.read(arguments),
          values = this.getValues(),
          t = Curve.getNearestTime(values, point),
          pt = Curve.getPoint(values, t);
      return new CurveLocation(this, t, pt, null, point.getDistance(pt));
    },
    getNearestPoint: function getNearestPoint() {
      var loc = this.getNearestLocation.apply(this, arguments);
      return loc ? loc.getPoint() : loc;
    }
  }, new function () {
    var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent', 'getWeightedNormal', 'getCurvature'];
    return Base.each(methods, function (name) {
      this[name + 'At'] = function (location, _isTime) {
        var values = this.getValues();
        return Curve[name](values, _isTime ? location : Curve.getTimeAt(values, location));
      };

      this[name + 'AtTime'] = function (time) {
        return Curve[name](this.getValues(), time);
      };
    }, {
      statics: {
        _evaluateMethods: methods
      }
    });
  }(), new function () {
    function getLengthIntegrand(v) {
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          ax = 9 * (x1 - x2) + 3 * (x3 - x0),
          bx = 6 * (x0 + x2) - 12 * x1,
          cx = 3 * (x1 - x0),
          ay = 9 * (y1 - y2) + 3 * (y3 - y0),
          by = 6 * (y0 + y2) - 12 * y1,
          cy = 3 * (y1 - y0);
      return function (t) {
        var dx = (ax * t + bx) * t + cx,
            dy = (ay * t + by) * t + cy;
        return Math.sqrt(dx * dx + dy * dy);
      };
    }

    function getIterations(a, b) {
      return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
    }

    function evaluate(v, t, type, normalized) {
      if (t == null || t < 0 || t > 1) return null;
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          isZero = Numerical.isZero;

      if (isZero(x1 - x0) && isZero(y1 - y0)) {
        x1 = x0;
        y1 = y0;
      }

      if (isZero(x2 - x3) && isZero(y2 - y3)) {
        x2 = x3;
        y2 = y3;
      }

      var cx = 3 * (x1 - x0),
          bx = 3 * (x2 - x1) - cx,
          ax = x3 - x0 - cx - bx,
          cy = 3 * (y1 - y0),
          by = 3 * (y2 - y1) - cy,
          ay = y3 - y0 - cy - by,
          x,
          y;

      if (type === 0) {
        x = t === 0 ? x0 : t === 1 ? x3 : ((ax * t + bx) * t + cx) * t + x0;
        y = t === 0 ? y0 : t === 1 ? y3 : ((ay * t + by) * t + cy) * t + y0;
      } else {
        var tMin = 1e-8,
            tMax = 1 - tMin;

        if (t < tMin) {
          x = cx;
          y = cy;
        } else if (t > tMax) {
          x = 3 * (x3 - x2);
          y = 3 * (y3 - y2);
        } else {
          x = (3 * ax * t + 2 * bx) * t + cx;
          y = (3 * ay * t + 2 * by) * t + cy;
        }

        if (normalized) {
          if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
            x = x2 - x1;
            y = y2 - y1;
          }

          var len = Math.sqrt(x * x + y * y);

          if (len) {
            x /= len;
            y /= len;
          }
        }

        if (type === 3) {
          var x2 = 6 * ax * t + 2 * bx,
              y2 = 6 * ay * t + 2 * by,
              d = Math.pow(x * x + y * y, 3 / 2);
          x = d !== 0 ? (x * y2 - y * x2) / d : 0;
          y = 0;
        }
      }

      return type === 2 ? new Point(y, -x) : new Point(x, y);
    }

    return {
      statics: {
        classify: function classify(v) {
          var x0 = v[0],
              y0 = v[1],
              x1 = v[2],
              y1 = v[3],
              x2 = v[4],
              y2 = v[5],
              x3 = v[6],
              y3 = v[7],
              a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
              a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
              a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
              d3 = 3 * a3,
              d2 = d3 - a2,
              d1 = d2 - a2 + a1,
              l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
              s = l !== 0 ? 1 / l : 0,
              isZero = Numerical.isZero,
              serpentine = 'serpentine';
          d1 *= s;
          d2 *= s;
          d3 *= s;

          function type(type, t1, t2) {
            var hasRoots = t1 !== undefined,
                t1Ok = hasRoots && t1 > 0 && t1 < 1,
                t2Ok = hasRoots && t2 > 0 && t2 < 1;

            if (hasRoots && (!(t1Ok || t2Ok) || type === 'loop' && !(t1Ok && t2Ok))) {
              type = 'arch';
              t1Ok = t2Ok = false;
            }

            return {
              type: type,
              roots: t1Ok || t2Ok ? t1Ok && t2Ok ? t1 < t2 ? [t1, t2] : [t2, t1] : [t1Ok ? t1 : t2] : null
            };
          }

          if (isZero(d1)) {
            return isZero(d2) ? type(isZero(d3) ? 'line' : 'quadratic') : type(serpentine, d3 / (3 * d2));
          }

          var d = 3 * d2 * d2 - 4 * d1 * d3;

          if (isZero(d)) {
            return type('cusp', d2 / (2 * d1));
          }

          var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
              f2 = 2 * d1;
          return type(d > 0 ? serpentine : 'loop', (d2 + f1) / f2, (d2 - f1) / f2);
        },
        getLength: function getLength(v, a, b, ds) {
          if (a === undefined) a = 0;
          if (b === undefined) b = 1;

          if (Curve.isStraight(v)) {
            var c = v;

            if (b < 1) {
              c = Curve.subdivide(c, b)[0];
              a /= b;
            }

            if (a > 0) {
              c = Curve.subdivide(c, a)[1];
            }

            var dx = c[6] - c[0],
                dy = c[7] - c[1];
            return Math.sqrt(dx * dx + dy * dy);
          }

          return Numerical.integrate(ds || getLengthIntegrand(v), a, b, getIterations(a, b));
        },
        getTimeAt: function getTimeAt(v, offset, start) {
          if (start === undefined) start = offset < 0 ? 1 : 0;
          if (offset === 0) return start;
          var abs = Math.abs,
              epsilon = 1e-12,
              forward = offset > 0,
              a = forward ? start : 0,
              b = forward ? 1 : start,
              ds = getLengthIntegrand(v),
              rangeLength = Curve.getLength(v, a, b, ds),
              diff = abs(offset) - rangeLength;

          if (abs(diff) < epsilon) {
            return forward ? b : a;
          } else if (diff > epsilon) {
            return null;
          }

          var guess = offset / rangeLength,
              length = 0;

          function f(t) {
            length += Numerical.integrate(ds, start, t, getIterations(start, t));
            start = t;
            return length - offset;
          }

          return Numerical.findRoot(f, ds, start + guess, a, b, 32, 1e-12);
        },
        getPoint: function getPoint(v, t) {
          return evaluate(v, t, 0, false);
        },
        getTangent: function getTangent(v, t) {
          return evaluate(v, t, 1, true);
        },
        getWeightedTangent: function getWeightedTangent(v, t) {
          return evaluate(v, t, 1, false);
        },
        getNormal: function getNormal(v, t) {
          return evaluate(v, t, 2, true);
        },
        getWeightedNormal: function getWeightedNormal(v, t) {
          return evaluate(v, t, 2, false);
        },
        getCurvature: function getCurvature(v, t) {
          return evaluate(v, t, 3, false).x;
        },
        getPeaks: function getPeaks(v) {
          var x0 = v[0],
              y0 = v[1],
              x1 = v[2],
              y1 = v[3],
              x2 = v[4],
              y2 = v[5],
              x3 = v[6],
              y3 = v[7],
              ax = -x0 + 3 * x1 - 3 * x2 + x3,
              bx = 3 * x0 - 6 * x1 + 3 * x2,
              cx = -3 * x0 + 3 * x1,
              ay = -y0 + 3 * y1 - 3 * y2 + y3,
              by = 3 * y0 - 6 * y1 + 3 * y2,
              cy = -3 * y0 + 3 * y1,
              tMin = 1e-8,
              tMax = 1 - tMin,
              roots = [];
          Numerical.solveCubic(9 * (ax * ax + ay * ay), 9 * (ax * bx + by * ay), 2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay), cx * bx + by * cy, roots, tMin, tMax);
          return roots.sort();
        }
      }
    };
  }(), new function () {
    function addLocation(locations, include, c1, t1, c2, t2, overlap) {
      var excludeStart = !overlap && c1.getPrevious() === c2,
          excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
          tMin = 1e-8,
          tMax = 1 - tMin;

      if (t1 !== null && t1 >= (excludeStart ? tMin : 0) && t1 <= (excludeEnd ? tMax : 1)) {
        if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) && t2 <= (excludeStart ? tMax : 1)) {
          var loc1 = new CurveLocation(c1, t1, null, overlap),
              loc2 = new CurveLocation(c2, t2, null, overlap);
          loc1._intersection = loc2;
          loc2._intersection = loc1;

          if (!include || include(loc1)) {
            CurveLocation.insert(locations, loc1, true);
          }
        }
      }
    }

    function addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMin, tMax, uMin, uMax) {
      if (++calls >= 4096 || ++recursion >= 40) return calls;
      var fatLineEpsilon = 1e-9,
          q0x = v2[0],
          q0y = v2[1],
          q3x = v2[6],
          q3y = v2[7],
          getSignedDistance = Line.getSignedDistance,
          d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
          d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
          factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
          dMin = factor * Math.min(0, d1, d2),
          dMax = factor * Math.max(0, d1, d2),
          dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
          dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
          dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
          dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
          hull = getConvexHull(dp0, dp1, dp2, dp3),
          top = hull[0],
          bottom = hull[1],
          tMinClip,
          tMaxClip;
      if (d1 === 0 && d2 === 0 && dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0 || (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null || (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(), dMin, dMax)) == null) return calls;
      var tMinNew = tMin + (tMax - tMin) * tMinClip,
          tMaxNew = tMin + (tMax - tMin) * tMaxClip;

      if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
        var t = (tMinNew + tMaxNew) / 2,
            u = (uMin + uMax) / 2;
        addLocation(locations, include, flip ? c2 : c1, flip ? u : t, flip ? c1 : c2, flip ? t : u);
      } else {
        v1 = Curve.getPart(v1, tMinClip, tMaxClip);
        var uDiff = uMax - uMin;

        if (tMaxClip - tMinClip > 0.8) {
          if (tMaxNew - tMinNew > uDiff) {
            var parts = Curve.subdivide(v1, 0.5),
                t = (tMinNew + tMaxNew) / 2;
            calls = addCurveIntersections(v2, parts[0], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, t);
            calls = addCurveIntersections(v2, parts[1], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, t, tMaxNew);
          } else {
            var parts = Curve.subdivide(v2, 0.5),
                u = (uMin + uMax) / 2;
            calls = addCurveIntersections(parts[0], v1, c2, c1, locations, include, !flip, recursion, calls, uMin, u, tMinNew, tMaxNew);
            calls = addCurveIntersections(parts[1], v1, c2, c1, locations, include, !flip, recursion, calls, u, uMax, tMinNew, tMaxNew);
          }
        } else {
          if (uDiff === 0 || uDiff >= fatLineEpsilon) {
            calls = addCurveIntersections(v2, v1, c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, tMaxNew);
          } else {
            calls = addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMinNew, tMaxNew, uMin, uMax);
          }
        }
      }

      return calls;
    }

    function getConvexHull(dq0, dq1, dq2, dq3) {
      var p0 = [0, dq0],
          p1 = [1 / 3, dq1],
          p2 = [2 / 3, dq2],
          p3 = [1, dq3],
          dist1 = dq1 - (2 * dq0 + dq3) / 3,
          dist2 = dq2 - (dq0 + 2 * dq3) / 3,
          hull;

      if (dist1 * dist2 < 0) {
        hull = [[p0, p1, p3], [p0, p2, p3]];
      } else {
        var distRatio = dist1 / dist2;
        hull = [distRatio >= 2 ? [p0, p1, p3] : distRatio <= 0.5 ? [p0, p2, p3] : [p0, p1, p2, p3], [p0, p3]];
      }

      return (dist1 || dist2) < 0 ? hull.reverse() : hull;
    }

    function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
      if (hullTop[0][1] < dMin) {
        return clipConvexHullPart(hullTop, true, dMin);
      } else if (hullBottom[0][1] > dMax) {
        return clipConvexHullPart(hullBottom, false, dMax);
      } else {
        return hullTop[0][0];
      }
    }

    function clipConvexHullPart(part, top, threshold) {
      var px = part[0][0],
          py = part[0][1];

      for (var i = 1, l = part.length; i < l; i++) {
        var qx = part[i][0],
            qy = part[i][1];

        if (top ? qy >= threshold : qy <= threshold) {
          return qy === threshold ? qx : px + (threshold - py) * (qx - px) / (qy - py);
        }

        px = qx;
        py = qy;
      }

      return null;
    }

    function getCurveLineIntersections(v, px, py, vx, vy) {
      var isZero = Numerical.isZero;

      if (isZero(vx) && isZero(vy)) {
        var t = Curve.getTimeOf(v, new Point(px, py));
        return t === null ? [] : [t];
      }

      var angle = Math.atan2(-vy, vx),
          sin = Math.sin(angle),
          cos = Math.cos(angle),
          rv = [],
          roots = [];

      for (var i = 0; i < 8; i += 2) {
        var x = v[i] - px,
            y = v[i + 1] - py;
        rv.push(x * cos - y * sin, x * sin + y * cos);
      }

      Curve.solveCubic(rv, 1, 0, roots, 0, 1);
      return roots;
    }

    function addCurveLineIntersections(v1, v2, c1, c2, locations, include, flip) {
      var x1 = v2[0],
          y1 = v2[1],
          x2 = v2[6],
          y2 = v2[7],
          roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);

      for (var i = 0, l = roots.length; i < l; i++) {
        var t1 = roots[i],
            p1 = Curve.getPoint(v1, t1),
            t2 = Curve.getTimeOf(v2, p1);

        if (t2 !== null) {
          addLocation(locations, include, flip ? c2 : c1, flip ? t2 : t1, flip ? c1 : c2, flip ? t1 : t2);
        }
      }
    }

    function addLineIntersection(v1, v2, c1, c2, locations, include) {
      var pt = Line.intersect(v1[0], v1[1], v1[6], v1[7], v2[0], v2[1], v2[6], v2[7]);

      if (pt) {
        addLocation(locations, include, c1, Curve.getTimeOf(v1, pt), c2, Curve.getTimeOf(v2, pt));
      }
    }

    function getCurveIntersections(v1, v2, c1, c2, locations, include) {
      var epsilon = 1e-12,
          min = Math.min,
          max = Math.max;

      if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon > min(v2[0], v2[2], v2[4], v2[6]) && min(v1[0], v1[2], v1[4], v1[6]) - epsilon < max(v2[0], v2[2], v2[4], v2[6]) && max(v1[1], v1[3], v1[5], v1[7]) + epsilon > min(v2[1], v2[3], v2[5], v2[7]) && min(v1[1], v1[3], v1[5], v1[7]) - epsilon < max(v2[1], v2[3], v2[5], v2[7])) {
        var overlaps = getOverlaps(v1, v2);

        if (overlaps) {
          for (var i = 0; i < 2; i++) {
            var overlap = overlaps[i];
            addLocation(locations, include, c1, overlap[0], c2, overlap[1], true);
          }
        } else {
          var straight1 = Curve.isStraight(v1),
              straight2 = Curve.isStraight(v2),
              straight = straight1 && straight2,
              flip = straight1 && !straight2,
              before = locations.length;
          (straight ? addLineIntersection : straight1 || straight2 ? addCurveLineIntersections : addCurveIntersections)(flip ? v2 : v1, flip ? v1 : v2, flip ? c2 : c1, flip ? c1 : c2, locations, include, flip, 0, 0, 0, 1, 0, 1);

          if (!straight || locations.length === before) {
            for (var i = 0; i < 4; i++) {
              var t1 = i >> 1,
                  t2 = i & 1,
                  i1 = t1 * 6,
                  i2 = t2 * 6,
                  p1 = new Point(v1[i1], v1[i1 + 1]),
                  p2 = new Point(v2[i2], v2[i2 + 1]);

              if (p1.isClose(p2, epsilon)) {
                addLocation(locations, include, c1, t1, c2, t2);
              }
            }
          }
        }
      }

      return locations;
    }

    function getSelfIntersection(v1, c1, locations, include) {
      var info = Curve.classify(v1);

      if (info.type === 'loop') {
        var roots = info.roots;
        addLocation(locations, include, c1, roots[0], c1, roots[1]);
      }

      return locations;
    }

    function getIntersections(curves1, curves2, include, matrix1, matrix2, _returnFirst) {
      var epsilon = 1e-7,
          self = !curves2;
      if (self) curves2 = curves1;
      var length1 = curves1.length,
          length2 = curves2.length,
          values1 = new Array(length1),
          values2 = self ? values1 : new Array(length2),
          locations = [];

      for (var i = 0; i < length1; i++) {
        values1[i] = curves1[i].getValues(matrix1);
      }

      if (!self) {
        for (var i = 0; i < length2; i++) {
          values2[i] = curves2[i].getValues(matrix2);
        }
      }

      var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(values1, values2, epsilon);

      for (var index1 = 0; index1 < length1; index1++) {
        var curve1 = curves1[index1],
            v1 = values1[index1];

        if (self) {
          getSelfIntersection(v1, curve1, locations, include);
        }

        var collisions1 = boundsCollisions[index1];

        if (collisions1) {
          for (var j = 0; j < collisions1.length; j++) {
            if (_returnFirst && locations.length) return locations;
            var index2 = collisions1[j];

            if (!self || index2 > index1) {
              var curve2 = curves2[index2],
                  v2 = values2[index2];
              getCurveIntersections(v1, v2, curve1, curve2, locations, include);
            }
          }
        }
      }

      return locations;
    }

    function getOverlaps(v1, v2) {
      function getSquaredLineLength(v) {
        var x = v[6] - v[0],
            y = v[7] - v[1];
        return x * x + y * y;
      }

      var abs = Math.abs,
          getDistance = Line.getDistance,
          timeEpsilon = 1e-8,
          geomEpsilon = 1e-7,
          straight1 = Curve.isStraight(v1),
          straight2 = Curve.isStraight(v2),
          straightBoth = straight1 && straight2,
          flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
          l1 = flip ? v2 : v1,
          l2 = flip ? v1 : v2,
          px = l1[0],
          py = l1[1],
          vx = l1[6] - px,
          vy = l1[7] - py;

      if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
        if (!straightBoth && getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
          straight1 = straight2 = straightBoth = true;
        }
      } else if (straightBoth) {
        return null;
      }

      if (straight1 ^ straight2) {
        return null;
      }

      var v = [v1, v2],
          pairs = [];

      for (var i = 0; i < 4 && pairs.length < 2; i++) {
        var i1 = i & 1,
            i2 = i1 ^ 1,
            t1 = i >> 1,
            t2 = Curve.getTimeOf(v[i1], new Point(v[i2][t1 ? 6 : 0], v[i2][t1 ? 7 : 1]));

        if (t2 != null) {
          var pair = i1 ? [t1, t2] : [t2, t1];

          if (!pairs.length || abs(pair[0] - pairs[0][0]) > timeEpsilon && abs(pair[1] - pairs[0][1]) > timeEpsilon) {
            pairs.push(pair);
          }
        }

        if (i > 2 && !pairs.length) break;
      }

      if (pairs.length !== 2) {
        pairs = null;
      } else if (!straightBoth) {
        var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
            o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
        if (abs(o2[2] - o1[2]) > geomEpsilon || abs(o2[3] - o1[3]) > geomEpsilon || abs(o2[4] - o1[4]) > geomEpsilon || abs(o2[5] - o1[5]) > geomEpsilon) pairs = null;
      }

      return pairs;
    }

    function getTimesWithTangent(v, tangent) {
      var x0 = v[0],
          y0 = v[1],
          x1 = v[2],
          y1 = v[3],
          x2 = v[4],
          y2 = v[5],
          x3 = v[6],
          y3 = v[7],
          normalized = tangent.normalize(),
          tx = normalized.x,
          ty = normalized.y,
          ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,
          ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,
          bx = 6 * x2 - 12 * x1 + 6 * x0,
          by = 6 * y2 - 12 * y1 + 6 * y0,
          cx = 3 * x1 - 3 * x0,
          cy = 3 * y1 - 3 * y0,
          den = 2 * ax * ty - 2 * ay * tx,
          times = [];

      if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
        var num = ax * cy - ay * cx,
            den = ax * by - ay * bx;

        if (den != 0) {
          var t = -num / den;
          if (t >= 0 && t <= 1) times.push(t);
        }
      } else {
        var delta = (bx * bx - 4 * ax * cx) * ty * ty + (-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty + (by * by - 4 * ay * cy) * tx * tx,
            k = bx * ty - by * tx;

        if (delta >= 0 && den != 0) {
          var d = Math.sqrt(delta),
              t0 = -(k + d) / den,
              t1 = (-k + d) / den;
          if (t0 >= 0 && t0 <= 1) times.push(t0);
          if (t1 >= 0 && t1 <= 1) times.push(t1);
        }
      }

      return times;
    }

    return {
      getIntersections: function getIntersections(curve) {
        var v1 = this.getValues(),
            v2 = curve && curve !== this && curve.getValues();
        return v2 ? getCurveIntersections(v1, v2, this, curve, []) : getSelfIntersection(v1, this, []);
      },
      statics: {
        getOverlaps: getOverlaps,
        getIntersections: getIntersections,
        getCurveLineIntersections: getCurveLineIntersections,
        getTimesWithTangent: getTimesWithTangent
      }
    };
  }());
  var CurveLocation = Base.extend({
    _class: 'CurveLocation',
    initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
      if (time >= 0.99999999) {
        var next = curve.getNext();

        if (next) {
          time = 0;
          curve = next;
        }
      }

      this._setCurve(curve);

      this._time = time;
      this._point = point || curve.getPointAtTime(time);
      this._overlap = _overlap;
      this._distance = _distance;
      this._intersection = this._next = this._previous = null;
    },
    _setPath: function _setPath(path) {
      this._path = path;
      this._version = path ? path._version : 0;
    },
    _setCurve: function _setCurve(curve) {
      this._setPath(curve._path);

      this._curve = curve;
      this._segment = null;
      this._segment1 = curve._segment1;
      this._segment2 = curve._segment2;
    },
    _setSegment: function _setSegment(segment) {
      var curve = segment.getCurve();

      if (curve) {
        this._setCurve(curve);
      } else {
        this._setPath(segment._path);

        this._segment1 = segment;
        this._segment2 = null;
      }

      this._segment = segment;
      this._time = segment === this._segment1 ? 0 : 1;
      this._point = segment._point.clone();
    },
    getSegment: function getSegment() {
      var segment = this._segment;

      if (!segment) {
        var curve = this.getCurve(),
            time = this.getTime();

        if (time === 0) {
          segment = curve._segment1;
        } else if (time === 1) {
          segment = curve._segment2;
        } else if (time != null) {
          segment = curve.getPartLength(0, time) < curve.getPartLength(time, 1) ? curve._segment1 : curve._segment2;
        }

        this._segment = segment;
      }

      return segment;
    },
    getCurve: function getCurve() {
      var path = this._path,
          that = this;

      if (path && path._version !== this._version) {
        this._time = this._offset = this._curveOffset = this._curve = null;
      }

      function trySegment(segment) {
        var curve = segment && segment.getCurve();

        if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
          that._setCurve(curve);

          return curve;
        }
      }

      return this._curve || trySegment(this._segment) || trySegment(this._segment1) || trySegment(this._segment2.getPrevious());
    },
    getPath: function getPath() {
      var curve = this.getCurve();
      return curve && curve._path;
    },
    getIndex: function getIndex() {
      var curve = this.getCurve();
      return curve && curve.getIndex();
    },
    getTime: function getTime() {
      var curve = this.getCurve(),
          time = this._time;
      return curve && time == null ? this._time = curve.getTimeOf(this._point) : time;
    },
    getParameter: '#getTime',
    getPoint: function getPoint() {
      return this._point;
    },
    getOffset: function getOffset() {
      var offset = this._offset;

      if (offset == null) {
        offset = 0;
        var path = this.getPath(),
            index = this.getIndex();

        if (path && index != null) {
          var curves = path.getCurves();

          for (var i = 0; i < index; i++) {
            offset += curves[i].getLength();
          }
        }

        this._offset = offset += this.getCurveOffset();
      }

      return offset;
    },
    getCurveOffset: function getCurveOffset() {
      var offset = this._curveOffset;

      if (offset == null) {
        var curve = this.getCurve(),
            time = this.getTime();
        this._curveOffset = offset = time != null && curve && curve.getPartLength(0, time);
      }

      return offset;
    },
    getIntersection: function getIntersection() {
      return this._intersection;
    },
    getDistance: function getDistance() {
      return this._distance;
    },
    divide: function divide() {
      var curve = this.getCurve(),
          res = curve && curve.divideAtTime(this.getTime());

      if (res) {
        this._setSegment(res._segment1);
      }

      return res;
    },
    split: function split() {
      var curve = this.getCurve(),
          path = curve._path,
          res = curve && curve.splitAtTime(this.getTime());

      if (res) {
        this._setSegment(path.getLastSegment());
      }

      return res;
    },
    equals: function equals(loc, _ignoreOther) {
      var res = this === loc;

      if (!res && loc instanceof CurveLocation) {
        var c1 = this.getCurve(),
            c2 = loc.getCurve(),
            p1 = c1._path,
            p2 = c2._path;

        if (p1 === p2) {
          var abs = Math.abs,
              epsilon = 1e-7,
              diff = abs(this.getOffset() - loc.getOffset()),
              i1 = !_ignoreOther && this._intersection,
              i2 = !_ignoreOther && loc._intersection;
          res = (diff < epsilon || p1 && abs(p1.getLength() - diff) < epsilon) && (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
        }
      }

      return res;
    },
    toString: function toString() {
      var parts = [],
          point = this.getPoint(),
          f = Formatter.instance;
      if (point) parts.push('point: ' + point);
      var index = this.getIndex();
      if (index != null) parts.push('index: ' + index);
      var time = this.getTime();
      if (time != null) parts.push('time: ' + f.number(time));
      if (this._distance != null) parts.push('distance: ' + f.number(this._distance));
      return '{ ' + parts.join(', ') + ' }';
    },
    isTouching: function isTouching() {
      var inter = this._intersection;

      if (inter && this.getTangent().isCollinear(inter.getTangent())) {
        var curve1 = this.getCurve(),
            curve2 = inter.getCurve();
        return !(curve1.isStraight() && curve2.isStraight() && curve1.getLine().intersect(curve2.getLine()));
      }

      return false;
    },
    isCrossing: function isCrossing() {
      var inter = this._intersection;
      if (!inter) return false;
      var t1 = this.getTime(),
          t2 = inter.getTime(),
          tMin = 1e-8,
          tMax = 1 - tMin,
          t1Inside = t1 >= tMin && t1 <= tMax,
          t2Inside = t2 >= tMin && t2 <= tMax;
      if (t1Inside && t2Inside) return !this.isTouching();
      var c2 = this.getCurve(),
          c1 = c2 && t1 < tMin ? c2.getPrevious() : c2,
          c4 = inter.getCurve(),
          c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;
      if (t1 > tMax) c2 = c2.getNext();
      if (t2 > tMax) c4 = c4.getNext();
      if (!c1 || !c2 || !c3 || !c4) return false;
      var offsets = [];

      function addOffsets(curve, end) {
        var v = curve.getValues(),
            roots = Curve.classify(v).roots || Curve.getPeaks(v),
            count = roots.length,
            offset = Curve.getLength(v, end && count ? roots[count - 1] : 0, !end && count ? roots[0] : 1);
        offsets.push(count ? offset : offset / 32);
      }

      function isInRange(angle, min, max) {
        return min < max ? angle > min && angle < max : angle > min || angle < max;
      }

      if (!t1Inside) {
        addOffsets(c1, true);
        addOffsets(c2, false);
      }

      if (!t2Inside) {
        addOffsets(c3, true);
        addOffsets(c4, false);
      }

      var pt = this.getPoint(),
          offset = Math.min.apply(Math, offsets),
          v2 = t1Inside ? c2.getTangentAtTime(t1) : c2.getPointAt(offset).subtract(pt),
          v1 = t1Inside ? v2.negate() : c1.getPointAt(-offset).subtract(pt),
          v4 = t2Inside ? c4.getTangentAtTime(t2) : c4.getPointAt(offset).subtract(pt),
          v3 = t2Inside ? v4.negate() : c3.getPointAt(-offset).subtract(pt),
          a1 = v1.getAngle(),
          a2 = v2.getAngle(),
          a3 = v3.getAngle(),
          a4 = v4.getAngle();
      return !!(t1Inside ? isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4) && isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3) : isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2) && isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));
    },
    hasOverlap: function hasOverlap() {
      return !!this._overlap;
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    var get = name + 'At';

    this[name] = function () {
      var curve = this.getCurve(),
          time = this.getTime();
      return time != null && curve && curve[get](time, true);
    };
  }, {
    preserve: true
  }), new function () {
    function insert(locations, loc, merge) {
      var length = locations.length,
          l = 0,
          r = length - 1;

      function search(index, dir) {
        for (var i = index + dir; i >= -1 && i <= length; i += dir) {
          var loc2 = locations[(i % length + length) % length];
          if (!loc.getPoint().isClose(loc2.getPoint(), 1e-7)) break;
          if (loc.equals(loc2)) return loc2;
        }

        return null;
      }

      while (l <= r) {
        var m = l + r >>> 1,
            loc2 = locations[m],
            found;

        if (merge && (found = loc.equals(loc2) ? loc2 : search(m, -1) || search(m, 1))) {
          if (loc._overlap) {
            found._overlap = found._intersection._overlap = true;
          }

          return found;
        }

        var path1 = loc.getPath(),
            path2 = loc2.getPath(),
            diff = path1 !== path2 ? path1._id - path2._id : loc.getIndex() + loc.getTime() - (loc2.getIndex() + loc2.getTime());

        if (diff < 0) {
          r = m - 1;
        } else {
          l = m + 1;
        }
      }

      locations.splice(l, 0, loc);
      return loc;
    }

    return {
      statics: {
        insert: insert,
        expand: function expand(locations) {
          var expanded = locations.slice();

          for (var i = locations.length - 1; i >= 0; i--) {
            insert(expanded, locations[i]._intersection, false);
          }

          return expanded;
        }
      }
    };
  }());
  var PathItem = Item.extend({
    _class: 'PathItem',
    _selectBounds: false,
    _canScaleStroke: true,
    beans: true,
    initialize: function PathItem() {},
    statics: {
      create: function create(arg) {
        var data, segments, compound;

        if (Base.isPlainObject(arg)) {
          segments = arg.segments;
          data = arg.pathData;
        } else if (Array.isArray(arg)) {
          segments = arg;
        } else if (typeof arg === 'string') {
          data = arg;
        }

        if (segments) {
          var first = segments[0];
          compound = first && Array.isArray(first[0]);
        } else if (data) {
          compound = (data.match(/m/gi) || []).length > 1 || /z\s*\S+/i.test(data);
        }

        var ctor = compound ? CompoundPath : Path;
        return new ctor(arg);
      }
    },
    _asPathItem: function _asPathItem() {
      return this;
    },
    isClockwise: function isClockwise() {
      return this.getArea() >= 0;
    },
    setClockwise: function setClockwise(clockwise) {
      if (this.isClockwise() != (clockwise = !!clockwise)) this.reverse();
    },
    setPathData: function setPathData(data) {
      var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
          coords,
          relative = false,
          previous,
          control,
          current = new Point(),
          start = new Point();

      function getCoord(index, coord) {
        var val = +coords[index];
        if (relative) val += current[coord];
        return val;
      }

      function getPoint(index) {
        return new Point(getCoord(index, 'x'), getCoord(index + 1, 'y'));
      }

      this.clear();

      for (var i = 0, l = parts && parts.length; i < l; i++) {
        var part = parts[i],
            command = part[0],
            lower = command.toLowerCase();
        coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
        var length = coords && coords.length;
        relative = command === lower;
        if (previous === 'z' && !/[mz]/.test(lower)) this.moveTo(current);

        switch (lower) {
          case 'm':
          case 'l':
            var move = lower === 'm';

            for (var j = 0; j < length; j += 2) {
              this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));

              if (move) {
                start = current;
                move = false;
              }
            }

            control = current;
            break;

          case 'h':
          case 'v':
            var coord = lower === 'h' ? 'x' : 'y';
            current = current.clone();

            for (var j = 0; j < length; j++) {
              current[coord] = getCoord(j, coord);
              this.lineTo(current);
            }

            control = current;
            break;

          case 'c':
            for (var j = 0; j < length; j += 6) {
              this.cubicCurveTo(getPoint(j), control = getPoint(j + 2), current = getPoint(j + 4));
            }

            break;

          case 's':
            for (var j = 0; j < length; j += 4) {
              this.cubicCurveTo(/[cs]/.test(previous) ? current.multiply(2).subtract(control) : current, control = getPoint(j), current = getPoint(j + 2));
              previous = lower;
            }

            break;

          case 'q':
            for (var j = 0; j < length; j += 4) {
              this.quadraticCurveTo(control = getPoint(j), current = getPoint(j + 2));
            }

            break;

          case 't':
            for (var j = 0; j < length; j += 2) {
              this.quadraticCurveTo(control = /[qt]/.test(previous) ? current.multiply(2).subtract(control) : current, current = getPoint(j));
              previous = lower;
            }

            break;

          case 'a':
            for (var j = 0; j < length; j += 7) {
              this.arcTo(current = getPoint(j + 5), new Size(+coords[j], +coords[j + 1]), +coords[j + 2], +coords[j + 4], +coords[j + 3]);
            }

            break;

          case 'z':
            this.closePath(1e-12);
            current = start;
            break;
        }

        previous = lower;
      }
    },
    _canComposite: function _canComposite() {
      return !(this.hasFill() && this.hasStroke());
    },
    _contains: function _contains(point) {
      var winding = point.isInside(this.getBounds({
        internal: true,
        handle: true
      })) ? this._getWinding(point) : {};
      return winding.onPath || !!(this.getFillRule() === 'evenodd' ? winding.windingL & 1 || winding.windingR & 1 : winding.winding);
    },
    getIntersections: function getIntersections(path, include, _matrix, _returnFirst) {
      var self = this === path || !path,
          matrix1 = this._matrix._orNullIfIdentity(),
          matrix2 = self ? matrix1 : (_matrix || path._matrix)._orNullIfIdentity();

      return self || this.getBounds(matrix1).intersects(path.getBounds(matrix2), 1e-12) ? Curve.getIntersections(this.getCurves(), !self && path.getCurves(), include, matrix1, matrix2, _returnFirst) : [];
    },
    getCrossings: function getCrossings(path) {
      return this.getIntersections(path, function (inter) {
        return inter.isCrossing();
      });
    },
    getNearestLocation: function getNearestLocation() {
      var point = Point.read(arguments),
          curves = this.getCurves(),
          minDist = Infinity,
          minLoc = null;

      for (var i = 0, l = curves.length; i < l; i++) {
        var loc = curves[i].getNearestLocation(point);

        if (loc._distance < minDist) {
          minDist = loc._distance;
          minLoc = loc;
        }
      }

      return minLoc;
    },
    getNearestPoint: function getNearestPoint() {
      var loc = this.getNearestLocation.apply(this, arguments);
      return loc ? loc.getPoint() : loc;
    },
    interpolate: function interpolate(from, to, factor) {
      var isPath = !this._children,
          name = isPath ? '_segments' : '_children',
          itemsFrom = from[name],
          itemsTo = to[name],
          items = this[name];

      if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
        throw new Error('Invalid operands in interpolate() call: ' + from + ', ' + to);
      }

      var current = items.length,
          length = itemsTo.length;

      if (current < length) {
        var ctor = isPath ? Segment : Path;

        for (var i = current; i < length; i++) {
          this.add(new ctor());
        }
      } else if (current > length) {
        this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
      }

      for (var i = 0; i < length; i++) {
        items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
      }

      if (isPath) {
        this.setClosed(from._closed);

        this._changed(9);
      }
    },
    compare: function compare(path) {
      var ok = false;

      if (path) {
        var paths1 = this._children || [this],
            paths2 = path._children ? path._children.slice() : [path],
            length1 = paths1.length,
            length2 = paths2.length,
            matched = [],
            count = 0;
        ok = true;
        var boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);

        for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
          var path1 = paths1[i1];
          ok = false;
          var pathBoundsOverlaps = boundsOverlaps[i1];

          if (pathBoundsOverlaps) {
            for (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {
              if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {
                if (!matched[pathBoundsOverlaps[i2]]) {
                  matched[pathBoundsOverlaps[i2]] = true;
                  count++;
                }

                ok = true;
              }
            }
          }
        }

        ok = ok && count === length2;
      }

      return ok;
    }
  });
  var Path = PathItem.extend({
    _class: 'Path',
    _serializeFields: {
      segments: [],
      closed: false
    },
    initialize: function Path(arg) {
      this._closed = false;
      this._segments = [];
      this._version = 0;
      var args = arguments,
          segments = Array.isArray(arg) ? _typeof(arg[0]) === 'object' ? arg : args : arg && arg.size === undefined && (arg.x !== undefined || arg.point !== undefined) ? args : null;

      if (segments && segments.length > 0) {
        this.setSegments(segments);
      } else {
        this._curves = undefined;
        this._segmentSelection = 0;

        if (!segments && typeof arg === 'string') {
          this.setPathData(arg);
          arg = null;
        }
      }

      this._initialize(!segments && arg);
    },
    _equals: function _equals(item) {
      return this._closed === item._closed && Base.equals(this._segments, item._segments);
    },
    copyContent: function copyContent(source) {
      this.setSegments(source._segments);
      this._closed = source._closed;
    },
    _changed: function _changed(flags) {
      _changed.base.call(this, flags);

      if (flags & 8) {
        this._length = this._area = undefined;

        if (flags & 32) {
          this._version++;
        } else if (this._curves) {
          for (var i = 0, l = this._curves.length; i < l; i++) {
            this._curves[i]._changed();
          }
        }
      } else if (flags & 64) {
        this._bounds = undefined;
      }
    },
    getStyle: function getStyle() {
      var parent = this._parent;
      return (parent instanceof CompoundPath ? parent : this)._style;
    },
    getSegments: function getSegments() {
      return this._segments;
    },
    setSegments: function setSegments(segments) {
      var fullySelected = this.isFullySelected(),
          length = segments && segments.length;
      this._segments.length = 0;
      this._segmentSelection = 0;
      this._curves = undefined;

      if (length) {
        var last = segments[length - 1];

        if (typeof last === 'boolean') {
          this.setClosed(last);
          length--;
        }

        this._add(Segment.readList(segments, 0, {}, length));
      }

      if (fullySelected) this.setFullySelected(true);
    },
    getFirstSegment: function getFirstSegment() {
      return this._segments[0];
    },
    getLastSegment: function getLastSegment() {
      return this._segments[this._segments.length - 1];
    },
    getCurves: function getCurves() {
      var curves = this._curves,
          segments = this._segments;

      if (!curves) {
        var length = this._countCurves();

        curves = this._curves = new Array(length);

        for (var i = 0; i < length; i++) {
          curves[i] = new Curve(this, segments[i], segments[i + 1] || segments[0]);
        }
      }

      return curves;
    },
    getFirstCurve: function getFirstCurve() {
      return this.getCurves()[0];
    },
    getLastCurve: function getLastCurve() {
      var curves = this.getCurves();
      return curves[curves.length - 1];
    },
    isClosed: function isClosed() {
      return this._closed;
    },
    setClosed: function setClosed(closed) {
      if (this._closed != (closed = !!closed)) {
        this._closed = closed;

        if (this._curves) {
          var length = this._curves.length = this._countCurves();

          if (closed) this._curves[length - 1] = new Curve(this, this._segments[length - 1], this._segments[0]);
        }

        this._changed(41);
      }
    }
  }, {
    beans: true,
    getPathData: function getPathData(_matrix, _precision) {
      var segments = this._segments,
          length = segments.length,
          f = new Formatter(_precision),
          coords = new Array(6),
          first = true,
          curX,
          curY,
          prevX,
          prevY,
          inX,
          inY,
          outX,
          outY,
          parts = [];

      function addSegment(segment, skipLine) {
        segment._transformCoordinates(_matrix, coords);

        curX = coords[0];
        curY = coords[1];

        if (first) {
          parts.push('M' + f.pair(curX, curY));
          first = false;
        } else {
          inX = coords[2];
          inY = coords[3];

          if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
            if (!skipLine) {
              var dx = curX - prevX,
                  dy = curY - prevY;
              parts.push(dx === 0 ? 'v' + f.number(dy) : dy === 0 ? 'h' + f.number(dx) : 'l' + f.pair(dx, dy));
            }
          } else {
            parts.push('c' + f.pair(outX - prevX, outY - prevY) + ' ' + f.pair(inX - prevX, inY - prevY) + ' ' + f.pair(curX - prevX, curY - prevY));
          }
        }

        prevX = curX;
        prevY = curY;
        outX = coords[4];
        outY = coords[5];
      }

      if (!length) return '';

      for (var i = 0; i < length; i++) {
        addSegment(segments[i]);
      }

      if (this._closed && length > 0) {
        addSegment(segments[0], true);
        parts.push('z');
      }

      return parts.join('');
    },
    isEmpty: function isEmpty() {
      return !this._segments.length;
    },
    _transformContent: function _transformContent(matrix) {
      var segments = this._segments,
          coords = new Array(6);

      for (var i = 0, l = segments.length; i < l; i++) {
        segments[i]._transformCoordinates(matrix, coords, true);
      }

      return true;
    },
    _add: function _add(segs, index) {
      var segments = this._segments,
          curves = this._curves,
          amount = segs.length,
          append = index == null,
          index = append ? segments.length : index;

      for (var i = 0; i < amount; i++) {
        var segment = segs[i];
        if (segment._path) segment = segs[i] = segment.clone();
        segment._path = this;
        segment._index = index + i;
        if (segment._selection) this._updateSelection(segment, 0, segment._selection);
      }

      if (append) {
        Base.push(segments, segs);
      } else {
        segments.splice.apply(segments, [index, 0].concat(segs));

        for (var i = index + amount, l = segments.length; i < l; i++) {
          segments[i]._index = i;
        }
      }

      if (curves) {
        var total = this._countCurves(),
            start = index > 0 && index + amount - 1 === total ? index - 1 : index,
            insert = start,
            end = Math.min(start + amount, total);

        if (segs._curves) {
          curves.splice.apply(curves, [start, 0].concat(segs._curves));
          insert += segs._curves.length;
        }

        for (var i = insert; i < end; i++) {
          curves.splice(i, 0, new Curve(this, null, null));
        }

        this._adjustCurves(start, end);
      }

      this._changed(41);

      return segs;
    },
    _adjustCurves: function _adjustCurves(start, end) {
      var segments = this._segments,
          curves = this._curves,
          curve;

      for (var i = start; i < end; i++) {
        curve = curves[i];
        curve._path = this;
        curve._segment1 = segments[i];
        curve._segment2 = segments[i + 1] || segments[0];

        curve._changed();
      }

      if (curve = curves[this._closed && !start ? segments.length - 1 : start - 1]) {
        curve._segment2 = segments[start] || segments[0];

        curve._changed();
      }

      if (curve = curves[end]) {
        curve._segment1 = segments[end];

        curve._changed();
      }
    },
    _countCurves: function _countCurves() {
      var length = this._segments.length;
      return !this._closed && length > 0 ? length - 1 : length;
    },
    add: function add(segment1) {
      var args = arguments;
      return args.length > 1 && typeof segment1 !== 'number' ? this._add(Segment.readList(args)) : this._add([Segment.read(args)])[0];
    },
    insert: function insert(index, segment1) {
      var args = arguments;
      return args.length > 2 && typeof segment1 !== 'number' ? this._add(Segment.readList(args, 1), index) : this._add([Segment.read(args, 1)], index)[0];
    },
    addSegment: function addSegment() {
      return this._add([Segment.read(arguments)])[0];
    },
    insertSegment: function insertSegment(index) {
      return this._add([Segment.read(arguments, 1)], index)[0];
    },
    addSegments: function addSegments(segments) {
      return this._add(Segment.readList(segments));
    },
    insertSegments: function insertSegments(index, segments) {
      return this._add(Segment.readList(segments), index);
    },
    removeSegment: function removeSegment(index) {
      return this.removeSegments(index, index + 1)[0] || null;
    },
    removeSegments: function removeSegments(start, end, _includeCurves) {
      start = start || 0;
      end = Base.pick(end, this._segments.length);
      var segments = this._segments,
          curves = this._curves,
          count = segments.length,
          removed = segments.splice(start, end - start),
          amount = removed.length;
      if (!amount) return removed;

      for (var i = 0; i < amount; i++) {
        var segment = removed[i];
        if (segment._selection) this._updateSelection(segment, segment._selection, 0);
        segment._index = segment._path = null;
      }

      for (var i = start, l = segments.length; i < l; i++) {
        segments[i]._index = i;
      }

      if (curves) {
        var index = start > 0 && end === count + (this._closed ? 1 : 0) ? start - 1 : start,
            curves = curves.splice(index, amount);

        for (var i = curves.length - 1; i >= 0; i--) {
          curves[i]._path = null;
        }

        if (_includeCurves) removed._curves = curves.slice(1);

        this._adjustCurves(index, index);
      }

      this._changed(41);

      return removed;
    },
    clear: '#removeSegments',
    hasHandles: function hasHandles() {
      var segments = this._segments;

      for (var i = 0, l = segments.length; i < l; i++) {
        if (segments[i].hasHandles()) return true;
      }

      return false;
    },
    clearHandles: function clearHandles() {
      var segments = this._segments;

      for (var i = 0, l = segments.length; i < l; i++) {
        segments[i].clearHandles();
      }
    },
    getLength: function getLength() {
      if (this._length == null) {
        var curves = this.getCurves(),
            length = 0;

        for (var i = 0, l = curves.length; i < l; i++) {
          length += curves[i].getLength();
        }

        this._length = length;
      }

      return this._length;
    },
    getArea: function getArea() {
      var area = this._area;

      if (area == null) {
        var segments = this._segments,
            closed = this._closed;
        area = 0;

        for (var i = 0, l = segments.length; i < l; i++) {
          var last = i + 1 === l;
          area += Curve.getArea(Curve.getValues(segments[i], segments[last ? 0 : i + 1], null, last && !closed));
        }

        this._area = area;
      }

      return area;
    },
    isFullySelected: function isFullySelected() {
      var length = this._segments.length;
      return this.isSelected() && length > 0 && this._segmentSelection === length * 7;
    },
    setFullySelected: function setFullySelected(selected) {
      if (selected) this._selectSegments(true);
      this.setSelected(selected);
    },
    setSelection: function setSelection(selection) {
      if (!(selection & 1)) this._selectSegments(false);
      setSelection.base.call(this, selection);
    },
    _selectSegments: function _selectSegments(selected) {
      var segments = this._segments,
          length = segments.length,
          selection = selected ? 7 : 0;
      this._segmentSelection = selection * length;

      for (var i = 0; i < length; i++) {
        segments[i]._selection = selection;
      }
    },
    _updateSelection: function _updateSelection(segment, oldSelection, newSelection) {
      segment._selection = newSelection;
      var selection = this._segmentSelection += newSelection - oldSelection;
      if (selection > 0) this.setSelected(true);
    },
    divideAt: function divideAt(location) {
      var loc = this.getLocationAt(location),
          curve;
      return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset())) ? curve._segment1 : null;
    },
    splitAt: function splitAt(location) {
      var loc = this.getLocationAt(location),
          index = loc && loc.index,
          time = loc && loc.time,
          tMin = 1e-8,
          tMax = 1 - tMin;

      if (time > tMax) {
        index++;
        time = 0;
      }

      var curves = this.getCurves();

      if (index >= 0 && index < curves.length) {
        if (time >= tMin) {
          curves[index++].divideAtTime(time);
        }

        var segs = this.removeSegments(index, this._segments.length, true),
            path;

        if (this._closed) {
          this.setClosed(false);
          path = this;
        } else {
          path = new Path(Item.NO_INSERT);
          path.insertAbove(this);
          path.copyAttributes(this);
        }

        path._add(segs, 0);

        this.addSegment(segs[0]);
        return path;
      }

      return null;
    },
    split: function split(index, time) {
      var curve,
          location = time === undefined ? index : (curve = this.getCurves()[index]) && curve.getLocationAtTime(time);
      return location != null ? this.splitAt(location) : null;
    },
    join: function join(path, tolerance) {
      var epsilon = tolerance || 0;

      if (path && path !== this) {
        var segments = path._segments,
            last1 = this.getLastSegment(),
            last2 = path.getLastSegment();
        if (!last2) return this;
        if (last1 && last1._point.isClose(last2._point, epsilon)) path.reverse();
        var first2 = path.getFirstSegment();

        if (last1 && last1._point.isClose(first2._point, epsilon)) {
          last1.setHandleOut(first2._handleOut);

          this._add(segments.slice(1));
        } else {
          var first1 = this.getFirstSegment();
          if (first1 && first1._point.isClose(first2._point, epsilon)) path.reverse();
          last2 = path.getLastSegment();

          if (first1 && first1._point.isClose(last2._point, epsilon)) {
            first1.setHandleIn(last2._handleIn);

            this._add(segments.slice(0, segments.length - 1), 0);
          } else {
            this._add(segments.slice());
          }
        }

        if (path._closed) this._add([segments[0]]);
        path.remove();
      }

      var first = this.getFirstSegment(),
          last = this.getLastSegment();

      if (first !== last && first._point.isClose(last._point, epsilon)) {
        first.setHandleIn(last._handleIn);
        last.remove();
        this.setClosed(true);
      }

      return this;
    },
    reduce: function reduce(options) {
      var curves = this.getCurves(),
          simplify = options && options.simplify,
          tolerance = simplify ? 1e-7 : 0;

      for (var i = curves.length - 1; i >= 0; i--) {
        var curve = curves[i];
        if (!curve.hasHandles() && (!curve.hasLength(tolerance) || simplify && curve.isCollinear(curve.getNext()))) curve.remove();
      }

      return this;
    },
    reverse: function reverse() {
      this._segments.reverse();

      for (var i = 0, l = this._segments.length; i < l; i++) {
        var segment = this._segments[i];
        var handleIn = segment._handleIn;
        segment._handleIn = segment._handleOut;
        segment._handleOut = handleIn;
        segment._index = i;
      }

      this._curves = null;

      this._changed(9);
    },
    flatten: function flatten(flatness) {
      var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
          parts = flattener.parts,
          length = parts.length,
          segments = [];

      for (var i = 0; i < length; i++) {
        segments.push(new Segment(parts[i].curve.slice(0, 2)));
      }

      if (!this._closed && length > 0) {
        segments.push(new Segment(parts[length - 1].curve.slice(6)));
      }

      this.setSegments(segments);
    },
    simplify: function simplify(tolerance) {
      var segments = new PathFitter(this).fit(tolerance || 2.5);
      if (segments) this.setSegments(segments);
      return !!segments;
    },
    smooth: function smooth(options) {
      var that = this,
          opts = options || {},
          type = opts.type || 'asymmetric',
          segments = this._segments,
          length = segments.length,
          closed = this._closed;

      function getIndex(value, _default) {
        var index = value && value.index;

        if (index != null) {
          var path = value.path;
          if (path && path !== that) throw new Error(value._class + ' ' + index + ' of ' + path + ' is not part of ' + that);
          if (_default && value instanceof Curve) index++;
        } else {
          index = typeof value === 'number' ? value : _default;
        }

        return Math.min(index < 0 && closed ? index % length : index < 0 ? index + length : index, length - 1);
      }

      var loop = closed && opts.from === undefined && opts.to === undefined,
          from = getIndex(opts.from, 0),
          to = getIndex(opts.to, length - 1);

      if (from > to) {
        if (closed) {
          from -= length;
        } else {
          var tmp = from;
          from = to;
          to = tmp;
        }
      }

      if (/^(?:asymmetric|continuous)$/.test(type)) {
        var asymmetric = type === 'asymmetric',
            min = Math.min,
            amount = to - from + 1,
            n = amount - 1,
            padding = loop ? min(amount, 4) : 1,
            paddingLeft = padding,
            paddingRight = padding,
            knots = [];

        if (!closed) {
          paddingLeft = min(1, from);
          paddingRight = min(1, length - to - 1);
        }

        n += paddingLeft + paddingRight;
        if (n <= 1) return;

        for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
          knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
        }

        var x = knots[0]._x + 2 * knots[1]._x,
            y = knots[0]._y + 2 * knots[1]._y,
            f = 2,
            n_1 = n - 1,
            rx = [x],
            ry = [y],
            rf = [f],
            px = [],
            py = [];

        for (var i = 1; i < n; i++) {
          var internal = i < n_1,
              a = internal ? 1 : asymmetric ? 1 : 2,
              b = internal ? 4 : asymmetric ? 2 : 7,
              u = internal ? 4 : asymmetric ? 3 : 8,
              v = internal ? 2 : asymmetric ? 0 : 1,
              m = a / f;
          f = rf[i] = b - m;
          x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
          y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
        }

        px[n_1] = rx[n_1] / rf[n_1];
        py[n_1] = ry[n_1] / rf[n_1];

        for (var i = n - 2; i >= 0; i--) {
          px[i] = (rx[i] - px[i + 1]) / rf[i];
          py[i] = (ry[i] - py[i + 1]) / rf[i];
        }

        px[n] = (3 * knots[n]._x - px[n_1]) / 2;
        py[n] = (3 * knots[n]._y - py[n_1]) / 2;

        for (var i = paddingLeft, max = n - paddingRight, j = from; i <= max; i++, j++) {
          var segment = segments[j < 0 ? j + length : j],
              pt = segment._point,
              hx = px[i] - pt._x,
              hy = py[i] - pt._y;
          if (loop || i < max) segment.setHandleOut(hx, hy);
          if (loop || i > paddingLeft) segment.setHandleIn(-hx, -hy);
        }
      } else {
        for (var i = from; i <= to; i++) {
          segments[i < 0 ? i + length : i].smooth(opts, !loop && i === from, !loop && i === to);
        }
      }
    },
    toShape: function toShape(insert) {
      if (!this._closed) return null;
      var segments = this._segments,
          type,
          size,
          radius,
          topCenter;

      function isCollinear(i, j) {
        var seg1 = segments[i],
            seg2 = seg1.getNext(),
            seg3 = segments[j],
            seg4 = seg3.getNext();
        return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg3._handleOut.isZero() && seg4._handleIn.isZero() && seg2._point.subtract(seg1._point).isCollinear(seg4._point.subtract(seg3._point));
      }

      function isOrthogonal(i) {
        var seg2 = segments[i],
            seg1 = seg2.getPrevious(),
            seg3 = seg2.getNext();
        return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg2._handleOut.isZero() && seg3._handleIn.isZero() && seg2._point.subtract(seg1._point).isOrthogonal(seg3._point.subtract(seg2._point));
      }

      function isArc(i) {
        var seg1 = segments[i],
            seg2 = seg1.getNext(),
            handle1 = seg1._handleOut,
            handle2 = seg2._handleIn,
            kappa = 0.5522847498307936;

        if (handle1.isOrthogonal(handle2)) {
          var pt1 = seg1._point,
              pt2 = seg2._point,
              corner = new Line(pt1, handle1, true).intersect(new Line(pt2, handle2, true), true);
          return corner && Numerical.isZero(handle1.getLength() / corner.subtract(pt1).getLength() - kappa) && Numerical.isZero(handle2.getLength() / corner.subtract(pt2).getLength() - kappa);
        }

        return false;
      }

      function getDistance(i, j) {
        return segments[i]._point.getDistance(segments[j]._point);
      }

      if (!this.hasHandles() && segments.length === 4 && isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
        type = Shape.Rectangle;
        size = new Size(getDistance(0, 3), getDistance(0, 1));
        topCenter = segments[1]._point.add(segments[2]._point).divide(2);
      } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4) && isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
        type = Shape.Rectangle;
        size = new Size(getDistance(1, 6), getDistance(0, 3));
        radius = size.subtract(new Size(getDistance(0, 7), getDistance(1, 2))).divide(2);
        topCenter = segments[3]._point.add(segments[4]._point).divide(2);
      } else if (segments.length === 4 && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
        if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
          type = Shape.Circle;
          radius = getDistance(0, 2) / 2;
        } else {
          type = Shape.Ellipse;
          radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
        }

        topCenter = segments[1]._point;
      }

      if (type) {
        var center = this.getPosition(true),
            shape = new type({
          center: center,
          size: size,
          radius: radius,
          insert: false
        });
        shape.copyAttributes(this, true);

        shape._matrix.prepend(this._matrix);

        shape.rotate(topCenter.subtract(center).getAngle() + 90);
        if (insert === undefined || insert) shape.insertAbove(this);
        return shape;
      }

      return null;
    },
    toPath: '#clone',
    compare: function compare(path) {
      if (!path || path instanceof CompoundPath) return compare.base.call(this, path);
      var curves1 = this.getCurves(),
          curves2 = path.getCurves(),
          length1 = curves1.length,
          length2 = curves2.length;

      if (!length1 || !length2) {
        return length1 == length2;
      }

      var v1 = curves1[0].getValues(),
          values2 = [],
          pos1 = 0,
          pos2,
          end1 = 0,
          end2;

      for (var i = 0; i < length2; i++) {
        var v2 = curves2[i].getValues();
        values2.push(v2);
        var overlaps = Curve.getOverlaps(v1, v2);

        if (overlaps) {
          pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
          end2 = overlaps[0][1];
          break;
        }
      }

      var abs = Math.abs,
          epsilon = 1e-8,
          v2 = values2[pos2],
          start2;

      while (v1 && v2) {
        var overlaps = Curve.getOverlaps(v1, v2);

        if (overlaps) {
          var t1 = overlaps[0][0];

          if (abs(t1 - end1) < epsilon) {
            end1 = overlaps[1][0];

            if (end1 === 1) {
              v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
              end1 = 0;
            }

            var t2 = overlaps[0][1];

            if (abs(t2 - end2) < epsilon) {
              if (!start2) start2 = [pos2, t2];
              end2 = overlaps[1][1];

              if (end2 === 1) {
                if (++pos2 >= length2) pos2 = 0;
                v2 = values2[pos2] || curves2[pos2].getValues();
                end2 = 0;
              }

              if (!v1) {
                return start2[0] === pos2 && start2[1] === end2;
              }

              continue;
            }
          }
        }

        break;
      }

      return false;
    },
    _hitTestSelf: function _hitTestSelf(point, options, viewMatrix, strokeMatrix) {
      var that = this,
          style = this.getStyle(),
          segments = this._segments,
          numSegments = segments.length,
          closed = this._closed,
          tolerancePadding = options._tolerancePadding,
          strokePadding = tolerancePadding,
          join,
          cap,
          miterLimit,
          area,
          loc,
          res,
          hitStroke = options.stroke && style.hasStroke(),
          hitFill = options.fill && style.hasFill(),
          hitCurves = options.curves,
          strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : hitFill && options.tolerance > 0 || hitCurves ? 0 : null;

      if (strokeRadius !== null) {
        if (strokeRadius > 0) {
          join = style.getStrokeJoin();
          cap = style.getStrokeCap();
          miterLimit = style.getMiterLimit();
          strokePadding = strokePadding.add(Path._getStrokePadding(strokeRadius, strokeMatrix));
        } else {
          join = cap = 'round';
        }
      }

      function isCloseEnough(pt, padding) {
        return point.subtract(pt).divide(padding).length <= 1;
      }

      function checkSegmentPoint(seg, pt, name) {
        if (!options.selected || pt.isSelected()) {
          var anchor = seg._point;
          if (pt !== anchor) pt = pt.add(anchor);

          if (isCloseEnough(pt, strokePadding)) {
            return new HitResult(name, that, {
              segment: seg,
              point: pt
            });
          }
        }
      }

      function checkSegmentPoints(seg, ends) {
        return (ends || options.segments) && checkSegmentPoint(seg, seg._point, 'segment') || !ends && options.handles && (checkSegmentPoint(seg, seg._handleIn, 'handle-in') || checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
      }

      function addToArea(point) {
        area.add(point);
      }

      function checkSegmentStroke(segment) {
        var isJoin = closed || segment._index > 0 && segment._index < numSegments - 1;

        if ((isJoin ? join : cap) === 'round') {
          return isCloseEnough(segment._point, strokePadding);
        } else {
          area = new Path({
            internal: true,
            closed: true
          });

          if (isJoin) {
            if (!segment.isSmooth()) {
              Path._addBevelJoin(segment, join, strokeRadius, miterLimit, null, strokeMatrix, addToArea, true);
            }
          } else if (cap === 'square') {
            Path._addSquareCap(segment, cap, strokeRadius, null, strokeMatrix, addToArea, true);
          }

          if (!area.isEmpty()) {
            var loc;
            return area.contains(point) || (loc = area.getNearestLocation(point)) && isCloseEnough(loc.getPoint(), tolerancePadding);
          }
        }
      }

      if (options.ends && !options.segments && !closed) {
        if (res = checkSegmentPoints(segments[0], true) || checkSegmentPoints(segments[numSegments - 1], true)) return res;
      } else if (options.segments || options.handles) {
        for (var i = 0; i < numSegments; i++) {
          if (res = checkSegmentPoints(segments[i])) return res;
        }
      }

      if (strokeRadius !== null) {
        loc = this.getNearestLocation(point);

        if (loc) {
          var time = loc.getTime();

          if (time === 0 || time === 1 && numSegments > 1) {
            if (!checkSegmentStroke(loc.getSegment())) loc = null;
          } else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
            loc = null;
          }
        }

        if (!loc && join === 'miter' && numSegments > 1) {
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];

            if (point.getDistance(segment._point) <= miterLimit * strokeRadius && checkSegmentStroke(segment)) {
              loc = segment.getLocation();
              break;
            }
          }
        }
      }

      return !loc && hitFill && this._contains(point) || loc && !hitStroke && !hitCurves ? new HitResult('fill', this) : loc ? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
        location: loc,
        point: loc.getPoint()
      }) : null;
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    this[name + 'At'] = function (offset) {
      var loc = this.getLocationAt(offset);
      return loc && loc[name]();
    };
  }, {
    beans: false,
    getLocationOf: function getLocationOf() {
      var point = Point.read(arguments),
          curves = this.getCurves();

      for (var i = 0, l = curves.length; i < l; i++) {
        var loc = curves[i].getLocationOf(point);
        if (loc) return loc;
      }

      return null;
    },
    getOffsetOf: function getOffsetOf() {
      var loc = this.getLocationOf.apply(this, arguments);
      return loc ? loc.getOffset() : null;
    },
    getLocationAt: function getLocationAt(offset) {
      if (typeof offset === 'number') {
        var curves = this.getCurves(),
            length = 0;

        for (var i = 0, l = curves.length; i < l; i++) {
          var start = length,
              curve = curves[i];
          length += curve.getLength();

          if (length > offset) {
            return curve.getLocationAt(offset - start);
          }
        }

        if (curves.length > 0 && offset <= this.getLength()) {
          return new CurveLocation(curves[curves.length - 1], 1);
        }
      } else if (offset && offset.getPath && offset.getPath() === this) {
        return offset;
      }

      return null;
    },
    getOffsetsWithTangent: function getOffsetsWithTangent() {
      var tangent = Point.read(arguments);

      if (tangent.isZero()) {
        return [];
      }

      var offsets = [];
      var curveStart = 0;
      var curves = this.getCurves();

      for (var i = 0, l = curves.length; i < l; i++) {
        var curve = curves[i];
        var curveTimes = curve.getTimesWithTangent(tangent);

        for (var j = 0, m = curveTimes.length; j < m; j++) {
          var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);

          if (offsets.indexOf(offset) < 0) {
            offsets.push(offset);
          }
        }

        curveStart += curve.length;
      }

      return offsets;
    }
  }), new function () {
    function drawHandles(ctx, segments, matrix, size) {
      if (size <= 0) return;
      var half = size / 2,
          miniSize = size - 2,
          miniHalf = half - 1,
          coords = new Array(6),
          pX,
          pY;

      function drawHandle(index) {
        var hX = coords[index],
            hY = coords[index + 1];

        if (pX != hX || pY != hY) {
          ctx.beginPath();
          ctx.moveTo(pX, pY);
          ctx.lineTo(hX, hY);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
          ctx.fill();
        }
      }

      for (var i = 0, l = segments.length; i < l; i++) {
        var segment = segments[i],
            selection = segment._selection;

        segment._transformCoordinates(matrix, coords);

        pX = coords[0];
        pY = coords[1];
        if (selection & 2) drawHandle(2);
        if (selection & 4) drawHandle(4);
        ctx.fillRect(pX - half, pY - half, size, size);

        if (miniSize > 0 && !(selection & 1)) {
          var fillStyle = ctx.fillStyle;
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);
          ctx.fillStyle = fillStyle;
        }
      }
    }

    function drawSegments(ctx, path, matrix) {
      var segments = path._segments,
          length = segments.length,
          coords = new Array(6),
          first = true,
          curX,
          curY,
          prevX,
          prevY,
          inX,
          inY,
          outX,
          outY;

      function drawSegment(segment) {
        if (matrix) {
          segment._transformCoordinates(matrix, coords);

          curX = coords[0];
          curY = coords[1];
        } else {
          var point = segment._point;
          curX = point._x;
          curY = point._y;
        }

        if (first) {
          ctx.moveTo(curX, curY);
          first = false;
        } else {
          if (matrix) {
            inX = coords[2];
            inY = coords[3];
          } else {
            var handle = segment._handleIn;
            inX = curX + handle._x;
            inY = curY + handle._y;
          }

          if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
            ctx.lineTo(curX, curY);
          } else {
            ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
          }
        }

        prevX = curX;
        prevY = curY;

        if (matrix) {
          outX = coords[4];
          outY = coords[5];
        } else {
          var handle = segment._handleOut;
          outX = prevX + handle._x;
          outY = prevY + handle._y;
        }
      }

      for (var i = 0; i < length; i++) {
        drawSegment(segments[i]);
      }

      if (path._closed && length > 0) drawSegment(segments[0]);
    }

    return {
      _draw: function _draw(ctx, param, viewMatrix, strokeMatrix) {
        var dontStart = param.dontStart,
            dontPaint = param.dontFinish || param.clip,
            style = this.getStyle(),
            hasFill = style.hasFill(),
            hasStroke = style.hasStroke(),
            dashArray = style.getDashArray(),
            dashLength = !paper.support.nativeDash && hasStroke && dashArray && dashArray.length;
        if (!dontStart) ctx.beginPath();

        if (hasFill || hasStroke && !dashLength || dontPaint) {
          drawSegments(ctx, this, strokeMatrix);
          if (this._closed) ctx.closePath();
        }

        function getOffset(i) {
          return dashArray[(i % dashLength + dashLength) % dashLength];
        }

        if (!dontPaint && (hasFill || hasStroke)) {
          this._setStyles(ctx, param, viewMatrix);

          if (hasFill) {
            ctx.fill(style.getFillRule());
            ctx.shadowColor = 'rgba(0,0,0,0)';
          }

          if (hasStroke) {
            if (dashLength) {
              if (!dontStart) ctx.beginPath();
              var flattener = new PathFlattener(this, 0.25, 32, false, strokeMatrix),
                  length = flattener.length,
                  from = -style.getDashOffset(),
                  to,
                  i = 0;

              while (from > 0) {
                from -= getOffset(i--) + getOffset(i--);
              }

              while (from < length) {
                to = from + getOffset(i++);
                if (from > 0 || to > 0) flattener.drawPart(ctx, Math.max(from, 0), Math.max(to, 0));
                from = to + getOffset(i++);
              }
            }

            ctx.stroke();
          }
        }
      },
      _drawSelected: function _drawSelected(ctx, matrix) {
        ctx.beginPath();
        drawSegments(ctx, this, matrix);
        ctx.stroke();
        drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
      }
    };
  }(), new function () {
    function getCurrentSegment(that) {
      var segments = that._segments;
      if (!segments.length) throw new Error('Use a moveTo() command first');
      return segments[segments.length - 1];
    }

    return {
      moveTo: function moveTo() {
        var segments = this._segments;
        if (segments.length === 1) this.removeSegment(0);
        if (!segments.length) this._add([new Segment(Point.read(arguments))]);
      },
      moveBy: function moveBy() {
        throw new Error('moveBy() is unsupported on Path items.');
      },
      lineTo: function lineTo() {
        this._add([new Segment(Point.read(arguments))]);
      },
      cubicCurveTo: function cubicCurveTo() {
        var args = arguments,
            handle1 = Point.read(args),
            handle2 = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this);
        current.setHandleOut(handle1.subtract(current._point));

        this._add([new Segment(to, handle2.subtract(to))]);
      },
      quadraticCurveTo: function quadraticCurveTo() {
        var args = arguments,
            handle = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.cubicCurveTo(handle.add(current.subtract(handle).multiply(1 / 3)), handle.add(to.subtract(handle).multiply(1 / 3)), to);
      },
      curveTo: function curveTo() {
        var args = arguments,
            through = Point.read(args),
            to = Point.read(args),
            t = Base.pick(Base.read(args), 0.5),
            t1 = 1 - t,
            current = getCurrentSegment(this)._point,
            handle = through.subtract(current.multiply(t1 * t1)).subtract(to.multiply(t * t)).divide(2 * t * t1);

        if (handle.isNaN()) throw new Error('Cannot put a curve through points with parameter = ' + t);
        this.quadraticCurveTo(handle, to);
      },
      arcTo: function arcTo() {
        var args = arguments,
            abs = Math.abs,
            sqrt = Math.sqrt,
            current = getCurrentSegment(this),
            from = current._point,
            to = Point.read(args),
            through,
            peek = Base.peek(args),
            clockwise = Base.pick(peek, true),
            center,
            extent,
            vector,
            matrix;

        if (typeof clockwise === 'boolean') {
          var middle = from.add(to).divide(2),
              through = middle.add(middle.subtract(from).rotate(clockwise ? -90 : 90));
        } else if (Base.remain(args) <= 2) {
          through = to;
          to = Point.read(args);
        } else if (!from.equals(to)) {
          var radius = Size.read(args),
              isZero = Numerical.isZero;
          if (isZero(radius.width) || isZero(radius.height)) return this.lineTo(to);
          var rotation = Base.read(args),
              clockwise = !!Base.read(args),
              large = !!Base.read(args),
              middle = from.add(to).divide(2),
              pt = from.subtract(middle).rotate(-rotation),
              x = pt.x,
              y = pt.y,
              rx = abs(radius.width),
              ry = abs(radius.height),
              rxSq = rx * rx,
              rySq = ry * ry,
              xSq = x * x,
              ySq = y * y;
          var factor = sqrt(xSq / rxSq + ySq / rySq);

          if (factor > 1) {
            rx *= factor;
            ry *= factor;
            rxSq = rx * rx;
            rySq = ry * ry;
          }

          factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) / (rxSq * ySq + rySq * xSq);
          if (abs(factor) < 1e-12) factor = 0;
          if (factor < 0) throw new Error('Cannot create an arc with the given arguments');
          center = new Point(rx * y / ry, -ry * x / rx).multiply((large === clockwise ? -1 : 1) * sqrt(factor)).rotate(rotation).add(middle);
          matrix = new Matrix().translate(center).rotate(rotation).scale(rx, ry);
          vector = matrix._inverseTransform(from);
          extent = vector.getDirectedAngle(matrix._inverseTransform(to));
          if (!clockwise && extent > 0) extent -= 360;else if (clockwise && extent < 0) extent += 360;
        }

        if (through) {
          var l1 = new Line(from.add(through).divide(2), through.subtract(from).rotate(90), true),
              l2 = new Line(through.add(to).divide(2), to.subtract(through).rotate(90), true),
              line = new Line(from, to),
              throughSide = line.getSide(through);
          center = l1.intersect(l2, true);

          if (!center) {
            if (!throughSide) return this.lineTo(to);
            throw new Error('Cannot create an arc with the given arguments');
          }

          vector = from.subtract(center);
          extent = vector.getDirectedAngle(to.subtract(center));
          var centerSide = line.getSide(center, true);

          if (centerSide === 0) {
            extent = throughSide * abs(extent);
          } else if (throughSide === centerSide) {
            extent += extent < 0 ? 360 : -360;
          }
        }

        if (extent) {
          var epsilon = 1e-7,
              ext = abs(extent),
              count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
              inc = extent / count,
              half = inc * Math.PI / 360,
              z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
              segments = [];

          for (var i = 0; i <= count; i++) {
            var pt = to,
                out = null;

            if (i < count) {
              out = vector.rotate(90).multiply(z);

              if (matrix) {
                pt = matrix._transformPoint(vector);
                out = matrix._transformPoint(vector.add(out)).subtract(pt);
              } else {
                pt = center.add(vector);
              }
            }

            if (!i) {
              current.setHandleOut(out);
            } else {
              var _in = vector.rotate(-90).multiply(z);

              if (matrix) {
                _in = matrix._transformPoint(vector.add(_in)).subtract(pt);
              }

              segments.push(new Segment(pt, _in, out));
            }

            vector = vector.rotate(inc);
          }

          this._add(segments);
        }
      },
      lineBy: function lineBy() {
        var to = Point.read(arguments),
            current = getCurrentSegment(this)._point;

        this.lineTo(current.add(to));
      },
      curveBy: function curveBy() {
        var args = arguments,
            through = Point.read(args),
            to = Point.read(args),
            parameter = Base.read(args),
            current = getCurrentSegment(this)._point;

        this.curveTo(current.add(through), current.add(to), parameter);
      },
      cubicCurveBy: function cubicCurveBy() {
        var args = arguments,
            handle1 = Point.read(args),
            handle2 = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.cubicCurveTo(current.add(handle1), current.add(handle2), current.add(to));
      },
      quadraticCurveBy: function quadraticCurveBy() {
        var args = arguments,
            handle = Point.read(args),
            to = Point.read(args),
            current = getCurrentSegment(this)._point;

        this.quadraticCurveTo(current.add(handle), current.add(to));
      },
      arcBy: function arcBy() {
        var args = arguments,
            current = getCurrentSegment(this)._point,
            point = current.add(Point.read(args)),
            clockwise = Base.pick(Base.peek(args), true);

        if (typeof clockwise === 'boolean') {
          this.arcTo(point, clockwise);
        } else {
          this.arcTo(point, current.add(Point.read(args)));
        }
      },
      closePath: function closePath(tolerance) {
        this.setClosed(true);
        this.join(this, tolerance);
      }
    };
  }(), {
    _getBounds: function _getBounds(matrix, options) {
      var method = options.handle ? 'getHandleBounds' : options.stroke ? 'getStrokeBounds' : 'getBounds';
      return Path[method](this._segments, this._closed, this, matrix, options);
    },
    statics: {
      getBounds: function getBounds(segments, closed, path, matrix, options, strokePadding) {
        var first = segments[0];
        if (!first) return new _Rectangle();

        var coords = new Array(6),
            prevCoords = first._transformCoordinates(matrix, new Array(6)),
            min = prevCoords.slice(0, 2),
            max = min.slice(),
            roots = new Array(2);

        function processSegment(segment) {
          segment._transformCoordinates(matrix, coords);

          for (var i = 0; i < 2; i++) {
            Curve._addBounds(prevCoords[i], prevCoords[i + 4], coords[i + 2], coords[i], i, strokePadding ? strokePadding[i] : 0, min, max, roots);
          }

          var tmp = prevCoords;
          prevCoords = coords;
          coords = tmp;
        }

        for (var i = 1, l = segments.length; i < l; i++) {
          processSegment(segments[i]);
        }

        if (closed) processSegment(first);
        return new _Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      getStrokeBounds: function getStrokeBounds(segments, closed, path, matrix, options) {
        var style = path.getStyle(),
            stroke = style.hasStroke(),
            strokeWidth = style.getStrokeWidth(),
            strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
            strokePadding = stroke && Path._getStrokePadding(strokeWidth, strokeMatrix),
            bounds = Path.getBounds(segments, closed, path, matrix, options, strokePadding);

        if (!stroke) return bounds;
        var strokeRadius = strokeWidth / 2,
            join = style.getStrokeJoin(),
            cap = style.getStrokeCap(),
            miterLimit = style.getMiterLimit(),
            joinBounds = new _Rectangle(new Size(strokePadding));

        function addPoint(point) {
          bounds = bounds.include(point);
        }

        function addRound(segment) {
          bounds = bounds.unite(joinBounds.setCenter(segment._point.transform(matrix)));
        }

        function addJoin(segment, join) {
          if (join === 'round' || segment.isSmooth()) {
            addRound(segment);
          } else {
            Path._addBevelJoin(segment, join, strokeRadius, miterLimit, matrix, strokeMatrix, addPoint);
          }
        }

        function addCap(segment, cap) {
          if (cap === 'round') {
            addRound(segment);
          } else {
            Path._addSquareCap(segment, cap, strokeRadius, matrix, strokeMatrix, addPoint);
          }
        }

        var length = segments.length - (closed ? 0 : 1);

        if (length > 0) {
          for (var i = 1; i < length; i++) {
            addJoin(segments[i], join);
          }

          if (closed) {
            addJoin(segments[0], join);
          } else {
            addCap(segments[0], cap);
            addCap(segments[segments.length - 1], cap);
          }
        }

        return bounds;
      },
      _getStrokePadding: function _getStrokePadding(radius, matrix) {
        if (!matrix) return [radius, radius];
        var hor = new Point(radius, 0).transform(matrix),
            ver = new Point(0, radius).transform(matrix),
            phi = hor.getAngleInRadians(),
            a = hor.getLength(),
            b = ver.getLength();
        var sin = Math.sin(phi),
            cos = Math.cos(phi),
            tan = Math.tan(phi),
            tx = Math.atan2(b * tan, a),
            ty = Math.atan2(b, tan * a);
        return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin), Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
      },
      _addBevelJoin: function _addBevelJoin(segment, join, radius, miterLimit, matrix, strokeMatrix, addPoint, isArea) {
        var curve2 = segment.getCurve(),
            curve1 = curve2.getPrevious(),
            point = curve2.getPoint1().transform(matrix),
            normal1 = curve1.getNormalAtTime(1).multiply(radius).transform(strokeMatrix),
            normal2 = curve2.getNormalAtTime(0).multiply(radius).transform(strokeMatrix),
            angle = normal1.getDirectedAngle(normal2);

        if (angle < 0 || angle >= 180) {
          normal1 = normal1.negate();
          normal2 = normal2.negate();
        }

        if (isArea) addPoint(point);
        addPoint(point.add(normal1));

        if (join === 'miter') {
          var corner = new Line(point.add(normal1), new Point(-normal1.y, normal1.x), true).intersect(new Line(point.add(normal2), new Point(-normal2.y, normal2.x), true), true);

          if (corner && point.getDistance(corner) <= miterLimit * radius) {
            addPoint(corner);
          }
        }

        addPoint(point.add(normal2));
      },
      _addSquareCap: function _addSquareCap(segment, cap, radius, matrix, strokeMatrix, addPoint, isArea) {
        var point = segment._point.transform(matrix),
            loc = segment.getLocation(),
            normal = loc.getNormal().multiply(loc.getTime() === 0 ? radius : -radius).transform(strokeMatrix);

        if (cap === 'square') {
          if (isArea) {
            addPoint(point.subtract(normal));
            addPoint(point.add(normal));
          }

          point = point.add(normal.rotate(-90));
        }

        addPoint(point.add(normal));
        addPoint(point.subtract(normal));
      },
      getHandleBounds: function getHandleBounds(segments, closed, path, matrix, options) {
        var style = path.getStyle(),
            stroke = options.stroke && style.hasStroke(),
            strokePadding,
            joinPadding;

        if (stroke) {
          var strokeMatrix = path._getStrokeMatrix(matrix, options),
              strokeRadius = style.getStrokeWidth() / 2,
              joinRadius = strokeRadius;

          if (style.getStrokeJoin() === 'miter') joinRadius = strokeRadius * style.getMiterLimit();
          if (style.getStrokeCap() === 'square') joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
          strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
          joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
        }

        var coords = new Array(6),
            x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2;

        for (var i = 0, l = segments.length; i < l; i++) {
          var segment = segments[i];

          segment._transformCoordinates(matrix, coords);

          for (var j = 0; j < 6; j += 2) {
            var padding = !j ? joinPadding : strokePadding,
                paddingX = padding ? padding[0] : 0,
                paddingY = padding ? padding[1] : 0,
                x = coords[j],
                y = coords[j + 1],
                xn = x - paddingX,
                xx = x + paddingX,
                yn = y - paddingY,
                yx = y + paddingY;
            if (xn < x1) x1 = xn;
            if (xx > x2) x2 = xx;
            if (yn < y1) y1 = yn;
            if (yx > y2) y2 = yx;
          }
        }

        return new _Rectangle(x1, y1, x2 - x1, y2 - y1);
      }
    }
  });
  Path.inject({
    statics: new function () {
      var kappa = 0.5522847498307936,
          ellipseSegments = [new Segment([-1, 0], [0, kappa], [0, -kappa]), new Segment([0, -1], [-kappa, 0], [kappa, 0]), new Segment([1, 0], [0, -kappa], [0, kappa]), new Segment([0, 1], [kappa, 0], [-kappa, 0])];

      function createPath(segments, closed, args) {
        var props = Base.getNamed(args),
            path = new Path(props && props.insert == false && Item.NO_INSERT);

        path._add(segments);

        path._closed = closed;
        return path.set(props, {
          insert: true
        });
      }

      function createEllipse(center, radius, args) {
        var segments = new Array(4);

        for (var i = 0; i < 4; i++) {
          var segment = ellipseSegments[i];
          segments[i] = new Segment(segment._point.multiply(radius).add(center), segment._handleIn.multiply(radius), segment._handleOut.multiply(radius));
        }

        return createPath(segments, true, args);
      }

      return {
        Line: function Line() {
          var args = arguments;
          return createPath([new Segment(Point.readNamed(args, 'from')), new Segment(Point.readNamed(args, 'to'))], false, args);
        },
        Circle: function Circle() {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              radius = Base.readNamed(args, 'radius');
          return createEllipse(center, new Size(radius), args);
        },
        Rectangle: function Rectangle() {
          var args = arguments,
              rect = _Rectangle.readNamed(args, 'rectangle'),
              radius = Size.readNamed(args, 'radius', 0, {
            readNull: true
          }),
              bl = rect.getBottomLeft(true),
              tl = rect.getTopLeft(true),
              tr = rect.getTopRight(true),
              br = rect.getBottomRight(true),
              segments;

          if (!radius || radius.isZero()) {
            segments = [new Segment(bl), new Segment(tl), new Segment(tr), new Segment(br)];
          } else {
            radius = Size.min(radius, rect.getSize(true).divide(2));
            var rx = radius.width,
                ry = radius.height,
                hx = rx * kappa,
                hy = ry * kappa;
            segments = [new Segment(bl.add(rx, 0), null, [-hx, 0]), new Segment(bl.subtract(0, ry), [0, hy]), new Segment(tl.add(0, ry), null, [0, -hy]), new Segment(tl.add(rx, 0), [-hx, 0], null), new Segment(tr.subtract(rx, 0), null, [hx, 0]), new Segment(tr.add(0, ry), [0, -hy], null), new Segment(br.subtract(0, ry), null, [0, hy]), new Segment(br.subtract(rx, 0), [hx, 0])];
          }

          return createPath(segments, true, args);
        },
        RoundRectangle: '#Rectangle',
        Ellipse: function Ellipse() {
          var args = arguments,
              ellipse = Shape._readEllipse(args);

          return createEllipse(ellipse.center, ellipse.radius, args);
        },
        Oval: '#Ellipse',
        Arc: function Arc() {
          var args = arguments,
              from = Point.readNamed(args, 'from'),
              through = Point.readNamed(args, 'through'),
              to = Point.readNamed(args, 'to'),
              props = Base.getNamed(args),
              path = new Path(props && props.insert == false && Item.NO_INSERT);
          path.moveTo(from);
          path.arcTo(through, to);
          return path.set(props);
        },
        RegularPolygon: function RegularPolygon() {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              sides = Base.readNamed(args, 'sides'),
              radius = Base.readNamed(args, 'radius'),
              step = 360 / sides,
              three = sides % 3 === 0,
              vector = new Point(0, three ? -radius : radius),
              offset = three ? -1 : 0.5,
              segments = new Array(sides);

          for (var i = 0; i < sides; i++) {
            segments[i] = new Segment(center.add(vector.rotate((i + offset) * step)));
          }

          return createPath(segments, true, args);
        },
        Star: function Star() {
          var args = arguments,
              center = Point.readNamed(args, 'center'),
              points = Base.readNamed(args, 'points') * 2,
              radius1 = Base.readNamed(args, 'radius1'),
              radius2 = Base.readNamed(args, 'radius2'),
              step = 360 / points,
              vector = new Point(0, -1),
              segments = new Array(points);

          for (var i = 0; i < points; i++) {
            segments[i] = new Segment(center.add(vector.rotate(step * i).multiply(i % 2 ? radius2 : radius1)));
          }

          return createPath(segments, true, args);
        }
      };
    }()
  });
  var CompoundPath = PathItem.extend({
    _class: 'CompoundPath',
    _serializeFields: {
      children: []
    },
    beans: true,
    initialize: function CompoundPath(arg) {
      this._children = [];
      this._namedChildren = {};

      if (!this._initialize(arg)) {
        if (typeof arg === 'string') {
          this.setPathData(arg);
        } else {
          this.addChildren(Array.isArray(arg) ? arg : arguments);
        }
      }
    },
    insertChildren: function insertChildren(index, items) {
      var list = items,
          first = list[0];
      if (first && typeof first[0] === 'number') list = [list];

      for (var i = items.length - 1; i >= 0; i--) {
        var item = list[i];
        if (list === items && !(item instanceof Path)) list = Base.slice(list);

        if (Array.isArray(item)) {
          list[i] = new Path({
            segments: item,
            insert: false
          });
        } else if (item instanceof CompoundPath) {
          list.splice.apply(list, [i, 1].concat(item.removeChildren()));
          item.remove();
        }
      }

      return insertChildren.base.call(this, index, list);
    },
    reduce: function reduce(options) {
      var children = this._children;

      for (var i = children.length - 1; i >= 0; i--) {
        var path = children[i].reduce(options);
        if (path.isEmpty()) path.remove();
      }

      if (!children.length) {
        var path = new Path(Item.NO_INSERT);
        path.copyAttributes(this);
        path.insertAbove(this);
        this.remove();
        return path;
      }

      return reduce.base.call(this);
    },
    isClosed: function isClosed() {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        if (!children[i]._closed) return false;
      }

      return true;
    },
    setClosed: function setClosed(closed) {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].setClosed(closed);
      }
    },
    getFirstSegment: function getFirstSegment() {
      var first = this.getFirstChild();
      return first && first.getFirstSegment();
    },
    getLastSegment: function getLastSegment() {
      var last = this.getLastChild();
      return last && last.getLastSegment();
    },
    getCurves: function getCurves() {
      var children = this._children,
          curves = [];

      for (var i = 0, l = children.length; i < l; i++) {
        Base.push(curves, children[i].getCurves());
      }

      return curves;
    },
    getFirstCurve: function getFirstCurve() {
      var first = this.getFirstChild();
      return first && first.getFirstCurve();
    },
    getLastCurve: function getLastCurve() {
      var last = this.getLastChild();
      return last && last.getLastCurve();
    },
    getArea: function getArea() {
      var children = this._children,
          area = 0;

      for (var i = 0, l = children.length; i < l; i++) {
        area += children[i].getArea();
      }

      return area;
    },
    getLength: function getLength() {
      var children = this._children,
          length = 0;

      for (var i = 0, l = children.length; i < l; i++) {
        length += children[i].getLength();
      }

      return length;
    },
    getPathData: function getPathData(_matrix, _precision) {
      var children = this._children,
          paths = [];

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i],
            mx = child._matrix;
        paths.push(child.getPathData(_matrix && !mx.isIdentity() ? _matrix.appended(mx) : _matrix, _precision));
      }

      return paths.join('');
    },
    _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
      return _hitTestChildren.base.call(this, point, options.class === Path || options.type === 'path' ? options : Base.set({}, options, {
        fill: false
      }), viewMatrix);
    },
    _draw: function _draw(ctx, param, viewMatrix, strokeMatrix) {
      var children = this._children;
      if (!children.length) return;
      param = param.extend({
        dontStart: true,
        dontFinish: true
      });
      ctx.beginPath();

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].draw(ctx, param, strokeMatrix);
      }

      if (!param.clip) {
        this._setStyles(ctx, param, viewMatrix);

        var style = this._style;

        if (style.hasFill()) {
          ctx.fill(style.getFillRule());
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (style.hasStroke()) ctx.stroke();
      }
    },
    _drawSelected: function _drawSelected(ctx, matrix, selectionItems) {
      var children = this._children;

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i],
            mx = child._matrix;

        if (!selectionItems[child._id]) {
          child._drawSelected(ctx, mx.isIdentity() ? matrix : matrix.appended(mx));
        }
      }
    }
  }, new function () {
    function getCurrentPath(that, check) {
      var children = that._children;
      if (check && !children.length) throw new Error('Use a moveTo() command first');
      return children[children.length - 1];
    }

    return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'], function (key) {
      this[key] = function () {
        var path = getCurrentPath(this, true);
        path[key].apply(path, arguments);
      };
    }, {
      moveTo: function moveTo() {
        var current = getCurrentPath(this),
            path = current && current.isEmpty() ? current : new Path(Item.NO_INSERT);
        if (path !== current) this.addChild(path);
        path.moveTo.apply(path, arguments);
      },
      moveBy: function moveBy() {
        var current = getCurrentPath(this, true),
            last = current && current.getLastSegment(),
            point = Point.read(arguments);
        this.moveTo(last ? point.add(last._point) : point);
      },
      closePath: function closePath(tolerance) {
        getCurrentPath(this, true).closePath(tolerance);
      }
    });
  }(), Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function (key) {
    this[key] = function (param) {
      var children = this._children,
          res;

      for (var i = 0, l = children.length; i < l; i++) {
        res = children[i][key](param) || res;
      }

      return res;
    };
  }, {}));
  PathItem.inject(new function () {
    var min = Math.min,
        max = Math.max,
        abs = Math.abs,
        operators = {
      unite: {
        '1': true,
        '2': true
      },
      intersect: {
        '2': true
      },
      subtract: {
        '1': true
      },
      exclude: {
        '1': true,
        '-1': true
      }
    };

    function getPaths(path) {
      return path._children || [path];
    }

    function preparePath(path, resolve) {
      var res = path.clone(false).reduce({
        simplify: true
      }).transform(null, true, true);

      if (resolve) {
        var paths = getPaths(res);

        for (var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];

          if (!path._closed && !path.isEmpty()) {
            path.closePath(1e-12);
            path.getFirstSegment().setHandleIn(0, 0);
            path.getLastSegment().setHandleOut(0, 0);
          }
        }

        res = res.resolveCrossings().reorient(res.getFillRule() === 'nonzero', true);
      }

      return res;
    }

    function createResult(paths, simplify, path1, path2, options) {
      var result = new CompoundPath(Item.NO_INSERT);
      result.addChildren(paths, true);
      result = result.reduce({
        simplify: simplify
      });

      if (!(options && options.insert == false)) {
        result.insertAbove(path2 && path1.isSibling(path2) && path1.getIndex() < path2.getIndex() ? path2 : path1);
      }

      result.copyAttributes(path1, true);
      return result;
    }

    function filterIntersection(inter) {
      return inter.hasOverlap() || inter.isCrossing();
    }

    function traceBoolean(path1, path2, operation, options) {
      if (options && (options.trace == false || options.stroke) && /^(subtract|intersect)$/.test(operation)) return splitBoolean(path1, path2, operation);

      var _path1 = preparePath(path1, true),
          _path2 = path2 && path1 !== path2 && preparePath(path2, true),
          operator = operators[operation];

      operator[operation] = true;
      if (_path2 && (operator.subtract || operator.exclude) ^ (_path2.isClockwise() ^ _path1.isClockwise())) _path2.reverse();

      var crossings = divideLocations(CurveLocation.expand(_path1.getIntersections(_path2, filterIntersection))),
          paths1 = getPaths(_path1),
          paths2 = _path2 && getPaths(_path2),
          segments = [],
          curves = [],
          paths;

      function collectPaths(paths) {
        for (var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];
          Base.push(segments, path._segments);
          Base.push(curves, path.getCurves());
          path._overlapsOnly = true;
        }
      }

      function getCurves(indices) {
        var list = [];

        for (var i = 0, l = indices && indices.length; i < l; i++) {
          list.push(curves[indices[i]]);
        }

        return list;
      }

      if (crossings.length) {
        collectPaths(paths1);
        if (paths2) collectPaths(paths2);
        var curvesValues = new Array(curves.length);

        for (var i = 0, l = curves.length; i < l; i++) {
          curvesValues[i] = curves[i].getValues();
        }

        var curveCollisions = CollisionDetection.findCurveBoundsCollisions(curvesValues, curvesValues, 0, true);
        var curveCollisionsMap = {};

        for (var i = 0; i < curves.length; i++) {
          var curve = curves[i],
              id = curve._path._id,
              map = curveCollisionsMap[id] = curveCollisionsMap[id] || {};
          map[curve.getIndex()] = {
            hor: getCurves(curveCollisions[i].hor),
            ver: getCurves(curveCollisions[i].ver)
          };
        }

        for (var i = 0, l = crossings.length; i < l; i++) {
          propagateWinding(crossings[i]._segment, _path1, _path2, curveCollisionsMap, operator);
        }

        for (var i = 0, l = segments.length; i < l; i++) {
          var segment = segments[i],
              inter = segment._intersection;

          if (!segment._winding) {
            propagateWinding(segment, _path1, _path2, curveCollisionsMap, operator);
          }

          if (!(inter && inter._overlap)) segment._path._overlapsOnly = false;
        }

        paths = tracePaths(segments, operator);
      } else {
        paths = reorientPaths(paths2 ? paths1.concat(paths2) : paths1.slice(), function (w) {
          return !!operator[w];
        });
      }

      return createResult(paths, true, path1, path2, options);
    }

    function splitBoolean(path1, path2, operation) {
      var _path1 = preparePath(path1),
          _path2 = preparePath(path2),
          crossings = _path1.getIntersections(_path2, filterIntersection),
          subtract = operation === 'subtract',
          divide = operation === 'divide',
          added = {},
          paths = [];

      function addPath(path) {
        if (!added[path._id] && (divide || _path2.contains(path.getPointAt(path.getLength() / 2)) ^ subtract)) {
          paths.unshift(path);
          return added[path._id] = true;
        }
      }

      for (var i = crossings.length - 1; i >= 0; i--) {
        var path = crossings[i].split();

        if (path) {
          if (addPath(path)) path.getFirstSegment().setHandleIn(0, 0);

          _path1.getLastSegment().setHandleOut(0, 0);
        }
      }

      addPath(_path1);
      return createResult(paths, false, path1, path2);
    }

    function linkIntersections(from, to) {
      var prev = from;

      while (prev) {
        if (prev === to) return;
        prev = prev._previous;
      }

      while (from._next && from._next !== to) {
        from = from._next;
      }

      if (!from._next) {
        while (to._previous) {
          to = to._previous;
        }

        from._next = to;
        to._previous = from;
      }
    }

    function clearCurveHandles(curves) {
      for (var i = curves.length - 1; i >= 0; i--) {
        curves[i].clearHandles();
      }
    }

    function reorientPaths(paths, isInside, clockwise) {
      var length = paths && paths.length;

      if (length) {
        var lookup = Base.each(paths, function (path, i) {
          this[path._id] = {
            container: null,
            winding: path.isClockwise() ? 1 : -1,
            index: i
          };
        }, {}),
            sorted = paths.slice().sort(function (a, b) {
          return abs(b.getArea()) - abs(a.getArea());
        }),
            first = sorted[0];
        var collisions = CollisionDetection.findItemBoundsCollisions(sorted, null, Numerical.GEOMETRIC_EPSILON);
        if (clockwise == null) clockwise = first.isClockwise();

        for (var i = 0; i < length; i++) {
          var path1 = sorted[i],
              entry1 = lookup[path1._id],
              containerWinding = 0,
              indices = collisions[i];

          if (indices) {
            var point = null;

            for (var j = indices.length - 1; j >= 0; j--) {
              if (indices[j] < i) {
                point = point || path1.getInteriorPoint();
                var path2 = sorted[indices[j]];

                if (path2.contains(point)) {
                  var entry2 = lookup[path2._id];
                  containerWinding = entry2.winding;
                  entry1.winding += containerWinding;
                  entry1.container = entry2.exclude ? entry2.container : path2;
                  break;
                }
              }
            }
          }

          if (isInside(entry1.winding) === isInside(containerWinding)) {
            entry1.exclude = true;
            paths[entry1.index] = null;
          } else {
            var container = entry1.container;
            path1.setClockwise(container ? !container.isClockwise() : clockwise);
          }
        }
      }

      return paths;
    }

    function divideLocations(locations, include, clearLater) {
      var results = include && [],
          tMin = 1e-8,
          tMax = 1 - tMin,
          clearHandles = false,
          clearCurves = clearLater || [],
          clearLookup = clearLater && {},
          renormalizeLocs,
          prevCurve,
          prevTime;

      function getId(curve) {
        return curve._path._id + '.' + curve._segment1._index;
      }

      for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
        var curve = clearLater[i];
        if (curve._path) clearLookup[getId(curve)] = true;
      }

      for (var i = locations.length - 1; i >= 0; i--) {
        var loc = locations[i],
            time = loc._time,
            origTime = time,
            exclude = include && !include(loc),
            curve = loc._curve,
            segment;

        if (curve) {
          if (curve !== prevCurve) {
            clearHandles = !curve.hasHandles() || clearLookup && clearLookup[getId(curve)];
            renormalizeLocs = [];
            prevTime = null;
            prevCurve = curve;
          } else if (prevTime >= tMin) {
            time /= prevTime;
          }
        }

        if (exclude) {
          if (renormalizeLocs) renormalizeLocs.push(loc);
          continue;
        } else if (include) {
          results.unshift(loc);
        }

        prevTime = origTime;

        if (time < tMin) {
          segment = curve._segment1;
        } else if (time > tMax) {
          segment = curve._segment2;
        } else {
          var newCurve = curve.divideAtTime(time, true);
          if (clearHandles) clearCurves.push(curve, newCurve);
          segment = newCurve._segment1;

          for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
            var l = renormalizeLocs[j];
            l._time = (l._time - time) / (1 - time);
          }
        }

        loc._setSegment(segment);

        var inter = segment._intersection,
            dest = loc._intersection;

        if (inter) {
          linkIntersections(inter, dest);
          var other = inter;

          while (other) {
            linkIntersections(other._intersection, inter);
            other = other._next;
          }
        } else {
          segment._intersection = dest;
        }
      }

      if (!clearLater) clearCurveHandles(clearCurves);
      return results || locations;
    }

    function getWinding(point, curves, dir, closed, dontFlip) {
      var curvesList = Array.isArray(curves) ? curves : curves[dir ? 'hor' : 'ver'];
      var ia = dir ? 1 : 0,
          io = ia ^ 1,
          pv = [point.x, point.y],
          pa = pv[ia],
          po = pv[io],
          windingEpsilon = 1e-9,
          qualityEpsilon = 1e-6,
          paL = pa - windingEpsilon,
          paR = pa + windingEpsilon,
          windingL = 0,
          windingR = 0,
          pathWindingL = 0,
          pathWindingR = 0,
          onPath = false,
          onAnyPath = false,
          quality = 1,
          roots = [],
          vPrev,
          vClose;

      function addWinding(v) {
        var o0 = v[io + 0],
            o3 = v[io + 6];

        if (po < min(o0, o3) || po > max(o0, o3)) {
          return;
        }

        var a0 = v[ia + 0],
            a1 = v[ia + 2],
            a2 = v[ia + 4],
            a3 = v[ia + 6];

        if (o0 === o3) {
          if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
            onPath = true;
          }

          return;
        }

        var t = po === o0 ? 0 : po === o3 ? 1 : paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? 1 : Curve.solveCubic(v, io, po, roots, 0, 1) > 0 ? roots[0] : 1,
            a = t === 0 ? a0 : t === 1 ? a3 : Curve.getPoint(v, t)[dir ? 'y' : 'x'],
            winding = o0 > o3 ? 1 : -1,
            windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
            a3Prev = vPrev[ia + 6];

        if (po !== o0) {
          if (a < paL) {
            pathWindingL += winding;
          } else if (a > paR) {
            pathWindingR += winding;
          } else {
            onPath = true;
          }

          if (a > pa - qualityEpsilon && a < pa + qualityEpsilon) quality /= 2;
        } else {
          if (winding !== windingPrev) {
            if (a0 < paL) {
              pathWindingL += winding;
            } else if (a0 > paR) {
              pathWindingR += winding;
            }
          } else if (a0 != a3Prev) {
            if (a3Prev < paR && a > paR) {
              pathWindingR += winding;
              onPath = true;
            } else if (a3Prev > paL && a < paL) {
              pathWindingL += winding;
              onPath = true;
            }
          }

          quality /= 4;
        }

        vPrev = v;
        return !dontFlip && a > paL && a < paR && Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0 && getWinding(point, curves, !dir, closed, true);
      }

      function handleCurve(v) {
        var o0 = v[io + 0],
            o1 = v[io + 2],
            o2 = v[io + 4],
            o3 = v[io + 6];

        if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
          var a0 = v[ia + 0],
              a1 = v[ia + 2],
              a2 = v[ia + 4],
              a3 = v[ia + 6],
              monoCurves = paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? [v] : Curve.getMonoCurves(v, dir),
              res;

          for (var i = 0, l = monoCurves.length; i < l; i++) {
            if (res = addWinding(monoCurves[i])) return res;
          }
        }
      }

      for (var i = 0, l = curvesList.length; i < l; i++) {
        var curve = curvesList[i],
            path = curve._path,
            v = curve.getValues(),
            res;

        if (!i || curvesList[i - 1]._path !== path) {
          vPrev = null;

          if (!path._closed) {
            vClose = Curve.getValues(path.getLastCurve().getSegment2(), curve.getSegment1(), null, !closed);

            if (vClose[io] !== vClose[io + 6]) {
              vPrev = vClose;
            }
          }

          if (!vPrev) {
            vPrev = v;
            var prev = path.getLastCurve();

            while (prev && prev !== curve) {
              var v2 = prev.getValues();

              if (v2[io] !== v2[io + 6]) {
                vPrev = v2;
                break;
              }

              prev = prev.getPrevious();
            }
          }
        }

        if (res = handleCurve(v)) return res;

        if (i + 1 === l || curvesList[i + 1]._path !== path) {
          if (vClose && (res = handleCurve(vClose))) return res;

          if (onPath && !pathWindingL && !pathWindingR) {
            pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir ? 1 : -1;
          }

          windingL += pathWindingL;
          windingR += pathWindingR;
          pathWindingL = pathWindingR = 0;

          if (onPath) {
            onAnyPath = true;
            onPath = false;
          }

          vClose = null;
        }
      }

      windingL = abs(windingL);
      windingR = abs(windingR);
      return {
        winding: max(windingL, windingR),
        windingL: windingL,
        windingR: windingR,
        quality: quality,
        onPath: onAnyPath
      };
    }

    function propagateWinding(segment, path1, path2, curveCollisionsMap, operator) {
      var chain = [],
          start = segment,
          totalLength = 0,
          winding;

      do {
        var curve = segment.getCurve();

        if (curve) {
          var length = curve.getLength();
          chain.push({
            segment: segment,
            curve: curve,
            length: length
          });
          totalLength += length;
        }

        segment = segment.getNext();
      } while (segment && !segment._intersection && segment !== start);

      var offsets = [0.5, 0.25, 0.75],
          winding = {
        winding: 0,
        quality: -1
      },
          tMin = 1e-3,
          tMax = 1 - tMin;

      for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
        var length = totalLength * offsets[i];

        for (var j = 0, l = chain.length; j < l; j++) {
          var entry = chain[j],
              curveLength = entry.length;

          if (length <= curveLength) {
            var curve = entry.curve,
                path = curve._path,
                parent = path._parent,
                operand = parent instanceof CompoundPath ? parent : path,
                t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
                pt = curve.getPointAtTime(t),
                dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
            var wind = null;

            if (operator.subtract && path2) {
              var otherPath = operand === path1 ? path2 : path1,
                  pathWinding = otherPath._getWinding(pt, dir, true);

              if (operand === path1 && pathWinding.winding || operand === path2 && !pathWinding.winding) {
                if (pathWinding.quality < 1) {
                  continue;
                } else {
                  wind = {
                    winding: 0,
                    quality: 1
                  };
                }
              }
            }

            wind = wind || getWinding(pt, curveCollisionsMap[path._id][curve.getIndex()], dir, true);
            if (wind.quality > winding.quality) winding = wind;
            break;
          }

          length -= curveLength;
        }
      }

      for (var j = chain.length - 1; j >= 0; j--) {
        chain[j].segment._winding = winding;
      }
    }

    function tracePaths(segments, operator) {
      var paths = [],
          starts;

      function isValid(seg) {
        var winding;
        return !!(seg && !seg._visited && (!operator || operator[(winding = seg._winding || {}).winding] && !(operator.unite && winding.winding === 2 && winding.windingL && winding.windingR)));
      }

      function isStart(seg) {
        if (seg) {
          for (var i = 0, l = starts.length; i < l; i++) {
            if (seg === starts[i]) return true;
          }
        }

        return false;
      }

      function visitPath(path) {
        var segments = path._segments;

        for (var i = 0, l = segments.length; i < l; i++) {
          segments[i]._visited = true;
        }
      }

      function getCrossingSegments(segment, collectStarts) {
        var inter = segment._intersection,
            start = inter,
            crossings = [];
        if (collectStarts) starts = [segment];

        function collect(inter, end) {
          while (inter && inter !== end) {
            var other = inter._segment,
                path = other && other._path;

            if (path) {
              var next = other.getNext() || path.getFirstSegment(),
                  nextInter = next._intersection;

              if (other !== segment && (isStart(other) || isStart(next) || next && isValid(other) && (isValid(next) || nextInter && isValid(nextInter._segment)))) {
                crossings.push(other);
              }

              if (collectStarts) starts.push(other);
            }

            inter = inter._next;
          }
        }

        if (inter) {
          collect(inter);

          while (inter && inter._previous) {
            inter = inter._previous;
          }

          collect(inter, start);
        }

        return crossings;
      }

      segments.sort(function (seg1, seg2) {
        var inter1 = seg1._intersection,
            inter2 = seg2._intersection,
            over1 = !!(inter1 && inter1._overlap),
            over2 = !!(inter2 && inter2._overlap),
            path1 = seg1._path,
            path2 = seg2._path;
        return over1 ^ over2 ? over1 ? 1 : -1 : !inter1 ^ !inter2 ? inter1 ? 1 : -1 : path1 !== path2 ? path1._id - path2._id : seg1._index - seg2._index;
      });

      for (var i = 0, l = segments.length; i < l; i++) {
        var seg = segments[i],
            valid = isValid(seg),
            path = null,
            finished = false,
            closed = true,
            branches = [],
            branch,
            visited,
            handleIn;

        if (valid && seg._path._overlapsOnly) {
          var path1 = seg._path,
              path2 = seg._intersection._segment._path;

          if (path1.compare(path2)) {
            if (path1.getArea()) paths.push(path1.clone(false));
            visitPath(path1);
            visitPath(path2);
            valid = false;
          }
        }

        while (valid) {
          var first = !path,
              crossings = getCrossingSegments(seg, first),
              other = crossings.shift(),
              finished = !first && (isStart(seg) || isStart(other)),
              cross = !finished && other;

          if (first) {
            path = new Path(Item.NO_INSERT);
            branch = null;
          }

          if (finished) {
            if (seg.isFirst() || seg.isLast()) closed = seg._path._closed;
            seg._visited = true;
            break;
          }

          if (cross && branch) {
            branches.push(branch);
            branch = null;
          }

          if (!branch) {
            if (cross) crossings.push(seg);
            branch = {
              start: path._segments.length,
              crossings: crossings,
              visited: visited = [],
              handleIn: handleIn
            };
          }

          if (cross) seg = other;

          if (!isValid(seg)) {
            path.removeSegments(branch.start);

            for (var j = 0, k = visited.length; j < k; j++) {
              visited[j]._visited = false;
            }

            visited.length = 0;

            do {
              seg = branch && branch.crossings.shift();

              if (!seg || !seg._path) {
                seg = null;
                branch = branches.pop();

                if (branch) {
                  visited = branch.visited;
                  handleIn = branch.handleIn;
                }
              }
            } while (branch && !isValid(seg));

            if (!seg) break;
          }

          var next = seg.getNext();
          path.add(new Segment(seg._point, handleIn, next && seg._handleOut));
          seg._visited = true;
          visited.push(seg);
          seg = next || seg._path.getFirstSegment();
          handleIn = next && next._handleIn;
        }

        if (finished) {
          if (closed) {
            path.getFirstSegment().setHandleIn(handleIn);
            path.setClosed(closed);
          }

          if (path.getArea() !== 0) {
            paths.push(path);
          }
        }
      }

      return paths;
    }

    return {
      _getWinding: function _getWinding(point, dir, closed) {
        return getWinding(point, this.getCurves(), dir, closed);
      },
      unite: function unite(path, options) {
        return traceBoolean(this, path, 'unite', options);
      },
      intersect: function intersect(path, options) {
        return traceBoolean(this, path, 'intersect', options);
      },
      subtract: function subtract(path, options) {
        return traceBoolean(this, path, 'subtract', options);
      },
      exclude: function exclude(path, options) {
        return traceBoolean(this, path, 'exclude', options);
      },
      divide: function divide(path, options) {
        return options && (options.trace == false || options.stroke) ? splitBoolean(this, path, 'divide') : createResult([this.subtract(path, options), this.intersect(path, options)], true, this, path, options);
      },
      resolveCrossings: function resolveCrossings() {
        var children = this._children,
            paths = children || [this];

        function hasOverlap(seg, path) {
          var inter = seg && seg._intersection;
          return inter && inter._overlap && inter._path === path;
        }

        var hasOverlaps = false,
            hasCrossings = false,
            intersections = this.getIntersections(null, function (inter) {
          return inter.hasOverlap() && (hasOverlaps = true) || inter.isCrossing() && (hasCrossings = true);
        }),
            clearCurves = hasOverlaps && hasCrossings && [];
        intersections = CurveLocation.expand(intersections);

        if (hasOverlaps) {
          var overlaps = divideLocations(intersections, function (inter) {
            return inter.hasOverlap();
          }, clearCurves);

          for (var i = overlaps.length - 1; i >= 0; i--) {
            var overlap = overlaps[i],
                path = overlap._path,
                seg = overlap._segment,
                prev = seg.getPrevious(),
                next = seg.getNext();

            if (hasOverlap(prev, path) && hasOverlap(next, path)) {
              seg.remove();

              prev._handleOut._set(0, 0);

              next._handleIn._set(0, 0);

              if (prev !== seg && !prev.getCurve().hasLength()) {
                next._handleIn.set(prev._handleIn);

                prev.remove();
              }
            }
          }
        }

        if (hasCrossings) {
          divideLocations(intersections, hasOverlaps && function (inter) {
            var curve1 = inter.getCurve(),
                seg1 = inter.getSegment(),
                other = inter._intersection,
                curve2 = other._curve,
                seg2 = other._segment;
            if (curve1 && curve2 && curve1._path && curve2._path) return true;
            if (seg1) seg1._intersection = null;
            if (seg2) seg2._intersection = null;
          }, clearCurves);
          if (clearCurves) clearCurveHandles(clearCurves);
          paths = tracePaths(Base.each(paths, function (path) {
            Base.push(this, path._segments);
          }, []));
        }

        var length = paths.length,
            item;

        if (length > 1 && children) {
          if (paths !== children) this.setChildren(paths);
          item = this;
        } else if (length === 1 && !children) {
          if (paths[0] !== this) this.setSegments(paths[0].removeSegments());
          item = this;
        }

        if (!item) {
          item = new CompoundPath(Item.NO_INSERT);
          item.addChildren(paths);
          item = item.reduce();
          item.copyAttributes(this);
          this.replaceWith(item);
        }

        return item;
      },
      reorient: function reorient(nonZero, clockwise) {
        var children = this._children;

        if (children && children.length) {
          this.setChildren(reorientPaths(this.removeChildren(), function (w) {
            return !!(nonZero ? w : w & 1);
          }, clockwise));
        } else if (clockwise !== undefined) {
          this.setClockwise(clockwise);
        }

        return this;
      },
      getInteriorPoint: function getInteriorPoint() {
        var bounds = this.getBounds(),
            point = bounds.getCenter(true);

        if (!this.contains(point)) {
          var curves = this.getCurves(),
              y = point.y,
              intercepts = [],
              roots = [];

          for (var i = 0, l = curves.length; i < l; i++) {
            var v = curves[i].getValues(),
                o0 = v[1],
                o1 = v[3],
                o2 = v[5],
                o3 = v[7];

            if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
              var monoCurves = Curve.getMonoCurves(v);

              for (var j = 0, m = monoCurves.length; j < m; j++) {
                var mv = monoCurves[j],
                    mo0 = mv[1],
                    mo3 = mv[7];

                if (mo0 !== mo3 && (y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)) {
                  var x = y === mo0 ? mv[0] : y === mo3 ? mv[6] : Curve.solveCubic(mv, 1, y, roots, 0, 1) === 1 ? Curve.getPoint(mv, roots[0]).x : (mv[0] + mv[6]) / 2;
                  intercepts.push(x);
                }
              }
            }
          }

          if (intercepts.length > 1) {
            intercepts.sort(function (a, b) {
              return a - b;
            });
            point.x = (intercepts[0] + intercepts[1]) / 2;
          }
        }

        return point;
      }
    };
  }());
  var PathFlattener = Base.extend({
    _class: 'PathFlattener',
    initialize: function initialize(path, flatness, maxRecursion, ignoreStraight, matrix) {
      var curves = [],
          parts = [],
          length = 0,
          minSpan = 1 / (maxRecursion || 32),
          segments = path._segments,
          segment1 = segments[0],
          segment2;

      function addCurve(segment1, segment2) {
        var curve = Curve.getValues(segment1, segment2, matrix);
        curves.push(curve);
        computeParts(curve, segment1._index, 0, 1);
      }

      function computeParts(curve, index, t1, t2) {
        if (t2 - t1 > minSpan && !(ignoreStraight && Curve.isStraight(curve)) && !Curve.isFlatEnough(curve, flatness || 0.25)) {
          var halves = Curve.subdivide(curve, 0.5),
              tMid = (t1 + t2) / 2;
          computeParts(halves[0], index, t1, tMid);
          computeParts(halves[1], index, tMid, t2);
        } else {
          var dx = curve[6] - curve[0],
              dy = curve[7] - curve[1],
              dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            length += dist;
            parts.push({
              offset: length,
              curve: curve,
              index: index,
              time: t2
            });
          }
        }
      }

      for (var i = 1, l = segments.length; i < l; i++) {
        segment2 = segments[i];
        addCurve(segment1, segment2);
        segment1 = segment2;
      }

      if (path._closed) addCurve(segment2 || segment1, segments[0]);
      this.curves = curves;
      this.parts = parts;
      this.length = length;
      this.index = 0;
    },
    _get: function _get(offset) {
      var parts = this.parts,
          length = parts.length,
          start,
          i,
          j = this.index;

      for (;;) {
        i = j;
        if (!j || parts[--j].offset < offset) break;
      }

      for (; i < length; i++) {
        var part = parts[i];

        if (part.offset >= offset) {
          this.index = i;
          var prev = parts[i - 1],
              prevTime = prev && prev.index === part.index ? prev.time : 0,
              prevOffset = prev ? prev.offset : 0;
          return {
            index: part.index,
            time: prevTime + (part.time - prevTime) * (offset - prevOffset) / (part.offset - prevOffset)
          };
        }
      }

      return {
        index: parts[length - 1].index,
        time: 1
      };
    },
    drawPart: function drawPart(ctx, from, to) {
      var start = this._get(from),
          end = this._get(to);

      for (var i = start.index, l = end.index; i <= l; i++) {
        var curve = Curve.getPart(this.curves[i], i === start.index ? start.time : 0, i === end.index ? end.time : 1);
        if (i === start.index) ctx.moveTo(curve[0], curve[1]);
        ctx.bezierCurveTo.apply(ctx, curve.slice(2));
      }
    }
  }, Base.each(Curve._evaluateMethods, function (name) {
    this[name + 'At'] = function (offset) {
      var param = this._get(offset);

      return Curve[name](this.curves[param.index], param.time);
    };
  }, {}));
  var PathFitter = Base.extend({
    initialize: function initialize(path) {
      var points = this.points = [],
          segments = path._segments,
          closed = path._closed;

      for (var i = 0, prev, l = segments.length; i < l; i++) {
        var point = segments[i].point;

        if (!prev || !prev.equals(point)) {
          points.push(prev = point.clone());
        }
      }

      if (closed) {
        points.unshift(points[points.length - 1]);
        points.push(points[1]);
      }

      this.closed = closed;
    },
    fit: function fit(error) {
      var points = this.points,
          length = points.length,
          segments = null;

      if (length > 0) {
        segments = [new Segment(points[0])];

        if (length > 1) {
          this.fitCubic(segments, error, 0, length - 1, points[1].subtract(points[0]), points[length - 2].subtract(points[length - 1]));

          if (this.closed) {
            segments.shift();
            segments.pop();
          }
        }
      }

      return segments;
    },
    fitCubic: function fitCubic(segments, error, first, last, tan1, tan2) {
      var points = this.points;

      if (last - first === 1) {
        var pt1 = points[first],
            pt2 = points[last],
            dist = pt1.getDistance(pt2) / 3;
        this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)), pt2.add(tan2.normalize(dist)), pt2]);
        return;
      }

      var uPrime = this.chordLengthParameterize(first, last),
          maxError = Math.max(error, error * error),
          split,
          parametersInOrder = true;

      for (var i = 0; i <= 4; i++) {
        var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
        var max = this.findMaxError(first, last, curve, uPrime);

        if (max.error < error && parametersInOrder) {
          this.addCurve(segments, curve);
          return;
        }

        split = max.index;
        if (max.error >= maxError) break;
        parametersInOrder = this.reparameterize(first, last, uPrime, curve);
        maxError = max.error;
      }

      var tanCenter = points[split - 1].subtract(points[split + 1]);
      this.fitCubic(segments, error, first, split, tan1, tanCenter);
      this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
    },
    addCurve: function addCurve(segments, curve) {
      var prev = segments[segments.length - 1];
      prev.setHandleOut(curve[1].subtract(curve[0]));
      segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
    },
    generateBezier: function generateBezier(first, last, uPrime, tan1, tan2) {
      var epsilon = 1e-12,
          abs = Math.abs,
          points = this.points,
          pt1 = points[first],
          pt2 = points[last],
          C = [[0, 0], [0, 0]],
          X = [0, 0];

      for (var i = 0, l = last - first + 1; i < l; i++) {
        var u = uPrime[i],
            t = 1 - u,
            b = 3 * u * t,
            b0 = t * t * t,
            b1 = b * t,
            b2 = b * u,
            b3 = u * u * u,
            a1 = tan1.normalize(b1),
            a2 = tan2.normalize(b2),
            tmp = points[first + i].subtract(pt1.multiply(b0 + b1)).subtract(pt2.multiply(b2 + b3));
        C[0][0] += a1.dot(a1);
        C[0][1] += a1.dot(a2);
        C[1][0] = C[0][1];
        C[1][1] += a2.dot(a2);
        X[0] += a1.dot(tmp);
        X[1] += a2.dot(tmp);
      }

      var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
          alpha1,
          alpha2;

      if (abs(detC0C1) > epsilon) {
        var detC0X = C[0][0] * X[1] - C[1][0] * X[0],
            detXC1 = X[0] * C[1][1] - X[1] * C[0][1];
        alpha1 = detXC1 / detC0C1;
        alpha2 = detC0X / detC0C1;
      } else {
        var c0 = C[0][0] + C[0][1],
            c1 = C[1][0] + C[1][1];
        alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0 : abs(c1) > epsilon ? X[1] / c1 : 0;
      }

      var segLength = pt2.getDistance(pt1),
          eps = epsilon * segLength,
          handle1,
          handle2;

      if (alpha1 < eps || alpha2 < eps) {
        alpha1 = alpha2 = segLength / 3;
      } else {
        var line = pt2.subtract(pt1);
        handle1 = tan1.normalize(alpha1);
        handle2 = tan2.normalize(alpha2);

        if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
          alpha1 = alpha2 = segLength / 3;
          handle1 = handle2 = null;
        }
      }

      return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)), pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
    },
    reparameterize: function reparameterize(first, last, u, curve) {
      for (var i = first; i <= last; i++) {
        u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
      }

      for (var i = 1, l = u.length; i < l; i++) {
        if (u[i] <= u[i - 1]) return false;
      }

      return true;
    },
    findRoot: function findRoot(curve, point, u) {
      var curve1 = [],
          curve2 = [];

      for (var i = 0; i <= 2; i++) {
        curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
      }

      for (var i = 0; i <= 1; i++) {
        curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
      }

      var pt = this.evaluate(3, curve, u),
          pt1 = this.evaluate(2, curve1, u),
          pt2 = this.evaluate(1, curve2, u),
          diff = pt.subtract(point),
          df = pt1.dot(pt1) + diff.dot(pt2);
      return Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;
    },
    evaluate: function evaluate(degree, curve, t) {
      var tmp = curve.slice();

      for (var i = 1; i <= degree; i++) {
        for (var j = 0; j <= degree - i; j++) {
          tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
        }
      }

      return tmp[0];
    },
    chordLengthParameterize: function chordLengthParameterize(first, last) {
      var u = [0];

      for (var i = first + 1; i <= last; i++) {
        u[i - first] = u[i - first - 1] + this.points[i].getDistance(this.points[i - 1]);
      }

      for (var i = 1, m = last - first; i <= m; i++) {
        u[i] /= u[m];
      }

      return u;
    },
    findMaxError: function findMaxError(first, last, curve, u) {
      var index = Math.floor((last - first + 1) / 2),
          maxDist = 0;

      for (var i = first + 1; i < last; i++) {
        var P = this.evaluate(3, curve, u[i - first]);
        var v = P.subtract(this.points[i]);
        var dist = v.x * v.x + v.y * v.y;

        if (dist >= maxDist) {
          maxDist = dist;
          index = i;
        }
      }

      return {
        error: maxDist,
        index: index
      };
    }
  });
  var TextItem = Item.extend({
    _class: 'TextItem',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _serializeFields: {
      content: null
    },
    _boundsOptions: {
      stroke: false,
      handle: false
    },
    initialize: function TextItem(arg) {
      this._content = '';
      this._lines = [];
      var hasProps = arg && Base.isPlainObject(arg) && arg.x === undefined && arg.y === undefined;

      this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
    },
    _equals: function _equals(item) {
      return this._content === item._content;
    },
    copyContent: function copyContent(source) {
      this.setContent(source._content);
    },
    getContent: function getContent() {
      return this._content;
    },
    setContent: function setContent(content) {
      this._content = '' + content;
      this._lines = this._content.split(/\r\n|\n|\r/mg);

      this._changed(521);
    },
    isEmpty: function isEmpty() {
      return !this._content;
    },
    getCharacterStyle: '#getStyle',
    setCharacterStyle: '#setStyle',
    getParagraphStyle: '#getStyle',
    setParagraphStyle: '#setStyle'
  });
  var PointText = TextItem.extend({
    _class: 'PointText',
    initialize: function PointText() {
      TextItem.apply(this, arguments);
    },
    getPoint: function getPoint() {
      var point = this._matrix.getTranslation();

      return new LinkedPoint(point.x, point.y, this, 'setPoint');
    },
    setPoint: function setPoint() {
      var point = Point.read(arguments);
      this.translate(point.subtract(this._matrix.getTranslation()));
    },
    _draw: function _draw(ctx, param, viewMatrix) {
      if (!this._content) return;

      this._setStyles(ctx, param, viewMatrix);

      var lines = this._lines,
          style = this._style,
          hasFill = style.hasFill(),
          hasStroke = style.hasStroke(),
          leading = style.getLeading(),
          shadowColor = ctx.shadowColor;
      ctx.font = style.getFontStyle();
      ctx.textAlign = style.getJustification();

      for (var i = 0, l = lines.length; i < l; i++) {
        ctx.shadowColor = shadowColor;
        var line = lines[i];

        if (hasFill) {
          ctx.fillText(line, 0, 0);
          ctx.shadowColor = 'rgba(0,0,0,0)';
        }

        if (hasStroke) ctx.strokeText(line, 0, 0);
        ctx.translate(0, leading);
      }
    },
    _getBounds: function _getBounds(matrix, options) {
      var style = this._style,
          lines = this._lines,
          numLines = lines.length,
          justification = style.getJustification(),
          leading = style.getLeading(),
          width = this.getView().getTextWidth(style.getFontStyle(), lines),
          x = 0;
      if (justification !== 'left') x -= width / (justification === 'center' ? 2 : 1);
      var rect = new _Rectangle(x, numLines ? -0.75 * leading : 0, width, numLines * leading);
      return matrix ? matrix._transformBounds(rect, rect) : rect;
    }
  });
  var Color = Base.extend(new function () {
    var types = {
      gray: ['gray'],
      rgb: ['red', 'green', 'blue'],
      hsb: ['hue', 'saturation', 'brightness'],
      hsl: ['hue', 'saturation', 'lightness'],
      gradient: ['gradient', 'origin', 'destination', 'highlight']
    };
    var componentParsers = {},
        namedColors = {
      transparent: [0, 0, 0, 0]
    },
        colorCtx;

    function fromCSS(string) {
      var match = string.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i) || string.match(/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i),
          type = 'rgb',
          components;

      if (match) {
        var amount = match[4] ? 4 : 3;
        components = new Array(amount);

        for (var i = 0; i < amount; i++) {
          var value = match[i + 1];
          components[i] = parseInt(value.length == 1 ? value + value : value, 16) / 255;
        }
      } else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
        type = match[1];
        components = match[2].trim().split(/[,\s]+/g);
        var isHSL = type === 'hsl';

        for (var i = 0, l = Math.min(components.length, 4); i < l; i++) {
          var component = components[i];
          var value = parseFloat(component);

          if (isHSL) {
            if (i === 0) {
              var unit = component.match(/([a-z]*)$/)[1];
              value *= {
                turn: 360,
                rad: 180 / Math.PI,
                grad: 0.9
              }[unit] || 1;
            } else if (i < 3) {
              value /= 100;
            }
          } else if (i < 3) {
            value /= /%$/.test(component) ? 100 : 255;
          }

          components[i] = value;
        }
      } else {
        var color = namedColors[string];

        if (!color) {
          if (window) {
            if (!colorCtx) {
              colorCtx = CanvasProvider.getContext(1, 1);
              colorCtx.globalCompositeOperation = 'copy';
            }

            colorCtx.fillStyle = 'rgba(0,0,0,0)';
            colorCtx.fillStyle = string;
            colorCtx.fillRect(0, 0, 1, 1);
            var data = colorCtx.getImageData(0, 0, 1, 1).data;
            color = namedColors[string] = [data[0] / 255, data[1] / 255, data[2] / 255];
          } else {
            color = [0, 0, 0];
          }
        }

        components = color.slice();
      }

      return [type, components];
    }

    var hsbIndices = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]];
    var converters = {
      'rgb-hsb': function rgbHsb(r, g, b) {
        var max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            delta = max - min,
            h = delta === 0 ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60;
        return [h, max === 0 ? 0 : delta / max, max];
      },
      'hsb-rgb': function hsbRgb(h, s, b) {
        h = (h / 60 % 6 + 6) % 6;
        var i = Math.floor(h),
            f = h - i,
            i = hsbIndices[i],
            v = [b, b * (1 - s), b * (1 - s * f), b * (1 - s * (1 - f))];
        return [v[i[0]], v[i[1]], v[i[2]]];
      },
      'rgb-hsl': function rgbHsl(r, g, b) {
        var max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            delta = max - min,
            achromatic = delta === 0,
            h = achromatic ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60,
            l = (max + min) / 2,
            s = achromatic ? 0 : l < 0.5 ? delta / (max + min) : delta / (2 - max - min);
        return [h, s, l];
      },
      'hsl-rgb': function hslRgb(h, s, l) {
        h = (h / 360 % 1 + 1) % 1;
        if (s === 0) return [l, l, l];
        var t3s = [h + 1 / 3, h, h - 1 / 3],
            t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
            t1 = 2 * l - t2,
            c = [];

        for (var i = 0; i < 3; i++) {
          var t3 = t3s[i];
          if (t3 < 0) t3 += 1;
          if (t3 > 1) t3 -= 1;
          c[i] = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
        }

        return c;
      },
      'rgb-gray': function rgbGray(r, g, b) {
        return [r * 0.2989 + g * 0.587 + b * 0.114];
      },
      'gray-rgb': function grayRgb(g) {
        return [g, g, g];
      },
      'gray-hsb': function grayHsb(g) {
        return [0, 0, g];
      },
      'gray-hsl': function grayHsl(g) {
        return [0, 0, g];
      },
      'gradient-rgb': function gradientRgb() {
        return [];
      },
      'rgb-gradient': function rgbGradient() {
        return [];
      }
    };
    return Base.each(types, function (properties, type) {
      componentParsers[type] = [];
      Base.each(properties, function (name, index) {
        var part = Base.capitalize(name),
            hasOverlap = /^(hue|saturation)$/.test(name),
            parser = componentParsers[type][index] = type === 'gradient' ? name === 'gradient' ? function (value) {
          var current = this._components[0];
          value = Gradient.read(Array.isArray(value) ? value : arguments, 0, {
            readNull: true
          });

          if (current !== value) {
            if (current) current._removeOwner(this);
            if (value) value._addOwner(this);
          }

          return value;
        } : function () {
          return Point.read(arguments, 0, {
            readNull: name === 'highlight',
            clone: true
          });
        } : function (value) {
          return value == null || isNaN(value) ? 0 : +value;
        };

        this['get' + part] = function () {
          return this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) ? this._components[index] : this._convert(type)[index];
        };

        this['set' + part] = function (value) {
          if (this._type !== type && !(hasOverlap && /^hs[bl]$/.test(this._type))) {
            this._components = this._convert(type);
            this._properties = types[type];
            this._type = type;
          }

          this._components[index] = parser.call(this, value);

          this._changed();
        };
      }, this);
    }, {
      _class: 'Color',
      _readIndex: true,
      initialize: function Color(arg) {
        var args = arguments,
            reading = this.__read,
            read = 0,
            type,
            components,
            alpha,
            values;

        if (Array.isArray(arg)) {
          args = arg;
          arg = args[0];
        }

        var argType = arg != null && _typeof(arg);

        if (argType === 'string' && arg in types) {
          type = arg;
          arg = args[1];

          if (Array.isArray(arg)) {
            components = arg;
            alpha = args[2];
          } else {
            if (reading) read = 1;
            args = Base.slice(args, 1);
            argType = _typeof(arg);
          }
        }

        if (!components) {
          values = argType === 'number' ? args : argType === 'object' && arg.length != null ? arg : null;

          if (values) {
            if (!type) type = values.length >= 3 ? 'rgb' : 'gray';
            var length = types[type].length;
            alpha = values[length];

            if (reading) {
              read += values === arguments ? length + (alpha != null ? 1 : 0) : 1;
            }

            if (values.length > length) values = Base.slice(values, 0, length);
          } else if (argType === 'string') {
            var converted = fromCSS(arg);
            type = converted[0];
            components = converted[1];

            if (components.length === 4) {
              alpha = components[3];
              components.length--;
            }
          } else if (argType === 'object') {
            if (arg.constructor === Color) {
              type = arg._type;
              components = arg._components.slice();
              alpha = arg._alpha;

              if (type === 'gradient') {
                for (var i = 1, l = components.length; i < l; i++) {
                  var point = components[i];
                  if (point) components[i] = point.clone();
                }
              }
            } else if (arg.constructor === Gradient) {
              type = 'gradient';
              values = args;
            } else {
              type = 'hue' in arg ? 'lightness' in arg ? 'hsl' : 'hsb' : 'gradient' in arg || 'stops' in arg || 'radial' in arg ? 'gradient' : 'gray' in arg ? 'gray' : 'rgb';
              var properties = types[type],
                  parsers = componentParsers[type];
              this._components = components = [];

              for (var i = 0, l = properties.length; i < l; i++) {
                var value = arg[properties[i]];

                if (value == null && !i && type === 'gradient' && 'stops' in arg) {
                  value = {
                    stops: arg.stops,
                    radial: arg.radial
                  };
                }

                value = parsers[i].call(this, value);
                if (value != null) components[i] = value;
              }

              alpha = arg.alpha;
            }
          }

          if (reading && type) read = 1;
        }

        this._type = type || 'rgb';

        if (!components) {
          this._components = components = [];
          var parsers = componentParsers[this._type];

          for (var i = 0, l = parsers.length; i < l; i++) {
            var value = parsers[i].call(this, values && values[i]);
            if (value != null) components[i] = value;
          }
        }

        this._components = components;
        this._properties = types[this._type];
        this._alpha = alpha;
        if (reading) this.__read = read;
        return this;
      },
      set: '#initialize',
      _serialize: function _serialize(options, dictionary) {
        var components = this.getComponents();
        return Base.serialize(/^(gray|rgb)$/.test(this._type) ? components : [this._type].concat(components), options, true, dictionary);
      },
      _changed: function _changed() {
        this._canvasStyle = null;

        if (this._owner) {
          if (this._setter) {
            this._owner[this._setter](this);
          } else {
            this._owner._changed(129);
          }
        }
      },
      _convert: function _convert(type) {
        var converter;
        return this._type === type ? this._components.slice() : (converter = converters[this._type + '-' + type]) ? converter.apply(this, this._components) : converters['rgb-' + type].apply(this, converters[this._type + '-rgb'].apply(this, this._components));
      },
      convert: function convert(type) {
        return new Color(type, this._convert(type), this._alpha);
      },
      getType: function getType() {
        return this._type;
      },
      setType: function setType(type) {
        this._components = this._convert(type);
        this._properties = types[type];
        this._type = type;
      },
      getComponents: function getComponents() {
        var components = this._components.slice();

        if (this._alpha != null) components.push(this._alpha);
        return components;
      },
      getAlpha: function getAlpha() {
        return this._alpha != null ? this._alpha : 1;
      },
      setAlpha: function setAlpha(alpha) {
        this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);

        this._changed();
      },
      hasAlpha: function hasAlpha() {
        return this._alpha != null;
      },
      equals: function equals(color) {
        var col = Base.isPlainValue(color, true) ? Color.read(arguments) : color;
        return col === this || col && this._class === col._class && this._type === col._type && this.getAlpha() === col.getAlpha() && Base.equals(this._components, col._components) || false;
      },
      toString: function toString() {
        var properties = this._properties,
            parts = [],
            isGradient = this._type === 'gradient',
            f = Formatter.instance;

        for (var i = 0, l = properties.length; i < l; i++) {
          var value = this._components[i];
          if (value != null) parts.push(properties[i] + ': ' + (isGradient ? value : f.number(value)));
        }

        if (this._alpha != null) parts.push('alpha: ' + f.number(this._alpha));
        return '{ ' + parts.join(', ') + ' }';
      },
      toCSS: function toCSS(hex) {
        var components = this._convert('rgb'),
            alpha = hex || this._alpha == null ? 1 : this._alpha;

        function convert(val) {
          return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
        }

        components = [convert(components[0]), convert(components[1]), convert(components[2])];
        if (alpha < 1) components.push(alpha < 0 ? 0 : alpha);
        return hex ? '#' + ((1 << 24) + (components[0] << 16) + (components[1] << 8) + components[2]).toString(16).slice(1) : (components.length == 4 ? 'rgba(' : 'rgb(') + components.join(',') + ')';
      },
      toCanvasStyle: function toCanvasStyle(ctx, matrix) {
        if (this._canvasStyle) return this._canvasStyle;
        if (this._type !== 'gradient') return this._canvasStyle = this.toCSS();
        var components = this._components,
            gradient = components[0],
            stops = gradient._stops,
            origin = components[1],
            destination = components[2],
            highlight = components[3],
            inverse = matrix && matrix.inverted(),
            canvasGradient;

        if (inverse) {
          origin = inverse._transformPoint(origin);
          destination = inverse._transformPoint(destination);
          if (highlight) highlight = inverse._transformPoint(highlight);
        }

        if (gradient._radial) {
          var radius = destination.getDistance(origin);

          if (highlight) {
            var vector = highlight.subtract(origin);
            if (vector.getLength() > radius) highlight = origin.add(vector.normalize(radius - 0.1));
          }

          var start = highlight || origin;
          canvasGradient = ctx.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);
        } else {
          canvasGradient = ctx.createLinearGradient(origin.x, origin.y, destination.x, destination.y);
        }

        for (var i = 0, l = stops.length; i < l; i++) {
          var stop = stops[i],
              offset = stop._offset;
          canvasGradient.addColorStop(offset == null ? i / (l - 1) : offset, stop._color.toCanvasStyle());
        }

        return this._canvasStyle = canvasGradient;
      },
      transform: function transform(matrix) {
        if (this._type === 'gradient') {
          var components = this._components;

          for (var i = 1, l = components.length; i < l; i++) {
            var point = components[i];

            matrix._transformPoint(point, point, true);
          }

          this._changed();
        }
      },
      statics: {
        _types: types,
        random: function random() {
          var random = Math.random;
          return new Color(random(), random(), random());
        },
        _setOwner: function _setOwner(color, owner, setter) {
          if (color) {
            if (color._owner && owner && color._owner !== owner) {
              color = color.clone();
            }

            if (!color._owner ^ !owner) {
              color._owner = owner || null;
              color._setter = setter || null;
            }
          }

          return color;
        }
      }
    });
  }(), new function () {
    var operators = {
      add: function add(a, b) {
        return a + b;
      },
      subtract: function subtract(a, b) {
        return a - b;
      },
      multiply: function multiply(a, b) {
        return a * b;
      },
      divide: function divide(a, b) {
        return a / b;
      }
    };
    return Base.each(operators, function (operator, name) {
      this[name] = function (color) {
        color = Color.read(arguments);

        var type = this._type,
            components1 = this._components,
            components2 = color._convert(type);

        for (var i = 0, l = components1.length; i < l; i++) {
          components2[i] = operator(components1[i], components2[i]);
        }

        return new Color(type, components2, this._alpha != null ? operator(this._alpha, color.getAlpha()) : null);
      };
    }, {});
  }());
  var Gradient = Base.extend({
    _class: 'Gradient',
    initialize: function Gradient(stops, radial) {
      this._id = UID.get();

      if (stops && Base.isPlainObject(stops)) {
        this.set(stops);
        stops = radial = null;
      }

      if (this._stops == null) {
        this.setStops(stops || ['white', 'black']);
      }

      if (this._radial == null) {
        this.setRadial(typeof radial === 'string' && radial === 'radial' || radial || false);
      }
    },
    _serialize: function _serialize(options, dictionary) {
      return dictionary.add(this, function () {
        return Base.serialize([this._stops, this._radial], options, true, dictionary);
      });
    },
    _changed: function _changed() {
      for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
        this._owners[i]._changed();
      }
    },
    _addOwner: function _addOwner(color) {
      if (!this._owners) this._owners = [];

      this._owners.push(color);
    },
    _removeOwner: function _removeOwner(color) {
      var index = this._owners ? this._owners.indexOf(color) : -1;

      if (index != -1) {
        this._owners.splice(index, 1);

        if (!this._owners.length) this._owners = undefined;
      }
    },
    clone: function clone() {
      var stops = [];

      for (var i = 0, l = this._stops.length; i < l; i++) {
        stops[i] = this._stops[i].clone();
      }

      return new Gradient(stops, this._radial);
    },
    getStops: function getStops() {
      return this._stops;
    },
    setStops: function setStops(stops) {
      if (stops.length < 2) {
        throw new Error('Gradient stop list needs to contain at least two stops.');
      }

      var _stops = this._stops;

      if (_stops) {
        for (var i = 0, l = _stops.length; i < l; i++) {
          _stops[i]._owner = undefined;
        }
      }

      _stops = this._stops = GradientStop.readList(stops, 0, {
        clone: true
      });

      for (var i = 0, l = _stops.length; i < l; i++) {
        _stops[i]._owner = this;
      }

      this._changed();
    },
    getRadial: function getRadial() {
      return this._radial;
    },
    setRadial: function setRadial(radial) {
      this._radial = radial;

      this._changed();
    },
    equals: function equals(gradient) {
      if (gradient === this) return true;

      if (gradient && this._class === gradient._class) {
        var stops1 = this._stops,
            stops2 = gradient._stops,
            length = stops1.length;

        if (length === stops2.length) {
          for (var i = 0; i < length; i++) {
            if (!stops1[i].equals(stops2[i])) return false;
          }

          return true;
        }
      }

      return false;
    }
  });
  var GradientStop = Base.extend({
    _class: 'GradientStop',
    initialize: function GradientStop(arg0, arg1) {
      var color = arg0,
          offset = arg1;

      if (_typeof(arg0) === 'object' && arg1 === undefined) {
        if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
          color = arg0[0];
          offset = arg0[1];
        } else if ('color' in arg0 || 'offset' in arg0 || 'rampPoint' in arg0) {
          color = arg0.color;
          offset = arg0.offset || arg0.rampPoint || 0;
        }
      }

      this.setColor(color);
      this.setOffset(offset);
    },
    clone: function clone() {
      return new GradientStop(this._color.clone(), this._offset);
    },
    _serialize: function _serialize(options, dictionary) {
      var color = this._color,
          offset = this._offset;
      return Base.serialize(offset == null ? [color] : [color, offset], options, true, dictionary);
    },
    _changed: function _changed() {
      if (this._owner) this._owner._changed(129);
    },
    getOffset: function getOffset() {
      return this._offset;
    },
    setOffset: function setOffset(offset) {
      this._offset = offset;

      this._changed();
    },
    getRampPoint: '#getOffset',
    setRampPoint: '#setOffset',
    getColor: function getColor() {
      return this._color;
    },
    setColor: function setColor() {
      Color._setOwner(this._color, null);

      this._color = Color._setOwner(Color.read(arguments, 0), this, 'setColor');

      this._changed();
    },
    equals: function equals(stop) {
      return stop === this || stop && this._class === stop._class && this._color.equals(stop._color) && this._offset == stop._offset || false;
    }
  });
  var Style = Base.extend(new function () {
    var itemDefaults = {
      fillColor: null,
      fillRule: 'nonzero',
      strokeColor: null,
      strokeWidth: 1,
      strokeCap: 'butt',
      strokeJoin: 'miter',
      strokeScaling: true,
      miterLimit: 10,
      dashOffset: 0,
      dashArray: [],
      shadowColor: null,
      shadowBlur: 0,
      shadowOffset: new Point(),
      selectedColor: null
    },
        groupDefaults = Base.set({}, itemDefaults, {
      fontFamily: 'sans-serif',
      fontWeight: 'normal',
      fontSize: 12,
      leading: null,
      justification: 'left'
    }),
        textDefaults = Base.set({}, groupDefaults, {
      fillColor: new Color()
    }),
        flags = {
      strokeWidth: 193,
      strokeCap: 193,
      strokeJoin: 193,
      strokeScaling: 201,
      miterLimit: 193,
      fontFamily: 9,
      fontWeight: 9,
      fontSize: 9,
      font: 9,
      leading: 9,
      justification: 9
    },
        item = {
      beans: true
    },
        fields = {
      _class: 'Style',
      beans: true,
      initialize: function Style(style, _owner, _project) {
        this._values = {};
        this._owner = _owner;
        this._project = _owner && _owner._project || _project || paper.project;
        this._defaults = !_owner || _owner instanceof Group ? groupDefaults : _owner instanceof TextItem ? textDefaults : itemDefaults;
        if (style) this.set(style);
      }
    };
    Base.each(groupDefaults, function (value, key) {
      var isColor = /Color$/.test(key),
          isPoint = key === 'shadowOffset',
          part = Base.capitalize(key),
          flag = flags[key],
          set = 'set' + part,
          get = 'get' + part;

      fields[set] = function (value) {
        var owner = this._owner,
            children = owner && owner._children,
            applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath);

        if (applyToChildren) {
          for (var i = 0, l = children.length; i < l; i++) {
            children[i]._style[set](value);
          }
        }

        if ((key === 'selectedColor' || !applyToChildren) && key in this._defaults) {
          var old = this._values[key];

          if (old !== value) {
            if (isColor) {
              if (old) {
                Color._setOwner(old, null);

                old._canvasStyle = null;
              }

              if (value && value.constructor === Color) {
                value = Color._setOwner(value, owner, applyToChildren && set);
              }
            }

            this._values[key] = value;
            if (owner) owner._changed(flag || 129);
          }
        }
      };

      fields[get] = function (_dontMerge) {
        var owner = this._owner,
            children = owner && owner._children,
            applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath),
            value;

        if (applyToChildren && !_dontMerge) {
          for (var i = 0, l = children.length; i < l; i++) {
            var childValue = children[i]._style[get]();

            if (!i) {
              value = childValue;
            } else if (!Base.equals(value, childValue)) {
              return undefined;
            }
          }
        } else if (key in this._defaults) {
          var value = this._values[key];

          if (value === undefined) {
            value = this._defaults[key];

            if (value && value.clone) {
              value = value.clone();
            }
          } else {
            var ctor = isColor ? Color : isPoint ? Point : null;

            if (ctor && !(value && value.constructor === ctor)) {
              this._values[key] = value = ctor.read([value], 0, {
                readNull: true,
                clone: true
              });
            }
          }
        }

        if (value && isColor) {
          value = Color._setOwner(value, owner, applyToChildren && set);
        }

        return value;
      };

      item[get] = function (_dontMerge) {
        return this._style[get](_dontMerge);
      };

      item[set] = function (value) {
        this._style[set](value);
      };
    });
    Base.each({
      Font: 'FontFamily',
      WindingRule: 'FillRule'
    }, function (value, key) {
      var get = 'get' + key,
          set = 'set' + key;
      fields[get] = item[get] = '#get' + value;
      fields[set] = item[set] = '#set' + value;
    });
    Item.inject(item);
    return fields;
  }(), {
    set: function set(style) {
      var isStyle = style instanceof Style,
          values = isStyle ? style._values : style;

      if (values) {
        for (var key in values) {
          if (key in this._defaults) {
            var value = values[key];
            this[key] = value && isStyle && value.clone ? value.clone() : value;
          }
        }
      }
    },
    equals: function equals(style) {
      function compare(style1, style2, secondary) {
        var values1 = style1._values,
            values2 = style2._values,
            defaults2 = style2._defaults;

        for (var key in values1) {
          var value1 = values1[key],
              value2 = values2[key];
          if (!(secondary && key in values2) && !Base.equals(value1, value2 === undefined ? defaults2[key] : value2)) return false;
        }

        return true;
      }

      return style === this || style && this._class === style._class && compare(this, style) && compare(style, this, true) || false;
    },
    _dispose: function _dispose() {
      var color;
      color = this.getFillColor();
      if (color) color._canvasStyle = null;
      color = this.getStrokeColor();
      if (color) color._canvasStyle = null;
      color = this.getShadowColor();
      if (color) color._canvasStyle = null;
    },
    hasFill: function hasFill() {
      var color = this.getFillColor();
      return !!color && color.alpha > 0;
    },
    hasStroke: function hasStroke() {
      var color = this.getStrokeColor();
      return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
    },
    hasShadow: function hasShadow() {
      var color = this.getShadowColor();
      return !!color && color.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero());
    },
    getView: function getView() {
      return this._project._view;
    },
    getFontStyle: function getFontStyle() {
      var fontSize = this.getFontSize();
      return this.getFontWeight() + ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ') + this.getFontFamily();
    },
    getFont: '#getFontFamily',
    setFont: '#setFontFamily',
    getLeading: function getLeading() {
      var leading = getLeading.base.call(this),
          fontSize = this.getFontSize();
      if (/pt|em|%|px/.test(fontSize)) fontSize = this.getView().getPixelSize(fontSize);
      return leading != null ? leading : fontSize * 1.2;
    }
  });
  var DomElement = new function () {
    function handlePrefix(el, name, set, value) {
      var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
          suffix = name[0].toUpperCase() + name.substring(1);

      for (var i = 0; i < 6; i++) {
        var prefix = prefixes[i],
            key = prefix ? prefix + suffix : name;

        if (key in el) {
          if (set) {
            el[key] = value;
          } else {
            return el[key];
          }

          break;
        }
      }
    }

    return {
      getStyles: function getStyles(el) {
        var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
            view = doc && doc.defaultView;
        return view && view.getComputedStyle(el, '');
      },
      getBounds: function getBounds(el, viewport) {
        var doc = el.ownerDocument,
            body = doc.body,
            html = doc.documentElement,
            rect;

        try {
          rect = el.getBoundingClientRect();
        } catch (e) {
          rect = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
          };
        }

        var x = rect.left - (html.clientLeft || body.clientLeft || 0),
            y = rect.top - (html.clientTop || body.clientTop || 0);

        if (!viewport) {
          var view = doc.defaultView;
          x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
          y += view.pageYOffset || html.scrollTop || body.scrollTop;
        }

        return new _Rectangle(x, y, rect.width, rect.height);
      },
      getViewportBounds: function getViewportBounds(el) {
        var doc = el.ownerDocument,
            view = doc.defaultView,
            html = doc.documentElement;
        return new _Rectangle(0, 0, view.innerWidth || html.clientWidth, view.innerHeight || html.clientHeight);
      },
      getOffset: function getOffset(el, viewport) {
        return DomElement.getBounds(el, viewport).getPoint();
      },
      getSize: function getSize(el) {
        return DomElement.getBounds(el, true).getSize();
      },
      isInvisible: function isInvisible(el) {
        return DomElement.getSize(el).equals(new Size(0, 0));
      },
      isInView: function isInView(el) {
        return !DomElement.isInvisible(el) && DomElement.getViewportBounds(el).intersects(DomElement.getBounds(el, true));
      },
      isInserted: function isInserted(el) {
        return document.body.contains(el);
      },
      getPrefixed: function getPrefixed(el, name) {
        return el && handlePrefix(el, name);
      },
      setPrefixed: function setPrefixed(el, name, value) {
        if (_typeof(name) === 'object') {
          for (var key in name) {
            handlePrefix(el, key, true, name[key]);
          }
        } else {
          handlePrefix(el, name, true, value);
        }
      }
    };
  }();
  var DomEvent = {
    add: function add(el, events) {
      if (el) {
        for (var type in events) {
          var func = events[type],
              parts = type.split(/[\s,]+/g);

          for (var i = 0, l = parts.length; i < l; i++) {
            var name = parts[i];
            var options = el === document && (name === 'touchstart' || name === 'touchmove') ? {
              passive: false
            } : false;
            el.addEventListener(name, func, options);
          }
        }
      }
    },
    remove: function remove(el, events) {
      if (el) {
        for (var type in events) {
          var func = events[type],
              parts = type.split(/[\s,]+/g);

          for (var i = 0, l = parts.length; i < l; i++) {
            el.removeEventListener(parts[i], func, false);
          }
        }
      }
    },
    getPoint: function getPoint(event) {
      var pos = event.targetTouches ? event.targetTouches.length ? event.targetTouches[0] : event.changedTouches[0] : event;
      return new Point(pos.pageX || pos.clientX + document.documentElement.scrollLeft, pos.pageY || pos.clientY + document.documentElement.scrollTop);
    },
    getTarget: function getTarget(event) {
      return event.target || event.srcElement;
    },
    getRelatedTarget: function getRelatedTarget(event) {
      return event.relatedTarget || event.toElement;
    },
    getOffset: function getOffset(event, target) {
      return DomEvent.getPoint(event).subtract(DomElement.getOffset(target || DomEvent.getTarget(event)));
    }
  };
  DomEvent.requestAnimationFrame = new function () {
    var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
        requested = false,
        callbacks = [],
        timer;

    function handleCallbacks() {
      var functions = callbacks;
      callbacks = [];

      for (var i = 0, l = functions.length; i < l; i++) {
        functions[i]();
      }

      requested = nativeRequest && callbacks.length;
      if (requested) nativeRequest(handleCallbacks);
    }

    return function (callback) {
      callbacks.push(callback);

      if (nativeRequest) {
        if (!requested) {
          nativeRequest(handleCallbacks);
          requested = true;
        }
      } else if (!timer) {
        timer = setInterval(handleCallbacks, 1000 / 60);
      }
    };
  }();
  var View = Base.extend(Emitter, {
    _class: 'View',
    initialize: function View(project, element) {
      function getSize(name) {
        return element[name] || parseInt(element.getAttribute(name), 10);
      }

      function getCanvasSize() {
        var size = DomElement.getSize(element);
        return size.isNaN() || size.isZero() ? new Size(getSize('width'), getSize('height')) : size;
      }

      var size;

      if (window && element) {
        this._id = element.getAttribute('id');
        if (this._id == null) element.setAttribute('id', this._id = 'paper-view-' + View._id++);
        DomEvent.add(element, this._viewEvents);
        var none = 'none';
        DomElement.setPrefixed(element.style, {
          userDrag: none,
          userSelect: none,
          touchCallout: none,
          contentZooming: none,
          tapHighlightColor: 'rgba(0,0,0,0)'
        });

        if (PaperScope.hasAttribute(element, 'resize')) {
          var that = this;
          DomEvent.add(window, this._windowEvents = {
            resize: function resize() {
              that.setViewSize(getCanvasSize());
            }
          });
        }

        size = getCanvasSize();

        if (PaperScope.hasAttribute(element, 'stats') && typeof Stats !== 'undefined') {
          this._stats = new Stats();
          var stats = this._stats.domElement,
              style = stats.style,
              offset = DomElement.getOffset(element);
          style.position = 'absolute';
          style.left = offset.x + 'px';
          style.top = offset.y + 'px';
          document.body.appendChild(stats);
        }
      } else {
        size = new Size(element);
        element = null;
      }

      this._project = project;
      this._scope = project._scope;
      this._element = element;
      if (!this._pixelRatio) this._pixelRatio = window && window.devicePixelRatio || 1;

      this._setElementSize(size.width, size.height);

      this._viewSize = size;

      View._views.push(this);

      View._viewsById[this._id] = this;
      (this._matrix = new Matrix())._owner = this;
      if (!View._focused) View._focused = this;
      this._frameItems = {};
      this._frameItemCount = 0;
      this._itemEvents = {
        native: {},
        virtual: {}
      };
      this._autoUpdate = !paper.agent.node;
      this._needsUpdate = false;
    },
    remove: function remove() {
      if (!this._project) return false;
      if (View._focused === this) View._focused = null;

      View._views.splice(View._views.indexOf(this), 1);

      delete View._viewsById[this._id];
      var project = this._project;
      if (project._view === this) project._view = null;
      DomEvent.remove(this._element, this._viewEvents);
      DomEvent.remove(window, this._windowEvents);
      this._element = this._project = null;
      this.off('frame');
      this._animate = false;
      this._frameItems = {};
      return true;
    },
    _events: Base.each(Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']), function (name) {
      this[name] = {};
    }, {
      onFrame: {
        install: function install() {
          this.play();
        },
        uninstall: function uninstall() {
          this.pause();
        }
      }
    }),
    _animate: false,
    _time: 0,
    _count: 0,
    getAutoUpdate: function getAutoUpdate() {
      return this._autoUpdate;
    },
    setAutoUpdate: function setAutoUpdate(autoUpdate) {
      this._autoUpdate = autoUpdate;
      if (autoUpdate) this.requestUpdate();
    },
    update: function update() {},
    draw: function draw() {
      this.update();
    },
    requestUpdate: function requestUpdate() {
      if (!this._requested) {
        var that = this;
        DomEvent.requestAnimationFrame(function () {
          that._requested = false;

          if (that._animate) {
            that.requestUpdate();
            var element = that._element;

            if ((!DomElement.getPrefixed(document, 'hidden') || PaperScope.getAttribute(element, 'keepalive') === 'true') && DomElement.isInView(element)) {
              that._handleFrame();
            }
          }

          if (that._autoUpdate) that.update();
        });
        this._requested = true;
      }
    },
    play: function play() {
      this._animate = true;
      this.requestUpdate();
    },
    pause: function pause() {
      this._animate = false;
    },
    _handleFrame: function _handleFrame() {
      paper = this._scope;
      var now = Date.now() / 1000,
          delta = this._last ? now - this._last : 0;
      this._last = now;
      this.emit('frame', new Base({
        delta: delta,
        time: this._time += delta,
        count: this._count++
      }));
      if (this._stats) this._stats.update();
    },
    _animateItem: function _animateItem(item, animate) {
      var items = this._frameItems;

      if (animate) {
        items[item._id] = {
          item: item,
          time: 0,
          count: 0
        };
        if (++this._frameItemCount === 1) this.on('frame', this._handleFrameItems);
      } else {
        delete items[item._id];

        if (--this._frameItemCount === 0) {
          this.off('frame', this._handleFrameItems);
        }
      }
    },
    _handleFrameItems: function _handleFrameItems(event) {
      for (var i in this._frameItems) {
        var entry = this._frameItems[i];
        entry.item.emit('frame', new Base(event, {
          time: entry.time += event.delta,
          count: entry.count++
        }));
      }
    },
    _changed: function _changed() {
      this._project._changed(4097);

      this._bounds = this._decomposed = undefined;
    },
    getElement: function getElement() {
      return this._element;
    },
    getPixelRatio: function getPixelRatio() {
      return this._pixelRatio;
    },
    getResolution: function getResolution() {
      return this._pixelRatio * 72;
    },
    getViewSize: function getViewSize() {
      var size = this._viewSize;
      return new LinkedSize(size.width, size.height, this, 'setViewSize');
    },
    setViewSize: function setViewSize() {
      var size = Size.read(arguments),
          delta = size.subtract(this._viewSize);
      if (delta.isZero()) return;

      this._setElementSize(size.width, size.height);

      this._viewSize.set(size);

      this._changed();

      this.emit('resize', {
        size: size,
        delta: delta
      });

      if (this._autoUpdate) {
        this.update();
      }
    },
    _setElementSize: function _setElementSize(width, height) {
      var element = this._element;

      if (element) {
        if (element.width !== width) element.width = width;
        if (element.height !== height) element.height = height;
      }
    },
    getBounds: function getBounds() {
      if (!this._bounds) this._bounds = this._matrix.inverted()._transformBounds(new _Rectangle(new Point(), this._viewSize));
      return this._bounds;
    },
    getSize: function getSize() {
      return this.getBounds().getSize();
    },
    isVisible: function isVisible() {
      return DomElement.isInView(this._element);
    },
    isInserted: function isInserted() {
      return DomElement.isInserted(this._element);
    },
    getPixelSize: function getPixelSize(size) {
      var element = this._element,
          pixels;

      if (element) {
        var parent = element.parentNode,
            temp = document.createElement('div');
        temp.style.fontSize = size;
        parent.appendChild(temp);
        pixels = parseFloat(DomElement.getStyles(temp).fontSize);
        parent.removeChild(temp);
      } else {
        pixels = parseFloat(pixels);
      }

      return pixels;
    },
    getTextWidth: function getTextWidth(font, lines) {
      return 0;
    }
  }, Base.each(['rotate', 'scale', 'shear', 'skew'], function (key) {
    var rotate = key === 'rotate';

    this[key] = function () {
      var args = arguments,
          value = (rotate ? Base : Point).read(args),
          center = Point.read(args, 0, {
        readNull: true
      });
      return this.transform(new Matrix()[key](value, center || this.getCenter(true)));
    };
  }, {
    _decompose: function _decompose() {
      return this._decomposed || (this._decomposed = this._matrix.decompose());
    },
    translate: function translate() {
      var mx = new Matrix();
      return this.transform(mx.translate.apply(mx, arguments));
    },
    getCenter: function getCenter() {
      return this.getBounds().getCenter();
    },
    setCenter: function setCenter() {
      var center = Point.read(arguments);
      this.translate(this.getCenter().subtract(center));
    },
    getZoom: function getZoom() {
      var scaling = this._decompose().scaling;

      return (scaling.x + scaling.y) / 2;
    },
    setZoom: function setZoom(zoom) {
      this.transform(new Matrix().scale(zoom / this.getZoom(), this.getCenter()));
    },
    getRotation: function getRotation() {
      return this._decompose().rotation;
    },
    setRotation: function setRotation(rotation) {
      var current = this.getRotation();

      if (current != null && rotation != null) {
        this.rotate(rotation - current);
      }
    },
    getScaling: function getScaling() {
      var scaling = this._decompose().scaling;

      return new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');
    },
    setScaling: function setScaling() {
      var current = this.getScaling(),
          scaling = Point.read(arguments, 0, {
        clone: true,
        readNull: true
      });

      if (current && scaling) {
        this.scale(scaling.x / current.x, scaling.y / current.y);
      }
    },
    getMatrix: function getMatrix() {
      return this._matrix;
    },
    setMatrix: function setMatrix() {
      var matrix = this._matrix;
      matrix.set.apply(matrix, arguments);
    },
    transform: function transform(matrix) {
      this._matrix.append(matrix);
    },
    scrollBy: function scrollBy() {
      this.translate(Point.read(arguments).negate());
    }
  }), {
    projectToView: function projectToView() {
      return this._matrix._transformPoint(Point.read(arguments));
    },
    viewToProject: function viewToProject() {
      return this._matrix._inverseTransform(Point.read(arguments));
    },
    getEventPoint: function getEventPoint(event) {
      return this.viewToProject(DomEvent.getOffset(event, this._element));
    }
  }, {
    statics: {
      _views: [],
      _viewsById: {},
      _id: 0,
      create: function create(project, element) {
        if (document && typeof element === 'string') element = document.getElementById(element);
        var ctor = window ? CanvasView : View;
        return new ctor(project, element);
      }
    }
  }, new function () {
    if (!window) return;
    var prevFocus,
        tempFocus,
        dragging = false,
        mouseDown = false;

    function getView(event) {
      var target = DomEvent.getTarget(event);
      return target.getAttribute && View._viewsById[target.getAttribute('id')];
    }

    function updateFocus() {
      var view = View._focused;

      if (!view || !view.isVisible()) {
        for (var i = 0, l = View._views.length; i < l; i++) {
          if ((view = View._views[i]).isVisible()) {
            View._focused = tempFocus = view;
            break;
          }
        }
      }
    }

    function handleMouseMove(view, event, point) {
      view._handleMouseEvent('mousemove', event, point);
    }

    var navigator = window.navigator,
        mousedown,
        mousemove,
        mouseup;

    if (navigator.pointerEnabled || navigator.msPointerEnabled) {
      mousedown = 'pointerdown MSPointerDown';
      mousemove = 'pointermove MSPointerMove';
      mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
    } else {
      mousedown = 'touchstart';
      mousemove = 'touchmove';
      mouseup = 'touchend touchcancel';

      if (!('ontouchstart' in window && navigator.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
        mousedown += ' mousedown';
        mousemove += ' mousemove';
        mouseup += ' mouseup';
      }
    }

    var viewEvents = {},
        docEvents = {
      mouseout: function mouseout(event) {
        var view = View._focused,
            target = DomEvent.getRelatedTarget(event);

        if (view && (!target || target.nodeName === 'HTML')) {
          var offset = DomEvent.getOffset(event, view._element),
              x = offset.x,
              abs = Math.abs,
              ax = abs(x),
              max = 1 << 25,
              diff = ax - max;
          offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
          handleMouseMove(view, event, view.viewToProject(offset));
        }
      },
      scroll: updateFocus
    };

    viewEvents[mousedown] = function (event) {
      var view = View._focused = getView(event);

      if (!dragging) {
        dragging = true;

        view._handleMouseEvent('mousedown', event);
      }
    };

    docEvents[mousemove] = function (event) {
      var view = View._focused;

      if (!mouseDown) {
        var target = getView(event);

        if (target) {
          if (view !== target) {
            if (view) handleMouseMove(view, event);
            if (!prevFocus) prevFocus = view;
            view = View._focused = tempFocus = target;
          }
        } else if (tempFocus && tempFocus === view) {
          if (prevFocus && !prevFocus.isInserted()) prevFocus = null;
          view = View._focused = prevFocus;
          prevFocus = null;
          updateFocus();
        }
      }

      if (view) handleMouseMove(view, event);
    };

    docEvents[mousedown] = function () {
      mouseDown = true;
    };

    docEvents[mouseup] = function (event) {
      var view = View._focused;
      if (view && dragging) view._handleMouseEvent('mouseup', event);
      mouseDown = dragging = false;
    };

    DomEvent.add(document, docEvents);
    DomEvent.add(window, {
      load: updateFocus
    });
    var called = false,
        prevented = false,
        fallbacks = {
      doubleclick: 'click',
      mousedrag: 'mousemove'
    },
        wasInView = false,
        overView,
        downPoint,
        lastPoint,
        downItem,
        overItem,
        dragItem,
        clickItem,
        clickTime,
        dblClick;

    function emitMouseEvent(obj, target, type, event, point, prevPoint, stopItem) {
      var stopped = false,
          mouseEvent;

      function emit(obj, type) {
        if (obj.responds(type)) {
          if (!mouseEvent) {
            mouseEvent = new MouseEvent(type, event, point, target || obj, prevPoint ? point.subtract(prevPoint) : null);
          }

          if (obj.emit(type, mouseEvent)) {
            called = true;
            if (mouseEvent.prevented) prevented = true;
            if (mouseEvent.stopped) return stopped = true;
          }
        } else {
          var fallback = fallbacks[type];
          if (fallback) return emit(obj, fallback);
        }
      }

      while (obj && obj !== stopItem) {
        if (emit(obj, type)) break;
        obj = obj._parent;
      }

      return stopped;
    }

    function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
      view._project.removeOn(type);

      prevented = called = false;
      return dragItem && emitMouseEvent(dragItem, null, type, event, point, prevPoint) || hitItem && hitItem !== dragItem && !hitItem.isDescendant(dragItem) && emitMouseEvent(hitItem, null, type === 'mousedrag' ? 'mousemove' : type, event, point, prevPoint, dragItem) || emitMouseEvent(view, dragItem || hitItem || view, type, event, point, prevPoint);
    }

    var itemEventsMap = {
      mousedown: {
        mousedown: 1,
        mousedrag: 1,
        click: 1,
        doubleclick: 1
      },
      mouseup: {
        mouseup: 1,
        mousedrag: 1,
        click: 1,
        doubleclick: 1
      },
      mousemove: {
        mousedrag: 1,
        mousemove: 1,
        mouseenter: 1,
        mouseleave: 1
      }
    };
    return {
      _viewEvents: viewEvents,
      _handleMouseEvent: function _handleMouseEvent(type, event, point) {
        var itemEvents = this._itemEvents,
            hitItems = itemEvents.native[type],
            nativeMove = type === 'mousemove',
            tool = this._scope.tool,
            view = this;

        function responds(type) {
          return itemEvents.virtual[type] || view.responds(type) || tool && tool.responds(type);
        }

        if (nativeMove && dragging && responds('mousedrag')) type = 'mousedrag';
        if (!point) point = this.getEventPoint(event);

        var inView = this.getBounds().contains(point),
            hit = hitItems && inView && view._project.hitTest(point, {
          tolerance: 0,
          fill: true,
          stroke: true
        }),
            hitItem = hit && hit.item || null,
            handle = false,
            mouse = {};

        mouse[type.substr(5)] = true;

        if (hitItems && hitItem !== overItem) {
          if (overItem) {
            emitMouseEvent(overItem, null, 'mouseleave', event, point);
          }

          if (hitItem) {
            emitMouseEvent(hitItem, null, 'mouseenter', event, point);
          }

          overItem = hitItem;
        }

        if (wasInView ^ inView) {
          emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave', event, point);
          overView = inView ? this : null;
          handle = true;
        }

        if ((inView || mouse.drag) && !point.equals(lastPoint)) {
          emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove', event, point, lastPoint);
          handle = true;
        }

        wasInView = inView;

        if (mouse.down && inView || mouse.up && downPoint) {
          emitMouseEvents(this, hitItem, type, event, point, downPoint);

          if (mouse.down) {
            dblClick = hitItem === clickItem && Date.now() - clickTime < 300;
            downItem = clickItem = hitItem;

            if (!prevented && hitItem) {
              var item = hitItem;

              while (item && !item.responds('mousedrag')) {
                item = item._parent;
              }

              if (item) dragItem = hitItem;
            }

            downPoint = point;
          } else if (mouse.up) {
            if (!prevented && hitItem === downItem) {
              clickTime = Date.now();
              emitMouseEvents(this, hitItem, dblClick ? 'doubleclick' : 'click', event, point, downPoint);
              dblClick = false;
            }

            downItem = dragItem = null;
          }

          wasInView = false;
          handle = true;
        }

        lastPoint = point;

        if (handle && tool) {
          called = tool._handleMouseEvent(type, event, point, mouse) || called;
        }

        if (event.cancelable !== false && (called && !mouse.move || mouse.down && responds('mouseup'))) {
          event.preventDefault();
        }
      },
      _handleKeyEvent: function _handleKeyEvent(type, event, key, character) {
        var scope = this._scope,
            tool = scope.tool,
            keyEvent;

        function emit(obj) {
          if (obj.responds(type)) {
            paper = scope;
            obj.emit(type, keyEvent = keyEvent || new KeyEvent(type, event, key, character));
          }
        }

        if (this.isVisible()) {
          emit(this);
          if (tool && tool.responds(type)) emit(tool);
        }
      },
      _countItemEvent: function _countItemEvent(type, sign) {
        var itemEvents = this._itemEvents,
            native = itemEvents.native,
            virtual = itemEvents.virtual;

        for (var key in itemEventsMap) {
          native[key] = (native[key] || 0) + (itemEventsMap[key][type] || 0) * sign;
        }

        virtual[type] = (virtual[type] || 0) + sign;
      },
      statics: {
        updateFocus: updateFocus,
        _resetState: function _resetState() {
          dragging = mouseDown = called = wasInView = false;
          prevFocus = tempFocus = overView = downPoint = lastPoint = downItem = overItem = dragItem = clickItem = clickTime = dblClick = null;
        }
      }
    };
  }());
  var CanvasView = View.extend({
    _class: 'CanvasView',
    initialize: function CanvasView(project, canvas) {
      if (!(canvas instanceof window.HTMLCanvasElement)) {
        var size = Size.read(arguments, 1);
        if (size.isZero()) throw new Error('Cannot create CanvasView with the provided argument: ' + Base.slice(arguments, 1));
        canvas = CanvasProvider.getCanvas(size);
      }

      var ctx = this._context = canvas.getContext('2d');
      ctx.save();
      this._pixelRatio = 1;

      if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
        var deviceRatio = window.devicePixelRatio || 1,
            backingStoreRatio = DomElement.getPrefixed(ctx, 'backingStorePixelRatio') || 1;
        this._pixelRatio = deviceRatio / backingStoreRatio;
      }

      View.call(this, project, canvas);
      this._needsUpdate = true;
    },
    remove: function remove() {
      this._context.restore();

      return remove.base.call(this);
    },
    _setElementSize: function _setElementSize(width, height) {
      var pixelRatio = this._pixelRatio;

      _setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);

      if (pixelRatio !== 1) {
        var element = this._element,
            ctx = this._context;

        if (!PaperScope.hasAttribute(element, 'resize')) {
          var style = element.style;
          style.width = width + 'px';
          style.height = height + 'px';
        }

        ctx.restore();
        ctx.save();
        ctx.scale(pixelRatio, pixelRatio);
      }
    },
    getContext: function getContext() {
      return this._context;
    },
    getPixelSize: function getPixelSize(size) {
      var agent = paper.agent,
          pixels;

      if (agent && agent.firefox) {
        pixels = getPixelSize.base.call(this, size);
      } else {
        var ctx = this._context,
            prevFont = ctx.font;
        ctx.font = size + ' serif';
        pixels = parseFloat(ctx.font);
        ctx.font = prevFont;
      }

      return pixels;
    },
    getTextWidth: function getTextWidth(font, lines) {
      var ctx = this._context,
          prevFont = ctx.font,
          width = 0;
      ctx.font = font;

      for (var i = 0, l = lines.length; i < l; i++) {
        width = Math.max(width, ctx.measureText(lines[i]).width);
      }

      ctx.font = prevFont;
      return width;
    },
    update: function update() {
      if (!this._needsUpdate) return false;
      var project = this._project,
          ctx = this._context,
          size = this._viewSize;
      ctx.clearRect(0, 0, size.width + 1, size.height + 1);
      if (project) project.draw(ctx, this._matrix, this._pixelRatio);
      this._needsUpdate = false;
      return true;
    }
  });
  var Event = Base.extend({
    _class: 'Event',
    initialize: function Event(event) {
      this.event = event;
      this.type = event && event.type;
    },
    prevented: false,
    stopped: false,
    preventDefault: function preventDefault() {
      this.prevented = true;
      this.event.preventDefault();
    },
    stopPropagation: function stopPropagation() {
      this.stopped = true;
      this.event.stopPropagation();
    },
    stop: function stop() {
      this.stopPropagation();
      this.preventDefault();
    },
    getTimeStamp: function getTimeStamp() {
      return this.event.timeStamp;
    },
    getModifiers: function getModifiers() {
      return Key.modifiers;
    }
  });
  var KeyEvent = Event.extend({
    _class: 'KeyEvent',
    initialize: function KeyEvent(type, event, key, character) {
      this.type = type;
      this.event = event;
      this.key = key;
      this.character = character;
    },
    toString: function toString() {
      return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
    }
  });
  var Key = new function () {
    var keyLookup = {
      '\t': 'tab',
      ' ': 'space',
      '\b': 'backspace',
      '\x7f': 'delete',
      'Spacebar': 'space',
      'Del': 'delete',
      'Win': 'meta',
      'Esc': 'escape'
    },
        charLookup = {
      'tab': '\t',
      'space': ' ',
      'enter': '\r'
    },
        keyMap = {},
        charMap = {},
        metaFixMap,
        downKey,
        modifiers = new Base({
      shift: false,
      control: false,
      alt: false,
      meta: false,
      capsLock: false,
      space: false
    }).inject({
      option: {
        get: function get() {
          return this.alt;
        }
      },
      command: {
        get: function get() {
          var agent = paper && paper.agent;
          return agent && agent.mac ? this.meta : this.control;
        }
      }
    });

    function getKey(event) {
      var key = event.key || event.keyIdentifier;
      key = /^U\+/.test(key) ? String.fromCharCode(parseInt(key.substr(2), 16)) : /^Arrow[A-Z]/.test(key) ? key.substr(5) : key === 'Unidentified' || key === undefined ? String.fromCharCode(event.keyCode) : key;
      return keyLookup[key] || (key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
    }

    function handleKey(down, key, character, event) {
      var type = down ? 'keydown' : 'keyup',
          view = View._focused,
          name;
      keyMap[key] = down;

      if (down) {
        charMap[key] = character;
      } else {
        delete charMap[key];
      }

      if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
        modifiers[name] = down;
        var agent = paper && paper.agent;

        if (name === 'meta' && agent && agent.mac) {
          if (down) {
            metaFixMap = {};
          } else {
            for (var k in metaFixMap) {
              if (k in charMap) handleKey(false, k, metaFixMap[k], event);
            }

            metaFixMap = null;
          }
        }
      } else if (down && metaFixMap) {
        metaFixMap[key] = character;
      }

      if (view) {
        view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key, character);
      }
    }

    DomEvent.add(document, {
      keydown: function keydown(event) {
        var key = getKey(event),
            agent = paper && paper.agent;

        if (key.length > 1 || agent && agent.chrome && (event.altKey || agent.mac && event.metaKey || !agent.mac && event.ctrlKey)) {
          handleKey(true, key, charLookup[key] || (key.length > 1 ? '' : key), event);
        } else {
          downKey = key;
        }
      },
      keypress: function keypress(event) {
        if (downKey) {
          var key = getKey(event),
              code = event.charCode,
              character = code >= 32 ? String.fromCharCode(code) : key.length > 1 ? '' : key;

          if (key !== downKey) {
            key = character.toLowerCase();
          }

          handleKey(true, key, character, event);
          downKey = null;
        }
      },
      keyup: function keyup(event) {
        var key = getKey(event);
        if (key in charMap) handleKey(false, key, charMap[key], event);
      }
    });
    DomEvent.add(window, {
      blur: function blur(event) {
        for (var key in charMap) {
          handleKey(false, key, charMap[key], event);
        }
      }
    });
    return {
      modifiers: modifiers,
      isDown: function isDown(key) {
        return !!keyMap[key];
      }
    };
  }();
  var MouseEvent = Event.extend({
    _class: 'MouseEvent',
    initialize: function MouseEvent(type, event, point, target, delta) {
      this.type = type;
      this.event = event;
      this.point = point;
      this.target = target;
      this.delta = delta;
    },
    toString: function toString() {
      return "{ type: '" + this.type + "', point: " + this.point + ', target: ' + this.target + (this.delta ? ', delta: ' + this.delta : '') + ', modifiers: ' + this.getModifiers() + ' }';
    }
  });
  var ToolEvent = Event.extend({
    _class: 'ToolEvent',
    _item: null,
    initialize: function ToolEvent(tool, type, event) {
      this.tool = tool;
      this.type = type;
      this.event = event;
    },
    _choosePoint: function _choosePoint(point, toolPoint) {
      return point ? point : toolPoint ? toolPoint.clone() : null;
    },
    getPoint: function getPoint() {
      return this._choosePoint(this._point, this.tool._point);
    },
    setPoint: function setPoint(point) {
      this._point = point;
    },
    getLastPoint: function getLastPoint() {
      return this._choosePoint(this._lastPoint, this.tool._lastPoint);
    },
    setLastPoint: function setLastPoint(lastPoint) {
      this._lastPoint = lastPoint;
    },
    getDownPoint: function getDownPoint() {
      return this._choosePoint(this._downPoint, this.tool._downPoint);
    },
    setDownPoint: function setDownPoint(downPoint) {
      this._downPoint = downPoint;
    },
    getMiddlePoint: function getMiddlePoint() {
      if (!this._middlePoint && this.tool._lastPoint) {
        return this.tool._point.add(this.tool._lastPoint).divide(2);
      }

      return this._middlePoint;
    },
    setMiddlePoint: function setMiddlePoint(middlePoint) {
      this._middlePoint = middlePoint;
    },
    getDelta: function getDelta() {
      return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
    },
    setDelta: function setDelta(delta) {
      this._delta = delta;
    },
    getCount: function getCount() {
      return this.tool[/^mouse(down|up)$/.test(this.type) ? '_downCount' : '_moveCount'];
    },
    setCount: function setCount(count) {
      this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count'] = count;
    },
    getItem: function getItem() {
      if (!this._item) {
        var result = this.tool._scope.project.hitTest(this.getPoint());

        if (result) {
          var item = result.item,
              parent = item._parent;

          while (/^(Group|CompoundPath)$/.test(parent._class)) {
            item = parent;
            parent = parent._parent;
          }

          this._item = item;
        }
      }

      return this._item;
    },
    setItem: function setItem(item) {
      this._item = item;
    },
    toString: function toString() {
      return '{ type: ' + this.type + ', point: ' + this.getPoint() + ', count: ' + this.getCount() + ', modifiers: ' + this.getModifiers() + ' }';
    }
  });
  var Tool = PaperScopeItem.extend({
    _class: 'Tool',
    _list: 'tools',
    _reference: 'tool',
    _events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove', 'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown', 'onKeyUp'],
    initialize: function Tool(props) {
      PaperScopeItem.call(this);
      this._moveCount = -1;
      this._downCount = -1;
      this.set(props);
    },
    getMinDistance: function getMinDistance() {
      return this._minDistance;
    },
    setMinDistance: function setMinDistance(minDistance) {
      this._minDistance = minDistance;

      if (minDistance != null && this._maxDistance != null && minDistance > this._maxDistance) {
        this._maxDistance = minDistance;
      }
    },
    getMaxDistance: function getMaxDistance() {
      return this._maxDistance;
    },
    setMaxDistance: function setMaxDistance(maxDistance) {
      this._maxDistance = maxDistance;

      if (this._minDistance != null && maxDistance != null && maxDistance < this._minDistance) {
        this._minDistance = maxDistance;
      }
    },
    getFixedDistance: function getFixedDistance() {
      return this._minDistance == this._maxDistance ? this._minDistance : null;
    },
    setFixedDistance: function setFixedDistance(distance) {
      this._minDistance = this._maxDistance = distance;
    },
    _handleMouseEvent: function _handleMouseEvent(type, event, point, mouse) {
      paper = this._scope;
      if (mouse.drag && !this.responds(type)) type = 'mousemove';
      var move = mouse.move || mouse.drag,
          responds = this.responds(type),
          minDistance = this.minDistance,
          maxDistance = this.maxDistance,
          called = false,
          tool = this;

      function update(minDistance, maxDistance) {
        var pt = point,
            toolPoint = move ? tool._point : tool._downPoint || pt;

        if (move) {
          if (tool._moveCount >= 0 && pt.equals(toolPoint)) {
            return false;
          }

          if (toolPoint && (minDistance != null || maxDistance != null)) {
            var vector = pt.subtract(toolPoint),
                distance = vector.getLength();
            if (distance < (minDistance || 0)) return false;

            if (maxDistance) {
              pt = toolPoint.add(vector.normalize(Math.min(distance, maxDistance)));
            }
          }

          tool._moveCount++;
        }

        tool._point = pt;
        tool._lastPoint = toolPoint || pt;

        if (mouse.down) {
          tool._moveCount = -1;
          tool._downPoint = pt;
          tool._downCount++;
        }

        return true;
      }

      function emit() {
        if (responds) {
          called = tool.emit(type, new ToolEvent(tool, type, event)) || called;
        }
      }

      if (mouse.down) {
        update();
        emit();
      } else if (mouse.up) {
        update(null, maxDistance);
        emit();
      } else if (responds) {
        while (update(minDistance, maxDistance)) {
          emit();
        }
      }

      return called;
    }
  });
  var Tween = Base.extend(Emitter, {
    _class: 'Tween',
    statics: {
      easings: {
        linear: function linear(t) {
          return t;
        },
        easeInQuad: function easeInQuad(t) {
          return t * t;
        },
        easeOutQuad: function easeOutQuad(t) {
          return t * (2 - t);
        },
        easeInOutQuad: function easeInOutQuad(t) {
          return t < 0.5 ? 2 * t * t : -1 + 2 * (2 - t) * t;
        },
        easeInCubic: function easeInCubic(t) {
          return t * t * t;
        },
        easeOutCubic: function easeOutCubic(t) {
          return --t * t * t + 1;
        },
        easeInOutCubic: function easeInOutCubic(t) {
          return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        },
        easeInQuart: function easeInQuart(t) {
          return t * t * t * t;
        },
        easeOutQuart: function easeOutQuart(t) {
          return 1 - --t * t * t * t;
        },
        easeInOutQuart: function easeInOutQuart(t) {
          return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
        },
        easeInQuint: function easeInQuint(t) {
          return t * t * t * t * t;
        },
        easeOutQuint: function easeOutQuint(t) {
          return 1 + --t * t * t * t * t;
        },
        easeInOutQuint: function easeInOutQuint(t) {
          return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
        }
      }
    },
    initialize: function Tween(object, from, to, duration, easing, start) {
      this.object = object;

      var type = _typeof(easing);

      var isFunction = type === 'function';
      this.type = isFunction ? type : type === 'string' ? easing : 'linear';
      this.easing = isFunction ? easing : Tween.easings[this.type];
      this.duration = duration;
      this.running = false;
      this._then = null;
      this._startTime = null;
      var state = from || to;
      this._keys = state ? Object.keys(state) : [];
      this._parsedKeys = this._parseKeys(this._keys);
      this._from = state && this._getState(from);
      this._to = state && this._getState(to);

      if (start !== false) {
        this.start();
      }
    },
    then: function then(_then) {
      this._then = _then;
      return this;
    },
    start: function start() {
      this._startTime = null;
      this.running = true;
      return this;
    },
    stop: function stop() {
      this.running = false;
      return this;
    },
    update: function update(progress) {
      if (this.running) {
        if (progress >= 1) {
          progress = 1;
          this.running = false;
        }

        var factor = this.easing(progress),
            keys = this._keys,
            getValue = function getValue(value) {
          return typeof value === 'function' ? value(factor, progress) : value;
        };

        for (var i = 0, l = keys && keys.length; i < l; i++) {
          var key = keys[i],
              from = getValue(this._from[key]),
              to = getValue(this._to[key]),
              value = from && to && from.__add && to.__add ? to.__subtract(from).__multiply(factor).__add(from) : (to - from) * factor + from;

          this._setProperty(this._parsedKeys[key], value);
        }

        if (this.responds('update')) {
          this.emit('update', new Base({
            progress: progress,
            factor: factor
          }));
        }

        if (!this.running && this._then) {
          this._then(this.object);
        }
      }

      return this;
    },
    _events: {
      onUpdate: {}
    },
    _handleFrame: function _handleFrame(time) {
      var startTime = this._startTime,
          progress = startTime ? (time - startTime) / this.duration : 0;

      if (!startTime) {
        this._startTime = time;
      }

      this.update(progress);
    },
    _getState: function _getState(state) {
      var keys = this._keys,
          result = {};

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i],
            path = this._parsedKeys[key],
            current = this._getProperty(path),
            value;

        if (state) {
          var resolved = this._resolveValue(current, state[key]);

          this._setProperty(path, resolved);

          value = this._getProperty(path);
          value = value && value.clone ? value.clone() : value;

          this._setProperty(path, current);
        } else {
          value = current && current.clone ? current.clone() : current;
        }

        result[key] = value;
      }

      return result;
    },
    _resolveValue: function _resolveValue(current, value) {
      if (value) {
        if (Array.isArray(value) && value.length === 2) {
          var operator = value[0];
          return operator && operator.match && operator.match(/^[+\-\*\/]=/) ? this._calculate(current, operator[0], value[1]) : value;
        } else if (typeof value === 'string') {
          var match = value.match(/^[+\-*/]=(.*)/);

          if (match) {
            var parsed = JSON.parse(match[1].replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": '));
            return this._calculate(current, value[0], parsed);
          }
        }
      }

      return value;
    },
    _calculate: function _calculate(left, operator, right) {
      return paper.PaperScript.calculateBinary(left, operator, right);
    },
    _parseKeys: function _parseKeys(keys) {
      var parsed = {};

      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i],
            path = key.replace(/\.([^.]*)/g, '/$1').replace(/\[['"]?([^'"\]]*)['"]?\]/g, '/$1');
        parsed[key] = path.split('/');
      }

      return parsed;
    },
    _getProperty: function _getProperty(path, offset) {
      var obj = this.object;

      for (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {
        obj = obj[path[i]];
      }

      return obj;
    },
    _setProperty: function _setProperty(path, value) {
      var dest = this._getProperty(path, 1);

      if (dest) {
        dest[path[path.length - 1]] = value;
      }
    }
  });
  var Http = {
    request: function request(options) {
      var xhr = new self.XMLHttpRequest();
      xhr.open((options.method || 'get').toUpperCase(), options.url, Base.pick(options.async, true));
      if (options.mimeType) xhr.overrideMimeType(options.mimeType);

      xhr.onload = function () {
        var status = xhr.status;

        if (status === 0 || status === 200) {
          if (options.onLoad) {
            options.onLoad.call(xhr, xhr.responseText);
          }
        } else {
          xhr.onerror();
        }
      };

      xhr.onerror = function () {
        var status = xhr.status,
            message = 'Could not load "' + options.url + '" (Status: ' + status + ')';

        if (options.onError) {
          options.onError(message, status);
        } else {
          throw new Error(message);
        }
      };

      return xhr.send(null);
    }
  };
  var CanvasProvider = Base.exports.CanvasProvider = {
    canvases: [],
    getCanvas: function getCanvas(width, height) {
      if (!window) return null;
      var canvas,
          clear = true;

      if (_typeof(width) === 'object') {
        height = width.height;
        width = width.width;
      }

      if (this.canvases.length) {
        canvas = this.canvases.pop();
      } else {
        canvas = document.createElement('canvas');
        clear = false;
      }

      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Canvas ' + canvas + ' is unable to provide a 2D context.');
      }

      if (canvas.width === width && canvas.height === height) {
        if (clear) ctx.clearRect(0, 0, width + 1, height + 1);
      } else {
        canvas.width = width;
        canvas.height = height;
      }

      ctx.save();
      return canvas;
    },
    getContext: function getContext(width, height) {
      var canvas = this.getCanvas(width, height);
      return canvas ? canvas.getContext('2d') : null;
    },
    release: function release(obj) {
      var canvas = obj && obj.canvas ? obj.canvas : obj;

      if (canvas && canvas.getContext) {
        canvas.getContext('2d').restore();
        this.canvases.push(canvas);
      }
    }
  };
  var BlendMode = new function () {
    var min = Math.min,
        max = Math.max,
        abs = Math.abs,
        sr,
        sg,
        sb,
        sa,
        br,
        bg,
        bb,
        ba,
        dr,
        dg,
        db;

    function getLum(r, g, b) {
      return 0.2989 * r + 0.587 * g + 0.114 * b;
    }

    function setLum(r, g, b, l) {
      var d = l - getLum(r, g, b);
      dr = r + d;
      dg = g + d;
      db = b + d;
      var l = getLum(dr, dg, db),
          mn = min(dr, dg, db),
          mx = max(dr, dg, db);

      if (mn < 0) {
        var lmn = l - mn;
        dr = l + (dr - l) * l / lmn;
        dg = l + (dg - l) * l / lmn;
        db = l + (db - l) * l / lmn;
      }

      if (mx > 255) {
        var ln = 255 - l,
            mxl = mx - l;
        dr = l + (dr - l) * ln / mxl;
        dg = l + (dg - l) * ln / mxl;
        db = l + (db - l) * ln / mxl;
      }
    }

    function getSat(r, g, b) {
      return max(r, g, b) - min(r, g, b);
    }

    function setSat(r, g, b, s) {
      var col = [r, g, b],
          mx = max(r, g, b),
          mn = min(r, g, b),
          md;
      mn = mn === r ? 0 : mn === g ? 1 : 2;
      mx = mx === r ? 0 : mx === g ? 1 : 2;
      md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;

      if (col[mx] > col[mn]) {
        col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
        col[mx] = s;
      } else {
        col[md] = col[mx] = 0;
      }

      col[mn] = 0;
      dr = col[0];
      dg = col[1];
      db = col[2];
    }

    var modes = {
      multiply: function multiply() {
        dr = br * sr / 255;
        dg = bg * sg / 255;
        db = bb * sb / 255;
      },
      screen: function screen() {
        dr = br + sr - br * sr / 255;
        dg = bg + sg - bg * sg / 255;
        db = bb + sb - bb * sb / 255;
      },
      overlay: function overlay() {
        dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
        dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
        db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
      },
      'soft-light': function softLight() {
        var t = sr * br / 255;
        dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
        t = sg * bg / 255;
        dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
        t = sb * bb / 255;
        db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
      },
      'hard-light': function hardLight() {
        dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
        dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
        db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
      },
      'color-dodge': function colorDodge() {
        dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
        dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
        db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
      },
      'color-burn': function colorBurn() {
        dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
        dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
        db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
      },
      darken: function darken() {
        dr = br < sr ? br : sr;
        dg = bg < sg ? bg : sg;
        db = bb < sb ? bb : sb;
      },
      lighten: function lighten() {
        dr = br > sr ? br : sr;
        dg = bg > sg ? bg : sg;
        db = bb > sb ? bb : sb;
      },
      difference: function difference() {
        dr = br - sr;
        if (dr < 0) dr = -dr;
        dg = bg - sg;
        if (dg < 0) dg = -dg;
        db = bb - sb;
        if (db < 0) db = -db;
      },
      exclusion: function exclusion() {
        dr = br + sr * (255 - br - br) / 255;
        dg = bg + sg * (255 - bg - bg) / 255;
        db = bb + sb * (255 - bb - bb) / 255;
      },
      hue: function hue() {
        setSat(sr, sg, sb, getSat(br, bg, bb));
        setLum(dr, dg, db, getLum(br, bg, bb));
      },
      saturation: function saturation() {
        setSat(br, bg, bb, getSat(sr, sg, sb));
        setLum(dr, dg, db, getLum(br, bg, bb));
      },
      luminosity: function luminosity() {
        setLum(br, bg, bb, getLum(sr, sg, sb));
      },
      color: function color() {
        setLum(sr, sg, sb, getLum(br, bg, bb));
      },
      add: function add() {
        dr = min(br + sr, 255);
        dg = min(bg + sg, 255);
        db = min(bb + sb, 255);
      },
      subtract: function subtract() {
        dr = max(br - sr, 0);
        dg = max(bg - sg, 0);
        db = max(bb - sb, 0);
      },
      average: function average() {
        dr = (br + sr) / 2;
        dg = (bg + sg) / 2;
        db = (bb + sb) / 2;
      },
      negation: function negation() {
        dr = 255 - abs(255 - sr - br);
        dg = 255 - abs(255 - sg - bg);
        db = 255 - abs(255 - sb - bb);
      }
    };
    var nativeModes = this.nativeModes = Base.each(['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'darker', 'copy', 'xor'], function (mode) {
      this[mode] = true;
    }, {});
    var ctx = CanvasProvider.getContext(1, 1);

    if (ctx) {
      Base.each(modes, function (func, mode) {
        var darken = mode === 'darken',
            ok = false;
        ctx.save();

        try {
          ctx.fillStyle = darken ? '#300' : '#a00';
          ctx.fillRect(0, 0, 1, 1);
          ctx.globalCompositeOperation = mode;

          if (ctx.globalCompositeOperation === mode) {
            ctx.fillStyle = darken ? '#a00' : '#300';
            ctx.fillRect(0, 0, 1, 1);
            ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
          }
        } catch (e) {}

        ctx.restore();
        nativeModes[mode] = ok;
      });
      CanvasProvider.release(ctx);
    }

    this.process = function (mode, srcContext, dstContext, alpha, offset) {
      var srcCanvas = srcContext.canvas,
          normal = mode === 'normal';

      if (normal || nativeModes[mode]) {
        dstContext.save();
        dstContext.setTransform(1, 0, 0, 1, 0, 0);
        dstContext.globalAlpha = alpha;
        if (!normal) dstContext.globalCompositeOperation = mode;
        dstContext.drawImage(srcCanvas, offset.x, offset.y);
        dstContext.restore();
      } else {
        var process = modes[mode];
        if (!process) return;
        var dstData = dstContext.getImageData(offset.x, offset.y, srcCanvas.width, srcCanvas.height),
            dst = dstData.data,
            src = srcContext.getImageData(0, 0, srcCanvas.width, srcCanvas.height).data;

        for (var i = 0, l = dst.length; i < l; i += 4) {
          sr = src[i];
          br = dst[i];
          sg = src[i + 1];
          bg = dst[i + 1];
          sb = src[i + 2];
          bb = dst[i + 2];
          sa = src[i + 3];
          ba = dst[i + 3];
          process();
          var a1 = sa * alpha / 255,
              a2 = 1 - a1;
          dst[i] = a1 * dr + a2 * br;
          dst[i + 1] = a1 * dg + a2 * bg;
          dst[i + 2] = a1 * db + a2 * bb;
          dst[i + 3] = sa * alpha + a2 * ba;
        }

        dstContext.putImageData(dstData, offset.x, offset.y);
      }
    };
  }();
  var SvgElement = new function () {
    var svg = 'http://www.w3.org/2000/svg',
        xmlns = 'http://www.w3.org/2000/xmlns',
        xlink = 'http://www.w3.org/1999/xlink',
        attributeNamespace = {
      href: xlink,
      xlink: xmlns,
      xmlns: xmlns + '/',
      'xmlns:xlink': xmlns + '/'
    };

    function create(tag, attributes, formatter) {
      return set(document.createElementNS(svg, tag), attributes, formatter);
    }

    function get(node, name) {
      var namespace = attributeNamespace[name],
          value = namespace ? node.getAttributeNS(namespace, name) : node.getAttribute(name);
      return value === 'null' ? null : value;
    }

    function set(node, attributes, formatter) {
      for (var name in attributes) {
        var value = attributes[name],
            namespace = attributeNamespace[name];
        if (typeof value === 'number' && formatter) value = formatter.number(value);

        if (namespace) {
          node.setAttributeNS(namespace, name, value);
        } else {
          node.setAttribute(name, value);
        }
      }

      return node;
    }

    return {
      svg: svg,
      xmlns: xmlns,
      xlink: xlink,
      create: create,
      get: get,
      set: set
    };
  }();
  var SvgStyles = Base.each({
    fillColor: ['fill', 'color'],
    fillRule: ['fill-rule', 'string'],
    strokeColor: ['stroke', 'color'],
    strokeWidth: ['stroke-width', 'number'],
    strokeCap: ['stroke-linecap', 'string'],
    strokeJoin: ['stroke-linejoin', 'string'],
    strokeScaling: ['vector-effect', 'lookup', {
      true: 'none',
      false: 'non-scaling-stroke'
    }, function (item, value) {
      return !value && (item instanceof PathItem || item instanceof Shape || item instanceof TextItem);
    }],
    miterLimit: ['stroke-miterlimit', 'number'],
    dashArray: ['stroke-dasharray', 'array'],
    dashOffset: ['stroke-dashoffset', 'number'],
    fontFamily: ['font-family', 'string'],
    fontWeight: ['font-weight', 'string'],
    fontSize: ['font-size', 'number'],
    justification: ['text-anchor', 'lookup', {
      left: 'start',
      center: 'middle',
      right: 'end'
    }],
    opacity: ['opacity', 'number'],
    blendMode: ['mix-blend-mode', 'style']
  }, function (entry, key) {
    var part = Base.capitalize(key),
        lookup = entry[2];
    this[key] = {
      type: entry[1],
      property: key,
      attribute: entry[0],
      toSVG: lookup,
      fromSVG: lookup && Base.each(lookup, function (value, name) {
        this[value] = name;
      }, {}),
      exportFilter: entry[3],
      get: 'get' + part,
      set: 'set' + part
    };
  }, {});
  new function () {
    var formatter;

    function getTransform(matrix, coordinates, center) {
      var attrs = new Base(),
          trans = matrix.getTranslation();

      if (coordinates) {
        var point;

        if (matrix.isInvertible()) {
          matrix = matrix._shiftless();
          point = matrix._inverseTransform(trans);
          trans = null;
        } else {
          point = new Point();
        }

        attrs[center ? 'cx' : 'x'] = point.x;
        attrs[center ? 'cy' : 'y'] = point.y;
      }

      if (!matrix.isIdentity()) {
        var decomposed = matrix.decompose();

        if (decomposed) {
          var parts = [],
              angle = decomposed.rotation,
              scale = decomposed.scaling,
              skew = decomposed.skewing;
          if (trans && !trans.isZero()) parts.push('translate(' + formatter.point(trans) + ')');
          if (angle) parts.push('rotate(' + formatter.number(angle) + ')');
          if (!Numerical.isZero(scale.x - 1) || !Numerical.isZero(scale.y - 1)) parts.push('scale(' + formatter.point(scale) + ')');
          if (skew.x) parts.push('skewX(' + formatter.number(skew.x) + ')');
          if (skew.y) parts.push('skewY(' + formatter.number(skew.y) + ')');
          attrs.transform = parts.join(' ');
        } else {
          attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
        }
      }

      return attrs;
    }

    function exportGroup(item, options) {
      var attrs = getTransform(item._matrix),
          children = item._children;
      var node = SvgElement.create('g', attrs, formatter);

      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];

        var childNode = _exportSVG(child, options);

        if (childNode) {
          if (child.isClipMask()) {
            var clip = SvgElement.create('clipPath');
            clip.appendChild(childNode);
            setDefinition(child, clip, 'clip');
            SvgElement.set(node, {
              'clip-path': 'url(#' + clip.id + ')'
            });
          } else {
            node.appendChild(childNode);
          }
        }
      }

      return node;
    }

    function exportRaster(item, options) {
      var attrs = getTransform(item._matrix, true),
          size = item.getSize(),
          image = item.getImage();
      attrs.x -= size.width / 2;
      attrs.y -= size.height / 2;
      attrs.width = size.width;
      attrs.height = size.height;
      attrs.href = options.embedImages == false && image && image.src || item.toDataURL();
      return SvgElement.create('image', attrs, formatter);
    }

    function exportPath(item, options) {
      var matchShapes = options.matchShapes;

      if (matchShapes) {
        var shape = item.toShape(false);
        if (shape) return exportShape(shape, options);
      }

      var segments = item._segments,
          length = segments.length,
          type,
          attrs = getTransform(item._matrix);

      if (matchShapes && length >= 2 && !item.hasHandles()) {
        if (length > 2) {
          type = item._closed ? 'polygon' : 'polyline';
          var parts = [];

          for (var i = 0; i < length; i++) {
            parts.push(formatter.point(segments[i]._point));
          }

          attrs.points = parts.join(' ');
        } else {
          type = 'line';
          var start = segments[0]._point,
              end = segments[1]._point;
          attrs.set({
            x1: start.x,
            y1: start.y,
            x2: end.x,
            y2: end.y
          });
        }
      } else {
        type = 'path';
        attrs.d = item.getPathData(null, options.precision);
      }

      return SvgElement.create(type, attrs, formatter);
    }

    function exportShape(item) {
      var type = item._type,
          radius = item._radius,
          attrs = getTransform(item._matrix, true, type !== 'rectangle');

      if (type === 'rectangle') {
        type = 'rect';
        var size = item._size,
            width = size.width,
            height = size.height;
        attrs.x -= width / 2;
        attrs.y -= height / 2;
        attrs.width = width;
        attrs.height = height;
        if (radius.isZero()) radius = null;
      }

      if (radius) {
        if (type === 'circle') {
          attrs.r = radius;
        } else {
          attrs.rx = radius.width;
          attrs.ry = radius.height;
        }
      }

      return SvgElement.create(type, attrs, formatter);
    }

    function exportCompoundPath(item, options) {
      var attrs = getTransform(item._matrix);
      var data = item.getPathData(null, options.precision);
      if (data) attrs.d = data;
      return SvgElement.create('path', attrs, formatter);
    }

    function exportSymbolItem(item, options) {
      var attrs = getTransform(item._matrix, true),
          definition = item._definition,
          node = getDefinition(definition, 'symbol'),
          definitionItem = definition._item,
          bounds = definitionItem.getStrokeBounds();

      if (!node) {
        node = SvgElement.create('symbol', {
          viewBox: formatter.rectangle(bounds)
        });
        node.appendChild(_exportSVG(definitionItem, options));
        setDefinition(definition, node, 'symbol');
      }

      attrs.href = '#' + node.id;
      attrs.x += bounds.x;
      attrs.y += bounds.y;
      attrs.width = bounds.width;
      attrs.height = bounds.height;
      attrs.overflow = 'visible';
      return SvgElement.create('use', attrs, formatter);
    }

    function exportGradient(color) {
      var gradientNode = getDefinition(color, 'color');

      if (!gradientNode) {
        var gradient = color.getGradient(),
            radial = gradient._radial,
            origin = color.getOrigin(),
            destination = color.getDestination(),
            attrs;

        if (radial) {
          attrs = {
            cx: origin.x,
            cy: origin.y,
            r: origin.getDistance(destination)
          };
          var highlight = color.getHighlight();

          if (highlight) {
            attrs.fx = highlight.x;
            attrs.fy = highlight.y;
          }
        } else {
          attrs = {
            x1: origin.x,
            y1: origin.y,
            x2: destination.x,
            y2: destination.y
          };
        }

        attrs.gradientUnits = 'userSpaceOnUse';
        gradientNode = SvgElement.create((radial ? 'radial' : 'linear') + 'Gradient', attrs, formatter);
        var stops = gradient._stops;

        for (var i = 0, l = stops.length; i < l; i++) {
          var stop = stops[i],
              stopColor = stop._color,
              alpha = stopColor.getAlpha(),
              offset = stop._offset;
          attrs = {
            offset: offset == null ? i / (l - 1) : offset
          };
          if (stopColor) attrs['stop-color'] = stopColor.toCSS(true);
          if (alpha < 1) attrs['stop-opacity'] = alpha;
          gradientNode.appendChild(SvgElement.create('stop', attrs, formatter));
        }

        setDefinition(color, gradientNode, 'color');
      }

      return 'url(#' + gradientNode.id + ')';
    }

    function exportText(item) {
      var node = SvgElement.create('text', getTransform(item._matrix, true), formatter);
      node.textContent = item._content;
      return node;
    }

    var exporters = {
      Group: exportGroup,
      Layer: exportGroup,
      Raster: exportRaster,
      Path: exportPath,
      Shape: exportShape,
      CompoundPath: exportCompoundPath,
      SymbolItem: exportSymbolItem,
      PointText: exportText
    };

    function applyStyle(item, node, isRoot) {
      var attrs = {},
          parent = !isRoot && item.getParent(),
          style = [];
      if (item._name != null) attrs.id = item._name;
      Base.each(SvgStyles, function (entry) {
        var get = entry.get,
            type = entry.type,
            value = item[get]();

        if (entry.exportFilter ? entry.exportFilter(item, value) : !parent || !Base.equals(parent[get](), value)) {
          if (type === 'color' && value != null) {
            var alpha = value.getAlpha();
            if (alpha < 1) attrs[entry.attribute + '-opacity'] = alpha;
          }

          if (type === 'style') {
            style.push(entry.attribute + ': ' + value);
          } else {
            attrs[entry.attribute] = value == null ? 'none' : type === 'color' ? value.gradient ? exportGradient(value, item) : value.toCSS(true) : type === 'array' ? value.join(',') : type === 'lookup' ? entry.toSVG[value] : value;
          }
        }
      });
      if (style.length) attrs.style = style.join(';');
      if (attrs.opacity === 1) delete attrs.opacity;
      if (!item._visible) attrs.visibility = 'hidden';
      return SvgElement.set(node, attrs, formatter);
    }

    var definitions;

    function getDefinition(item, type) {
      if (!definitions) definitions = {
        ids: {},
        svgs: {}
      };
      return item && definitions.svgs[type + '-' + (item._id || item.__id || (item.__id = UID.get('svg')))];
    }

    function setDefinition(item, node, type) {
      if (!definitions) getDefinition();
      var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
      node.id = type + '-' + typeId;
      definitions.svgs[type + '-' + (item._id || item.__id)] = node;
    }

    function exportDefinitions(node, options) {
      var svg = node,
          defs = null;

      if (definitions) {
        svg = node.nodeName.toLowerCase() === 'svg' && node;

        for (var i in definitions.svgs) {
          if (!defs) {
            if (!svg) {
              svg = SvgElement.create('svg');
              svg.appendChild(node);
            }

            defs = svg.insertBefore(SvgElement.create('defs'), svg.firstChild);
          }

          defs.appendChild(definitions.svgs[i]);
        }

        definitions = null;
      }

      return options.asString ? new self.XMLSerializer().serializeToString(svg) : svg;
    }

    function _exportSVG(item, options, isRoot) {
      var exporter = exporters[item._class],
          node = exporter && exporter(item, options);

      if (node) {
        var onExport = options.onExport;
        if (onExport) node = onExport(item, node, options) || node;
        var data = JSON.stringify(item._data);
        if (data && data !== '{}' && data !== 'null') node.setAttribute('data-paper-data', data);
      }

      return node && applyStyle(item, node, isRoot);
    }

    function setOptions(options) {
      if (!options) options = {};
      formatter = new Formatter(options.precision);
      return options;
    }

    Item.inject({
      exportSVG: function exportSVG(options) {
        options = setOptions(options);
        return exportDefinitions(_exportSVG(this, options, true), options);
      }
    });
    Project.inject({
      exportSVG: function exportSVG(options) {
        options = setOptions(options);
        var children = this._children,
            view = this.getView(),
            bounds = Base.pick(options.bounds, 'view'),
            mx = options.matrix || bounds === 'view' && view._matrix,
            matrix = mx && Matrix.read([mx]),
            rect = bounds === 'view' ? new _Rectangle([0, 0], view.getViewSize()) : bounds === 'content' ? Item._getBounds(children, matrix, {
          stroke: true
        }).rect : _Rectangle.read([bounds], 0, {
          readNull: true
        }),
            attrs = {
          version: '1.1',
          xmlns: SvgElement.svg,
          'xmlns:xlink': SvgElement.xlink
        };

        if (rect) {
          attrs.width = rect.width;
          attrs.height = rect.height;
          if (rect.x || rect.x === 0 || rect.y || rect.y === 0) attrs.viewBox = formatter.rectangle(rect);
        }

        var node = SvgElement.create('svg', attrs, formatter),
            parent = node;

        if (matrix && !matrix.isIdentity()) {
          parent = node.appendChild(SvgElement.create('g', getTransform(matrix), formatter));
        }

        for (var i = 0, l = children.length; i < l; i++) {
          parent.appendChild(_exportSVG(children[i], options, true));
        }

        return exportDefinitions(node, options);
      }
    });
  }();
  new function () {
    var definitions = {},
        rootSize;

    function getValue(node, name, isString, allowNull, allowPercent, defaultValue) {
      var value = SvgElement.get(node, name) || defaultValue,
          res = value == null ? allowNull ? null : isString ? '' : 0 : isString ? value : parseFloat(value);
      return /%\s*$/.test(value) ? res / 100 * (allowPercent ? 1 : rootSize[/x|^width/.test(name) ? 'width' : 'height']) : res;
    }

    function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {
      x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
      y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
      return allowNull && (x == null || y == null) ? null : new Point(x, y);
    }

    function getSize(node, w, h, allowNull, allowPercent) {
      w = getValue(node, w || 'width', false, allowNull, allowPercent);
      h = getValue(node, h || 'height', false, allowNull, allowPercent);
      return allowNull && (w == null || h == null) ? null : new Size(w, h);
    }

    function convertValue(value, type, lookup) {
      return value === 'none' ? null : type === 'number' ? parseFloat(value) : type === 'array' ? value ? value.split(/[\s,]+/g).map(parseFloat) : [] : type === 'color' ? getDefinition(value) || value : type === 'lookup' ? lookup[value] : value;
    }

    function importGroup(node, type, options, isRoot) {
      var nodes = node.childNodes,
          isClip = type === 'clippath',
          isDefs = type === 'defs',
          item = new Group(),
          project = item._project,
          currentStyle = project._currentStyle,
          children = [];

      if (!isClip && !isDefs) {
        item = applyAttributes(item, node, isRoot);
        project._currentStyle = item._style.clone();
      }

      if (isRoot) {
        var defs = node.querySelectorAll('defs');

        for (var i = 0, l = defs.length; i < l; i++) {
          importNode(defs[i], options, false);
        }
      }

      for (var i = 0, l = nodes.length; i < l; i++) {
        var childNode = nodes[i],
            child;
        if (childNode.nodeType === 1 && !/^defs$/i.test(childNode.nodeName) && (child = importNode(childNode, options, false)) && !(child instanceof SymbolDefinition)) children.push(child);
      }

      item.addChildren(children);
      if (isClip) item = applyAttributes(item.reduce(), node, isRoot);
      project._currentStyle = currentStyle;

      if (isClip || isDefs) {
        item.remove();
        item = null;
      }

      return item;
    }

    function importPoly(node, type) {
      var coords = node.getAttribute('points').match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
          points = [];

      for (var i = 0, l = coords.length; i < l; i += 2) {
        points.push(new Point(parseFloat(coords[i]), parseFloat(coords[i + 1])));
      }

      var path = new Path(points);
      if (type === 'polygon') path.closePath();
      return path;
    }

    function importPath(node) {
      return PathItem.create(node.getAttribute('d'));
    }

    function importGradient(node, type) {
      var id = (getValue(node, 'href', true) || '').substring(1),
          radial = type === 'radialgradient',
          gradient;

      if (id) {
        gradient = definitions[id].getGradient();

        if (gradient._radial ^ radial) {
          gradient = gradient.clone();
          gradient._radial = radial;
        }
      } else {
        var nodes = node.childNodes,
            stops = [];

        for (var i = 0, l = nodes.length; i < l; i++) {
          var child = nodes[i];
          if (child.nodeType === 1) stops.push(applyAttributes(new GradientStop(), child));
        }

        gradient = new Gradient(stops, radial);
      }

      var origin,
          destination,
          highlight,
          scaleToBounds = getValue(node, 'gradientUnits', true) !== 'userSpaceOnUse';

      if (radial) {
        origin = getPoint(node, 'cx', 'cy', false, scaleToBounds, '50%', '50%');
        destination = origin.add(getValue(node, 'r', false, false, scaleToBounds, '50%'), 0);
        highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
      } else {
        origin = getPoint(node, 'x1', 'y1', false, scaleToBounds, '0%', '0%');
        destination = getPoint(node, 'x2', 'y2', false, scaleToBounds, '100%', '0%');
      }

      var color = applyAttributes(new Color(gradient, origin, destination, highlight), node);
      color._scaleToBounds = scaleToBounds;
      return null;
    }

    var importers = {
      '#document': function document(node, type, options, isRoot) {
        var nodes = node.childNodes;

        for (var i = 0, l = nodes.length; i < l; i++) {
          var child = nodes[i];
          if (child.nodeType === 1) return importNode(child, options, isRoot);
        }
      },
      g: importGroup,
      svg: importGroup,
      clippath: importGroup,
      polygon: importPoly,
      polyline: importPoly,
      path: importPath,
      lineargradient: importGradient,
      radialgradient: importGradient,
      image: function image(node) {
        var raster = new Raster(getValue(node, 'href', true));
        raster.on('load', function () {
          var size = getSize(node);
          this.setSize(size);
          var center = getPoint(node).add(size.divide(2));

          this._matrix.append(new Matrix().translate(center));
        });
        return raster;
      },
      symbol: function symbol(node, type, options, isRoot) {
        return new SymbolDefinition(importGroup(node, type, options, isRoot), true);
      },
      defs: importGroup,
      use: function use(node) {
        var id = (getValue(node, 'href', true) || '').substring(1),
            definition = definitions[id],
            point = getPoint(node);
        return definition ? definition instanceof SymbolDefinition ? definition.place(point) : definition.clone().translate(point) : null;
      },
      circle: function circle(node) {
        return new Shape.Circle(getPoint(node, 'cx', 'cy'), getValue(node, 'r'));
      },
      ellipse: function ellipse(node) {
        return new Shape.Ellipse({
          center: getPoint(node, 'cx', 'cy'),
          radius: getSize(node, 'rx', 'ry')
        });
      },
      rect: function rect(node) {
        return new Shape.Rectangle(new _Rectangle(getPoint(node), getSize(node)), getSize(node, 'rx', 'ry'));
      },
      line: function line(node) {
        return new Path.Line(getPoint(node, 'x1', 'y1'), getPoint(node, 'x2', 'y2'));
      },
      text: function text(node) {
        var text = new PointText(getPoint(node).add(getPoint(node, 'dx', 'dy')));
        text.setContent(node.textContent.trim() || '');
        return text;
      },
      switch: importGroup
    };

    function applyTransform(item, value, name, node) {
      if (item.transform) {
        var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
            matrix = new Matrix();

        for (var i = 0, l = transforms.length; i < l; i++) {
          var transform = transforms[i];
          if (!transform) break;
          var parts = transform.split(/\(\s*/),
              command = parts[0],
              v = parts[1].split(/[\s,]+/g);

          for (var j = 0, m = v.length; j < m; j++) {
            v[j] = parseFloat(v[j]);
          }

          switch (command) {
            case 'matrix':
              matrix.append(new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
              break;

            case 'rotate':
              matrix.rotate(v[0], v[1] || 0, v[2] || 0);
              break;

            case 'translate':
              matrix.translate(v[0], v[1] || 0);
              break;

            case 'scale':
              matrix.scale(v);
              break;

            case 'skewX':
              matrix.skew(v[0], 0);
              break;

            case 'skewY':
              matrix.skew(0, v[0]);
              break;
          }
        }

        item.transform(matrix);
      }
    }

    function applyOpacity(item, value, name) {
      var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
          color = item[key] && item[key]();
      if (color) color.setAlpha(parseFloat(value));
    }

    var attributes = Base.set(Base.each(SvgStyles, function (entry) {
      this[entry.attribute] = function (item, value) {
        if (item[entry.set]) {
          item[entry.set](convertValue(value, entry.type, entry.fromSVG));

          if (entry.type === 'color') {
            var color = item[entry.get]();

            if (color) {
              if (color._scaleToBounds) {
                var bounds = item.getBounds();
                color.transform(new Matrix().translate(bounds.getPoint()).scale(bounds.getSize()));
              }
            }
          }
        }
      };
    }, {}), {
      id: function id(item, value) {
        definitions[value] = item;
        if (item.setName) item.setName(value);
      },
      'clip-path': function clipPath(item, value) {
        var clip = getDefinition(value);

        if (clip) {
          clip = clip.clone();
          clip.setClipMask(true);

          if (item instanceof Group) {
            item.insertChild(0, clip);
          } else {
            return new Group(clip, item);
          }
        }
      },
      gradientTransform: applyTransform,
      transform: applyTransform,
      'fill-opacity': applyOpacity,
      'stroke-opacity': applyOpacity,
      visibility: function visibility(item, value) {
        if (item.setVisible) item.setVisible(value === 'visible');
      },
      display: function display(item, value) {
        if (item.setVisible) item.setVisible(value !== null);
      },
      'stop-color': function stopColor(item, value) {
        if (item.setColor) item.setColor(value);
      },
      'stop-opacity': function stopOpacity(item, value) {
        if (item._color) item._color.setAlpha(parseFloat(value));
      },
      offset: function offset(item, value) {
        if (item.setOffset) {
          var percent = value.match(/(.*)%$/);
          item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
        }
      },
      viewBox: function viewBox(item, value, name, node, styles) {
        var rect = new _Rectangle(convertValue(value, 'array')),
            size = getSize(node, null, null, true),
            group,
            matrix;

        if (item instanceof Group) {
          var scale = size ? size.divide(rect.getSize()) : 1,
              matrix = new Matrix().scale(scale).translate(rect.getPoint().negate());
          group = item;
        } else if (item instanceof SymbolDefinition) {
          if (size) rect.setSize(size);
          group = item._item;
        }

        if (group) {
          if (getAttribute(node, 'overflow', styles) !== 'visible') {
            var clip = new Shape.Rectangle(rect);
            clip.setClipMask(true);
            group.addChild(clip);
          }

          if (matrix) group.transform(matrix);
        }
      }
    });

    function getAttribute(node, name, styles) {
      var attr = node.attributes[name],
          value = attr && attr.value;

      if (!value && node.style) {
        var style = Base.camelize(name);
        value = node.style[style];
        if (!value && styles.node[style] !== styles.parent[style]) value = styles.node[style];
      }

      return !value ? undefined : value === 'none' ? null : value;
    }

    function applyAttributes(item, node, isRoot) {
      var parent = node.parentNode,
          styles = {
        node: DomElement.getStyles(node) || {},
        parent: !isRoot && !/^defs$/i.test(parent.tagName) && DomElement.getStyles(parent) || {}
      };
      Base.each(attributes, function (apply, name) {
        var value = getAttribute(node, name, styles);
        item = value !== undefined && apply(item, value, name, node, styles) || item;
      });
      return item;
    }

    function getDefinition(value) {
      var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
          name = match && match[1],
          res = name && definitions[window ? name.replace(window.location.href.split('#')[0] + '#', '') : name];

      if (res && res._scaleToBounds) {
        res = res.clone();
        res._scaleToBounds = true;
      }

      return res;
    }

    function importNode(node, options, isRoot) {
      var type = node.nodeName.toLowerCase(),
          isElement = type !== '#document',
          body = document.body,
          container,
          parent,
          next;

      if (isRoot && isElement) {
        rootSize = paper.getView().getSize();
        rootSize = getSize(node, null, null, true) || rootSize;
        container = SvgElement.create('svg', {
          style: 'stroke-width: 1px; stroke-miterlimit: 10'
        });
        parent = node.parentNode;
        next = node.nextSibling;
        container.appendChild(node);
        body.appendChild(container);
      }

      var settings = paper.settings,
          applyMatrix = settings.applyMatrix,
          insertItems = settings.insertItems;
      settings.applyMatrix = false;
      settings.insertItems = false;
      var importer = importers[type],
          item = importer && importer(node, type, options, isRoot) || null;
      settings.insertItems = insertItems;
      settings.applyMatrix = applyMatrix;

      if (item) {
        if (isElement && !(item instanceof Group)) item = applyAttributes(item, node, isRoot);
        var onImport = options.onImport,
            data = isElement && node.getAttribute('data-paper-data');
        if (onImport) item = onImport(node, item, options) || item;

        if (options.expandShapes && item instanceof Shape) {
          item.remove();
          item = item.toPath();
        }

        if (data) item._data = JSON.parse(data);
      }

      if (container) {
        body.removeChild(container);

        if (parent) {
          if (next) {
            parent.insertBefore(node, next);
          } else {
            parent.appendChild(node);
          }
        }
      }

      if (isRoot) {
        definitions = {};
        if (item && Base.pick(options.applyMatrix, applyMatrix)) item.matrix.apply(true, true);
      }

      return item;
    }

    function _importSVG(source, options, owner) {
      if (!source) return null;
      options = typeof options === 'function' ? {
        onLoad: options
      } : options || {};
      var scope = paper,
          item = null;

      function onLoad(svg) {
        try {
          var node = _typeof(svg) === 'object' ? svg : new self.DOMParser().parseFromString(svg.trim(), 'image/svg+xml');

          if (!node.nodeName) {
            node = null;
            throw new Error('Unsupported SVG source: ' + source);
          }

          paper = scope;
          item = importNode(node, options, true);

          if (!options || options.insert !== false) {
            owner._insertItem(undefined, item);
          }

          var onLoad = options.onLoad;
          if (onLoad) onLoad(item, svg);
        } catch (e) {
          onError(e);
        }
      }

      function onError(message, status) {
        var onError = options.onError;

        if (onError) {
          onError(message, status);
        } else {
          throw new Error(message);
        }
      }

      if (typeof source === 'string' && !/^[\s\S]*</.test(source)) {
        var node = document.getElementById(source);

        if (node) {
          onLoad(node);
        } else {
          Http.request({
            url: source,
            async: true,
            onLoad: onLoad,
            onError: onError
          });
        }
      } else if (typeof File !== 'undefined' && source instanceof File) {
        var reader = new FileReader();

        reader.onload = function () {
          onLoad(reader.result);
        };

        reader.onerror = function () {
          onError(reader.error);
        };

        return reader.readAsText(source);
      } else {
        onLoad(source);
      }

      return item;
    }

    Item.inject({
      importSVG: function importSVG(node, options) {
        return _importSVG(node, options, this);
      }
    });
    Project.inject({
      importSVG: function importSVG(node, options) {
        this.activate();
        return _importSVG(node, options, this);
      }
    });
  }();

  Base.exports.PaperScript = function () {
    var global = this,
        acorn = global.acorn;

    if (!acorn && typeof require !== 'undefined') {
      try {
        acorn = require('acorn');
      } catch (e) {}
    }

    if (!acorn) {
      var exports, module;
      acorn = exports = module = {};

      (function (root, mod) {
        if (_typeof(exports) == "object" && _typeof(module) == "object") return mod(exports);
        if (typeof define == "function" && define.amd) return define(["exports"], mod);
        mod(root.acorn || (root.acorn = {}));
      })(this, function (exports) {
        "use strict";

        exports.version = "0.5.0";
        var options, input, inputLen, sourceFile;

        exports.parse = function (inpt, opts) {
          input = String(inpt);
          inputLen = input.length;
          setOptions(opts);
          initTokenState();
          return parseTopLevel(options.program);
        };

        var defaultOptions = exports.defaultOptions = {
          ecmaVersion: 5,
          strictSemicolons: false,
          allowTrailingCommas: true,
          forbidReserved: false,
          allowReturnOutsideFunction: false,
          locations: false,
          onComment: null,
          ranges: false,
          program: null,
          sourceFile: null,
          directSourceFile: null
        };

        function setOptions(opts) {
          options = opts || {};

          for (var opt in defaultOptions) {
            if (!Object.prototype.hasOwnProperty.call(options, opt)) options[opt] = defaultOptions[opt];
          }

          sourceFile = options.sourceFile || null;
        }

        var getLineInfo = exports.getLineInfo = function (input, offset) {
          for (var line = 1, cur = 0;;) {
            lineBreak.lastIndex = cur;
            var match = lineBreak.exec(input);

            if (match && match.index < offset) {
              ++line;
              cur = match.index + match[0].length;
            } else break;
          }

          return {
            line: line,
            column: offset - cur
          };
        };

        exports.tokenize = function (inpt, opts) {
          input = String(inpt);
          inputLen = input.length;
          setOptions(opts);
          initTokenState();
          var t = {};

          function getToken(forceRegexp) {
            lastEnd = tokEnd;
            readToken(forceRegexp);
            t.start = tokStart;
            t.end = tokEnd;
            t.startLoc = tokStartLoc;
            t.endLoc = tokEndLoc;
            t.type = tokType;
            t.value = tokVal;
            return t;
          }

          getToken.jumpTo = function (pos, reAllowed) {
            tokPos = pos;

            if (options.locations) {
              tokCurLine = 1;
              tokLineStart = lineBreak.lastIndex = 0;
              var match;

              while ((match = lineBreak.exec(input)) && match.index < pos) {
                ++tokCurLine;
                tokLineStart = match.index + match[0].length;
              }
            }

            tokRegexpAllowed = reAllowed;
            skipSpace();
          };

          return getToken;
        };

        var tokPos;
        var tokStart, tokEnd;
        var tokStartLoc, tokEndLoc;
        var tokType, tokVal;
        var tokRegexpAllowed;
        var tokCurLine, tokLineStart;
        var lastStart, lastEnd, lastEndLoc;
        var inFunction, labels, strict;

        function raise(pos, message) {
          var loc = getLineInfo(input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          err.pos = pos;
          err.loc = loc;
          err.raisedAt = tokPos;
          throw err;
        }

        var empty = [];
        var _num = {
          type: "num"
        },
            _regexp = {
          type: "regexp"
        },
            _string = {
          type: "string"
        };
        var _name = {
          type: "name"
        },
            _eof = {
          type: "eof"
        };
        var _break = {
          keyword: "break"
        },
            _case = {
          keyword: "case",
          beforeExpr: true
        },
            _catch = {
          keyword: "catch"
        };
        var _continue = {
          keyword: "continue"
        },
            _debugger = {
          keyword: "debugger"
        },
            _default = {
          keyword: "default"
        };
        var _do = {
          keyword: "do",
          isLoop: true
        },
            _else = {
          keyword: "else",
          beforeExpr: true
        };
        var _finally = {
          keyword: "finally"
        },
            _for = {
          keyword: "for",
          isLoop: true
        },
            _function = {
          keyword: "function"
        };
        var _if = {
          keyword: "if"
        },
            _return = {
          keyword: "return",
          beforeExpr: true
        },
            _switch = {
          keyword: "switch"
        };
        var _throw = {
          keyword: "throw",
          beforeExpr: true
        },
            _try = {
          keyword: "try"
        },
            _var = {
          keyword: "var"
        };
        var _while = {
          keyword: "while",
          isLoop: true
        },
            _with = {
          keyword: "with"
        },
            _new = {
          keyword: "new",
          beforeExpr: true
        };
        var _this = {
          keyword: "this"
        };
        var _null = {
          keyword: "null",
          atomValue: null
        },
            _true = {
          keyword: "true",
          atomValue: true
        };
        var _false = {
          keyword: "false",
          atomValue: false
        };
        var _in = {
          keyword: "in",
          binop: 7,
          beforeExpr: true
        };
        var keywordTypes = {
          "break": _break,
          "case": _case,
          "catch": _catch,
          "continue": _continue,
          "debugger": _debugger,
          "default": _default,
          "do": _do,
          "else": _else,
          "finally": _finally,
          "for": _for,
          "function": _function,
          "if": _if,
          "return": _return,
          "switch": _switch,
          "throw": _throw,
          "try": _try,
          "var": _var,
          "while": _while,
          "with": _with,
          "null": _null,
          "true": _true,
          "false": _false,
          "new": _new,
          "in": _in,
          "instanceof": {
            keyword: "instanceof",
            binop: 7,
            beforeExpr: true
          },
          "this": _this,
          "typeof": {
            keyword: "typeof",
            prefix: true,
            beforeExpr: true
          },
          "void": {
            keyword: "void",
            prefix: true,
            beforeExpr: true
          },
          "delete": {
            keyword: "delete",
            prefix: true,
            beforeExpr: true
          }
        };
        var _bracketL = {
          type: "[",
          beforeExpr: true
        },
            _bracketR = {
          type: "]"
        },
            _braceL = {
          type: "{",
          beforeExpr: true
        };
        var _braceR = {
          type: "}"
        },
            _parenL = {
          type: "(",
          beforeExpr: true
        },
            _parenR = {
          type: ")"
        };
        var _comma = {
          type: ",",
          beforeExpr: true
        },
            _semi = {
          type: ";",
          beforeExpr: true
        };
        var _colon = {
          type: ":",
          beforeExpr: true
        },
            _dot = {
          type: "."
        },
            _question = {
          type: "?",
          beforeExpr: true
        };
        var _slash = {
          binop: 10,
          beforeExpr: true
        },
            _eq = {
          isAssign: true,
          beforeExpr: true
        };
        var _assign = {
          isAssign: true,
          beforeExpr: true
        };
        var _incDec = {
          postfix: true,
          prefix: true,
          isUpdate: true
        },
            _prefix = {
          prefix: true,
          beforeExpr: true
        };
        var _logicalOR = {
          binop: 1,
          beforeExpr: true
        };
        var _logicalAND = {
          binop: 2,
          beforeExpr: true
        };
        var _bitwiseOR = {
          binop: 3,
          beforeExpr: true
        };
        var _bitwiseXOR = {
          binop: 4,
          beforeExpr: true
        };
        var _bitwiseAND = {
          binop: 5,
          beforeExpr: true
        };
        var _equality = {
          binop: 6,
          beforeExpr: true
        };
        var _relational = {
          binop: 7,
          beforeExpr: true
        };
        var _bitShift = {
          binop: 8,
          beforeExpr: true
        };
        var _plusMin = {
          binop: 9,
          prefix: true,
          beforeExpr: true
        };
        var _multiplyModulo = {
          binop: 10,
          beforeExpr: true
        };
        exports.tokTypes = {
          bracketL: _bracketL,
          bracketR: _bracketR,
          braceL: _braceL,
          braceR: _braceR,
          parenL: _parenL,
          parenR: _parenR,
          comma: _comma,
          semi: _semi,
          colon: _colon,
          dot: _dot,
          question: _question,
          slash: _slash,
          eq: _eq,
          name: _name,
          eof: _eof,
          num: _num,
          regexp: _regexp,
          string: _string
        };

        for (var kw in keywordTypes) {
          exports.tokTypes["_" + kw] = keywordTypes[kw];
        }

        function makePredicate(words) {
          words = words.split(" ");
          var f = "",
              cats = [];

          out: for (var i = 0; i < words.length; ++i) {
            for (var j = 0; j < cats.length; ++j) {
              if (cats[j][0].length == words[i].length) {
                cats[j].push(words[i]);
                continue out;
              }
            }

            cats.push([words[i]]);
          }

          function compareTo(arr) {
            if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
            f += "switch(str){";

            for (var i = 0; i < arr.length; ++i) {
              f += "case " + JSON.stringify(arr[i]) + ":";
            }

            f += "return true}return false;";
          }

          if (cats.length > 3) {
            cats.sort(function (a, b) {
              return b.length - a.length;
            });
            f += "switch(str.length){";

            for (var i = 0; i < cats.length; ++i) {
              var cat = cats[i];
              f += "case " + cat[0].length + ":";
              compareTo(cat);
            }

            f += "}";
          } else {
            compareTo(words);
          }

          return new Function("str", f);
        }

        var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");
        var isReservedWord5 = makePredicate("class enum extends super const export import");
        var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");
        var isStrictBadIdWord = makePredicate("eval arguments");
        var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");
        var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
        var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
        var nonASCIIidentifierChars = "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u0620-\u0649\u0672-\u06D3\u06E7-\u06E8\u06FB-\u06FC\u0730-\u074A\u0800-\u0814\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0840-\u0857\u08E4-\u08FE\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962-\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09D7\u09DF-\u09E0\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5F-\u0B60\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2-\u0CE3\u0CE6-\u0CEF\u0D02\u0D03\u0D46-\u0D48\u0D57\u0D62-\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E34-\u0E3A\u0E40-\u0E45\u0E50-\u0E59\u0EB4-\u0EB9\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F41-\u0F47\u0F71-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1029\u1040-\u1049\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u170E-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17B2\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1920-\u192B\u1930-\u193B\u1951-\u196D\u19B0-\u19C0\u19C8-\u19C9\u19D0-\u19D9\u1A00-\u1A15\u1A20-\u1A53\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1B46-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C00-\u1C22\u1C40-\u1C49\u1C5B-\u1C7D\u1CD0-\u1CD2\u1D00-\u1DBE\u1E01-\u1F15\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2D81-\u2D96\u2DE0-\u2DFF\u3021-\u3028\u3099\u309A\uA640-\uA66D\uA674-\uA67D\uA69F\uA6F0-\uA6F1\uA7F8-\uA800\uA806\uA80B\uA823-\uA827\uA880-\uA881\uA8B4-\uA8C4\uA8D0-\uA8D9\uA8F3-\uA8F7\uA900-\uA909\uA926-\uA92D\uA930-\uA945\uA980-\uA983\uA9B3-\uA9C0\uAA00-\uAA27\uAA40-\uAA41\uAA4C-\uAA4D\uAA50-\uAA59\uAA7B\uAAE0-\uAAE9\uAAF2-\uAAF3\uABC0-\uABE1\uABEC\uABED\uABF0-\uABF9\uFB20-\uFB28\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        var newline = /[\n\r\u2028\u2029]/;
        var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

        var isIdentifierStart = exports.isIdentifierStart = function (code) {
          if (code < 65) return code === 36;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
        };

        var isIdentifierChar = exports.isIdentifierChar = function (code) {
          if (code < 48) return code === 36;
          if (code < 58) return true;
          if (code < 65) return false;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
        };

        function line_loc_t() {
          this.line = tokCurLine;
          this.column = tokPos - tokLineStart;
        }

        function initTokenState() {
          tokCurLine = 1;
          tokPos = tokLineStart = 0;
          tokRegexpAllowed = true;
          skipSpace();
        }

        function finishToken(type, val) {
          tokEnd = tokPos;
          if (options.locations) tokEndLoc = new line_loc_t();
          tokType = type;
          skipSpace();
          tokVal = val;
          tokRegexpAllowed = type.beforeExpr;
        }

        function skipBlockComment() {
          var startLoc = options.onComment && options.locations && new line_loc_t();
          var start = tokPos,
              end = input.indexOf("*/", tokPos += 2);
          if (end === -1) raise(tokPos - 2, "Unterminated comment");
          tokPos = end + 2;

          if (options.locations) {
            lineBreak.lastIndex = start;
            var match;

            while ((match = lineBreak.exec(input)) && match.index < tokPos) {
              ++tokCurLine;
              tokLineStart = match.index + match[0].length;
            }
          }

          if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t());
        }

        function skipLineComment() {
          var start = tokPos;
          var startLoc = options.onComment && options.locations && new line_loc_t();
          var ch = input.charCodeAt(tokPos += 2);

          while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
            ++tokPos;
            ch = input.charCodeAt(tokPos);
          }

          if (options.onComment) options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t());
        }

        function skipSpace() {
          while (tokPos < inputLen) {
            var ch = input.charCodeAt(tokPos);

            if (ch === 32) {
              ++tokPos;
            } else if (ch === 13) {
              ++tokPos;
              var next = input.charCodeAt(tokPos);

              if (next === 10) {
                ++tokPos;
              }

              if (options.locations) {
                ++tokCurLine;
                tokLineStart = tokPos;
              }
            } else if (ch === 10 || ch === 8232 || ch === 8233) {
              ++tokPos;

              if (options.locations) {
                ++tokCurLine;
                tokLineStart = tokPos;
              }
            } else if (ch > 8 && ch < 14) {
              ++tokPos;
            } else if (ch === 47) {
              var next = input.charCodeAt(tokPos + 1);

              if (next === 42) {
                skipBlockComment();
              } else if (next === 47) {
                skipLineComment();
              } else break;
            } else if (ch === 160) {
              ++tokPos;
            } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
              ++tokPos;
            } else {
              break;
            }
          }
        }

        function readToken_dot() {
          var next = input.charCodeAt(tokPos + 1);
          if (next >= 48 && next <= 57) return readNumber(true);
          ++tokPos;
          return finishToken(_dot);
        }

        function readToken_slash() {
          var next = input.charCodeAt(tokPos + 1);

          if (tokRegexpAllowed) {
            ++tokPos;
            return readRegexp();
          }

          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_slash, 1);
        }

        function readToken_mult_modulo() {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_multiplyModulo, 1);
        }

        function readToken_pipe_amp(code) {
          var next = input.charCodeAt(tokPos + 1);
          if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
        }

        function readToken_caret() {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_bitwiseXOR, 1);
        }

        function readToken_plus_min(code) {
          var next = input.charCodeAt(tokPos + 1);

          if (next === code) {
            if (next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {
              tokPos += 3;
              skipLineComment();
              skipSpace();
              return readToken();
            }

            return finishOp(_incDec, 2);
          }

          if (next === 61) return finishOp(_assign, 2);
          return finishOp(_plusMin, 1);
        }

        function readToken_lt_gt(code) {
          var next = input.charCodeAt(tokPos + 1);
          var size = 1;

          if (next === code) {
            size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
            if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
            return finishOp(_bitShift, size);
          }

          if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {
            tokPos += 4;
            skipLineComment();
            skipSpace();
            return readToken();
          }

          if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
          return finishOp(_relational, size);
        }

        function readToken_eq_excl(code) {
          var next = input.charCodeAt(tokPos + 1);
          if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
          return finishOp(code === 61 ? _eq : _prefix, 1);
        }

        function getTokenFromCode(code) {
          switch (code) {
            case 46:
              return readToken_dot();

            case 40:
              ++tokPos;
              return finishToken(_parenL);

            case 41:
              ++tokPos;
              return finishToken(_parenR);

            case 59:
              ++tokPos;
              return finishToken(_semi);

            case 44:
              ++tokPos;
              return finishToken(_comma);

            case 91:
              ++tokPos;
              return finishToken(_bracketL);

            case 93:
              ++tokPos;
              return finishToken(_bracketR);

            case 123:
              ++tokPos;
              return finishToken(_braceL);

            case 125:
              ++tokPos;
              return finishToken(_braceR);

            case 58:
              ++tokPos;
              return finishToken(_colon);

            case 63:
              ++tokPos;
              return finishToken(_question);

            case 48:
              var next = input.charCodeAt(tokPos + 1);
              if (next === 120 || next === 88) return readHexNumber();

            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return readNumber(false);

            case 34:
            case 39:
              return readString(code);

            case 47:
              return readToken_slash(code);

            case 37:
            case 42:
              return readToken_mult_modulo();

            case 124:
            case 38:
              return readToken_pipe_amp(code);

            case 94:
              return readToken_caret();

            case 43:
            case 45:
              return readToken_plus_min(code);

            case 60:
            case 62:
              return readToken_lt_gt(code);

            case 61:
            case 33:
              return readToken_eq_excl(code);

            case 126:
              return finishOp(_prefix, 1);
          }

          return false;
        }

        function readToken(forceRegexp) {
          if (!forceRegexp) tokStart = tokPos;else tokPos = tokStart + 1;
          if (options.locations) tokStartLoc = new line_loc_t();
          if (forceRegexp) return readRegexp();
          if (tokPos >= inputLen) return finishToken(_eof);
          var code = input.charCodeAt(tokPos);
          if (isIdentifierStart(code) || code === 92) return readWord();
          var tok = getTokenFromCode(code);

          if (tok === false) {
            var ch = String.fromCharCode(code);
            if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
            raise(tokPos, "Unexpected character '" + ch + "'");
          }

          return tok;
        }

        function finishOp(type, size) {
          var str = input.slice(tokPos, tokPos + size);
          tokPos += size;
          finishToken(type, str);
        }

        function readRegexp() {
          var content = "",
              escaped,
              inClass,
              start = tokPos;

          for (;;) {
            if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
            var ch = input.charAt(tokPos);
            if (newline.test(ch)) raise(start, "Unterminated regular expression");

            if (!escaped) {
              if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
              escaped = ch === "\\";
            } else escaped = false;

            ++tokPos;
          }

          var content = input.slice(start, tokPos);
          ++tokPos;
          var mods = readWord1();
          if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");

          try {
            var value = new RegExp(content, mods);
          } catch (e) {
            if (e instanceof SyntaxError) raise(start, e.message);
            raise(e);
          }

          return finishToken(_regexp, value);
        }

        function readInt(radix, len) {
          var start = tokPos,
              total = 0;

          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
            var code = input.charCodeAt(tokPos),
                val;
            if (code >= 97) val = code - 97 + 10;else if (code >= 65) val = code - 65 + 10;else if (code >= 48 && code <= 57) val = code - 48;else val = Infinity;
            if (val >= radix) break;
            ++tokPos;
            total = total * radix + val;
          }

          if (tokPos === start || len != null && tokPos - start !== len) return null;
          return total;
        }

        function readHexNumber() {
          tokPos += 2;
          var val = readInt(16);
          if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
          if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
          return finishToken(_num, val);
        }

        function readNumber(startsWithDot) {
          var start = tokPos,
              isFloat = false,
              octal = input.charCodeAt(tokPos) === 48;
          if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");

          if (input.charCodeAt(tokPos) === 46) {
            ++tokPos;
            readInt(10);
            isFloat = true;
          }

          var next = input.charCodeAt(tokPos);

          if (next === 69 || next === 101) {
            next = input.charCodeAt(++tokPos);
            if (next === 43 || next === 45) ++tokPos;
            if (readInt(10) === null) raise(start, "Invalid number");
            isFloat = true;
          }

          if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
          var str = input.slice(start, tokPos),
              val;
          if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || strict) raise(start, "Invalid number");else val = parseInt(str, 8);
          return finishToken(_num, val);
        }

        function readString(quote) {
          tokPos++;
          var out = "";

          for (;;) {
            if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
            var ch = input.charCodeAt(tokPos);

            if (ch === quote) {
              ++tokPos;
              return finishToken(_string, out);
            }

            if (ch === 92) {
              ch = input.charCodeAt(++tokPos);
              var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
              if (octal) octal = octal[0];

              while (octal && parseInt(octal, 8) > 255) {
                octal = octal.slice(0, -1);
              }

              if (octal === "0") octal = null;
              ++tokPos;

              if (octal) {
                if (strict) raise(tokPos - 2, "Octal literal in strict mode");
                out += String.fromCharCode(parseInt(octal, 8));
                tokPos += octal.length - 1;
              } else {
                switch (ch) {
                  case 110:
                    out += "\n";
                    break;

                  case 114:
                    out += "\r";
                    break;

                  case 120:
                    out += String.fromCharCode(readHexChar(2));
                    break;

                  case 117:
                    out += String.fromCharCode(readHexChar(4));
                    break;

                  case 85:
                    out += String.fromCharCode(readHexChar(8));
                    break;

                  case 116:
                    out += "\t";
                    break;

                  case 98:
                    out += "\b";
                    break;

                  case 118:
                    out += "\x0B";
                    break;

                  case 102:
                    out += "\f";
                    break;

                  case 48:
                    out += "\0";
                    break;

                  case 13:
                    if (input.charCodeAt(tokPos) === 10) ++tokPos;

                  case 10:
                    if (options.locations) {
                      tokLineStart = tokPos;
                      ++tokCurLine;
                    }

                    break;

                  default:
                    out += String.fromCharCode(ch);
                    break;
                }
              }
            } else {
              if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
              out += String.fromCharCode(ch);
              ++tokPos;
            }
          }
        }

        function readHexChar(len) {
          var n = readInt(16, len);
          if (n === null) raise(tokStart, "Bad character escape sequence");
          return n;
        }

        var containsEsc;

        function readWord1() {
          containsEsc = false;
          var word,
              first = true,
              start = tokPos;

          for (;;) {
            var ch = input.charCodeAt(tokPos);

            if (isIdentifierChar(ch)) {
              if (containsEsc) word += input.charAt(tokPos);
              ++tokPos;
            } else if (ch === 92) {
              if (!containsEsc) word = input.slice(start, tokPos);
              containsEsc = true;
              if (input.charCodeAt(++tokPos) != 117) raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
              ++tokPos;
              var esc = readHexChar(4);
              var escStr = String.fromCharCode(esc);
              if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
              if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, "Invalid Unicode escape");
              word += escStr;
            } else {
              break;
            }

            first = false;
          }

          return containsEsc ? word : input.slice(start, tokPos);
        }

        function readWord() {
          var word = readWord1();
          var type = _name;
          if (!containsEsc && isKeyword(word)) type = keywordTypes[word];
          return finishToken(type, word);
        }

        function next() {
          lastStart = tokStart;
          lastEnd = tokEnd;
          lastEndLoc = tokEndLoc;
          readToken();
        }

        function setStrict(strct) {
          strict = strct;
          tokPos = tokStart;

          if (options.locations) {
            while (tokPos < tokLineStart) {
              tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
              --tokCurLine;
            }
          }

          skipSpace();
          readToken();
        }

        function node_t() {
          this.type = null;
          this.start = tokStart;
          this.end = null;
        }

        function node_loc_t() {
          this.start = tokStartLoc;
          this.end = null;
          if (sourceFile !== null) this.source = sourceFile;
        }

        function startNode() {
          var node = new node_t();
          if (options.locations) node.loc = new node_loc_t();
          if (options.directSourceFile) node.sourceFile = options.directSourceFile;
          if (options.ranges) node.range = [tokStart, 0];
          return node;
        }

        function startNodeFrom(other) {
          var node = new node_t();
          node.start = other.start;

          if (options.locations) {
            node.loc = new node_loc_t();
            node.loc.start = other.loc.start;
          }

          if (options.ranges) node.range = [other.range[0], 0];
          return node;
        }

        function finishNode(node, type) {
          node.type = type;
          node.end = lastEnd;
          if (options.locations) node.loc.end = lastEndLoc;
          if (options.ranges) node.range[1] = lastEnd;
          return node;
        }

        function isUseStrict(stmt) {
          return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
        }

        function eat(type) {
          if (tokType === type) {
            next();
            return true;
          }
        }

        function canInsertSemicolon() {
          return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
        }

        function semicolon() {
          if (!eat(_semi) && !canInsertSemicolon()) unexpected();
        }

        function expect(type) {
          if (tokType === type) next();else unexpected();
        }

        function unexpected() {
          raise(tokStart, "Unexpected token");
        }

        function checkLVal(expr) {
          if (expr.type !== "Identifier" && expr.type !== "MemberExpression") raise(expr.start, "Assigning to rvalue");
          if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name)) raise(expr.start, "Assigning to " + expr.name + " in strict mode");
        }

        function parseTopLevel(program) {
          lastStart = lastEnd = tokPos;
          if (options.locations) lastEndLoc = new line_loc_t();
          inFunction = strict = null;
          labels = [];
          readToken();
          var node = program || startNode(),
              first = true;
          if (!program) node.body = [];

          while (tokType !== _eof) {
            var stmt = parseStatement();
            node.body.push(stmt);
            if (first && isUseStrict(stmt)) setStrict(true);
            first = false;
          }

          return finishNode(node, "Program");
        }

        var loopLabel = {
          kind: "loop"
        },
            switchLabel = {
          kind: "switch"
        };

        function parseStatement() {
          if (tokType === _slash || tokType === _assign && tokVal == "/=") readToken(true);
          var starttype = tokType,
              node = startNode();

          switch (starttype) {
            case _break:
            case _continue:
              next();
              var isBreak = starttype === _break;
              if (eat(_semi) || canInsertSemicolon()) node.label = null;else if (tokType !== _name) unexpected();else {
                node.label = parseIdent();
                semicolon();
              }

              for (var i = 0; i < labels.length; ++i) {
                var lab = labels[i];

                if (node.label == null || lab.name === node.label.name) {
                  if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                  if (node.label && isBreak) break;
                }
              }

              if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
              return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

            case _debugger:
              next();
              semicolon();
              return finishNode(node, "DebuggerStatement");

            case _do:
              next();
              labels.push(loopLabel);
              node.body = parseStatement();
              labels.pop();
              expect(_while);
              node.test = parseParenExpression();
              semicolon();
              return finishNode(node, "DoWhileStatement");

            case _for:
              next();
              labels.push(loopLabel);
              expect(_parenL);
              if (tokType === _semi) return parseFor(node, null);

              if (tokType === _var) {
                var init = startNode();
                next();
                parseVar(init, true);
                finishNode(init, "VariableDeclaration");
                if (init.declarations.length === 1 && eat(_in)) return parseForIn(node, init);
                return parseFor(node, init);
              }

              var init = parseExpression(false, true);

              if (eat(_in)) {
                checkLVal(init);
                return parseForIn(node, init);
              }

              return parseFor(node, init);

            case _function:
              next();
              return parseFunction(node, true);

            case _if:
              next();
              node.test = parseParenExpression();
              node.consequent = parseStatement();
              node.alternate = eat(_else) ? parseStatement() : null;
              return finishNode(node, "IfStatement");

            case _return:
              if (!inFunction && !options.allowReturnOutsideFunction) raise(tokStart, "'return' outside of function");
              next();
              if (eat(_semi) || canInsertSemicolon()) node.argument = null;else {
                node.argument = parseExpression();
                semicolon();
              }
              return finishNode(node, "ReturnStatement");

            case _switch:
              next();
              node.discriminant = parseParenExpression();
              node.cases = [];
              expect(_braceL);
              labels.push(switchLabel);

              for (var cur, sawDefault; tokType != _braceR;) {
                if (tokType === _case || tokType === _default) {
                  var isCase = tokType === _case;
                  if (cur) finishNode(cur, "SwitchCase");
                  node.cases.push(cur = startNode());
                  cur.consequent = [];
                  next();
                  if (isCase) cur.test = parseExpression();else {
                    if (sawDefault) raise(lastStart, "Multiple default clauses");
                    sawDefault = true;
                    cur.test = null;
                  }
                  expect(_colon);
                } else {
                  if (!cur) unexpected();
                  cur.consequent.push(parseStatement());
                }
              }

              if (cur) finishNode(cur, "SwitchCase");
              next();
              labels.pop();
              return finishNode(node, "SwitchStatement");

            case _throw:
              next();
              if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, "Illegal newline after throw");
              node.argument = parseExpression();
              semicolon();
              return finishNode(node, "ThrowStatement");

            case _try:
              next();
              node.block = parseBlock();
              node.handler = null;

              if (tokType === _catch) {
                var clause = startNode();
                next();
                expect(_parenL);
                clause.param = parseIdent();
                if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
                expect(_parenR);
                clause.guard = null;
                clause.body = parseBlock();
                node.handler = finishNode(clause, "CatchClause");
              }

              node.guardedHandlers = empty;
              node.finalizer = eat(_finally) ? parseBlock() : null;
              if (!node.handler && !node.finalizer) raise(node.start, "Missing catch or finally clause");
              return finishNode(node, "TryStatement");

            case _var:
              next();
              parseVar(node);
              semicolon();
              return finishNode(node, "VariableDeclaration");

            case _while:
              next();
              node.test = parseParenExpression();
              labels.push(loopLabel);
              node.body = parseStatement();
              labels.pop();
              return finishNode(node, "WhileStatement");

            case _with:
              if (strict) raise(tokStart, "'with' in strict mode");
              next();
              node.object = parseParenExpression();
              node.body = parseStatement();
              return finishNode(node, "WithStatement");

            case _braceL:
              return parseBlock();

            case _semi:
              next();
              return finishNode(node, "EmptyStatement");

            default:
              var maybeName = tokVal,
                  expr = parseExpression();

              if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
                for (var i = 0; i < labels.length; ++i) {
                  if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
                }

                var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
                labels.push({
                  name: maybeName,
                  kind: kind
                });
                node.body = parseStatement();
                labels.pop();
                node.label = expr;
                return finishNode(node, "LabeledStatement");
              } else {
                node.expression = expr;
                semicolon();
                return finishNode(node, "ExpressionStatement");
              }

          }
        }

        function parseParenExpression() {
          expect(_parenL);
          var val = parseExpression();
          expect(_parenR);
          return val;
        }

        function parseBlock(allowStrict) {
          var node = startNode(),
              first = true,
              strict = false,
              oldStrict;
          node.body = [];
          expect(_braceL);

          while (!eat(_braceR)) {
            var stmt = parseStatement();
            node.body.push(stmt);

            if (first && allowStrict && isUseStrict(stmt)) {
              oldStrict = strict;
              setStrict(strict = true);
            }

            first = false;
          }

          if (strict && !oldStrict) setStrict(false);
          return finishNode(node, "BlockStatement");
        }

        function parseFor(node, init) {
          node.init = init;
          expect(_semi);
          node.test = tokType === _semi ? null : parseExpression();
          expect(_semi);
          node.update = tokType === _parenR ? null : parseExpression();
          expect(_parenR);
          node.body = parseStatement();
          labels.pop();
          return finishNode(node, "ForStatement");
        }

        function parseForIn(node, init) {
          node.left = init;
          node.right = parseExpression();
          expect(_parenR);
          node.body = parseStatement();
          labels.pop();
          return finishNode(node, "ForInStatement");
        }

        function parseVar(node, noIn) {
          node.declarations = [];
          node.kind = "var";

          for (;;) {
            var decl = startNode();
            decl.id = parseIdent();
            if (strict && isStrictBadIdWord(decl.id.name)) raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
            decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
            node.declarations.push(finishNode(decl, "VariableDeclarator"));
            if (!eat(_comma)) break;
          }

          return node;
        }

        function parseExpression(noComma, noIn) {
          var expr = parseMaybeAssign(noIn);

          if (!noComma && tokType === _comma) {
            var node = startNodeFrom(expr);
            node.expressions = [expr];

            while (eat(_comma)) {
              node.expressions.push(parseMaybeAssign(noIn));
            }

            return finishNode(node, "SequenceExpression");
          }

          return expr;
        }

        function parseMaybeAssign(noIn) {
          var left = parseMaybeConditional(noIn);

          if (tokType.isAssign) {
            var node = startNodeFrom(left);
            node.operator = tokVal;
            node.left = left;
            next();
            node.right = parseMaybeAssign(noIn);
            checkLVal(left);
            return finishNode(node, "AssignmentExpression");
          }

          return left;
        }

        function parseMaybeConditional(noIn) {
          var expr = parseExprOps(noIn);

          if (eat(_question)) {
            var node = startNodeFrom(expr);
            node.test = expr;
            node.consequent = parseExpression(true);
            expect(_colon);
            node.alternate = parseExpression(true, noIn);
            return finishNode(node, "ConditionalExpression");
          }

          return expr;
        }

        function parseExprOps(noIn) {
          return parseExprOp(parseMaybeUnary(), -1, noIn);
        }

        function parseExprOp(left, minPrec, noIn) {
          var prec = tokType.binop;

          if (prec != null && (!noIn || tokType !== _in)) {
            if (prec > minPrec) {
              var node = startNodeFrom(left);
              node.left = left;
              node.operator = tokVal;
              var op = tokType;
              next();
              node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
              var exprNode = finishNode(node, op === _logicalOR || op === _logicalAND ? "LogicalExpression" : "BinaryExpression");
              return parseExprOp(exprNode, minPrec, noIn);
            }
          }

          return left;
        }

        function parseMaybeUnary() {
          if (tokType.prefix) {
            var node = startNode(),
                update = tokType.isUpdate;
            node.operator = tokVal;
            node.prefix = true;
            tokRegexpAllowed = true;
            next();
            node.argument = parseMaybeUnary();
            if (update) checkLVal(node.argument);else if (strict && node.operator === "delete" && node.argument.type === "Identifier") raise(node.start, "Deleting local variable in strict mode");
            return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
          }

          var expr = parseExprSubscripts();

          while (tokType.postfix && !canInsertSemicolon()) {
            var node = startNodeFrom(expr);
            node.operator = tokVal;
            node.prefix = false;
            node.argument = expr;
            checkLVal(expr);
            next();
            expr = finishNode(node, "UpdateExpression");
          }

          return expr;
        }

        function parseExprSubscripts() {
          return parseSubscripts(parseExprAtom());
        }

        function parseSubscripts(base, noCalls) {
          if (eat(_dot)) {
            var node = startNodeFrom(base);
            node.object = base;
            node.property = parseIdent(true);
            node.computed = false;
            return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
          } else if (eat(_bracketL)) {
            var node = startNodeFrom(base);
            node.object = base;
            node.property = parseExpression();
            node.computed = true;
            expect(_bracketR);
            return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
          } else if (!noCalls && eat(_parenL)) {
            var node = startNodeFrom(base);
            node.callee = base;
            node.arguments = parseExprList(_parenR, false);
            return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
          } else return base;
        }

        function parseExprAtom() {
          switch (tokType) {
            case _this:
              var node = startNode();
              next();
              return finishNode(node, "ThisExpression");

            case _name:
              return parseIdent();

            case _num:
            case _string:
            case _regexp:
              var node = startNode();
              node.value = tokVal;
              node.raw = input.slice(tokStart, tokEnd);
              next();
              return finishNode(node, "Literal");

            case _null:
            case _true:
            case _false:
              var node = startNode();
              node.value = tokType.atomValue;
              node.raw = tokType.keyword;
              next();
              return finishNode(node, "Literal");

            case _parenL:
              var tokStartLoc1 = tokStartLoc,
                  tokStart1 = tokStart;
              next();
              var val = parseExpression();
              val.start = tokStart1;
              val.end = tokEnd;

              if (options.locations) {
                val.loc.start = tokStartLoc1;
                val.loc.end = tokEndLoc;
              }

              if (options.ranges) val.range = [tokStart1, tokEnd];
              expect(_parenR);
              return val;

            case _bracketL:
              var node = startNode();
              next();
              node.elements = parseExprList(_bracketR, true, true);
              return finishNode(node, "ArrayExpression");

            case _braceL:
              return parseObj();

            case _function:
              var node = startNode();
              next();
              return parseFunction(node, false);

            case _new:
              return parseNew();

            default:
              unexpected();
          }
        }

        function parseNew() {
          var node = startNode();
          next();
          node.callee = parseSubscripts(parseExprAtom(), true);
          if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);else node.arguments = empty;
          return finishNode(node, "NewExpression");
        }

        function parseObj() {
          var node = startNode(),
              first = true,
              sawGetSet = false;
          node.properties = [];
          next();

          while (!eat(_braceR)) {
            if (!first) {
              expect(_comma);
              if (options.allowTrailingCommas && eat(_braceR)) break;
            } else first = false;

            var prop = {
              key: parsePropertyName()
            },
                isGetSet = false,
                kind;

            if (eat(_colon)) {
              prop.value = parseExpression(true);
              kind = prop.kind = "init";
            } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set")) {
              isGetSet = sawGetSet = true;
              kind = prop.kind = prop.key.name;
              prop.key = parsePropertyName();
              if (tokType !== _parenL) unexpected();
              prop.value = parseFunction(startNode(), false);
            } else unexpected();

            if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
              for (var i = 0; i < node.properties.length; ++i) {
                var other = node.properties[i];

                if (other.key.name === prop.key.name) {
                  var conflict = kind == other.kind || isGetSet && other.kind === "init" || kind === "init" && (other.kind === "get" || other.kind === "set");
                  if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
                  if (conflict) raise(prop.key.start, "Redefinition of property");
                }
              }
            }

            node.properties.push(prop);
          }

          return finishNode(node, "ObjectExpression");
        }

        function parsePropertyName() {
          if (tokType === _num || tokType === _string) return parseExprAtom();
          return parseIdent(true);
        }

        function parseFunction(node, isStatement) {
          if (tokType === _name) node.id = parseIdent();else if (isStatement) unexpected();else node.id = null;
          node.params = [];
          var first = true;
          expect(_parenL);

          while (!eat(_parenR)) {
            if (!first) expect(_comma);else first = false;
            node.params.push(parseIdent());
          }

          var oldInFunc = inFunction,
              oldLabels = labels;
          inFunction = true;
          labels = [];
          node.body = parseBlock(true);
          inFunction = oldInFunc;
          labels = oldLabels;

          if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
            for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
              var id = i < 0 ? node.id : node.params[i];
              if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name)) raise(id.start, "Defining '" + id.name + "' in strict mode");
              if (i >= 0) for (var j = 0; j < i; ++j) {
                if (id.name === node.params[j].name) raise(id.start, "Argument name clash in strict mode");
              }
            }
          }

          return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
        }

        function parseExprList(close, allowTrailingComma, allowEmpty) {
          var elts = [],
              first = true;

          while (!eat(close)) {
            if (!first) {
              expect(_comma);
              if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
            } else first = false;

            if (allowEmpty && tokType === _comma) elts.push(null);else elts.push(parseExpression(true));
          }

          return elts;
        }

        function parseIdent(liberal) {
          var node = startNode();
          if (liberal && options.forbidReserved == "everywhere") liberal = false;

          if (tokType === _name) {
            if (!liberal && (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) || strict && isStrictReservedWord(tokVal)) && input.slice(tokStart, tokEnd).indexOf("\\") == -1) raise(tokStart, "The keyword '" + tokVal + "' is reserved");
            node.name = tokVal;
          } else if (liberal && tokType.keyword) {
            node.name = tokType.keyword;
          } else {
            unexpected();
          }

          tokRegexpAllowed = false;
          next();
          return finishNode(node, "Identifier");
        }
      });

      if (!acorn.version) acorn = null;
    }

    function parse(code, options) {
      return (global.acorn || acorn).parse(code, options);
    }

    var binaryOperators = {
      '+': '__add',
      '-': '__subtract',
      '*': '__multiply',
      '/': '__divide',
      '%': '__modulo',
      '==': '__equals',
      '!=': '__equals'
    };
    var unaryOperators = {
      '-': '__negate',
      '+': '__self'
    };
    var fields = Base.each(['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'], function (name) {
      this['__' + name] = '#' + name;
    }, {
      __self: function __self() {
        return this;
      }
    });
    Point.inject(fields);
    Size.inject(fields);
    Color.inject(fields);

    function __$__(left, operator, right) {
      var handler = binaryOperators[operator];

      if (left && left[handler]) {
        var res = left[handler](right);
        return operator === '!=' ? !res : res;
      }

      switch (operator) {
        case '+':
          return left + right;

        case '-':
          return left - right;

        case '*':
          return left * right;

        case '/':
          return left / right;

        case '%':
          return left % right;

        case '==':
          return left == right;

        case '!=':
          return left != right;
      }
    }

    function $__(operator, value) {
      var handler = unaryOperators[operator];
      if (value && value[handler]) return value[handler]();

      switch (operator) {
        case '+':
          return +value;

        case '-':
          return -value;
      }
    }

    function compile(code, options) {
      if (!code) return '';
      options = options || {};
      var insertions = [];

      function getOffset(offset) {
        for (var i = 0, l = insertions.length; i < l; i++) {
          var insertion = insertions[i];
          if (insertion[0] >= offset) break;
          offset += insertion[1];
        }

        return offset;
      }

      function getCode(node) {
        return code.substring(getOffset(node.range[0]), getOffset(node.range[1]));
      }

      function getBetween(left, right) {
        return code.substring(getOffset(left.range[1]), getOffset(right.range[0]));
      }

      function replaceCode(node, str) {
        var start = getOffset(node.range[0]),
            end = getOffset(node.range[1]),
            insert = 0;

        for (var i = insertions.length - 1; i >= 0; i--) {
          if (start > insertions[i][0]) {
            insert = i + 1;
            break;
          }
        }

        insertions.splice(insert, 0, [start, str.length - end + start]);
        code = code.substring(0, start) + str + code.substring(end);
      }

      function handleOverloading(node, parent) {
        switch (node.type) {
          case 'UnaryExpression':
            if (node.operator in unaryOperators && node.argument.type !== 'Literal') {
              var arg = getCode(node.argument);
              replaceCode(node, '$__("' + node.operator + '", ' + arg + ')');
            }

            break;

          case 'BinaryExpression':
            if (node.operator in binaryOperators && node.left.type !== 'Literal') {
              var left = getCode(node.left),
                  right = getCode(node.right),
                  between = getBetween(node.left, node.right),
                  operator = node.operator;
              replaceCode(node, '__$__(' + left + ',' + between.replace(new RegExp('\\' + operator), '"' + operator + '"') + ', ' + right + ')');
            }

            break;

          case 'UpdateExpression':
          case 'AssignmentExpression':
            var parentType = parent && parent.type;

            if (!(parentType === 'ForStatement' || parentType === 'BinaryExpression' && /^[=!<>]/.test(parent.operator) || parentType === 'MemberExpression' && parent.computed)) {
              if (node.type === 'UpdateExpression') {
                var arg = getCode(node.argument),
                    exp = '__$__(' + arg + ', "' + node.operator[0] + '", 1)',
                    str = arg + ' = ' + exp;

                if (node.prefix) {
                  str = '(' + str + ')';
                } else if (parentType === 'AssignmentExpression' || parentType === 'VariableDeclarator' || parentType === 'BinaryExpression') {
                  if (getCode(parent.left || parent.id) === arg) str = exp;
                  str = arg + '; ' + str;
                }

                replaceCode(node, str);
              } else {
                if (/^.=$/.test(node.operator) && node.left.type !== 'Literal') {
                  var left = getCode(node.left),
                      right = getCode(node.right),
                      exp = left + ' = __$__(' + left + ', "' + node.operator[0] + '", ' + right + ')';
                  replaceCode(node, /^\(.*\)$/.test(getCode(node)) ? '(' + exp + ')' : exp);
                }
              }
            }

            break;
        }
      }

      function handleExports(node) {
        switch (node.type) {
          case 'ExportDefaultDeclaration':
            replaceCode({
              range: [node.start, node.declaration.start]
            }, 'module.exports = ');
            break;

          case 'ExportNamedDeclaration':
            var declaration = node.declaration;
            var specifiers = node.specifiers;

            if (declaration) {
              var declarations = declaration.declarations;

              if (declarations) {
                declarations.forEach(function (dec) {
                  replaceCode(dec, 'module.exports.' + getCode(dec));
                });
                replaceCode({
                  range: [node.start, declaration.start + declaration.kind.length]
                }, '');
              }
            } else if (specifiers) {
              var exports = specifiers.map(function (specifier) {
                var name = getCode(specifier);
                return 'module.exports.' + name + ' = ' + name + '; ';
              }).join('');

              if (exports) {
                replaceCode(node, exports);
              }
            }

            break;
        }
      }

      function walkAST(node, parent, paperFeatures) {
        if (node) {
          for (var key in node) {
            if (key !== 'range' && key !== 'loc') {
              var value = node[key];

              if (Array.isArray(value)) {
                for (var i = 0, l = value.length; i < l; i++) {
                  walkAST(value[i], node, paperFeatures);
                }
              } else if (value && _typeof(value) === 'object') {
                walkAST(value, node, paperFeatures);
              }
            }
          }

          if (paperFeatures.operatorOverloading !== false) {
            handleOverloading(node, parent);
          }

          if (paperFeatures.moduleExports !== false) {
            handleExports(node);
          }
        }
      }

      function encodeVLQ(value) {
        var res = '',
            base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);

        while (value || !res) {
          var next = value & 32 - 1;
          value >>= 5;
          if (value) next |= 32;
          res += base64[next];
        }

        return res;
      }

      var url = options.url || '',
          sourceMaps = options.sourceMaps,
          paperFeatures = options.paperFeatures || {},
          source = options.source || code,
          offset = options.offset || 0,
          agent = paper.agent,
          version = agent.versionNumber,
          offsetCode = false,
          lineBreaks = /\r\n|\n|\r/mg,
          map;

      if (sourceMaps && (agent.chrome && version >= 30 || agent.webkit && version >= 537.76 || agent.firefox && version >= 23 || agent.node)) {
        if (agent.node) {
          offset -= 2;
        } else if (window && url && !window.location.href.indexOf(url)) {
          var html = document.getElementsByTagName('html')[0].innerHTML;
          offset = html.substr(0, html.indexOf(code) + 1).match(lineBreaks).length + 1;
        }

        offsetCode = offset > 0 && !(agent.chrome && version >= 36 || agent.safari && version >= 600 || agent.firefox && version >= 40 || agent.node);
        var mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];
        mappings.length = (code.match(lineBreaks) || []).length + 1 + (offsetCode ? offset : 0);
        map = {
          version: 3,
          file: url,
          names: [],
          mappings: mappings.join(';AACA'),
          sourceRoot: '',
          sources: [url],
          sourcesContent: [source]
        };
      }

      if (paperFeatures.operatorOverloading !== false || paperFeatures.moduleExports !== false) {
        walkAST(parse(code, {
          ranges: true,
          preserveParens: true,
          sourceType: 'module'
        }), null, paperFeatures);
      }

      if (map) {
        if (offsetCode) {
          code = new Array(offset + 1).join('\n') + code;
        }

        if (/^(inline|both)$/.test(sourceMaps)) {
          code += "\n//# sourceMappingURL=data:application/json;base64," + self.btoa(unescape(encodeURIComponent(JSON.stringify(map))));
        }

        code += "\n//# sourceURL=" + (url || 'paperscript');
      }

      return {
        url: url,
        source: source,
        code: code,
        map: map
      };
    }

    function execute(code, scope, options) {
      paper = scope;
      var view = scope.getView(),
          tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code) && !/\bnew\s+Tool\b/.test(code) ? new Tool() : null,
          toolHandlers = tool ? tool._events : [],
          handlers = ['onFrame', 'onResize'].concat(toolHandlers),
          params = [],
          args = [],
          func,
          compiled = _typeof(code) === 'object' ? code : compile(code, options);
      code = compiled.code;

      function expose(scope, hidden) {
        for (var key in scope) {
          if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)' + key.replace(/\$/g, '\\$') + '\\b').test(code)) {
            params.push(key);
            args.push(scope[key]);
          }
        }
      }

      expose({
        __$__: __$__,
        $__: $__,
        paper: scope,
        tool: tool
      }, true);
      expose(scope);
      code = 'var module = { exports: {} }; ' + code;
      var exports = Base.each(handlers, function (key) {
        if (new RegExp('\\s+' + key + '\\b').test(code)) {
          params.push(key);
          this.push('module.exports.' + key + ' = ' + key + ';');
        }
      }, []).join('\n');

      if (exports) {
        code += '\n' + exports;
      }

      code += '\nreturn module.exports;';
      var agent = paper.agent;

      if (document && (agent.chrome || agent.firefox && agent.versionNumber < 40)) {
        var script = document.createElement('script'),
            head = document.head || document.getElementsByTagName('head')[0];
        if (agent.firefox) code = '\n' + code;
        script.appendChild(document.createTextNode('document.__paperscript__ = function(' + params + ') {' + code + '\n}'));
        head.appendChild(script);
        func = document.__paperscript__;
        delete document.__paperscript__;
        head.removeChild(script);
      } else {
        func = Function(params, code);
      }

      var exports = func && func.apply(scope, args);
      var obj = exports || {};
      Base.each(toolHandlers, function (key) {
        var value = obj[key];
        if (value) tool[key] = value;
      });

      if (view) {
        if (obj.onResize) view.setOnResize(obj.onResize);
        view.emit('resize', {
          size: view.size,
          delta: new Point()
        });
        if (obj.onFrame) view.setOnFrame(obj.onFrame);
        view.requestUpdate();
      }

      return exports;
    }

    function loadScript(script) {
      if (/^text\/(?:x-|)paperscript$/.test(script.type) && PaperScope.getAttribute(script, 'ignore') !== 'true') {
        var canvasId = PaperScope.getAttribute(script, 'canvas'),
            canvas = document.getElementById(canvasId),
            src = script.src || script.getAttribute('data-src'),
            async = PaperScope.hasAttribute(script, 'async'),
            scopeAttribute = 'data-paper-scope';
        if (!canvas) throw new Error('Unable to find canvas with id "' + canvasId + '"');
        var scope = PaperScope.get(canvas.getAttribute(scopeAttribute)) || new PaperScope().setup(canvas);
        canvas.setAttribute(scopeAttribute, scope._id);

        if (src) {
          Http.request({
            url: src,
            async: async,
            mimeType: 'text/plain',
            onLoad: function onLoad(code) {
              execute(code, scope, src);
            }
          });
        } else {
          execute(script.innerHTML, scope, script.baseURI);
        }

        script.setAttribute('data-paper-ignore', 'true');
        return scope;
      }
    }

    function loadAll() {
      Base.each(document && document.getElementsByTagName('script'), loadScript);
    }

    function load(script) {
      return script ? loadScript(script) : loadAll();
    }

    if (window) {
      if (document.readyState === 'complete') {
        setTimeout(loadAll);
      } else {
        DomEvent.add(window, {
          load: loadAll
        });
      }
    }

    return {
      compile: compile,
      execute: execute,
      load: load,
      parse: parse,
      calculateBinary: __$__,
      calculateUnary: $__
    };
  }.call(this);

  var paper = new (PaperScope.inject(Base.exports, {
    Base: Base,
    Numerical: Numerical,
    Key: Key,
    DomEvent: DomEvent,
    DomElement: DomElement,
    document: document,
    window: window,
    Symbol: SymbolDefinition,
    PlacedSymbol: SymbolItem
  }))();

  if (paper.agent.node) {
    require('./node/extend.js')(paper);
  }

  if (typeof define === 'function' && define.amd) {
    define('paper', paper);
  } else if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object' && module) {
    module.exports = paper;
  }

  return paper;
}.call(this, (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : null);
},{"./node/self.js":"node_modules/parcel-bundler/src/builtins/_empty.js","acorn":"node_modules/acorn/dist/acorn.es.js","./node/extend.js":"node_modules/parcel-bundler/src/builtins/_empty.js","process":"node_modules/process/browser.js"}],"utils/demoUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMobile = isMobile;
exports.toggleLoadingUI = toggleLoadingUI;
exports.drawPoint = drawPoint;
exports.drawSegment = drawSegment;
exports.drawSkeleton = drawSkeleton;
exports.drawKeypoints = drawKeypoints;
exports.renderImageToCanvas = renderImageToCanvas;
exports.setStatusText = setStatusText;

var posenet = _interopRequireWildcard(require("@tensorflow-models/posenet"));

var tf = _interopRequireWildcard(require("@tensorflow/tfjs"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var color = 'aqua';
var boundingBoxColor = 'red';
var lineWidth = 2;

function isAndroid() {
  return /Android/i.test(navigator.userAgent);
}

function isiOS() {
  return /iPhone|iPad|iPod/i.test(navigator.userAgent);
}

function isMobile() {
  return isAndroid() || isiOS();
}

function setDatGuiPropertyCss(propertyText, liCssString) {
  var spanCssString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var spans = document.getElementsByClassName('property-name');

  for (var i = 0; i < spans.length; i++) {
    var text = spans[i].textContent || spans[i].innerText;

    if (text == propertyText) {
      spans[i].parentNode.parentNode.style = liCssString;

      if (spanCssString !== '') {
        spans[i].style = spanCssString;
      }
    }
  }
}
/**
 * Toggles between the loading UI and the main canvas UI.
 */


function toggleLoadingUI(showLoadingUI) {
  var loadingDivId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'loader';
  var mainDivId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'main';

  if (showLoadingUI) {
    document.getElementById(loadingDivId).style.display = 'block';
    document.getElementById(mainDivId).style.display = 'none';
  } else {
    document.getElementById(loadingDivId).style.display = 'none';
    document.getElementById(mainDivId).style.display = 'block';
  }
}

function toTuple(_ref) {
  var y = _ref.y,
      x = _ref.x;
  return [y, x];
}

function drawPoint(ctx, y, x, r, color) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2 * Math.PI);
  ctx.fillStyle = color;
  ctx.fill();
}
/**
 * Draws a line on a canvas, i.e. a joint
 */


function drawSegment(_ref2, _ref3, color, scale, ctx) {
  var _ref4 = _slicedToArray(_ref2, 2),
      ay = _ref4[0],
      ax = _ref4[1];

  var _ref5 = _slicedToArray(_ref3, 2),
      by = _ref5[0],
      bx = _ref5[1];

  ctx.beginPath();
  ctx.moveTo(ax * scale, ay * scale);
  ctx.lineTo(bx * scale, by * scale);
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = color;
  ctx.stroke();
}
/**
 * Draws a pose skeleton by looking up all adjacent keypoints/joints
 */


function drawSkeleton(keypoints, minConfidence, ctx) {
  var scale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var adjacentKeyPoints = posenet.getAdjacentKeyPoints(keypoints, minConfidence);
  adjacentKeyPoints.forEach(function (keypoints) {
    drawSegment(toTuple(keypoints[0].position), toTuple(keypoints[1].position), color, scale, ctx);
  });
}
/**
 * Draw pose keypoints onto a canvas
 */


function drawKeypoints(keypoints, minConfidence, ctx) {
  var scale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

  for (var i = 0; i < keypoints.length; i++) {
    var keypoint = keypoints[i];

    if (keypoint.score < minConfidence) {
      continue;
    }

    var _keypoint$position = keypoint.position,
        y = _keypoint$position.y,
        x = _keypoint$position.x;
    drawPoint(ctx, y * scale, x * scale, 3, color);
  }
}
/**
 * Draw an image on a canvas
 */


function renderImageToCanvas(image, size, canvas) {
  canvas.width = size[0];
  canvas.height = size[1];
  var ctx = canvas.getContext('2d');
  ctx.drawImage(image, 0, 0);
}

function setStatusText(text) {
  var resultElement = document.getElementById('status');
  resultElement.innerText = text;
}
},{"@tensorflow-models/posenet":"node_modules/@tensorflow-models/posenet/dist/posenet.esm.js","@tensorflow/tfjs":"node_modules/@tensorflow/tfjs/dist/tf.esm.js"}],"utils/svgUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SVGUtils = void 0;

var paper = _interopRequireWildcard(require("paper"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SVGUtils = /*#__PURE__*/function () {
  function SVGUtils() {
    _classCallCheck(this, SVGUtils);
  }

  _createClass(SVGUtils, null, [{
    key: "importSVG",
    value: function importSVG(file) {
      var svgScope = new paper.default.PaperScope();
      var canvas = svgScope.createCanvas(0, 0);
      svgScope.setup(canvas);
      return new Promise(function (resolve, reject) {
        svgScope.project.importSVG(file, function () {
          console.log('** SVG imported **');
          resolve(svgScope);
        }, function (e) {
          console.log('** SVG improt error: ', e);
          reject(svgScope);
        });
      });
    }
  }, {
    key: "drawEllipse",
    value: function drawEllipse(p, va, vb, ctrlDA, ctrlDB, scope, options) {
      var va1 = va.multiply(-1);
      var vb1 = vb.multiply(-1);
      var p0 = p.add(va);
      var p1 = p.add(vb);
      var p2 = p.add(va1);
      var p3 = p.add(vb1);
      var path = new scope.Path(options);
      path.addSegment(p0, vb1.normalize().multiply(ctrlDB), vb.normalize().multiply(ctrlDB));
      path.addSegment(p1, va.normalize().multiply(ctrlDA), va1.normalize().multiply(ctrlDA));
      path.addSegment(p2, vb.normalize().multiply(ctrlDB), vb1.normalize().multiply(ctrlDB));
      path.addSegment(p3, va1.normalize().multiply(ctrlDA), va.normalize().multiply(ctrlDA));
      path.closePath();
      return path;
    }
  }, {
    key: "genPathWithSpline",
    value: function genPathWithSpline(path, spline, height, options, scope) {
      var pathLen = path.length;

      if (pathLen == 0) {
        return path.clone();
      }

      var to = [];
      var back = [];
      ;
      var segCount = Math.max(pathLen / 3, 1.0);

      for (var i = 0; i < segCount; i++) {
        var perc = i / (segCount - 1);
        var p = path.getPointAt(perc * pathLen);
        var n = path.getNormalAt(perc * pathLen);
        var easeHeight = spline.get(perc);
        if (!p || !n) continue;
        var pp0 = p.add(n.multiply(height * easeHeight));
        var pp1 = p.subtract(n.multiply(height * easeHeight));
        to.push(pp0);
        back.unshift(pp1);
      }

      var outPath = new scope.Path(options);
      outPath.addSegments(to.concat(back));
      outPath.simplify();
      return outPath;
    }
  }, {
    key: "isPath",
    value: function isPath(item) {
      return item.constructor === item.project._scope.Path;
    }
  }, {
    key: "isShape",
    value: function isShape(item) {
      return item.constructor === item.project._scope.Shape;
    }
  }, {
    key: "isGroup",
    value: function isGroup(item) {
      return item.constructor === item.project._scope.Group;
    }
  }, {
    key: "findFirstItemWithPrefix",
    value: function findFirstItemWithPrefix(root, prefix) {
      var items = root.getItems({
        recursive: true
      });

      for (var i = 0; i < items.length; i++) {
        if (items[i].name && items[i].name.startsWith(prefix)) {
          return items[i];
        }
      }

      return null;
    }
  }]);

  return SVGUtils;
}();

exports.SVGUtils = SVGUtils;
},{"paper":"node_modules/paper/dist/paper-full.js"}],"utils/mathUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiSpline = exports.MathUtils = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getDistance(p0, p1) {
  return Math.sqrt((p0.x - p1.x) * (p0.x - p1.x) + (p0.y - p1.y) * (p0.y - p1.y));
}

var MathUtils = /*#__PURE__*/function () {
  function MathUtils() {
    _classCallCheck(this, MathUtils);
  }

  _createClass(MathUtils, null, [{
    key: "lerp",
    value: function lerp(v0, v1, perc) {
      return v0 + (v1 - v0) * perc;
    }
  }, {
    key: "random",
    value: function random(v0, v1) {
      return v0 + Math.random() * (v1 - v0);
    }
  }, {
    key: "smoothStep",
    value: function smoothStep(v, min, max) {
      var x = Math.max(0, Math.min(1, (v - min) / (max - min)));
      return x * x * (3 - 2 * x);
    } // Generate a transform function of p in the coordinate system defined by p0 and p1.

  }, {
    key: "getTransformFunc",
    value: function getTransformFunc(p0, p1, p) {
      var d = p1.subtract(p0);
      var dir = d.normalize();
      var l0 = d.length;
      var n = dir.clone();
      n.angle += 90;
      var v = p.subtract(p0);
      var x = v.dot(dir);
      var y = v.dot(n);
      return function (p0New, p1New) {
        var d = p1New.subtract(p0New);

        if (d.length === 0) {
          return p0New.clone();
        }

        var scale = d.length / l0;
        var dirNew = d.normalize();
        var nNew = dirNew.clone();
        nNew.angle += 90;
        return p0New.add(dirNew.multiply(x * scale)).add(nNew.multiply(y * scale));
      };
    }
  }, {
    key: "getClosestPointOnSegment",
    value: function getClosestPointOnSegment(p0, p1, p) {
      var d = p1.subtract(p0);
      var c = p.subtract(p0).dot(d) / d.dot(d);

      if (c >= 1) {
        return p1.clone();
      } else if (c <= 0) {
        return p0.clone();
      } else {
        return p0.add(d.multiply(c));
      }
    } // Check if v0 and v1 are collinear.
    // Returns true if cosine of the angle between v0 and v1 is within threshold to 1.

  }, {
    key: "isCollinear",
    value: function isCollinear(v0, v1) {
      var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.01;
      var colinear = false;

      if (v0 && v1) {
        var n0 = v0.normalize();
        var n1 = v1.normalize();
        colinear = Math.abs(n0.dot(n1)) > 1 - threshold;
      }

      return colinear;
    }
  }, {
    key: "gaussian",
    value: function gaussian(mean, variance) {
      var u = 0,
          v = 0;

      while (u === 0) {
        u = Math.random();
      } //Converting [0,1) to (0,1)


      while (v === 0) {
        v = Math.random();
      }

      var value = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
      return value * variance + mean;
    }
  }, {
    key: "clamp",
    value: function clamp(v, minV, maxV) {
      return Math.min(Math.max(v, minV), maxV);
    }
  }, {
    key: "selectSegments",
    value: function selectSegments(selectPerc, count, selectVar, segVar) {
      var segments = [];
      var totalSeg = 0;

      for (var i = 0; i < count; i++) {
        var seg = MathUtils.gaussian(1, segVar);
        segments.push(seg);
        totalSeg += seg;
      }

      for (var _i = 0; _i < segments.length; _i++) {
        segments[_i] = segments[_i] / totalSeg;
      }

      var cursor = 0;
      var selected = [];

      for (var _i2 = 0; _i2 < count; _i2++) {
        var s0 = cursor;
        var s1 = cursor + segments[_i2] * MathUtils.clamp(MathUtils.gaussian(1, selectVar) * selectPerc, 0, 1);
        selected.push([s0, s1]);
        cursor += segments[_i2];
      }

      return selected;
    }
  }, {
    key: "isLeft",
    value: function isLeft(p0, p1, p) {
      return (p1.x - p0.x) * (p.y - p0.y) - (p1.y - p0.y) * (p.x - p0.x) > 0;
    }
  }, {
    key: "packCircles",
    value: function packCircles(center, radius, seedCount, maxR, minR) {
      var maxIter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10;
      var circles = [];
      var iterCount = 0;

      var _loop = function _loop() {
        var _loop2 = function _loop2() {
          var c = {
            x: radius * (Math.random() * 2 - 1) + center.x,
            y: radius * (Math.random() * 2 - 1) + center.y
          };
          if (getDistance(c, center) > radius || circles.some(function (circle) {
            return getDistance(circle, c) < circle.radius;
          })) return "continue";
          circles.push({
            c: c,
            r: 0
          });
        };

        while (circles.length < seedCount) {
          var _ret = _loop2();

          if (_ret === "continue") continue;
        }

        var growthIterCount = 20;

        var intersects = function intersects(c0, c1) {
          var d = getDistance(c0.c, c1.c);
          return d < c0.r + c1.r && d > Math.abs(c0.r - c1.r);
        };

        var bound = {
          c: center,
          r: radius
        };

        for (var i = 0; i < growthIterCount; i++) {
          var grew = false;
          circles.forEach(function (s) {
            var intersecting = circles.some(function (other) {
              return s !== other && (intersects(s, other) || intersects(s, bound));
            });

            if (!intersecting && s.r < maxR) {
              s.r += maxR / growthIterCount;
              grew = true;
            }
          });
          if (!grew) break;
        }

        circles = circles.filter(function (c) {
          return c.r >= minR;
        });
        iterCount++;
      };

      while (circles.length < seedCount && iterCount < maxIter) {
        _loop();
      }

      return circles;
    }
  }]);

  return MathUtils;
}();

exports.MathUtils = MathUtils;

var KeySpline = /*#__PURE__*/function () {
  function KeySpline(mX1, mY1, mX2, mY2) {
    _classCallCheck(this, KeySpline);

    this.mX1 = mX1;
    this.mY1 = mY1;
    this.mX2 = mX2;
    this.mY2 = mY2;
  }

  _createClass(KeySpline, [{
    key: "get",
    value: function get(aX) {
      if (this.mX1 == this.mY1 && this.mX2 == this.mY2) return aX; // linear

      return this.CalcBezier(this.GetTForX(aX), this.mY1, this.mY2);
    }
  }, {
    key: "A",
    value: function A(aA1, aA2) {
      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }
  }, {
    key: "B",
    value: function B(aA1, aA2) {
      return 3.0 * aA2 - 6.0 * aA1;
    }
  }, {
    key: "C",
    value: function C(aA1) {
      return 3.0 * aA1;
    } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.

  }, {
    key: "CalcBezier",
    value: function CalcBezier(aT, aA1, aA2) {
      return ((this.A(aA1, aA2) * aT + this.B(aA1, aA2)) * aT + this.C(aA1)) * aT;
    } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.

  }, {
    key: "GetSlope",
    value: function GetSlope(aT, aA1, aA2) {
      return 3.0 * this.A(aA1, aA2) * aT * aT + 2.0 * this.B(aA1, aA2) * aT + this.C(aA1);
    }
  }, {
    key: "GetTForX",
    value: function GetTForX(aX) {
      // Newton raphson iteration
      var aGuessT = aX;

      for (var i = 0; i < 4; ++i) {
        var currentSlope = this.GetSlope(aGuessT, this.mX1, this.mX2);
        if (currentSlope == 0.0) return aGuessT;
        var currentX = this.CalcBezier(aGuessT, this.mX1, this.mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }

      return aGuessT;
    }
  }]);

  return KeySpline;
}();

;

var MultiSpline = /*#__PURE__*/function () {
  function MultiSpline() {
    _classCallCheck(this, MultiSpline);

    this.keySplines = [];
    this.segments = [];
    this.x0 = 0;
    this.y0 = 0;
  }

  _createClass(MultiSpline, [{
    key: "add",
    value: function add(mX1, mY1, mX2, mY2, x1, y1) {
      var ks = new KeySpline(mX1, mY1, mX2, mY2);
      var x0 = this.x0;
      var y0 = this.y0;

      if (this.segments.length) {
        x0 = this.segments[this.segments.length - 1][1].x;
        y0 = this.segments[this.segments.length - 1][1].y;
      }

      this.keySplines.push(ks);
      this.segments.push([{
        x: x0,
        y: y0
      }, {
        x: x1,
        y: y1
      }]);
    }
  }, {
    key: "get",
    value: function get(x) {
      var index = -1;

      for (var i = 0; i < this.segments.length; i++) {
        if (x >= this.segments[i][0].x && x < this.segments[i][1].x) {
          index = i;
          break;
        }
      }

      if (index < 0) {
        return 0;
      }

      var seg = this.segments[index];
      var ks = this.keySplines[index];
      var perc = (x - seg[0].x) / (seg[1].x - seg[0].x);

      if (index % 2 == 0) {
        return MathUtils.lerp(seg[0].y, seg[1].y, ks.get(perc));
      } else {
        return MathUtils.lerp(seg[1].y, seg[0].y, ks.get(1 - perc));
      }
    }
  }]);

  return MultiSpline;
}();

exports.MultiSpline = MultiSpline;
},{}],"utils/colorUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorUtils = exports.Palette = void 0;

var _mathUtils = require("./mathUtils");

var paper = _interopRequireWildcard(require("paper"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Palette = /*#__PURE__*/function () {
  function Palette(colors) {
    _classCallCheck(this, Palette);

    var scope = paper.default;
    this.colors = colors.map(function (c) {
      return {
        light: new scope.Color(c[0]).convert('hsb'),
        dark: new scope.Color(c[1]).convert('hsb')
      };
    });
  }

  _createClass(Palette, [{
    key: "select",
    value: function select(variance) {
      var scope = paper.default;
      var pair = this.colors[Math.floor(Math.random() * this.colors.length)];

      var varColor = function varColor(c) {
        return new scope.Color({
          hue: c.hue + 360 * _mathUtils.MathUtils.gaussian(0, variance),
          saturation: c.saturation + _mathUtils.MathUtils.gaussian(0, variance),
          brightness: c.brightness + _mathUtils.MathUtils.gaussian(0, variance)
        });
      };

      return {
        light: varColor(pair.light),
        dark: varColor(pair.dark)
      };
    }
  }]);

  return Palette;
}();

exports.Palette = Palette;

var ColorUtils = /*#__PURE__*/function () {
  function ColorUtils() {
    _classCallCheck(this, ColorUtils);
  }

  _createClass(ColorUtils, null, [{
    key: "addRGB",
    value: function addRGB(color, red, green, blue) {
      color.red = color.red + red;
      color.green = color.green + green;
      color.blue = color.blue + blue;
    }
  }, {
    key: "lerp",
    value: function lerp(color0, color1, amt) {
      return new paper.default.Color(_mathUtils.MathUtils.lerp(color0.red, color1.red, amt), _mathUtils.MathUtils.lerp(color0.green, color1.green, amt), _mathUtils.MathUtils.lerp(color0.blue, color1.blue, amt));
    } // Generates random color from string hash.

  }, {
    key: "fromStringHash",
    value: function fromStringHash(str) {
      // Compute hash from string
      // Source http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
      var hash = 0,
          i,
          chr;

      for (i = 0; i < str.length; i++) {
        chr = str.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
      } // Hash to rgb color.


      var r = hash & 255;
      var g = (hash & 255 << 8) >> 8;
      var b = (hash & 255 << 16) >> 16;
      return new paper.default.Color(r / 255, g / 255, b / 255);
    }
  }]);

  return ColorUtils;
}();

exports.ColorUtils = ColorUtils;
},{"./mathUtils":"utils/mathUtils.js","paper":"node_modules/paper/dist/paper-full.js"}],"illustrationGen/skeleton.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Skeleton = exports.Bone = exports.allPartNames = exports.facePartName2Index = void 0;

var paper = _interopRequireWildcard(require("paper"));

var _svgUtils = require("../utils/svgUtils");

var _mathUtils = require("../utils/mathUtils");

var _colorUtils = require("../utils/colorUtils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MIN_POSE_SCORE = 0.1;
var MIN_FACE_SCORE = 0.8;
var posePartNames = ['leftAnkle', 'leftKnee', 'leftHip', 'leftWrist', 'leftElbow', 'leftShoulder', 'rightAnkle', 'rightKnee', 'rightHip', 'rightWrist', 'rightElbow', 'rightShoulder', 'leftEar', 'rightEar']; // Mapping between face part names and their vertex indices in TF face mesh.

var facePartName2Index = {
  'topMid': 10,
  'rightTop0': 67,
  'rightTop1': 54,
  'leftTop0': 297,
  'leftTop1': 284,
  'rightJaw0': 21,
  'rightJaw1': 162,
  'rightJaw2': 127,
  'rightJaw3': 234,
  'rightJaw4': 132,
  'rightJaw5': 172,
  'rightJaw6': 150,
  'rightJaw7': 176,
  'jawMid': 152,
  // 0 - 8
  'leftJaw7': 400,
  'leftJaw6': 379,
  'leftJaw5': 397,
  'leftJaw4': 361,
  'leftJaw3': 454,
  'leftJaw2': 356,
  'leftJaw1': 389,
  'leftJaw0': 251,
  // 9 - 16
  'rightBrow0': 46,
  'rightBrow1': 53,
  'rightBrow2': 52,
  'rightBrow3': 65,
  'rightBrow4': 55,
  // 17 - 21
  'leftBrow4': 285,
  'leftBrow3': 295,
  'leftBrow2': 282,
  'leftBrow1': 283,
  'leftBrow0': 276,
  // 22 - 26
  'nose0': 6,
  'nose1': 197,
  'nose2': 195,
  'nose3': 5,
  // 27 - 30
  'rightNose0': 48,
  'rightNose1': 220,
  'nose4': 4,
  'leftNose1': 440,
  'leftNose0': 278,
  // 31 - 35
  'rightEye0': 33,
  'rightEye1': 160,
  'rightEye2': 158,
  'rightEye3': 133,
  'rightEye4': 153,
  'rightEye5': 144,
  // 36 - 41
  'leftEye3': 362,
  'leftEye2': 385,
  'leftEye1': 387,
  'leftEye0': 263,
  'leftEye5': 373,
  'leftEye4': 380,
  // 42 - 47
  'rightMouthCorner': 61,
  'rightUpperLipTop0': 40,
  'rightUpperLipTop1': 37,
  'upperLipTopMid': 0,
  'leftUpperLipTop1': 267,
  'leftUpperLipTop0': 270,
  'leftMouthCorner': 291,
  // 48 - 54
  'leftLowerLipBottom0': 321,
  'leftLowerLipBottom1': 314,
  'lowerLipBottomMid': 17,
  'rightLowerLipBottom1': 84,
  'rightLowerLipBottom0': 91,
  // 55 - 59
  'rightMiddleLip': 78,
  'rightUpperLipBottom1': 81,
  'upperLipBottomMid': 13,
  'leftUpperLipBottom1': 311,
  'leftMiddleLip': 308,
  // 60 - 64
  'leftLowerLipTop0': 402,
  'lowerLipTopMid': 14,
  'rightLowerLipTop0': 178 // 65 - 67

};
exports.facePartName2Index = facePartName2Index;
var facePartNames = ['topMid', 'rightTop0', 'rightTop1', 'leftTop0', 'leftTop1', 'rightJaw0', 'rightJaw1', 'rightJaw2', 'rightJaw3', 'rightJaw4', 'rightJaw5', 'rightJaw6', 'rightJaw7', 'jawMid', // 0 - 8
'leftJaw7', 'leftJaw6', 'leftJaw5', 'leftJaw4', 'leftJaw3', 'leftJaw2', 'leftJaw1', 'leftJaw0', // 9 - 16
'rightBrow0', 'rightBrow1', 'rightBrow2', 'rightBrow3', 'rightBrow4', // 17 - 21
'leftBrow4', 'leftBrow3', 'leftBrow2', 'leftBrow1', 'leftBrow0', // 22 - 26
'nose0', 'nose1', 'nose2', 'nose3', // 27 - 30
'rightNose0', 'rightNose1', 'nose4', 'leftNose1', 'leftNose0', // 31 - 35
'rightEye0', 'rightEye1', 'rightEye2', 'rightEye3', 'rightEye4', 'rightEye5', // 36 - 41
'leftEye3', 'leftEye2', 'leftEye1', 'leftEye0', 'leftEye5', 'leftEye4', // 42 - 47
'rightMouthCorner', 'rightUpperLipTop0', 'rightUpperLipTop1', 'upperLipTopMid', 'leftUpperLipTop1', 'leftUpperLipTop0', 'leftMouthCorner', // 48 - 54
'leftLowerLipBottom0', 'leftLowerLipBottom1', 'lowerLipBottomMid', 'rightLowerLipBottom1', 'rightLowerLipBottom0', // 55 - 59
'rightMiddleLip', 'rightUpperLipBottom1', 'upperLipBottomMid', 'leftUpperLipBottom1', 'leftMiddleLip', // 60 - 64
'leftLowerLipTop0', 'lowerLipTopMid', 'rightLowerLipTop0' // 65 - 67
];
var allPartNames = posePartNames.concat(facePartNames); // Represents a bone formed by two part keypoints.

exports.allPartNames = allPartNames;

var Bone = /*#__PURE__*/function () {
  function Bone() {
    _classCallCheck(this, Bone);
  }

  _createClass(Bone, [{
    key: "set",
    value: function set(kp0, kp1, skeleton, type) {
      this.name = "".concat(kp0.name, "-").concat(kp1.name);
      this.kp0 = kp0;
      this.kp1 = kp1;
      this.skeleton = skeleton;
      this.type = type;
      this.boneColor = _colorUtils.ColorUtils.fromStringHash(this.name);
      this.boneColor.saturation += 0.5;
      return this;
    }
  }, {
    key: "getPointTransform",
    // Finds a point's bone transform.
    // Let anchor be the closest point on the bone to the point.
    // A point's bone transformation is the transformation from anchor to the point.
    value: function getPointTransform(p) {
      var dir = this.kp1.position.subtract(this.kp0.position).normalize();
      var n = dir.clone();
      n.angle += 90;

      var closestP = _mathUtils.MathUtils.getClosestPointOnSegment(this.kp0.position, this.kp1.position, p);

      var v = p.subtract(closestP);
      var dirProjD = v.dot(dir);
      var dirProjN = v.dot(n);
      var d = this.kp0.position.subtract(this.kp1.position).length;
      var anchorPerc = closestP.subtract(this.kp0.position).length / d;
      return {
        transform: new paper.default.Point(dirProjD, dirProjN),
        anchorPerc: anchorPerc
      };
    } // Finds a point's current position from the current bone position.

  }, {
    key: "transform",
    value: function transform(trans) {
      if (!this.kp1.currentPosition || !this.kp0.currentPosition) {
        return;
      } // Scale distance from anchor point base on bone type.
      // All face bones will share one distance scale. All body bones share another.


      var scale = this.type === 'face' ? this.skeleton.currentFaceScale : this.skeleton.currentBodyScale;
      var dir = this.kp1.currentPosition.subtract(this.kp0.currentPosition).normalize();
      var n = dir.clone();
      n.angle += 90;
      var anchor = this.kp0.currentPosition.multiply(1 - trans.anchorPerc).add(this.kp1.currentPosition.multiply(trans.anchorPerc));
      var p = anchor.add(dir.multiply(trans.transform.x * scale)).add(n.multiply(trans.transform.y * scale));
      return p;
    }
  }]);

  return Bone;
}();

exports.Bone = Bone;

function getKeyPointFromSVG(group, partName) {
  var shape = _svgUtils.SVGUtils.findFirstItemWithPrefix(group, partName);

  return {
    position: shape.bounds.center,
    name: partName
  };
}

function getPartFromPose(pose, name) {
  if (!pose || !pose.keypoints) {
    return null;
  }

  var part = pose.keypoints.find(function (kp) {
    return kp.part === name;
  });
  return {
    position: new paper.default.Point(part.position.x, part.position.y),
    score: part.score
  };
}

function getKeypointFromFaceFrame(face, i) {
  if (!face || !face.scaledMesh || !face.scaledMesh.length) ;
  return new paper.default.Point(face.positions[i * 2], face.positions[i * 2 + 1]);
} // Represents a full body skeleton.


var Skeleton = /*#__PURE__*/function () {
  function Skeleton(scope) {
    var _this = this;

    _classCallCheck(this, Skeleton);

    var skeletonGroup = _svgUtils.SVGUtils.findFirstItemWithPrefix(scope.project, 'skeleton'); // Pose


    var leftAnkle = getKeyPointFromSVG(skeletonGroup, 'leftAnkle');
    var leftKnee = getKeyPointFromSVG(skeletonGroup, 'leftKnee');
    var leftHip = getKeyPointFromSVG(skeletonGroup, 'leftHip');
    var leftWrist = getKeyPointFromSVG(skeletonGroup, 'leftWrist');
    var leftElbow = getKeyPointFromSVG(skeletonGroup, 'leftElbow');
    var leftShoulder = getKeyPointFromSVG(skeletonGroup, 'leftShoulder');
    var rightAnkle = getKeyPointFromSVG(skeletonGroup, 'rightAnkle');
    var rightKnee = getKeyPointFromSVG(skeletonGroup, 'rightKnee');
    var rightHip = getKeyPointFromSVG(skeletonGroup, 'rightHip');
    var rightWrist = getKeyPointFromSVG(skeletonGroup, 'rightWrist');
    var rightElbow = getKeyPointFromSVG(skeletonGroup, 'rightElbow');
    var rightShoulder = getKeyPointFromSVG(skeletonGroup, 'rightShoulder'); // Face

    var topMid = getKeyPointFromSVG(skeletonGroup, 'topMid');
    var rightTop0 = getKeyPointFromSVG(skeletonGroup, 'rightTop0');
    var rightTop1 = getKeyPointFromSVG(skeletonGroup, 'rightTop1');
    var leftTop0 = getKeyPointFromSVG(skeletonGroup, 'leftTop0');
    var leftTop1 = getKeyPointFromSVG(skeletonGroup, 'leftTop1');
    var leftJaw2 = getKeyPointFromSVG(skeletonGroup, 'leftJaw2');
    var leftJaw3 = getKeyPointFromSVG(skeletonGroup, 'leftJaw3');
    var leftJaw4 = getKeyPointFromSVG(skeletonGroup, 'leftJaw4');
    var leftJaw5 = getKeyPointFromSVG(skeletonGroup, 'leftJaw5');
    var leftJaw6 = getKeyPointFromSVG(skeletonGroup, 'leftJaw6');
    var leftJaw7 = getKeyPointFromSVG(skeletonGroup, 'leftJaw7');
    var jawMid = getKeyPointFromSVG(skeletonGroup, 'jawMid');
    var rightJaw2 = getKeyPointFromSVG(skeletonGroup, 'rightJaw2');
    var rightJaw3 = getKeyPointFromSVG(skeletonGroup, 'rightJaw3');
    var rightJaw4 = getKeyPointFromSVG(skeletonGroup, 'rightJaw4');
    var rightJaw5 = getKeyPointFromSVG(skeletonGroup, 'rightJaw5');
    var rightJaw6 = getKeyPointFromSVG(skeletonGroup, 'rightJaw6');
    var rightJaw7 = getKeyPointFromSVG(skeletonGroup, 'rightJaw7');
    var nose0 = getKeyPointFromSVG(skeletonGroup, 'nose0');
    var nose1 = getKeyPointFromSVG(skeletonGroup, 'nose1');
    var nose2 = getKeyPointFromSVG(skeletonGroup, 'nose2');
    var nose3 = getKeyPointFromSVG(skeletonGroup, 'nose3');
    var nose4 = getKeyPointFromSVG(skeletonGroup, 'nose4');
    var leftNose0 = getKeyPointFromSVG(skeletonGroup, 'leftNose0');
    var leftNose1 = getKeyPointFromSVG(skeletonGroup, 'leftNose1');
    var rightNose0 = getKeyPointFromSVG(skeletonGroup, 'rightNose0');
    var rightNose1 = getKeyPointFromSVG(skeletonGroup, 'rightNose1');
    var leftEye0 = getKeyPointFromSVG(skeletonGroup, 'leftEye0');
    var leftEye1 = getKeyPointFromSVG(skeletonGroup, 'leftEye1');
    var leftEye2 = getKeyPointFromSVG(skeletonGroup, 'leftEye2');
    var leftEye3 = getKeyPointFromSVG(skeletonGroup, 'leftEye3');
    var leftEye4 = getKeyPointFromSVG(skeletonGroup, 'leftEye4');
    var leftEye5 = getKeyPointFromSVG(skeletonGroup, 'leftEye5');
    var rightEye0 = getKeyPointFromSVG(skeletonGroup, 'rightEye0');
    var rightEye1 = getKeyPointFromSVG(skeletonGroup, 'rightEye1');
    var rightEye2 = getKeyPointFromSVG(skeletonGroup, 'rightEye2');
    var rightEye3 = getKeyPointFromSVG(skeletonGroup, 'rightEye3');
    var rightEye4 = getKeyPointFromSVG(skeletonGroup, 'rightEye4');
    var rightEye5 = getKeyPointFromSVG(skeletonGroup, 'rightEye5');
    var leftBrow0 = getKeyPointFromSVG(skeletonGroup, 'leftBrow0');
    var leftBrow1 = getKeyPointFromSVG(skeletonGroup, 'leftBrow1');
    var leftBrow2 = getKeyPointFromSVG(skeletonGroup, 'leftBrow2');
    var leftBrow3 = getKeyPointFromSVG(skeletonGroup, 'leftBrow3');
    var leftBrow4 = getKeyPointFromSVG(skeletonGroup, 'leftBrow4');
    var rightBrow0 = getKeyPointFromSVG(skeletonGroup, 'rightBrow0');
    var rightBrow1 = getKeyPointFromSVG(skeletonGroup, 'rightBrow1');
    var rightBrow2 = getKeyPointFromSVG(skeletonGroup, 'rightBrow2');
    var rightBrow3 = getKeyPointFromSVG(skeletonGroup, 'rightBrow3');
    var rightBrow4 = getKeyPointFromSVG(skeletonGroup, 'rightBrow4');
    var leftMouthCorner = getKeyPointFromSVG(skeletonGroup, 'leftMouthCorner');
    var leftUpperLipTop0 = getKeyPointFromSVG(skeletonGroup, 'leftUpperLipTop0');
    var leftUpperLipTop1 = getKeyPointFromSVG(skeletonGroup, 'leftUpperLipTop1');
    var upperLipTopMid = getKeyPointFromSVG(skeletonGroup, 'upperLipTopMid');
    var rightMouthCorner = getKeyPointFromSVG(skeletonGroup, 'rightMouthCorner');
    var rightUpperLipTop0 = getKeyPointFromSVG(skeletonGroup, 'rightUpperLipTop0');
    var rightUpperLipTop1 = getKeyPointFromSVG(skeletonGroup, 'rightUpperLipTop1');
    var rightMiddleLip = getKeyPointFromSVG(skeletonGroup, 'rightMiddleLip');
    var rightUpperLipBottom1 = getKeyPointFromSVG(skeletonGroup, 'rightUpperLipBottom1');
    var leftMiddleLip = getKeyPointFromSVG(skeletonGroup, 'leftMiddleLip');
    var leftUpperLipBottom1 = getKeyPointFromSVG(skeletonGroup, 'leftUpperLipBottom1');
    var upperLipBottomMid = getKeyPointFromSVG(skeletonGroup, 'upperLipBottomMid');
    var rightLowerLipTop0 = getKeyPointFromSVG(skeletonGroup, 'rightLowerLipTop0');
    var leftLowerLipTop0 = getKeyPointFromSVG(skeletonGroup, 'leftLowerLipTop0');
    var lowerLipTopMid = getKeyPointFromSVG(skeletonGroup, 'lowerLipTopMid');
    var rightLowerLipBottom0 = getKeyPointFromSVG(skeletonGroup, 'rightLowerLipBottom0');
    var rightLowerLipBottom1 = getKeyPointFromSVG(skeletonGroup, 'rightLowerLipBottom1');
    var leftLowerLipBottom0 = getKeyPointFromSVG(skeletonGroup, 'leftLowerLipBottom0');
    var leftLowerLipBottom1 = getKeyPointFromSVG(skeletonGroup, 'leftLowerLipBottom1');
    var lowerLipBottomMid = getKeyPointFromSVG(skeletonGroup, 'lowerLipBottomMid');
    this.bLeftShoulderRightShoulder = new Bone().set(leftShoulder, rightShoulder, this, 'body');
    this.bRightShoulderRightHip = new Bone().set(rightShoulder, rightHip, this, 'body');
    this.bLeftHipRightHip = new Bone().set(leftHip, rightHip, this, 'body');
    this.bLeftShoulderLeftHip = new Bone().set(leftShoulder, leftHip, this, 'body');
    this.bLeftShoulderLeftElbow = new Bone().set(leftShoulder, leftElbow, this, 'body');
    this.bLeftElbowLeftWrist = new Bone().set(leftElbow, leftWrist, this, 'body');
    this.bRightShoulderRightElbow = new Bone().set(rightShoulder, rightElbow, this, 'body');
    this.bRightElbowRightWrist = new Bone().set(rightElbow, rightWrist, this, 'body');
    this.bLeftHipLeftKnee = new Bone().set(leftHip, leftKnee, this, 'body');
    this.bLeftKneeLeftAnkle = new Bone().set(leftKnee, leftAnkle, this, 'body');
    this.bRightHipRightKnee = new Bone().set(rightHip, rightKnee, this, 'body');
    this.bRightKneeRightAnkle = new Bone().set(rightKnee, rightAnkle, this, 'body');
    this.bTopMidRightTop0 = new Bone().set(topMid, rightTop0, this, 'face');
    this.bTopMidLeftTop0 = new Bone().set(topMid, leftTop0, this, 'face');
    this.bLeftTop0LeftTop1 = new Bone().set(leftTop0, leftTop1, this, 'face');
    this.bLeftTop1LeftJaw2 = new Bone().set(leftTop1, leftJaw2, this, 'face');
    this.bLeftJaw2LeftJaw3 = new Bone().set(leftJaw2, leftJaw3, this, 'face');
    this.bLeftJaw3LeftJaw4 = new Bone().set(leftJaw3, leftJaw4, this, 'face');
    this.bLeftJaw4LeftJaw5 = new Bone().set(leftJaw4, leftJaw5, this, 'face');
    this.bLeftJaw5LeftJaw6 = new Bone().set(leftJaw5, leftJaw6, this, 'face');
    this.bLeftJaw6LeftJaw7 = new Bone().set(leftJaw6, leftJaw7, this, 'face');
    this.bLeftJaw7JawMid = new Bone().set(leftJaw7, jawMid, this, 'face');
    this.bRightTop0RightTop1 = new Bone().set(rightTop0, rightTop1, this, 'face');
    this.bRightTop1RightJaw2 = new Bone().set(rightTop1, rightJaw2, this, 'face');
    this.bRightJaw2RightJaw3 = new Bone().set(rightJaw2, rightJaw3, this, 'face');
    this.bRightJaw3RightJaw4 = new Bone().set(rightJaw3, rightJaw4, this, 'face');
    this.bRightJaw4RightJaw5 = new Bone().set(rightJaw4, rightJaw5, this, 'face');
    this.bRightJaw5RightJaw6 = new Bone().set(rightJaw5, rightJaw6, this, 'face');
    this.bRightJaw6RightJaw7 = new Bone().set(rightJaw6, rightJaw7, this, 'face');
    this.bRightJaw7JawMid = new Bone().set(rightJaw7, jawMid, this, 'face');
    this.bLeftEye0LeftEye1 = new Bone().set(leftEye0, leftEye1, this, 'face');
    this.bLeftEye1LeftEye2 = new Bone().set(leftEye1, leftEye2, this, 'face');
    this.bLeftEye2LeftEye3 = new Bone().set(leftEye2, leftEye3, this, 'face');
    this.bLeftEye3LeftEye4 = new Bone().set(leftEye3, leftEye4, this, 'face');
    this.bLeftEye4LeftEye5 = new Bone().set(leftEye4, leftEye5, this, 'face');
    this.bLeftEye5LeftEye0 = new Bone().set(leftEye5, leftEye0, this, 'face');
    this.bRightEye0RightEye1 = new Bone().set(rightEye0, rightEye1, this, 'face');
    this.bRightEye1RightEye2 = new Bone().set(rightEye1, rightEye2, this, 'face');
    this.bRightEye2RightEye3 = new Bone().set(rightEye2, rightEye3, this, 'face');
    this.bRightEye3RightEye4 = new Bone().set(rightEye3, rightEye4, this, 'face');
    this.bRightEye4RightEye5 = new Bone().set(rightEye4, rightEye5, this, 'face');
    this.bRightEye5RightEye0 = new Bone().set(rightEye5, rightEye0, this, 'face');
    this.bLeftBrow0LeftBrow1 = new Bone().set(leftBrow0, leftBrow1, this, 'face');
    this.bLeftBrow1LeftBrow2 = new Bone().set(leftBrow1, leftBrow2, this, 'face');
    this.bLeftBrow2LeftBrow3 = new Bone().set(leftBrow2, leftBrow3, this, 'face');
    this.bLeftBrow3LeftBrow4 = new Bone().set(leftBrow3, leftBrow4, this, 'face');
    this.bRightBrow0RightBrow1 = new Bone().set(rightBrow0, rightBrow1, this, 'face');
    this.bRightBrow1RightBrow2 = new Bone().set(rightBrow1, rightBrow2, this, 'face');
    this.bRightBrow2RightBrow3 = new Bone().set(rightBrow2, rightBrow3, this, 'face');
    this.bRightBrow3RightBrow4 = new Bone().set(rightBrow3, rightBrow4, this, 'face');
    this.bNose0Nose1 = new Bone().set(nose0, nose1, this, 'face');
    this.bNose1Nose2 = new Bone().set(nose1, nose2, this, 'face');
    this.bNose2Nose3 = new Bone().set(nose2, nose3, this, 'face');
    this.bNose3Nose4 = new Bone().set(nose3, nose4, this, 'face');
    this.bLeftNose0LeftNose1 = new Bone().set(leftNose0, leftNose1, this, 'face');
    this.bLeftNose1Nose4 = new Bone().set(leftNose1, nose4, this, 'face');
    this.bRightNose0RightNose1 = new Bone().set(rightNose0, rightNose1, this, 'face');
    this.bRightNose1Nose4 = new Bone().set(rightNose1, nose4, this, 'face');
    this.bLeftMouthCornerLeftUpperLipTop0 = new Bone().set(leftMouthCorner, leftUpperLipTop0, this, 'face');
    this.bLeftUpperLipTop0LeftUpperLipTop1 = new Bone().set(leftUpperLipTop0, leftUpperLipTop1, this, 'face');
    this.bLeftUpperLipTop1UpperLipTopMid = new Bone().set(leftUpperLipTop1, upperLipTopMid, this, 'face');
    this.bRigthMouthCornerRigthUpperLipTop0 = new Bone().set(rightMouthCorner, rightUpperLipTop0, this, 'face');
    this.bRigthUpperLipTop0RigthUpperLipTop1 = new Bone().set(rightUpperLipTop0, rightUpperLipTop1, this, 'face');
    this.bRigthUpperLipTop1UpperLipTopMid = new Bone().set(rightUpperLipTop1, upperLipTopMid, this, 'face');
    this.bLeftMouthCornerLeftMiddleLip = new Bone().set(leftMouthCorner, leftMiddleLip, this, 'face');
    this.bLeftMiddleLipLeftUpperLipBottom1 = new Bone().set(leftMiddleLip, leftUpperLipBottom1, this, 'face');
    this.bLeftUpperLipBottom1UpperLipBottomMid = new Bone().set(leftUpperLipBottom1, upperLipBottomMid, this, 'face');
    this.bRightMouthCornerRightMiddleLip = new Bone().set(rightMouthCorner, rightMiddleLip, this, 'face');
    this.bRightMiddleLipRightUpperLipBottom1 = new Bone().set(rightMiddleLip, rightUpperLipBottom1, this, 'face');
    this.bRightUpperLipBottom1UpperLipBototmMid = new Bone().set(rightUpperLipBottom1, upperLipBottomMid, this, 'face');
    this.bLeftMiddleLipLeftLowerLipTop0 = new Bone().set(leftMiddleLip, leftLowerLipTop0, this, 'face');
    this.bLeftLowerLipTop0LowerLipTopMid = new Bone().set(leftLowerLipTop0, lowerLipTopMid, this, 'face');
    this.bRightMiddleLipRightLowerLipTop0 = new Bone().set(rightMiddleLip, rightLowerLipTop0, this, 'face');
    this.bRightLowerLipTop0LowerLipTopMid = new Bone().set(rightLowerLipTop0, lowerLipTopMid, this, 'face');
    this.bLeftMouthCornerLeftLowerLipBottom0 = new Bone().set(leftMouthCorner, leftLowerLipBottom0, this, 'face');
    this.bLeftLowerLipBottom0LeftLowerLipBottom1 = new Bone().set(leftLowerLipBottom0, leftLowerLipBottom1, this, 'face');
    this.bLeftLowerLipBottom1LowerLipBottomMid = new Bone().set(leftLowerLipBottom1, lowerLipBottomMid, this, 'face');
    this.bRightMouthCornerRightLowerLipBottom0 = new Bone().set(rightMouthCorner, rightLowerLipBottom0, this, 'face');
    this.bRightLowerLipBottom0RightLowerLipBottom1 = new Bone().set(rightLowerLipBottom0, rightLowerLipBottom1, this, 'face');
    this.bRightLowerLipBottom1LowerLipBottomMid = new Bone().set(rightLowerLipBottom1, lowerLipBottomMid, this, 'face');
    this.faceBones = [// Face
    this.bTopMidRightTop0, this.bRightTop0RightTop1, this.bTopMidLeftTop0, this.bLeftTop0LeftTop1, this.bLeftTop1LeftJaw2, this.bLeftJaw2LeftJaw3, this.bLeftJaw3LeftJaw4, this.bLeftJaw4LeftJaw5, this.bLeftJaw5LeftJaw6, this.bLeftJaw6LeftJaw7, this.bLeftJaw7JawMid, this.bRightTop1RightJaw2, this.bRightJaw2RightJaw3, this.bRightJaw3RightJaw4, this.bRightJaw4RightJaw5, this.bRightJaw5RightJaw6, this.bRightJaw6RightJaw7, this.bRightJaw7JawMid, this.bLeftEye0LeftEye1, this.bLeftEye1LeftEye2, this.bLeftEye2LeftEye3, this.bLeftEye3LeftEye4, this.bLeftEye4LeftEye5, this.bLeftEye5LeftEye0, this.bRightEye0RightEye1, this.bRightEye1RightEye2, this.bRightEye2RightEye3, this.bRightEye3RightEye4, this.bRightEye4RightEye5, this.bRightEye5RightEye0, this.bLeftBrow0LeftBrow1, this.bLeftBrow1LeftBrow2, this.bLeftBrow2LeftBrow3, this.bLeftBrow3LeftBrow4, this.bRightBrow0RightBrow1, this.bRightBrow1RightBrow2, this.bRightBrow2RightBrow3, this.bRightBrow3RightBrow4, this.bNose0Nose1, this.bNose1Nose2, this.bNose2Nose3, this.bNose3Nose4, this.bLeftNose0LeftNose1, this.bLeftNose1Nose4, this.bRightNose0RightNose1, this.bRightNose1Nose4, this.bLeftMouthCornerLeftUpperLipTop0, this.bLeftUpperLipTop0LeftUpperLipTop1, this.bLeftUpperLipTop1UpperLipTopMid, this.bRigthMouthCornerRigthUpperLipTop0, this.bRigthUpperLipTop0RigthUpperLipTop1, this.bRigthUpperLipTop1UpperLipTopMid, this.bLeftMouthCornerLeftMiddleLip, this.bLeftMiddleLipLeftUpperLipBottom1, this.bLeftUpperLipBottom1UpperLipBottomMid, this.bRightMouthCornerRightMiddleLip, this.bRightMiddleLipRightUpperLipBottom1, this.bRightUpperLipBottom1UpperLipBototmMid, this.bLeftMiddleLipLeftLowerLipTop0, this.bLeftLowerLipTop0LowerLipTopMid, this.bRightMiddleLipRightLowerLipTop0, this.bRightLowerLipTop0LowerLipTopMid, this.bLeftMouthCornerLeftLowerLipBottom0, this.bLeftLowerLipBottom0LeftLowerLipBottom1, this.bLeftLowerLipBottom1LowerLipBottomMid, this.bRightMouthCornerRightLowerLipBottom0, this.bRightLowerLipBottom0RightLowerLipBottom1, this.bRightLowerLipBottom1LowerLipBottomMid];
    this.bodyBones = [// Body
    this.bLeftShoulderRightShoulder, this.bRightShoulderRightHip, this.bLeftHipRightHip, this.bLeftShoulderLeftHip, this.bLeftShoulderLeftElbow, this.bLeftElbowLeftWrist, this.bRightShoulderRightElbow, this.bRightElbowRightWrist, this.bLeftHipLeftKnee, this.bLeftKneeLeftAnkle, this.bRightHipRightKnee, this.bRightKneeRightAnkle];
    this.bones = this.faceBones.concat(this.bodyBones);
    this.secondaryBones = [];
    this.parts = {};
    this.bodyLen0 = this.getTotalBoneLength(this.bodyBones);
    this.faceLen0 = this.getTotalBoneLength(this.faceBones);
    this.boneGroups = {
      'torso': [this.bLeftShoulderRightShoulder, this.bRightShoulderRightHip, this.bLeftHipRightHip, this.bLeftShoulderLeftHip],
      'leftLeg': [this.bLeftHipLeftKnee, this.bLeftKneeLeftAnkle],
      'rightLeg': [this.bRightHipRightKnee, this.bRightKneeRightAnkle],
      'leftArm': [this.bLeftShoulderLeftElbow, this.bLeftElbowLeftWrist],
      'rightArm': [this.bRightElbowRightWrist, this.bRightShoulderRightElbow],
      'face': this.faceBones
    };
    this.faceBones.forEach(function (bone) {
      var parts = [bone.kp0, bone.kp1];
      parts.forEach(function (part) {
        part.baseTransFunc = _mathUtils.MathUtils.getTransformFunc(_this.bLeftJaw2LeftJaw3.kp0.position, _this.bRightJaw2RightJaw3.kp0.position, part.position);
      });
    });
  }

  _createClass(Skeleton, [{
    key: "update",
    value: function update(pose, face) {
      var _this2 = this;

      if (pose.score < MIN_POSE_SCORE) {
        this.isValid = false;
        return;
      }

      this.isValid = this.updatePoseParts(pose);
      if (!this.isValid) return;
      this.isValid = this.updateFaceParts(face);
      if (!this.isValid) return; // Update bones.

      this.bones.forEach(function (bone) {
        var part0 = _this2.parts[bone.kp0.name];
        var part1 = _this2.parts[bone.kp1.name];
        bone.kp0.currentPosition = part0.position;
        bone.kp1.currentPosition = part1.position;
        bone.score = (part0.score + part1.score) / 2;
        bone.latestCenter = bone.kp1.currentPosition.add(bone.kp0.currentPosition).divide(2);
      }); // Update secondary bones.

      var nosePos = this.bNose3Nose4.kp1.currentPosition;
      this.secondaryBones.forEach(function (bone) {
        bone.kp0.currentPosition = bone.kp0.transformFunc(bone.parent.kp0.currentPosition, nosePos);
        bone.kp1.currentPosition = bone.kp1.transformFunc(bone.parent.kp1.currentPosition, nosePos);
        bone.score = bone.parent.score;
        bone.latestCenter = bone.kp1.currentPosition.add(bone.kp0.currentPosition).divide(2);
      }); // Recompute face & body bone scale.

      this.currentFaceScale = this.getTotalBoneLength(this.faceBones) / this.faceLen0;
      this.currentBodyScale = this.getTotalBoneLength(this.bodyBones) / this.bodyLen0;
      this.isValid = true;
    }
  }, {
    key: "updatePoseParts",
    value: function updatePoseParts(pose) {
      var _this3 = this;

      posePartNames.forEach(function (partName) {
        // Use new and old pose's confidence scores as weights to compute the new part position.
        var part1 = getPartFromPose(pose, partName);
        var part0 = _this3.parts[partName] || part1;
        var weight0 = part0.score / (part1.score + part0.score);
        var weight1 = part1.score / (part1.score + part0.score);
        var pos = part0.position.multiply(weight0).add(part1.position.multiply(weight1));
        _this3.parts[partName] = {
          position: pos,
          score: part0.score * weight0 + part1.score * weight1
        };
      });

      if (!this.parts['rightEar'] || !this.parts['leftEar']) {
        return false;
      }

      return true;
    }
  }, {
    key: "updateFaceParts",
    value: function updateFaceParts(face) {
      var _this4 = this;

      var posLeftEar = this.parts['leftEar'].position;
      var posRightEar = this.parts['rightEar'].position;

      if (face && face.positions && face.positions.length && face.faceInViewConfidence > MIN_FACE_SCORE) {
        // Valid face results.
        for (var i = 0; i < facePartNames.length; i++) {
          var partName = facePartNames[i];
          var pos = getKeypointFromFaceFrame(face, i);
          if (!pos) continue;
          this.parts[partName] = {
            position: pos,
            score: face.faceInViewConfidence
          };
        } // Keep track of the transformation from pose ear positions to face ear positions.
        // This can be used to infer face position when face tracking is lost.


        this.leftEarP2FFunc = _mathUtils.MathUtils.getTransformFunc(posLeftEar, posRightEar, this.parts['leftJaw2'].position);
        this.rightEarP2FFunc = _mathUtils.MathUtils.getTransformFunc(posLeftEar, posRightEar, this.parts['rightJaw2'].position);
      } else {
        // Invalid face keypoints. Infer face keypoints from pose.
        var fLeftEar = this.leftEarP2FFunc ? this.leftEarP2FFunc(posLeftEar, posRightEar) : posLeftEar;
        var fRightEar = this.rightEarP2FFunc ? this.rightEarP2FFunc(posLeftEar, posRightEar) : posRightEar; // Also infer face scale from pose.

        this.currentFaceScale = this.currentBodyScale;
        this.faceBones.forEach(function (bone) {
          var parts = [bone.kp0, bone.kp1];
          parts.forEach(function (part) {
            _this4.parts[part.name] = {
              position: part.baseTransFunc(fLeftEar, fRightEar),
              score: 1
            };
          });
        });
      }

      return true;
    }
  }, {
    key: "findBoneGroup",
    value: function findBoneGroup(point) {
      var _this5 = this;

      var minDistances = {};
      Object.keys(this.boneGroups).forEach(function (boneGroupKey) {
        var minDistance = Infinity;
        var boneGroup = _this5.boneGroups[boneGroupKey];
        boneGroup.forEach(function (bone) {
          var d = _mathUtils.MathUtils.getClosestPointOnSegment(bone.kp0.position, bone.kp1.position, point).getDistance(point);

          minDistance = Math.min(minDistance, d);
        });
        minDistances[boneGroupKey] = minDistance;
      });
      var minDistance = Math.min.apply(Math, _toConsumableArray(Object.values(minDistances)));
      var selectedGroups = [];
      Object.keys(minDistances).forEach(function (key) {
        var distance = minDistances[key];

        if (distance <= minDistance) {
          selectedGroups.push(_this5.boneGroups[key]);
        }
      });
      return selectedGroups.flatten();
    }
  }, {
    key: "getTotalBoneLength",
    value: function getTotalBoneLength(bones) {
      var totalLen = 0;
      bones.forEach(function (bone) {
        var d = (bone.kp0.currentPosition || bone.kp0.position).subtract(bone.kp1.currentPosition || bone.kp1.position);
        totalLen += d.length;
      });
      return totalLen;
    }
  }, {
    key: "debugDraw",
    value: function debugDraw(scope) {
      var group = new scope.Group();
      scope.project.activeLayer.addChild(group);
      this.bones.forEach(function (bone) {
        var path = new scope.Path({
          segments: [bone.kp0.currentPosition, bone.kp1.currentPosition],
          strokeWidth: 2,
          strokeColor: bone.boneColor
        });
        group.addChild(path);
      }); // this.secondaryBones.forEach(bone => {
      //     let path = new scope.Path({
      //         segments: [bone.kp0.currentPosition, bone.kp1.currentPosition],
      //         strokeColor: '#00ff00',
      //         strokeWidth: 5,
      //     });
      //     group.addChild(path);
      // });
    }
  }, {
    key: "debugDrawLabels",
    value: function debugDrawLabels(scope) {
      var group = new scope.Group();
      scope.project.activeLayer.addChild(group);
      this.bones.forEach(function (bone) {
        var addLabel = function addLabel(kp, name) {
          var text = new scope.PointText({
            point: [kp.currentPosition.x, kp.currentPosition.y],
            content: name,
            fillColor: 'black',
            fontSize: 7
          });
          group.addChild(text);
        };

        addLabel(bone.kp0, bone.kp0.name);
        addLabel(bone.kp1, bone.kp1.name);
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.parts = [];
    }
  }], [{
    key: "getCurrentPosition",
    value: function getCurrentPosition(segment) {
      var position = new paper.default.Point();
      Object.keys(segment.skinning).forEach(function (boneName) {
        var bt = segment.skinning[boneName];
        position = position.add(bt.bone.transform(bt.transform).multiply(bt.weight));
      });
      return position;
    }
  }, {
    key: "flipPose",
    value: function flipPose(pose) {
      pose.keypoints.forEach(function (kp) {
        if (kp.part && kp.part.startsWith('left')) {
          kp.part = 'right' + kp.part.substring('left'.length, kp.part.length);
        } else if (kp.part && kp.part.startsWith('right')) {
          kp.part = 'left' + kp.part.substring('right'.length, kp.part.length);
        }
      });
    }
  }, {
    key: "flipFace",
    value: function flipFace(face) {
      Object.keys(facePartName2Index).forEach(function (partName) {
        if (partName.startsWith('left')) {
          var rightName = 'right' + partName.substr('left'.length, partName.length);
          var temp = face.scaledMesh[facePartName2Index[partName]];
          face.scaledMesh[facePartName2Index[partName]] = face.scaledMesh[facePartName2Index[rightName]];
          face.scaledMesh[facePartName2Index[rightName]] = temp;
        }
      });
    }
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(pose) {
      var minX = 100000;
      var maxX = -100000;
      var minY = 100000;
      var maxY = -100000;

      var updateMinMax = function updateMinMax(x, y) {
        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);
        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);
      };

      pose.frames.forEach(function (frame) {
        frame.pose.keypoints.forEach(function (kp) {
          updateMinMax(kp.position.x, kp.position.y);
        });
        var faceKeypoints = frame.face.positions;

        for (var i = 0; i < faceKeypoints.length; i += 2) {
          updateMinMax(faceKeypoints[i], faceKeypoints[i + 1]);
        }
      });
      return [minX, maxX, minY, maxY];
    }
  }, {
    key: "translatePose",
    value: function translatePose(pose, d) {
      pose.frames.forEach(function (frame) {
        frame.pose.keypoints.forEach(function (kp) {
          kp.position.x += d.x;
          kp.position.y += d.y;
        });
        var faceKeypoints = frame.face.positions;

        for (var i = 0; i < faceKeypoints.length; i += 2) {
          faceKeypoints[i] += d.x;
          faceKeypoints[i + 1] += d.y;
        }
      });
    }
  }, {
    key: "resizePose",
    value: function resizePose(pose, origin, scale) {
      pose.frames.forEach(function (frame) {
        frame.pose.keypoints.forEach(function (kp) {
          kp.position.x = origin.x + (kp.position.x - origin.x) * scale.x;
          kp.position.y = origin.y + (kp.position.y - origin.y) * scale.y;
        });
        var faceKeypoints = frame.face.positions;

        for (var i = 0; i < faceKeypoints.length; i += 2) {
          faceKeypoints[i] = origin.x + (faceKeypoints[i] - origin.x) * scale.x;
          faceKeypoints[i + 1] = origin.y + (faceKeypoints[i + 1] - origin.y) * scale.y;
        }
      });
    }
  }, {
    key: "toFaceFrame",
    value: function toFaceFrame(faceDetection) {
      var frame = {
        positions: [],
        faceInViewConfidence: faceDetection.faceInViewConfidence
      };

      for (var i = 0; i < facePartNames.length; i++) {
        var partName = facePartNames[i];
        var p = faceDetection.scaledMesh[facePartName2Index[partName]];
        frame.positions.push(p[0]);
        frame.positions.push(p[1]);
      }

      return frame;
    }
  }]);

  return Skeleton;
}();

exports.Skeleton = Skeleton;
},{"paper":"node_modules/paper/dist/paper-full.js","../utils/svgUtils":"utils/svgUtils.js","../utils/mathUtils":"utils/mathUtils.js","../utils/colorUtils":"utils/colorUtils.js"}],"illustrationGen/illustration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PoseIllustration = void 0;

var _skeleton = require("./skeleton");

var _mathUtils = require("../utils/mathUtils");

var _svgUtils = require("../utils/svgUtils");

var _colorUtils = require("../utils/colorUtils");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var allPartNamesMap = {};

_skeleton.allPartNames.forEach(function (name) {
  return allPartNamesMap[name] = 1;
});

var MIN_CONFIDENCE_PATH_SCORE = 0.3; // Represents a skinned illustration.

var PoseIllustration = /*#__PURE__*/function () {
  function PoseIllustration(scope) {
    _classCallCheck(this, PoseIllustration);

    this.scope = scope;
    this.frames = [];
  }

  _createClass(PoseIllustration, [{
    key: "updateSkeleton",
    value: function updateSkeleton(pose, face) {
      this.pose = pose;
      this.face = face;
      this.skeleton.update(pose, face);

      if (!this.skeleton.isValid) {
        return;
      }

      var getConfidenceScore = function getConfidenceScore(p) {
        return Object.keys(p.skinning).reduce(function (totalScore, boneName) {
          var bt = p.skinning[boneName];
          return totalScore + bt.bone.score * bt.weight;
        }, 0);
      };

      this.skinnedPaths.forEach(function (skinnedPath) {
        var confidenceScore = 0;
        skinnedPath.segments.forEach(function (seg) {
          // Compute confidence score.
          confidenceScore += getConfidenceScore(seg.point); // Compute new positions for curve point and handles.

          seg.point.currentPosition = _skeleton.Skeleton.getCurrentPosition(seg.point);

          if (seg.handleIn) {
            seg.handleIn.currentPosition = _skeleton.Skeleton.getCurrentPosition(seg.handleIn);
          }

          if (seg.handleOut) {
            seg.handleOut.currentPosition = _skeleton.Skeleton.getCurrentPosition(seg.handleOut);
          }
        });
        skinnedPath.confidenceScore = confidenceScore / (skinnedPath.segments.length || 1);
      });
    }
  }, {
    key: "draw",
    value: function draw() {
      if (!this.skeleton.isValid) {
        return;
      }

      var scope = this.scope; // Add paths

      this.skinnedPaths.forEach(function (skinnedPath) {
        // Do not render paths with low confidence scores.
        if (!skinnedPath.confidenceScore || skinnedPath.confidenceScore < MIN_CONFIDENCE_PATH_SCORE) {
          return;
        }

        var path = new scope.Path({
          fillColor: skinnedPath.fillColor,
          strokeColor: skinnedPath.strokeColor,
          strokeWidth: skinnedPath.strokeWidth,
          closed: skinnedPath.closed
        });
        skinnedPath.segments.forEach(function (seg) {
          path.addSegment(seg.point.currentPosition, seg.handleIn ? seg.handleIn.currentPosition.subtract(seg.point.currentPosition) : null, seg.handleOut ? seg.handleOut.currentPosition.subtract(seg.point.currentPosition) : null);
        });

        if (skinnedPath.closed) {
          path.closePath();
        }

        scope.project.activeLayer.addChild(path);
      });
    }
  }, {
    key: "debugDraw",
    value: function debugDraw() {
      var scope = this.scope;
      var group = new scope.Group();
      scope.project.activeLayer.addChild(group);

      var drawCircle = function drawCircle(p) {
        var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        group.addChild(new scope.Path.Circle({
          center: [p.x, p.y],
          radius: opt.radius || 2,
          fillColor: opt.fillColor || 'red'
        }));
      };

      var drawLine = function drawLine(p0, p1) {
        var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        group.addChild(new scope.Path({
          segments: [p0, p1],
          strokeColor: opt.strokeColor || 'red',
          strokeWidth: opt.strokeWidth || 1
        }));
      }; // Draw skeleton.


      this.skeleton.debugDraw(scope); // Draw curve and handles.

      this.skinnedPaths.forEach(function (skinnedPath) {
        skinnedPath.segments.forEach(function (seg) {
          // Color represents weight influence from bones.
          var color = new scope.Color(0);
          Object.keys(seg.point.skinning).forEach(function (boneName) {
            var bt = seg.point.skinning[boneName];

            _colorUtils.ColorUtils.addRGB(color, bt.weight * bt.bone.boneColor.red, bt.weight * bt.bone.boneColor.green, bt.weight * bt.bone.boneColor.blue);

            var anchor = bt.bone.kp0.currentPosition.multiply(1 - bt.transform.anchorPerc).add(bt.bone.kp1.currentPosition.multiply(bt.transform.anchorPerc));
            drawLine(anchor, seg.point.currentPosition, {
              strokeColor: 'blue',
              strokeWidth: bt.weight
            });
          });
          drawCircle(seg.point.currentPosition, {
            fillColor: color
          });
          drawCircle(seg.handleIn.currentPosition, {
            fillColor: color
          });
          drawLine(seg.point.currentPosition, seg.handleIn.currentPosition, {
            strokeColor: color
          });
          drawCircle(seg.handleOut.currentPosition, {
            fillColor: color
          }, {
            strokeColor: color
          });
          drawLine(seg.point.currentPosition, seg.handleOut.currentPosition);
        });
      });
    }
  }, {
    key: "debugDrawLabel",
    value: function debugDrawLabel(scope) {
      this.skeleton.debugDrawLabels(scope);
    }
  }, {
    key: "bindSkeleton",
    value: function bindSkeleton(skeleton, skeletonScope) {
      var items = skeletonScope.project.getItems({
        recursive: true
      });
      items = items.filter(function (item) {
        return item.parent && item.parent.name && item.parent.name.startsWith('illustration');
      });
      this.skeleton = skeleton;
      this.skinnedPaths = []; // Only support rendering path and shapes for now.

      for (var i = 0; i < items.length; i++) {
        var item = items[i];

        if (_svgUtils.SVGUtils.isGroup(item)) {
          this.bindGroup(item, skeleton);
        } else if (_svgUtils.SVGUtils.isPath(item)) {
          this.bindPathToBones(item);
        } else if (_svgUtils.SVGUtils.isShape(item)) {
          this.bindPathToBones(item.toPath());
        }
      }
    }
  }, {
    key: "bindGroup",
    value: function bindGroup(group, skeleton) {
      var _this = this;

      var paths = [];
      var keypoints = {};
      var items = group.getItems({
        recursive: true
      }); // Find all paths and included keypoints.

      items.forEach(function (item) {
        var partName = item.name ? _skeleton.allPartNames.find(function (partName) {
          return item.name.startsWith(partName);
        }) : null;

        if (partName) {
          keypoints[partName] = {
            position: item.bounds.center,
            name: partName
          };
        } else if (_svgUtils.SVGUtils.isPath(item)) {
          paths.push(item);
        } else if (_svgUtils.SVGUtils.isShape(item)) {
          paths.push(item.toPath());
        }
      });
      var secondaryBones = []; // Find all parent bones of the included keypoints.

      var parentBones = skeleton.bones.filter(function (bone) {
        return keypoints[bone.kp0.name] && keypoints[bone.kp1.name];
      });
      var nosePos = skeleton.bNose3Nose4.kp1.position;

      if (!parentBones.length) {
        return;
      } // Crete secondary bones for the included keypoints.


      parentBones.forEach(function (parentBone) {
        var kp0 = keypoints[parentBone.kp0.name];
        var kp1 = keypoints[parentBone.kp1.name];
        var secondaryBone = new _skeleton.Bone().set(kp0, kp1, parentBone.skeleton, parentBone.type);
        kp0.transformFunc = _mathUtils.MathUtils.getTransformFunc(parentBone.kp0.position, nosePos, kp0.position);
        kp1.transformFunc = _mathUtils.MathUtils.getTransformFunc(parentBone.kp1.position, nosePos, kp1.position);
        secondaryBone.parent = parentBone;
        secondaryBones.push(secondaryBone);
      });
      skeleton.secondaryBones = skeleton.secondaryBones.concat(secondaryBones);
      paths.forEach(function (path) {
        _this.bindPathToBones(path, secondaryBones);
      });
    } // Assign weights from bones for point.
    // Weight calculation is roughly based on linear blend skinning model.

  }, {
    key: "getWeights",
    value: function getWeights(point, bones) {
      var totalW = 0;
      var weights = {};
      bones.forEach(function (bone) {
        var d = _mathUtils.MathUtils.getClosestPointOnSegment(bone.kp0.position, bone.kp1.position, point).getDistance(point); // Absolute weight = 1 / (distance * distance)


        var w = 1 / (d * d);
        weights[bone.name] = {
          value: w,
          bone: bone
        };
      });
      var values = Object.values(weights).sort(function (v0, v1) {
        return v1.value - v0.value;
      });
      weights = {};
      totalW = 0;
      values.forEach(function (v) {
        weights[v.bone.name] = v;
        totalW += v.value;
      });

      if (totalW === 0) {
        // Point is outside of the influence zone of all bones. It will not be influence by any bone.
        return {};
      } // Normalize weights to sum up to 1.


      Object.values(weights).forEach(function (weight) {
        weight.value /= totalW;
      });
      return weights;
    } // Binds a path to bones by compute weight contribution from each bones for each path segment.
    // If selectedBones are set, bind directly to the selected bones. Otherwise auto select the bone group closest to each segment.

  }, {
    key: "bindPathToBones",
    value: function bindPathToBones(path, selectedBones) {
      var _this2 = this;

      // Compute bone weights for each segment.
      var segs = path.segments.map(function (s) {
        // Check if control points are collinear.
        // If so, use the middle point's weight for all three points (curve point, handleIn, handleOut).
        // This makes sure smooth curves remain smooth after deformation.
        var collinear = _mathUtils.MathUtils.isCollinear(s.handleIn, s.handleOut);

        var bones = selectedBones || _this2.skeleton.findBoneGroup(s.point);

        var weightsP = _this2.getWeights(s.point, bones);

        var segment = {
          point: _this2.getSkinning(s.point, weightsP)
        }; // For handles, compute transformation in world space.

        if (s.handleIn) {
          var pHandleIn = s.handleIn.add(s.point);
          segment.handleIn = _this2.getSkinning(pHandleIn, collinear ? weightsP : _this2.getWeights(pHandleIn, bones));
        }

        if (s.handleOut) {
          var pHandleOut = s.handleOut.add(s.point);
          segment.handleOut = _this2.getSkinning(pHandleOut, collinear ? weightsP : _this2.getWeights(pHandleOut, bones));
        }

        return segment;
      });
      this.skinnedPaths.push({
        segments: segs,
        fillColor: path.fillColor,
        strokeColor: path.strokeColor,
        strokeWidth: path.strokeWidth,
        closed: path.closed
      });
    }
  }, {
    key: "getSkinning",
    value: function getSkinning(point, weights) {
      var skinning = {};
      Object.keys(weights).forEach(function (boneName) {
        skinning[boneName] = {
          bone: weights[boneName].bone,
          weight: weights[boneName].value,
          transform: weights[boneName].bone.getPointTransform(point)
        };
      });
      return {
        skinning: skinning,
        position: point,
        currentPosition: new this.scope.Point(0, 0)
      };
    }
  }]);

  return PoseIllustration;
}();

exports.PoseIllustration = PoseIllustration;
},{"./skeleton":"illustrationGen/skeleton.js","../utils/mathUtils":"utils/mathUtils.js","../utils/svgUtils":"utils/svgUtils.js","../utils/colorUtils":"utils/colorUtils.js"}],"utils/fileUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileUtils = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var FileUtils = /*#__PURE__*/function () {
  function FileUtils() {
    _classCallCheck(this, FileUtils);
  }

  _createClass(FileUtils, null, [{
    key: "setDragDropHandler",
    value: function setDragDropHandler(handler) {
      window.addEventListener("dragover", function (e) {
        e = e || event;
        e.preventDefault();
      }, false);
      window.addEventListener("drop", function (e) {
        e = e || event;
        e.preventDefault();

        if (e.dataTransfer.items) {
          var files = e.dataTransfer.items;

          if (files.length < 1) {
            return;
          }

          var reader = new FileReader();

          reader.onload = function (event) {
            handler(event.target.result);
          };

          reader.readAsText(e.dataTransfer.files[0]);
        }
      }, false);
    }
  }]);

  return FileUtils;
}();

exports.FileUtils = FileUtils;
},{}],"resources/illustration/girl.svg":[function(require,module,exports) {
module.exports = "/girl.9fcd92b4.svg";
},{}],"resources/illustration/boy.svg":[function(require,module,exports) {
module.exports = "/boy.f9d3081d.svg";
},{}],"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backend = hn;
exports.buffer = dr;
exports.customGrad = vo;
exports.deprecationWarn = Xe;
exports.disableDeprecationWarnings = je;
exports.dispose = tn;
exports.disposeVariables = Ye;
exports.enableDebugMode = Ke;
exports.enableProdMode = qe;
exports.engine = $e;
exports.env = i;
exports.fill = Hn;
exports.findBackend = un;
exports.findBackendFactory = cn;
exports.getBackend = an;
exports.getGradient = h;
exports.getKernel = l;
exports.getKernelsForBackend = f;
exports.grad = co;
exports.grads = lo;
exports.keep = en;
exports.linspace = qn;
exports.memory = Qe;
exports.nextFrame = Td;
exports.ones = zn;
exports.op = An;
exports.print = pr;
exports.profile = Je;
exports.range = Kn;
exports.ready = on;
exports.registerBackend = ln;
exports.registerGradient = p;
exports.registerKernel = d;
exports.removeBackend = sn;
exports.scalar = On;
exports.setBackend = rn;
exports.setPlatform = fn;
exports.sumOutType = Tt;
exports.tensor = Fn;
exports.tensor1d = Mn;
exports.tensor2d = Bn;
exports.tensor3d = Pn;
exports.tensor4d = Ln;
exports.tensor5d = Wn;
exports.tensor6d = Un;
exports.tidy = Ze;
exports.time = nn;
exports.unregisterGradient = m;
exports.unregisterKernel = v;
exports.valueAndGrad = ho;
exports.valueAndGrads = fo;
exports.variable = Vn;
exports.variableGrads = po;
exports.zeros = Gn;
exports.inTopKAsync = exports.image = exports.imag = exports.ifft = exports.hannWindow = exports.hammingWindow = exports.greaterStrict = exports.greaterEqualStrict = exports.greaterEqual = exports.greater = exports.gather_util = exports.gatherND = exports.gather = exports.fused = exports.frame = exports.floorDiv = exports.floor = exports.fft = exports.eye = exports.expm1 = exports.expandDims = exports.exp = exports.erf = exports.equalStrict = exports.equal = exports.elu = exports.dropout = exports.dot = exports.divStrict = exports.divNoNan = exports.div = exports.diag = exports.depthwiseConv2d = exports.depthToSpace = exports.cumsum = exports.cosh = exports.cos = exports.conv3dTranspose = exports.conv3d = exports.conv2dTranspose = exports.conv2d = exports.conv1d = exports.concat4d = exports.concat3d = exports.concat2d = exports.concat1d = exports.concat = exports.complex = exports.clone = exports.clipByValue = exports.ceil = exports.cast = exports.browser = exports.broadcastTo = exports.booleanMaskAsync = exports.batchToSpaceND = exports.batchNormalization4d = exports.batchNormalization3d = exports.batchNormalization2d = exports.batchNormalization = exports.batchNorm4d = exports.batchNorm3d = exports.batchNorm2d = exports.batchNorm = exports.basicLSTMCell = exports.backend_util = exports.avgPool3d = exports.avgPool = exports.atanh = exports.atan2 = exports.atan = exports.asinh = exports.asin = exports.argMin = exports.argMax = exports.any = exports.all = exports.addStrict = exports.addN = exports.add = exports.acosh = exports.acos = exports.abs = exports.Variable = exports.TensorBuffer = exports.Tensor = exports.SGDOptimizer = exports.Reduction = exports.Rank = exports.RMSPropOptimizer = exports.Optimizer = exports.MomentumOptimizer = exports.KernelBackend = exports.Environment = exports.ENV = exports.DataStorage = exports.AdamaxOptimizer = exports.AdamOptimizer = exports.AdagradOptimizer = exports.AdadeltaOptimizer = void 0;
exports.square = exports.sqrt = exports.split = exports.spectral = exports.sparseToDense = exports.spaceToBatchND = exports.softplus = exports.softmax = exports.slice_util = exports.slice4d = exports.slice3d = exports.slice2d = exports.slice1d = exports.slice = exports.sinh = exports.sin = exports.signal = exports.sign = exports.sigmoid = exports.setdiff1dAsync = exports.serialization = exports.separableConv2d = exports.selu = exports.scatter_util = exports.scatterND = exports.rsqrt = exports.round = exports.rfft = exports.reverse4d = exports.reverse3d = exports.reverse2d = exports.reverse1d = exports.reverse = exports.reshape = exports.relu6 = exports.relu = exports.reciprocal = exports.real = exports.randomUniform = exports.randomNormal = exports.randomGamma = exports.rand = exports.prod = exports.prelu = exports.powStrict = exports.pow = exports.pool = exports.pad4d = exports.pad3d = exports.pad2d = exports.pad1d = exports.pad = exports.outerProduct = exports.onesLike = exports.oneHot = exports.notEqualStrict = exports.notEqual = exports.norm = exports.neg = exports.multinomial = exports.multiRNNCell = exports.mulStrict = exports.mul = exports.movingAverage = exports.moments = exports.modStrict = exports.mod = exports.minimumStrict = exports.minimum = exports.min = exports.mean = exports.maximumStrict = exports.maximum = exports.maxPool3d = exports.maxPool = exports.max = exports.math = exports.matMul = exports.losses = exports.logicalXor = exports.logicalOr = exports.logicalNot = exports.logicalAnd = exports.logSumExp = exports.logSoftmax = exports.logSigmoid = exports.log1p = exports.log = exports.localResponseNormalization = exports.linalg = exports.lessStrict = exports.lessEqualStrict = exports.lessEqual = exports.less = exports.leakyRelu = exports.isNaN = exports.isInf = exports.isFinite = exports.irfft = exports.io = void 0;
exports.zerosLike = exports.whereAsync = exports.where = exports.webgl = exports.version_core = exports.util = exports.unstack = exports.unsortedSegmentSum = exports.truncatedNormal = exports.transpose = exports.train = exports.topk = exports.tile = exports.test_util = exports.tensor_util = exports.tanh = exports.tan = exports.sum = exports.subStrict = exports.sub = exports.stridedSlice = exports.stft = exports.step = exports.stack = exports.squeeze = exports.squaredDifferenceStrict = exports.squaredDifference = void 0;

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var t = function (e, n) {
  return (t = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (t, e) {
    t.__proto__ = e;
  } || function (t, e) {
    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
  })(e, n);
};

function e(e, n) {
  function r() {
    this.constructor = e;
  }

  t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());
}

function n(t, e, n, r) {
  return new (n || (n = Promise))(function (o, a) {
    function i(t) {
      try {
        u(r.next(t));
      } catch (t) {
        a(t);
      }
    }

    function s(t) {
      try {
        u(r.throw(t));
      } catch (t) {
        a(t);
      }
    }

    function u(t) {
      t.done ? o(t.value) : new n(function (e) {
        e(t.value);
      }).then(i, s);
    }

    u((r = r.apply(t, e || [])).next());
  });
}

function r(t, e) {
  var n,
      r,
      o,
      a,
      i = {
    label: 0,
    sent: function () {
      if (1 & o[0]) throw o[1];
      return o[1];
    },
    trys: [],
    ops: []
  };
  return a = {
    next: s(0),
    throw: s(1),
    return: s(2)
  }, "function" == typeof Symbol && (a[Symbol.iterator] = function () {
    return this;
  }), a;

  function s(a) {
    return function (s) {
      return function (a) {
        if (n) throw new TypeError("Generator is already executing.");

        for (; i;) try {
          if (n = 1, r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, a[1])).done) return o;

          switch (r = 0, o && (a = [2 & a[0], o.value]), a[0]) {
            case 0:
            case 1:
              o = a;
              break;

            case 4:
              return i.label++, {
                value: a[1],
                done: !1
              };

            case 5:
              i.label++, r = a[1], a = [0];
              continue;

            case 7:
              a = i.ops.pop(), i.trys.pop();
              continue;

            default:
              if (!(o = (o = i.trys).length > 0 && o[o.length - 1]) && (6 === a[0] || 2 === a[0])) {
                i = 0;
                continue;
              }

              if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {
                i.label = a[1];
                break;
              }

              if (6 === a[0] && i.label < o[1]) {
                i.label = o[1], o = a;
                break;
              }

              if (o && i.label < o[2]) {
                i.label = o[2], i.ops.push(a);
                break;
              }

              o[2] && i.ops.pop(), i.trys.pop();
              continue;
          }

          a = e.call(t, i);
        } catch (t) {
          a = [6, t], r = 0;
        } finally {
          n = o = 0;
        }

        if (5 & a[0]) throw a[1];
        return {
          value: a[0] ? a[1] : void 0,
          done: !0
        };
      }([a, s]);
    };
  }
}

var o = function () {
  function t(t) {
    this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();
  }

  return t.prototype.setPlatform = function (t, e) {
    null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e + "."), this.platformName = t, this.platform = e;
  }, t.prototype.registerFlag = function (t, e, n) {
    if (this.flagRegistry[t] = {
      evaluationFn: e,
      setHook: n
    }, null != this.urlFlags[t]) {
      var r = this.urlFlags[t];
      console.warn("Setting feature override from URL " + t + ": " + r + "."), this.set(t, r);
    }
  }, t.prototype.get = function (t) {
    return t in this.flags ? this.flags[t] : (this.flags[t] = this.evaluateFlag(t), this.flags[t]);
  }, t.prototype.getNumber = function (t) {
    return this.get(t);
  }, t.prototype.getBool = function (t) {
    return this.get(t);
  }, t.prototype.getFlags = function () {
    return this.flags;
  }, Object.defineProperty(t.prototype, "features", {
    get: function () {
      return this.flags;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.set = function (t, e) {
    if (null == this.flagRegistry[t]) throw new Error("Cannot set flag " + t + " as it has not been registered.");
    this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e);
  }, t.prototype.evaluateFlag = function (t) {
    if (null == this.flagRegistry[t]) throw new Error("Cannot evaluate flag '" + t + "': no evaluation function found.");
    return this.flagRegistry[t].evaluationFn();
  }, t.prototype.setFlags = function (t) {
    this.flags = Object.assign({}, t);
  }, t.prototype.reset = function () {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }, t.prototype.populateURLFlags = function () {
    var t = this;

    if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
      var e,
          n,
          r = (e = this.global.location.search, n = {}, e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (t) {
        for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];

        return a(n, e[0], e[1]), e.join("=");
      }), n);
      if ("tfjsflags" in r) r.tfjsflags.split(",").forEach(function (e) {
        var n = e.split(":"),
            r = n[0],
            o = n[1];

        t.urlFlags[r] = function (t, e) {
          if ("true" === (e = e.toLowerCase()) || "false" === e) return "true" === e;
          if ("" + +e === e) return +e;
          throw new Error("Could not parse value flag value " + e + " for flag " + t + ".");
        }(r, o);
      });
    }
  }, t;
}();

exports.Environment = o;

function a(t, e, n) {
  t[decodeURIComponent(e)] = decodeURIComponent(n || "");
}

function i() {
  return s;
}

var s = null;
exports.ENV = s;
var u = new Map(),
    c = new Map();

function l(t, e) {
  var n = g(t, e);
  return u.get(n);
}

function h(t) {
  return c.get(t);
}

function f(t) {
  for (var e = u.entries(), n = [];;) {
    var r = e.next(),
        o = r.done,
        a = r.value;
    if (o) break;
    var i = a[0],
        s = a[1];
    i.split("_")[0] === t && n.push(s);
  }

  return n;
}

function d(t) {
  var e = t.kernelName,
      n = t.backendName,
      r = g(e, n);
  if (u.has(r)) throw new Error("The kernel '" + e + "' for backend '" + n + "' is already registered");
  u.set(r, t);
}

function p(t) {
  var e = t.kernelName;
  c.has(e) && console.warn("Overriding the gradient for '" + e + "'"), c.set(e, t);
}

function v(t, e) {
  var n = g(t, e);
  if (!u.has(n)) throw new Error("The kernel '" + t + "' for backend '" + e + "' is not registered");
  u.delete(n);
}

function m(t) {
  if (!c.has(t)) throw new Error("The gradient '" + t + "' for backend is not registered");
  c.delete(t);
}

function g(t, e) {
  return e + "_" + t;
}

function y(t) {
  for (var e = t.length, n = 0, r = 0; e > 0;) r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n;
}

function x(t, e, n) {
  return Math.max(t, Math.min(e, n));
}

function b(t) {
  return t % 2 == 0 ? t : t + 1;
}

function w(t) {
  for (var e = 0, n = 0; n < t.length; n++) e += t[n];

  return e;
}

function C(t, e) {
  if (!t) throw new Error("string" == typeof e ? e : e());
}

function E(t, e, n) {
  void 0 === n && (n = ""), C(S(t, e), function () {
    return n + " Shapes " + t + " and " + e + " must match";
  });
}

function R(t) {
  C(null != t, function () {
    return "The input to the tensor constructor must be a non-null value.";
  });
}

function I(t, e, n) {
  if (void 0 === e && (e = []), void 0 === n && (n = !1), null == e && (e = []), Array.isArray(t) || V(t) && !n) for (var r = 0; r < t.length; ++r) I(t[r], e, n);else e.push(t);
  return e;
}

function k(t) {
  if (0 === t.length) return 1;

  for (var e = t[0], n = 1; n < t.length; n++) e *= t[n];

  return e;
}

function S(t, e) {
  if (t === e) return !0;
  if (null == t || null == e) return !1;
  if (t.length !== e.length) return !1;

  for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;

  return !0;
}

function A(t) {
  return t % 1 == 0;
}

function D(t) {
  if (null != Math.tanh) return Math.tanh(t);
  if (t === 1 / 0) return 1;
  if (t === -1 / 0) return -1;
  var e = Math.exp(2 * t);
  return (e - 1) / (e + 1);
}

function T(t) {
  var e = Math.ceil(Math.sqrt(t));
  return [e, Math.ceil(t / e)];
}

function N(t, e) {
  return e <= t.length ? t : t + " ".repeat(e - t.length);
}

function F(t, e, n) {
  return void 0 === e && (e = function (t) {
    return 0;
  }), new Promise(function (r, o) {
    var a = 0,
        i = function () {
      if (t()) r();else {
        a++;
        var s = e(a);
        null != n && a >= n ? o() : setTimeout(i, s);
      }
    };

    i();
  });
}

function _(t, e) {
  for (var n = 1, r = -1, o = 0; o < t.length; ++o) if (t[o] >= 0) n *= t[o];else if (-1 === t[o]) {
    if (-1 !== r) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + o);
    r = o;
  } else if (t[o] < 0) throw Error("Shapes can not be < 0. Found " + t[o] + " at dim " + o);

  if (-1 === r) {
    if (e > 0 && e !== n) throw Error("Size(" + e + ") must match the product of shape " + t);
    return t;
  }

  if (0 === n) throw Error("Cannot infer the missing size in [" + t + "] when there are 0 elements");
  if (e % n != 0) throw Error("The implicit shape can't be a fractional number. Got " + e + " / " + n);
  var a = t.slice();
  return a[r] = e / n, a;
}

function O(t, e) {
  var n = e.length;
  return C((t = null == t ? e.map(function (t, e) {
    return e;
  }) : [].concat(t)).every(function (t) {
    return t >= -n && t < n;
  }), function () {
    return "All values in axis param must be in range [-" + n + ", " + n + ") but got axis " + t;
  }), C(t.every(function (t) {
    return A(t);
  }), function () {
    return "All values in axis param must be integers but got axis " + t;
  }), t.map(function (t) {
    return t < 0 ? n + t : t;
  });
}

function M(t, e) {
  for (var n = [], r = [], o = null != e && Array.isArray(e) && 0 === e.length, a = null == e || o ? null : O(e, t).sort(), i = 0, s = 0; s < t.length; ++s) {
    if (null != a) {
      if (a[i] === s && 1 !== t[s]) throw new Error("Can't squeeze axis " + s + " since its dim '" + t[s] + "' is not 1");
      (null == a[i] || a[i] > s) && 1 === t[s] && (n.push(t[s]), r.push(s)), a[i] <= s && i++;
    }

    1 !== t[s] && (n.push(t[s]), r.push(s));
  }

  return {
    newShape: n,
    keptDims: r
  };
}

function B(t, e) {
  var n = null;
  if (null == t || "float32" === t) n = new Float32Array(e);else if ("int32" === t) n = new Int32Array(e);else {
    if ("bool" !== t) throw new Error("Unknown data type " + t);
    n = new Uint8Array(e);
  }
  return n;
}

function P(t, e) {
  var n = null;
  if (null == t || "float32" === t) n = new Float32Array(e);else if ("int32" === t) n = new Int32Array(e);else if ("bool" === t) n = new Uint8Array(e);else {
    if ("string" !== t) throw new Error("Unknown data type " + t);
    n = new Array(e);
  }
  return n;
}

function L(t, e) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + e + " being uploaded contains " + r + ".");
  }
}

function W(t) {
  return "bool" === t || "complex64" === t || "float32" === t || "int32" === t || "string" === t;
}

function U(t, e) {
  return "complex64" !== e && ("float32" !== e || "complex64" === t) && ("int32" !== e || "float32" === t || "complex64" === t) && ("bool" !== e || "bool" !== t);
}

function V(t) {
  return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array;
}

function z(t) {
  if ("float32" === t || "int32" === t) return 4;
  if ("complex64" === t) return 8;
  if ("bool" === t) return 1;
  throw new Error("Unknown dtype " + t);
}

function G(t) {
  if (null == t) return 0;
  var e = 0;
  return t.forEach(function (t) {
    return e += t.length;
  }), e;
}

function H(t) {
  return "string" == typeof t || t instanceof String;
}

function q(t) {
  return "boolean" == typeof t;
}

function K(t) {
  return "number" == typeof t;
}

function j(t) {
  return Array.isArray(t) ? j(t[0]) : t instanceof Float32Array ? "float32" : t instanceof Int32Array || t instanceof Uint8Array ? "int32" : K(t) ? "float32" : H(t) ? "string" : q(t) ? "bool" : "float32";
}

function X(t) {
  return !!(t && t.constructor && t.call && t.apply);
}

function Y(t, e) {
  for (var n = e; n < t; ++n) if (t % n == 0) return n;

  return t;
}

function $(t) {
  var e = t.length;
  if (e < 2) return [];
  var n = new Array(e - 1);
  n[e - 2] = t[e - 1];

  for (var r = e - 3; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];

  return n;
}

function Q(t, e, n) {
  if ("string" === e) throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(t) && (t = I(t)), n && L(t, e), function (t, e) {
    return t instanceof Float32Array && "float32" === e || t instanceof Int32Array && "int32" === e || t instanceof Uint8Array && "bool" === e;
  }(t, e)) return t;
  if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
  if ("int32" === e) return new Int32Array(t);

  if ("bool" === e) {
    for (var r = new Uint8Array(t.length), o = 0; o < r.length; ++o) 0 !== Math.round(t[o]) && (r[o] = 1);

    return r;
  }

  throw new Error("Unknown data type " + e);
}

function J(t, e) {
  if (0 === t.length) return e[0];
  var n = t.reduce(function (t, e) {
    return t * e;
  });
  if (0 === n) return [];
  if (n !== e.length) throw new Error("[" + t + "] does not match the input size.");
  return function t(e, n, r) {
    var o = new Array();
    if (1 === n.length) for (var a = n[0], i = 0; i < a; i++) o[i] = r[e + i];else {
      a = n[0];
      var s = n.slice(1),
          u = s.reduce(function (t, e) {
        return t * e;
      });

      for (i = 0; i < a; i++) o[i] = t(e + i * u, s, r);
    }
    return o;
  }(0, t, e);
}

function Z(t, e) {
  for (var n = tt(t, e), r = 0; r < n.length; r++) n[r] = 1;

  return n;
}

function tt(t, e) {
  if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
  if ("int32" === e) return new Int32Array(t);
  if ("bool" === e) return new Uint8Array(t);
  throw new Error("Unknown data type " + e);
}

function et() {
  return i().platform.now();
}

function nt(t) {
  t.forEach(function (e) {
    C(Number.isInteger(e) && e >= 0, function () {
      return "Tensor must have a shape comprised of positive integers but got shape [" + t + "].";
    });
  });
}

function rt(t, e) {
  return void 0 === e && (e = "utf-8"), e = e || "utf-8", i().platform.encode(t, e);
}

function ot(t, e) {
  return void 0 === e && (e = "utf-8"), e = e || "utf-8", i().platform.decode(t, e);
}

function at(t, e, n) {
  if (0 === e) return 0;
  if (1 === e) return t[0];

  for (var r = t[t.length - 1], o = 0; o < t.length - 1; ++o) r += n[o] * t[o];

  return r;
}

function it(t, e, n) {
  if (0 === e) return [];
  if (1 === e) return [t];

  for (var r = new Array(e), o = 0; o < r.length - 1; ++o) r[o] = Math.floor(t / n[o]), t -= r[o] * n[o];

  return r[r.length - 1] = t, r;
}

var st = Object.freeze({
  shuffle: y,
  clamp: x,
  nearestLargerEven: b,
  sum: w,
  randUniform: function (t, e) {
    var n = Math.random();
    return e * n + (1 - n) * t;
  },
  distSquared: function (t, e) {
    for (var n = 0, r = 0; r < t.length; r++) {
      var o = Number(t[r]) - Number(e[r]);
      n += o * o;
    }

    return n;
  },
  assert: C,
  assertShapesMatch: E,
  assertNonNull: R,
  flatten: I,
  sizeFromShape: k,
  isScalarShape: function (t) {
    return 0 === t.length;
  },
  arraysEqual: S,
  isInt: A,
  tanh: D,
  sizeToSquarishShape: T,
  createShuffledIndices: function (t) {
    for (var e = new Uint32Array(t), n = 0; n < t; ++n) e[n] = n;

    return y(e), e;
  },
  rightPad: N,
  repeatedTry: F,
  inferFromImplicitShape: _,
  parseAxisParam: O,
  squeezeShape: M,
  getTypedArrayFromDType: B,
  getArrayFromDType: P,
  checkConversionForErrors: L,
  isValidDtype: W,
  hasEncodingLoss: U,
  isTypedArray: V,
  bytesPerElement: z,
  bytesFromStringArray: G,
  isString: H,
  isBoolean: q,
  isNumber: K,
  inferDtype: j,
  isFunction: X,
  nearestDivisor: Y,
  computeStrides: $,
  toTypedArray: Q,
  toNestedArray: J,
  makeOnesTypedArray: Z,
  makeZerosTypedArray: tt,
  now: et,
  assertNonNegativeIntegerDimensions: nt,
  fetch: function (t, e) {
    return i().platform.fetch(t, e);
  },
  encodeString: rt,
  decodeString: ot,
  locToIndex: at,
  indexToLoc: it
}),
    ut = function () {
  function t(t, e) {
    this.backendTimer = t, this.logger = e, null == e && (this.logger = new ct());
  }

  return t.prototype.profileKernel = function (t, e, n) {
    var r,
        o = this,
        a = this.backendTimer.time(function () {
      r = n();
    });
    return r.forEach(function (n) {
      n.data().then(function (r) {
        !function (t, e, n) {
          if ("float32" !== e) return !1;

          for (var r = 0; r < t.length; r++) {
            var o = t[r];
            if (isNaN(o) || !isFinite(o)) return console.warn("Found " + o + " in the result of '" + n + "'"), !0;
          }
        }(r, n.dtype, t), a.then(function (a) {
          var i = "";
          null != a.getExtraProfileInfo && (i = a.getExtraProfileInfo()), o.logger.logKernelProfile(t, n, r, a.kernelMs, e, i);
        });
      });
    }), r;
  }, t;
}();

exports.util = st;

var ct = function () {
  function t() {}

  return t.prototype.logKernelProfile = function (t, e, n, r, o, a) {
    var i = "number" == typeof r ? N(r + "ms", 9) : r.error,
        s = N(t, 25),
        u = e.rank,
        c = e.size,
        l = N(e.shape.toString(), 14),
        h = "";

    for (var f in o) {
      var d = o[f].shape || e.shape,
          p = d.length;
      h += f + ": " + p + "D " + (p > 0 ? d : "") + " ";
    }

    console.log("%c" + s + "\t%c" + i + "\t%c" + u + "D " + l + "\t%c" + c + "\t%c" + h + "\t%c" + a, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }, t;
}();

var lt = 20,
    ht = 3,
    ft = 7;

function dt(t, e, n, r) {
  var o = $(e),
      a = function (t, e, n, r) {
    var o = k(e),
        a = r[r.length - 1],
        i = new Array(a).fill(0),
        s = e.length,
        u = "complex64" === n ? mt(t) : t;
    if (s > 1) for (var c = 0; c < o / a; c++) for (var l = c * a, h = 0; h < a; h++) i[h] = Math.max(i[h], pt(u[l + h], 0, n).length);
    return i;
  }(t, e, n, o),
      i = e.length,
      s = function t(e, n, r, o, a, i) {
    void 0 === i && (i = !0);
    var s = "complex64" === r ? 2 : 1,
        u = n[0],
        c = n.length;

    if (0 === c) {
      return "complex64" === r ? [pt(mt(e)[0], 0, r)] : "bool" === r ? [vt(e[0])] : [e[0].toString()];
    }

    if (1 === c) {
      if (u > lt) {
        var l = ht * s,
            h = Array.from(e.slice(0, l)),
            f = Array.from(e.slice((u - ht) * s, u * s));
        return "complex64" === r && (h = mt(h), f = mt(f)), ["[" + h.map(function (t, e) {
          return pt(t, a[e], r);
        }).join(", ") + ", ..., " + f.map(function (t, e) {
          return pt(t, a[u - ht + e], r);
        }).join(", ") + "]"];
      }

      return ["[" + ("complex64" === r ? mt(e) : Array.from(e)).map(function (t, e) {
        return pt(t, a[e], r);
      }).join(", ") + "]"];
    }

    var d = n.slice(1),
        p = o.slice(1),
        v = o[0] * s,
        m = [];

    if (u > lt) {
      for (var g = 0; g < ht; g++) {
        var y = (x = g * v) + v;
        m.push.apply(m, t(e.slice(x, y), d, r, p, a, !1));
      }

      m.push("...");

      for (g = u - ht; g < u; g++) {
        y = (x = g * v) + v;
        m.push.apply(m, t(e.slice(x, y), d, r, p, a, g === u - 1));
      }
    } else for (g = 0; g < u; g++) {
      var x;
      y = (x = g * v) + v;
      m.push.apply(m, t(e.slice(x, y), d, r, p, a, g === u - 1));
    }

    var b = 2 === c ? "," : "";
    m[0] = "[" + m[0] + b;

    for (g = 1; g < m.length - 1; g++) m[g] = " " + m[g] + b;

    var w = ",\n";

    for (g = 2; g < c; g++) w += "\n";

    return m[m.length - 1] = " " + m[m.length - 1] + "]" + (i ? "" : w), m;
  }(t, e, n, o, a),
      u = ["Tensor"];

  return r && (u.push("  dtype: " + n), u.push("  rank: " + i), u.push("  shape: [" + e + "]"), u.push("  values:")), u.push(s.map(function (t) {
    return "    " + t;
  }).join("\n")), u.join("\n");
}

function pt(t, e, n) {
  return N(Array.isArray(t) ? parseFloat(t[0].toFixed(ft)) + " + " + parseFloat(t[1].toFixed(ft)) + "j" : H(t) ? "'" + t + "'" : "bool" === n ? vt(t) : parseFloat(t.toFixed(ft)).toString(), e);
}

function vt(t) {
  return 0 === t ? "false" : "true";
}

function mt(t) {
  for (var e = [], n = 0; n < t.length; n += 2) e.push([t[n], t[n + 1]]);

  return e;
}

var gt = function () {
  function t(t, e, n) {
    var r = this;

    if (this.dtype = e, this.shape = t.slice(), this.size = k(t), null != n) {
      var o = n.length;
      C(o === this.size, function () {
        return "Length of values '" + o + "' does not match the size inferred by the shape '" + r.size + "'.";
      });
    }

    if ("complex64" === e) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n || P(e, this.size), this.strides = $(t);
  }

  return t.prototype.set = function (t) {
    for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];

    0 === n.length && (n = [0]), C(n.length === this.rank, function () {
      return "The number of provided coordinates (" + n.length + ") must match the rank (" + e.rank + ")";
    });
    var o = this.locToIndex(n);
    this.values[o] = t;
  }, t.prototype.get = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];

    0 === t.length && (t = [0]);

    for (var n = 0, r = 0, o = t; r < o.length; r++) {
      var a = o[r];

      if (a < 0 || a >= this.shape[n]) {
        var i = "Requested out of range element at " + t + ".   Buffer shape=" + this.shape;
        throw new Error(i);
      }

      n++;
    }

    for (var s = t[t.length - 1], u = 0; u < t.length - 1; ++u) s += this.strides[u] * t[u];

    return this.values[s];
  }, t.prototype.locToIndex = function (t) {
    if (0 === this.rank) return 0;
    if (1 === this.rank) return t[0];

    for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n) e += this.strides[n] * t[n];

    return e;
  }, t.prototype.indexToLoc = function (t) {
    if (0 === this.rank) return [];
    if (1 === this.rank) return [t];

    for (var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n) e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];

    return e[e.length - 1] = t, e;
  }, Object.defineProperty(t.prototype, "rank", {
    get: function () {
      return this.shape.length;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.toTensor = function () {
    return yt().makeTensor(this.values, this.shape, this.dtype);
  }, t;
}(),
    yt = null,
    xt = null,
    bt = null;

exports.TensorBuffer = gt;

var wt = function () {
  function t(t, e, n, r) {
    this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || "float32", this.size = k(t), this.strides = $(t), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }

  return t.prototype.flatten = function () {
    return this.throwIfDisposed(), this.as1D();
  }, t.prototype.asScalar = function () {
    return this.throwIfDisposed(), C(1 === this.size, function () {
      return "The array must have only 1 element.";
    }), this.reshape([]);
  }, t.prototype.as1D = function () {
    return this.throwIfDisposed(), this.reshape([this.size]);
  }, t.prototype.as2D = function (t, e) {
    return this.throwIfDisposed(), this.reshape([t, e]);
  }, t.prototype.as3D = function (t, e, n) {
    return this.throwIfDisposed(), this.reshape([t, e, n]);
  }, t.prototype.as4D = function (t, e, n, r) {
    return this.throwIfDisposed(), this.reshape([t, e, n, r]);
  }, t.prototype.as5D = function (t, e, n, r, o) {
    return this.throwIfDisposed(), this.reshape([t, e, n, r, o]);
  }, t.prototype.asType = function (t) {
    return this.throwIfDisposed(), xt.cast(this, t);
  }, Object.defineProperty(t.prototype, "rank", {
    get: function () {
      return this.shape.length;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.buffer = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.data()];

          case 1:
            return t = e.sent(), [2, xt.buffer(this.shape, this.dtype, t)];
        }
      });
    });
  }, t.prototype.bufferSync = function () {
    return xt.buffer(this.shape, this.dtype, this.dataSync());
  }, t.prototype.array = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.data()];

          case 1:
            return t = e.sent(), [2, J(this.shape, t)];
        }
      });
    });
  }, t.prototype.arraySync = function () {
    return J(this.shape, this.dataSync());
  }, t.prototype.data = function () {
    return n(this, void 0, void 0, function () {
      var t, e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return this.throwIfDisposed(), t = yt().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t];

          case 1:
            e = n.sent();

            try {
              return [2, e.map(function (t) {
                return ot(t);
              })];
            } catch (t) {
              throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }

            n.label = 2;

          case 2:
            return [2, t];
        }
      });
    });
  }, t.prototype.dataSync = function () {
    this.throwIfDisposed();
    var t = yt().readSync(this.dataId);
    if ("string" === this.dtype) try {
      return t.map(function (t) {
        return ot(t);
      });
    } catch (t) {
      throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
    }
    return t;
  }, t.prototype.bytes = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return this.throwIfDisposed(), [4, yt().read(this.dataId)];

          case 1:
            return t = e.sent(), "string" === this.dtype ? [2, t] : [2, new Uint8Array(t.buffer)];
        }
      });
    });
  }, t.prototype.dispose = function () {
    this.isDisposed || (yt().disposeTensor(this), this.isDisposedInternal = !0);
  }, Object.defineProperty(t.prototype, "isDisposed", {
    get: function () {
      return this.isDisposedInternal;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.throwIfDisposed = function () {
    if (this.isDisposed) throw new Error("Tensor is disposed.");
  }, t.prototype.toFloat = function () {
    return this.asType("float32");
  }, t.prototype.toInt = function () {
    return this.asType("int32");
  }, t.prototype.toBool = function () {
    return this.asType("bool");
  }, t.prototype.print = function (t) {
    return void 0 === t && (t = !1), xt.print(this, t);
  }, t.prototype.reshape = function (t) {
    return this.throwIfDisposed(), xt.reshape(this, t);
  }, t.prototype.reshapeAs = function (t) {
    return this.throwIfDisposed(), this.reshape(t.shape);
  }, t.prototype.expandDims = function (t) {
    return void 0 === t && (t = 0), xt.expandDims(this, t);
  }, t.prototype.cumsum = function (t, e, n) {
    return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), xt.cumsum(this, t, e, n);
  }, t.prototype.squeeze = function (t) {
    return this.throwIfDisposed(), xt.squeeze(this, t);
  }, t.prototype.clone = function () {
    return this.throwIfDisposed(), xt.clone(this);
  }, t.prototype.oneHot = function (t, e, n) {
    return this.throwIfDisposed(), xt.oneHot(this, t, e, n);
  }, t.prototype.toString = function (t) {
    return void 0 === t && (t = !1), dt(this.dataSync(), this.shape, this.dtype, t);
  }, t.prototype.tile = function (t) {
    return this.throwIfDisposed(), xt.tile(this, t);
  }, t.prototype.gather = function (t, e) {
    return void 0 === e && (e = 0), this.throwIfDisposed(), xt.gather(this, t, e);
  }, t.prototype.matMul = function (t, e, n) {
    return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), xt.matMul(this, t, e, n);
  }, t.prototype.dot = function (t) {
    return this.throwIfDisposed(), xt.dot(this, t);
  }, t.prototype.norm = function (t, e, n) {
    return void 0 === t && (t = "euclidean"), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), xt.norm(this, t, e, n);
  }, t.prototype.slice = function (t, e) {
    return this.throwIfDisposed(), xt.slice(this, t, e);
  }, t.prototype.reverse = function (t) {
    return this.throwIfDisposed(), xt.reverse(this, t);
  }, t.prototype.concat = function (e, n) {
    return void 0 === n && (n = 0), this.throwIfDisposed(), e instanceof t && (e = [e]), xt.concat([this].concat(e), n);
  }, t.prototype.split = function (t, e) {
    return void 0 === e && (e = 0), this.throwIfDisposed(), xt.split(this, t, e);
  }, t.prototype.stack = function (t, e) {
    return void 0 === e && (e = 0), xt.stack([this, t], e);
  }, t.prototype.unstack = function (t) {
    return void 0 === t && (t = 0), xt.unstack(this, t);
  }, t.prototype.pad = function (t, e) {
    return void 0 === e && (e = 0), xt.pad(this, t, e);
  }, t.prototype.batchNormalization = function (t, e, n, r, o) {
    return void 0 === n && (n = .001), bt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t, e, o, r, n);
  }, t.prototype.batchNorm = function (t, e, n, r, o) {
    return void 0 === o && (o = .001), this.throwIfDisposed(), xt.batchNorm(this, t, e, n, r, o);
  }, t.prototype.all = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.all(this, t, e);
  }, t.prototype.any = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.any(this, t, e);
  }, t.prototype.logSumExp = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.logSumExp(this, t, e);
  }, t.prototype.sum = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.sum(this, t, e);
  }, t.prototype.prod = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.prod(this, t, e);
  }, t.prototype.mean = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.mean(this, t, e);
  }, t.prototype.min = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.min(this, t, e);
  }, t.prototype.max = function (t, e) {
    return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.max(this, t, e);
  }, t.prototype.argMin = function (t) {
    return void 0 === t && (t = null), this.throwIfDisposed(), xt.argMin(this, t);
  }, t.prototype.argMax = function (t) {
    return void 0 === t && (t = null), this.throwIfDisposed(), xt.argMax(this, t);
  }, t.prototype.cast = function (t) {
    return this.throwIfDisposed(), xt.cast(this, t);
  }, t.prototype.add = function (t) {
    return this.throwIfDisposed(), xt.add(this, t);
  }, t.prototype.addStrict = function (t) {
    return this.throwIfDisposed(), xt.addStrict(this, t);
  }, t.prototype.atan2 = function (t) {
    return this.throwIfDisposed(), xt.atan2(this, t);
  }, t.prototype.sub = function (t) {
    return this.throwIfDisposed(), xt.sub(this, t);
  }, t.prototype.subStrict = function (t) {
    return this.throwIfDisposed(), xt.subStrict(this, t);
  }, t.prototype.pow = function (t) {
    return this.throwIfDisposed(), xt.pow(this, t);
  }, t.prototype.powStrict = function (t) {
    return this.throwIfDisposed(), xt.powStrict(this, t);
  }, t.prototype.mul = function (t) {
    return this.throwIfDisposed(), xt.mul(this, t);
  }, t.prototype.mulStrict = function (t) {
    return this.throwIfDisposed(), xt.mulStrict(this, t);
  }, t.prototype.div = function (t) {
    return this.throwIfDisposed(), xt.div(this, t);
  }, t.prototype.divNoNan = function (t) {
    return this.throwIfDisposed(), xt.divNoNan(this, t);
  }, t.prototype.floorDiv = function (t) {
    return this.throwIfDisposed(), xt.floorDiv(this, t);
  }, t.prototype.divStrict = function (t) {
    return this.throwIfDisposed(), xt.divStrict(this, t);
  }, t.prototype.minimum = function (t) {
    return this.throwIfDisposed(), xt.minimum(this, t);
  }, t.prototype.minimumStrict = function (t) {
    return this.throwIfDisposed(), xt.minimumStrict(this, t);
  }, t.prototype.maximum = function (t) {
    return this.throwIfDisposed(), xt.maximum(this, t);
  }, t.prototype.maximumStrict = function (t) {
    return this.throwIfDisposed(), xt.maximumStrict(this, t);
  }, t.prototype.mod = function (t) {
    return this.throwIfDisposed(), xt.mod(this, t);
  }, t.prototype.modStrict = function (t) {
    return this.throwIfDisposed(), xt.modStrict(this, t);
  }, t.prototype.squaredDifferenceStrict = function (t) {
    return this.throwIfDisposed(), xt.squaredDifferenceStrict(this, t);
  }, t.prototype.transpose = function (t) {
    return this.throwIfDisposed(), xt.transpose(this, t);
  }, t.prototype.notEqual = function (t) {
    return this.throwIfDisposed(), xt.notEqual(this, t);
  }, t.prototype.notEqualStrict = function (t) {
    return this.throwIfDisposed(), xt.notEqualStrict(this, t);
  }, t.prototype.less = function (t) {
    return this.throwIfDisposed(), xt.less(this, t);
  }, t.prototype.lessStrict = function (t) {
    return this.throwIfDisposed(), xt.lessStrict(this, t);
  }, t.prototype.equal = function (t) {
    return this.throwIfDisposed(), xt.equal(this, t);
  }, t.prototype.equalStrict = function (t) {
    return this.throwIfDisposed(), xt.equalStrict(this, t);
  }, t.prototype.lessEqual = function (t) {
    return this.throwIfDisposed(), xt.lessEqual(this, t);
  }, t.prototype.lessEqualStrict = function (t) {
    return this.throwIfDisposed(), xt.lessEqualStrict(this, t);
  }, t.prototype.greater = function (t) {
    return this.throwIfDisposed(), xt.greater(this, t);
  }, t.prototype.greaterStrict = function (t) {
    return this.throwIfDisposed(), xt.greaterStrict(this, t);
  }, t.prototype.greaterEqual = function (t) {
    return this.throwIfDisposed(), xt.greaterEqual(this, t);
  }, t.prototype.greaterEqualStrict = function (t) {
    return this.throwIfDisposed(), xt.greaterEqualStrict(this, t);
  }, t.prototype.logicalAnd = function (t) {
    return this.throwIfDisposed(), xt.logicalAnd(this, t);
  }, t.prototype.logicalOr = function (t) {
    return this.throwIfDisposed(), xt.logicalOr(this, t);
  }, t.prototype.logicalNot = function () {
    return this.throwIfDisposed(), xt.logicalNot(this);
  }, t.prototype.logicalXor = function (t) {
    return this.throwIfDisposed(), xt.logicalXor(this, t);
  }, t.prototype.where = function (t, e) {
    return this.throwIfDisposed(), xt.where(t, this, e);
  }, t.prototype.neg = function () {
    return this.throwIfDisposed(), xt.neg(this);
  }, t.prototype.ceil = function () {
    return this.throwIfDisposed(), xt.ceil(this);
  }, t.prototype.floor = function () {
    return this.throwIfDisposed(), xt.floor(this);
  }, t.prototype.sign = function () {
    return this.throwIfDisposed(), xt.sign(this);
  }, t.prototype.isNaN = function () {
    return this.throwIfDisposed(), xt.isNaN(this);
  }, t.prototype.isInf = function () {
    return this.throwIfDisposed(), xt.isInf(this);
  }, t.prototype.isFinite = function () {
    return this.throwIfDisposed(), xt.isFinite(this);
  }, t.prototype.exp = function () {
    return this.throwIfDisposed(), xt.exp(this);
  }, t.prototype.expm1 = function () {
    return this.throwIfDisposed(), xt.expm1(this);
  }, t.prototype.log = function () {
    return this.throwIfDisposed(), xt.log(this);
  }, t.prototype.log1p = function () {
    return this.throwIfDisposed(), xt.log1p(this);
  }, t.prototype.sqrt = function () {
    return this.throwIfDisposed(), xt.sqrt(this);
  }, t.prototype.rsqrt = function () {
    return this.throwIfDisposed(), xt.rsqrt(this);
  }, t.prototype.square = function () {
    return this.throwIfDisposed(), xt.square(this);
  }, t.prototype.reciprocal = function () {
    return this.throwIfDisposed(), xt.reciprocal(this);
  }, t.prototype.abs = function () {
    return this.throwIfDisposed(), xt.abs(this);
  }, t.prototype.clipByValue = function (t, e) {
    return this.throwIfDisposed(), xt.clipByValue(this, t, e);
  }, t.prototype.relu = function () {
    return this.throwIfDisposed(), xt.relu(this);
  }, t.prototype.relu6 = function () {
    return this.throwIfDisposed(), xt.relu6(this);
  }, t.prototype.elu = function () {
    return this.throwIfDisposed(), xt.elu(this);
  }, t.prototype.selu = function () {
    return this.throwIfDisposed(), xt.selu(this);
  }, t.prototype.leakyRelu = function (t) {
    return void 0 === t && (t = .2), this.throwIfDisposed(), xt.leakyRelu(this, t);
  }, t.prototype.prelu = function (t) {
    return this.throwIfDisposed(), xt.prelu(this, t);
  }, t.prototype.sigmoid = function () {
    return this.throwIfDisposed(), xt.sigmoid(this);
  }, t.prototype.logSigmoid = function () {
    return this.throwIfDisposed(), xt.logSigmoid(this);
  }, t.prototype.softplus = function () {
    return this.throwIfDisposed(), xt.softplus(this);
  }, t.prototype.zerosLike = function () {
    return this.throwIfDisposed(), xt.zerosLike(this);
  }, t.prototype.onesLike = function () {
    return this.throwIfDisposed(), xt.onesLike(this);
  }, t.prototype.sin = function () {
    return this.throwIfDisposed(), xt.sin(this);
  }, t.prototype.cos = function () {
    return this.throwIfDisposed(), xt.cos(this);
  }, t.prototype.tan = function () {
    return this.throwIfDisposed(), xt.tan(this);
  }, t.prototype.asin = function () {
    return this.throwIfDisposed(), xt.asin(this);
  }, t.prototype.acos = function () {
    return this.throwIfDisposed(), xt.acos(this);
  }, t.prototype.atan = function () {
    return this.throwIfDisposed(), xt.atan(this);
  }, t.prototype.sinh = function () {
    return this.throwIfDisposed(), xt.sinh(this);
  }, t.prototype.cosh = function () {
    return this.throwIfDisposed(), xt.cosh(this);
  }, t.prototype.tanh = function () {
    return this.throwIfDisposed(), xt.tanh(this);
  }, t.prototype.asinh = function () {
    return this.throwIfDisposed(), xt.asinh(this);
  }, t.prototype.acosh = function () {
    return this.throwIfDisposed(), xt.acosh(this);
  }, t.prototype.atanh = function () {
    return this.throwIfDisposed(), xt.atanh(this);
  }, t.prototype.erf = function () {
    return this.throwIfDisposed(), xt.erf(this);
  }, t.prototype.round = function () {
    return this.throwIfDisposed(), xt.round(this);
  }, t.prototype.step = function (t) {
    return void 0 === t && (t = 0), this.throwIfDisposed(), xt.step(this, t);
  }, t.prototype.softmax = function (t) {
    return void 0 === t && (t = -1), this.throwIfDisposed(), xt.softmax(this, t);
  }, t.prototype.logSoftmax = function (t) {
    return void 0 === t && (t = -1), this.throwIfDisposed(), xt.logSoftmax(this, t);
  }, t.prototype.resizeBilinear = function (t, e) {
    return void 0 === e && (e = !1), this.throwIfDisposed(), xt.image.resizeBilinear(this, t, e);
  }, t.prototype.resizeNearestNeighbor = function (t, e) {
    return void 0 === e && (e = !1), this.throwIfDisposed(), xt.image.resizeNearestNeighbor(this, t, e);
  }, t.prototype.conv1d = function (t, e, n, r, o, a) {
    return void 0 === r && (r = "NWC"), void 0 === o && (o = 1), this.throwIfDisposed(), xt.conv1d(this, t, e, n, r, o, a);
  }, t.prototype.conv2d = function (t, e, n, r, o, a) {
    return void 0 === r && (r = "NHWC"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), xt.conv2d(this, t, e, n, r, o, a);
  }, t.prototype.conv2dTranspose = function (t, e, n, r, o) {
    return this.throwIfDisposed(), xt.conv2dTranspose(this, t, e, n, r, o);
  }, t.prototype.depthwiseConv2D = function (t, e, n, r, o, a) {
    return void 0 === r && (r = "NHWC"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), xt.depthwiseConv2d(this, t, e, n, r, o, a);
  }, t.prototype.separableConv2d = function (t, e, n, r, o, a) {
    return void 0 === o && (o = [1, 1]), void 0 === a && (a = "NHWC"), this.throwIfDisposed(), xt.separableConv2d(this, t, e, n, r, o, a);
  }, t.prototype.avgPool = function (t, e, n, r) {
    return this.throwIfDisposed(), xt.avgPool(this, t, e, n, r);
  }, t.prototype.maxPool = function (t, e, n, r) {
    return this.throwIfDisposed(), xt.maxPool(this, t, e, n, r);
  }, t.prototype.localResponseNormalization = function (t, e, n, r) {
    return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), xt.localResponseNormalization(this, t, e, n, r);
  }, t.prototype.pool = function (t, e, n, r, o) {
    return this.throwIfDisposed(), xt.pool(this, t, e, n, r, o);
  }, t.prototype.variable = function (t, e, n) {
    return void 0 === t && (t = !0), this.throwIfDisposed(), yt().makeVariable(this, t, e, n);
  }, t.prototype.unsortedSegmentSum = function (t, e) {
    return this.throwIfDisposed(), xt.unsortedSegmentSum(this, t, e);
  }, t.prototype.batchToSpaceND = function (t, e) {
    return this.throwIfDisposed(), xt.batchToSpaceND(this, t, e);
  }, t.prototype.spaceToBatchND = function (t, e) {
    return this.throwIfDisposed(), xt.spaceToBatchND(this, t, e);
  }, t.prototype.topk = function (t, e) {
    return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), xt.topk(this, t, e);
  }, t.prototype.stridedSlice = function (t, e, n, r, o, a, i, s) {
    return void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.throwIfDisposed(), xt.stridedSlice(this, t, e, n, r, o, a, i, s);
  }, t.prototype.depthToSpace = function (t, e) {
    return this.throwIfDisposed(), xt.depthToSpace(this, t, e);
  }, t.prototype.fft = function () {
    return this.throwIfDisposed(), xt.spectral.fft(this);
  }, t.prototype.ifft = function () {
    return this.throwIfDisposed(), xt.spectral.ifft(this);
  }, t.prototype.rfft = function () {
    return this.throwIfDisposed(), xt.spectral.rfft(this);
  }, t.prototype.irfft = function () {
    return this.throwIfDisposed(), xt.spectral.irfft(this);
  }, t;
}();

exports.Tensor = wt;
Object.defineProperty(wt, Symbol.hasInstance, {
  value: function (t) {
    return !!t && null != t.dataId && null != t.shape && null != t.dtype;
  }
});

var Ct,
    Et,
    Rt,
    It,
    kt,
    St = function (t) {
  function n(e, n, r, o) {
    var a = t.call(this, e.shape, e.dtype, e.dataId, o) || this;
    return a.trainable = n, a.name = r, a;
  }

  return e(n, t), n.prototype.assign = function (t) {
    if (t.dtype !== this.dtype) throw new Error("dtype of the new value (" + t.dtype + ") and previous value (" + this.dtype + ") must match");
    if (!S(t.shape, this.shape)) throw new Error("shape of the new value (" + t.shape + ") and previous value (" + this.shape + ") must match");
    yt().disposeTensor(this), this.dataId = t.dataId, yt().incRef(this, null);
  }, n.prototype.dispose = function () {
    yt().disposeVariable(this), this.isDisposedInternal = !0;
  }, n;
}(wt);

exports.Variable = St;
exports.Rank = Ct;
Object.defineProperty(St, Symbol.hasInstance, {
  value: function (t) {
    return t instanceof wt && null != t.assign && t.assign instanceof Function;
  }
}), function (t) {
  t.R0 = "R0", t.R1 = "R1", t.R2 = "R2", t.R3 = "R3", t.R4 = "R4", t.R5 = "R5", t.R6 = "R6";
}(Ct || (exports.Rank = Ct = {})), function (t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "int32", t.complex64 = "complex64";
}(Et || (Et = {})), function (t) {
  t.float32 = "float32", t.int32 = "int32", t.bool = "bool", t.complex64 = "complex64";
}(Rt || (Rt = {})), function (t) {
  t.float32 = "float32", t.int32 = "float32", t.bool = "float32", t.complex64 = "complex64";
}(It || (It = {})), function (t) {
  t.float32 = "complex64", t.int32 = "complex64", t.bool = "complex64", t.complex64 = "complex64";
}(kt || (kt = {}));
var At = {
  float32: It,
  int32: Et,
  bool: Rt,
  complex64: kt
};

function Dt(t, e) {
  if ("string" === t || "string" === e) {
    if ("string" === t && "string" === e) return "string";
    throw new Error("Can not upcast " + t + " with " + e);
  }

  return At[t][e];
}

function Tt(t) {
  return Dt(t, "int32");
}

function Nt(t, e) {
  if (t.dtype === e.dtype) return [t, e];
  var n = Dt(t.dtype, e.dtype);
  return [t.cast(n), e.cast(n)];
}

function Ft(t, e) {
  C(t.dtype === e.dtype, function () {
    return "The dtypes of the first(" + t.dtype + ") and second(" + e.dtype + ") input must match";
  });
}

function _t(t) {
  var e = [];
  return function t(e, n, r) {
    if (null == e) return;
    if (e instanceof wt) return void n.push(e);
    if (o = e, !Array.isArray(o) && "object" != typeof o) return;
    var o;
    var a = e;

    for (var i in a) {
      var s = a[i];
      r.has(s) || (r.add(s), t(s, n, r));
    }
  }(t, e, new Set()), e;
}

var Ot,
    Mt = Object.freeze({
  makeTypesMatch: Nt,
  assertTypesMatch: Ft,
  isTensorInList: function (t, e) {
    return e.some(function (e) {
      return e.id === t.id;
    });
  },
  getTensorsInContainer: _t
}),
    Bt = function () {
  function t() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = !1, this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null
    };
  }

  return t.prototype.dispose = function () {
    for (var t in this.registeredVariables) this.registeredVariables[t].dispose();
  }, t;
}(),
    Pt = function () {
  function t(t) {
    this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Bt();
  }

  return t.prototype.ready = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (null != this.pendingBackendInit) return [2, this.pendingBackendInit.then(function () {})];
            if (null != this.backendInstance) return [2];
            t = this.getSortedBackends(), e = 0, r.label = 1;

          case 1:
            return e < t.length ? (n = t[e], [4, this.initializeBackend(n).success]) : [3, 5];

          case 2:
            return r.sent() ? [4, this.setBackend(n)] : [3, 4];

          case 3:
            return r.sent(), [2];

          case 4:
            return e++, [3, 1];

          case 5:
            throw new Error("Could not initialize any backends, all backend initializations failed.");
        }
      });
    });
  }, Object.defineProperty(t.prototype, "backend", {
    get: function () {
      if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");

      if (null == this.backendInstance) {
        var t = this.initializeBackendsAndReturnBest(),
            e = t.name;
        if (t.asyncInit) throw new Error("The highest priority backend '" + e + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
        this.setBackend(e);
      }

      return this.backendInstance;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.backendNames = function () {
    return Object.keys(this.registryFactory);
  }, t.prototype.findBackend = function (t) {
    if (!(t in this.registry)) {
      if (!(t in this.registryFactory)) return null;
      if (this.initializeBackend(t).asyncInit) return null;
    }

    return this.registry[t];
  }, t.prototype.findBackendFactory = function (t) {
    return t in this.registryFactory ? this.registryFactory[t].factory : null;
  }, t.prototype.registerBackend = function (t, e, n) {
    return void 0 === n && (n = 1), t in this.registryFactory ? (console.warn(t + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[t] = {
      factory: e,
      priority: n
    }, !0);
  }, t.prototype.setBackend = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (null == this.registryFactory[t]) throw new Error("Backend name '" + t + "' not found in registry");
            return this.backendName = t, null != this.registry[t] ? [3, 4] : (this.backendInstance = null, e = this.initializeBackend(t), n = e.success, e.asyncInit ? [4, n] : [3, 2]);

          case 1:
            return o = r.sent(), [3, 3];

          case 2:
            o = n, r.label = 3;

          case 3:
            if (!o) return [2, !1];
            r.label = 4;

          case 4:
            return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new ut(this.backendInstance), [2, !0];
        }
      });
    });
  }, t.prototype.setupRegisteredKernels = function () {
    var t = this;
    f(this.backendName).forEach(function (e) {
      null != e.setupFunc && e.setupFunc(t.backendInstance);
    });
  }, t.prototype.disposeRegisteredKernels = function (t) {
    var e = this;
    f(t).forEach(function (n) {
      null != n.disposeFunc && n.disposeFunc(e.registry[t]);
    });
  }, t.prototype.initializeBackend = function (t) {
    var e = this,
        n = this.registryFactory[t];
    if (null == n) throw new Error("Cannot initialize backend " + t + ", no registration found.");

    try {
      var r = n.factory();

      if (Promise.resolve(r) === r) {
        var o = ++this.pendingBackendInitId,
            a = r.then(function (n) {
          return !(o < e.pendingBackendInitId) && (e.registry[t] = n, e.pendingBackendInit = null, !0);
        }).catch(function (n) {
          return !(o < e.pendingBackendInitId) && (e.pendingBackendInit = null, console.warn("Initialization of backend " + t + " failed"), console.warn(n.stack || n.message), !1);
        });
        return this.pendingBackendInit = a, {
          success: a,
          asyncInit: !0
        };
      }

      return this.registry[t] = r, {
        success: !0,
        asyncInit: !1
      };
    } catch (e) {
      return console.warn("Initialization of backend " + t + " failed"), console.warn(e.stack || e.message), {
        success: !1,
        asyncInit: !1
      };
    }
  }, t.prototype.removeBackend = function (t) {
    if (!(t in this.registryFactory)) throw new Error(t + " backend not found in registry");
    this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }, t.prototype.getSortedBackends = function () {
    var t = this;
    if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort(function (e, n) {
      return t.registryFactory[n].priority - t.registryFactory[e].priority;
    });
  }, t.prototype.initializeBackendsAndReturnBest = function () {
    for (var t = this.getSortedBackends(), e = 0; e < t.length; e++) {
      var n = t[e],
          r = this.initializeBackend(n),
          o = r.success,
          a = r.asyncInit;
      if (a || o) return {
        name: n,
        asyncInit: a
      };
    }

    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }, t.prototype.moveData = function (t, e) {
    var n = this.state.tensorInfo.get(e),
        r = n.backend,
        o = this.readSync(e);
    r.disposeData(e), n.backend = t, t.move(e, o, n.shape, n.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }, t.prototype.tidy = function (t, e) {
    var n,
        r = this,
        o = null;

    if (null == e) {
      if ("function" != typeof t) throw new Error("Please provide a function to tidy()");
      e = t;
    } else {
      if ("string" != typeof t && !(t instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if ("function" != typeof e) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      o = t;
    }

    return this.scopedRun(function () {
      return r.startScope(o);
    }, function () {
      return r.endScope(n);
    }, function () {
      return (n = e()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n;
    });
  }, t.prototype.scopedRun = function (t, e, n) {
    t();

    try {
      var r = n();
      return e(), r;
    } catch (t) {
      throw e(), t;
    }
  }, t.prototype.nextTensorId = function () {
    return t.nextTensorId++;
  }, t.prototype.nextVariableId = function () {
    return t.nextVariableId++;
  }, t.prototype.clone = function (t) {
    var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype),
        n = {
      x: t
    };
    return this.addTapeNode(this.state.activeScope.name, n, [e], function (t) {
      return {
        x: function () {
          return t.toFloat();
        }
      };
    }, []), e;
  }, t.prototype.runKernel = function (t, e, n, r, o) {
    return this.runKernelFunc(null, e, null, t, n, r, o);
  }, t.prototype.shouldCheckForMemLeaks = function () {
    return this.ENV.getBool("IS_TEST");
  }, t.prototype.checkKernelForMemLeak = function (t, e, n) {
    var r = this.backend.numDataIds(),
        o = 0;
    n.forEach(function (t) {
      o += "complex64" === t.dtype ? 3 : 1;
    });
    var a = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
        i = r - e - o - a;
    if (i > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + i + " data ids) after running '" + t + "'");
  }, t.prototype.runKernelFunc = function (t, e, n, r, o, a, i) {
    var s,
        u = this;
    void 0 === a && (a = []), void 0 === i && (i = []);
    var c = [],
        h = this.isTapeOn();
    null == r && (r = null != this.state.activeScope ? this.state.activeScope.name : "");

    var f,
        d = function (t) {
      h && (c = t.map(function (t) {
        return u.keep(u.clone(t));
      }));
    },
        p = this.state.numBytes,
        v = this.state.numTensors;

    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    var m,
        g = l(r, this.backendName);
    return f = null != g ? function () {
      var t = u.backend.numDataIds();
      m = g.kernelFunc({
        inputs: e,
        attrs: o,
        backend: u.backend
      });
      var n = Array.isArray(m) ? m : [m];
      u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, t, n);
      var s = n.map(function (t) {
        var e = t.dataId,
            n = t.shape,
            r = t.dtype;
        return u.makeTensorFromDataId(e, n, r);
      }),
          c = s.filter(function (t, e) {
        return i[e];
      });
      return d((a || []).slice().concat(c)), s;
    } : function () {
      var e = u.backend.numDataIds();
      m = u.tidy(function () {
        return t(u.backend, d);
      });
      var n = Array.isArray(m) ? m : [m];
      return u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, e, n), n;
    }, this.scopedRun(function () {
      return u.state.kernelDepth++;
    }, function () {
      return u.state.kernelDepth--;
    }, function () {
      s = u.ENV.getBool("DEBUG") ? u.profiler.profileKernel(r, e, function () {
        return f();
      }) : f();
    }), h && this.addTapeNode(r, e, s, n, c), this.state.profiling && this.state.activeProfile.kernels.push({
      name: r,
      bytesAdded: this.state.numBytes - p,
      totalBytesSnapshot: this.state.numBytes,
      tensorsAdded: this.state.numTensors - v,
      totalTensorsSnapshot: this.state.numTensors,
      inputShapes: Object.keys(e).map(function (t) {
        return e[t].shape;
      }),
      outputShapes: s.map(function (t) {
        return t.shape;
      })
    }), Array.isArray(m) ? s : s[0];
  }, t.prototype.makeTensor = function (t, e, n, r) {
    if (null == t) throw new Error("Values passed to engine.makeTensor() are null");
    n = n || "float32", r = r || this.backend;
    var o = t;
    "string" === n && H(t[0]) && (o = t.map(function (t) {
      return rt(t);
    }));
    var a = r.write(o, e, n),
        i = new wt(e, n, a, this.nextTensorId());

    if (this.incRef(i, r), "string" === n) {
      var s = this.state.tensorInfo.get(a),
          u = G(o);
      this.state.numBytes += u - s.bytes, s.bytes = u;
    }

    return i;
  }, t.prototype.makeTensorFromDataId = function (t, e, n, r) {
    var o = new wt(e, n = n || "float32", t, this.nextTensorId());
    return this.incRef(o, r), o;
  }, t.prototype.makeVariable = function (t, e, n, r) {
    void 0 === e && (e = !0), n = n || this.nextVariableId().toString(), null != r && r !== t.dtype && (t = t.asType(r));
    var o = new St(t, e, n, this.nextTensorId());
    if (null != this.state.registeredVariables[o.name]) throw new Error("Variable with name " + o.name + " was already registered");
    return this.state.registeredVariables[o.name] = o, this.incRef(o, this.backend), o;
  }, t.prototype.incRef = function (t, e) {
    var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0;

    if (this.state.numTensors++, "string" === t.dtype && this.state.numStringTensors++, 0 === n) {
      this.state.numDataBuffers++;
      var r = 0;
      "complex64" !== t.dtype && "string" !== t.dtype && (r = t.size * z(t.dtype)), this.state.tensorInfo.set(t.dataId, {
        backend: e || this.backend,
        dtype: t.dtype,
        shape: t.shape,
        bytes: r,
        refCount: 0
      }), this.state.numBytes += r;
    }

    this.state.tensorInfo.get(t.dataId).refCount++, t instanceof St || this.track(t);
  }, t.prototype.disposeTensor = function (t) {
    if (this.state.tensorInfo.has(t.dataId)) {
      this.state.numTensors--, "string" === t.dtype && this.state.numStringTensors--;
      var e = this.state.tensorInfo.get(t.dataId);
      e.refCount <= 1 ? ("complex64" !== t.dtype && (this.state.numBytes -= e.bytes), this.state.numDataBuffers--, e.backend.disposeData(t.dataId), this.state.tensorInfo.delete(t.dataId)) : this.state.tensorInfo.get(t.dataId).refCount--;
    }
  }, t.prototype.disposeVariables = function () {
    for (var t in this.state.registeredVariables) {
      var e = this.state.registeredVariables[t];
      this.disposeVariable(e);
    }
  }, t.prototype.disposeVariable = function (t) {
    this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name];
  }, t.prototype.memory = function () {
    var t = this.backend.memory();
    return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, null == t.reasons && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t;
  }, t.prototype.profile = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n;
      return r(this, function (r) {
        return this.state.profiling = !0, e = this.state.numBytes, n = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function (t) {
          return t.totalBytesSnapshot;
        })), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - n, [2, this.state.activeProfile];
      });
    });
  }, t.prototype.isTapeOn = function () {
    return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
  }, t.prototype.addTapeNode = function (t, e, n, r, o) {
    var a = this,
        i = {
      id: this.state.nextTapeNodeId++,
      kernelName: t,
      inputs: e,
      outputs: n,
      saved: o
    },
        s = h(t);
    null != s && (r = s.gradFunc), null != r && (i.gradient = function (t) {
      return t = t.map(function (t, e) {
        if (null == t) {
          var r = n[e],
              o = tt(r.size, r.dtype);
          return a.makeTensor(o, r.shape, r.dtype);
        }

        return t;
      }), r(t.length > 1 ? t : t[0], o);
    }), this.state.activeTape.push(i);
  }, t.prototype.keep = function (t) {
    return t.kept = !0, t;
  }, t.prototype.startTape = function () {
    0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
  }, t.prototype.endTape = function () {
    this.state.gradientDepth--;
  }, t.prototype.startScope = function (t) {
    var e = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e;
  }, t.prototype.endScope = function (t) {
    for (var e = this, n = _t(t), r = new Set(n.map(function (t) {
      return t.id;
    })), o = 0; o < this.state.activeScope.track.length; o++) {
      var a = this.state.activeScope.track[o];
      a.kept || r.has(a.id) || a.dispose();
    }

    var i = this.state.scopeStack.pop();
    this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach(function (t) {
      t.kept || t.scopeId !== i.id || e.track(t);
    });
  }, t.prototype.gradients = function (t, e, n, r) {
    var o = this;
    if (void 0 === r && (r = !1), C(e.length > 0, function () {
      return "gradients() received an empty list of xs.";
    }), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n.dtype + "'");
    var a = this.scopedRun(function () {
      return o.startTape();
    }, function () {
      return o.endTape();
    }, function () {
      return o.tidy("forward", t);
    });
    C(a instanceof wt, function () {
      return "The result y returned by f() must be a tensor.";
    });

    var i = function (t, e, n) {
      for (var r = {}, o = {}, a = 0; a < e.length; a++) r[e[a].id] = !0;

      for (a = 0; a < t.length; a++) {
        var i = (p = t[a]).inputs;

        for (var s in i) {
          for (var u = i[s], c = !1, l = 0; l < e.length; l++) if (r[u.id]) {
            p.outputs.forEach(function (t) {
              return r[t.id] = !0;
            }), c = !0, o[p.id] = !0;
            break;
          }

          if (c) break;
        }
      }

      var h = {};
      h[n.id] = !0;
      var f = {};

      for (a = t.length - 1; a >= 0; a--) for (i = (p = t[a]).inputs, l = 0; l < p.outputs.length; l++) if (h[p.outputs[l].id]) {
        for (var s in i) h[i[s].id] = !0, f[p.id] = !0;

        break;
      }

      var d = [];

      for (a = 0; a < t.length; a++) {
        var p;

        if (o[(p = t[a]).id] && f[p.id]) {
          var v = {};

          for (var s in p.inputs) {
            var m = p.inputs[s];
            r[m.id] && (v[s] = m);
          }

          var g = Object.assign({}, p);
          g.inputs = v, g.outputs = p.outputs, d.push(g);
        }
      }

      return d;
    }(this.state.activeTape, e, a);

    if (!r && 0 === i.length && e.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", function () {
      var t,
          r,
          s = {};
      s[a.id] = null == n ? (t = a.shape, r = Z(k(t), "float32"), Lt.makeTensor(r, t, "float32")) : n, function (t, e, n) {
        for (var r = function (r) {
          var o = e[r],
              a = [];
          if (o.outputs.forEach(function (e) {
            var n = t[e.id];
            null != n ? a.push(n) : a.push(null);
          }), null == o.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + o.kernelName + ".");

          var i = o.gradient(a),
              s = function (e) {
            if (!(e in i)) throw new Error("Cannot backprop through input " + e + ". Available gradients found: " + Object.keys(i) + ".");
            var r = n(function () {
              return i[e]();
            });
            if ("float32" !== r.dtype) throw new Error("Error in gradient for op " + o.kernelName + ". The gradient of input " + e + " must have 'float32' dtype, but has '" + r.dtype + "'");
            var a = o.inputs[e];
            if (!S(r.shape, a.shape)) throw new Error("Error in gradient for op " + o.kernelName + ". The gradient of input '" + e + "' has shape '" + r.shape + "', which does not match the shape of the input '" + a.shape + "'");
            if (null == t[a.id]) t[a.id] = r;else {
              var s = t[a.id];
              t[a.id] = s.add(r), s.dispose();
            }
          };

          for (var u in o.inputs) s(u);
        }, o = e.length - 1; o >= 0; o--) r(o);
      }(s, i, function (t) {
        return o.tidy(t);
      });
      var u = e.map(function (t) {
        return s[t.id];
      });
      return 0 === o.state.gradientDepth && (o.state.activeTape.forEach(function (t) {
        for (var e = 0, n = t.saved; e < n.length; e++) {
          n[e].dispose();
        }
      }), o.state.activeTape = null), {
        value: a,
        grads: u
      };
    });
  }, t.prototype.customGrad = function (t) {
    var e = this;
    return C(X(t), function () {
      return "The f passed in customGrad(f) must be a function.";
    }), function () {
      for (var n, r = [], o = 0; o < arguments.length; o++) r[o] = arguments[o];

      C(r.every(function (t) {
        return t instanceof wt;
      }), function () {
        return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
      });
      var a = {};
      return r.forEach(function (t, e) {
        a[e] = t;
      }), e.runKernelFunc(function (e, o) {
        return C((n = t.apply(void 0, r.concat([o]))).value instanceof wt, function () {
          return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
        }), C(X(n.gradFunc), function () {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
        }), n.value;
      }, a, function (t, e) {
        var o = n.gradFunc(t, e),
            a = Array.isArray(o) ? o : [o];
        C(a.length === r.length, function () {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
        }), C(a.every(function (t) {
          return t instanceof wt;
        }), function () {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
        });
        var i = {};
        return a.forEach(function (t, e) {
          i[e] = function () {
            return t;
          };
        }), i;
      });
    };
  }, t.prototype.readSync = function (t) {
    return this.state.tensorInfo.get(t).backend.readSync(t);
  }, t.prototype.read = function (t) {
    return this.state.tensorInfo.get(t).backend.read(t);
  }, t.prototype.time = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return e = et(), [4, this.backend.time(t)];

          case 1:
            return (n = r.sent()).wallMs = et() - e, [2, n];
        }
      });
    });
  }, t.prototype.track = function (t) {
    return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t;
  }, Object.defineProperty(t.prototype, "registeredVariables", {
    get: function () {
      return this.state.registeredVariables;
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.reset = function () {
    for (var t in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Bt(), this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];

    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }, t.nextTensorId = 0, t.nextVariableId = 0, t;
}();

exports.tensor_util = Mt;

var Lt = function () {
  var t = function () {
    if (null == Ot) {
      var t = void 0;
      if ("undefined" != typeof window) t = window;else if ("undefined" != typeof global) t = global;else if ("undefined" != typeof process) t = process;else {
        if ("undefined" == typeof self) throw new Error("Could not find a global object");
        t = self;
      }
      Ot = t;
    }

    return Ot;
  }();

  if (null == t._tfengine) {
    var e = new o(t);
    t._tfengine = new Pt(e);
  }

  return function (t) {
    exports.ENV = s = t;
  }(t._tfengine.ENV), yt = function () {
    return t._tfengine;
  }, t._tfengine;
}();

function Wt() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}

var Ut = i();
Ut.registerFlag("DEBUG", function () {
  return !1;
}, function (t) {
  t && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Ut.registerFlag("IS_BROWSER", function () {
  return Wt();
}), Ut.registerFlag("IS_NODE", function () {
  return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
}), Ut.registerFlag("IS_CHROME", function () {
  return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), Ut.registerFlag("PROD", function () {
  return !1;
}), Ut.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function () {
  return Ut.getBool("DEBUG");
}), Ut.registerFlag("DEPRECATION_WARNINGS_ENABLED", function () {
  return !0;
}), Ut.registerFlag("IS_TEST", function () {
  return !1;
});
var Vt,
    zt,
    Gt,
    Ht = {},
    qt = {
  alpha: !1,
  antialias: !1,
  premultipliedAlpha: !1,
  preserveDrawingBuffer: !1,
  depth: !1,
  stencil: !1,
  failIfMajorPerformanceCaveat: !0
};

function Kt(t, e) {
  Ht[t] = e;
}

function jt(t) {
  t in Ht || (Ht[t] = function (t) {
    if (1 !== t && 2 !== t) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");

    var e = function (t) {
      if ("undefined" != typeof OffscreenCanvas && 2 === t) return new OffscreenCanvas(300, 150);
      if ("undefined" != typeof document) return document.createElement("canvas");
      throw new Error("Cannot create a canvas in this context");
    }(t);

    if (e.addEventListener("webglcontextlost", function (e) {
      e.preventDefault(), delete Ht[t];
    }, !1), 1 === t) return e.getContext("webgl", qt) || e.getContext("experimental-webgl", qt);
    return e.getContext("webgl2", qt);
  }(t));
  var e = Ht[t];
  return e.isContextLost() ? (delete Ht[t], jt(t)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), Ht[t]);
}

function Xt(t, e) {
  return [e, t];
}

function Yt(t) {
  var e = k(t);
  return T(Math.ceil(e / 4));
}

function $t(t, e) {
  return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(t / 2))];
}

function Qt(t, e) {
  var n,
      r,
      o,
      a,
      s,
      u,
      c,
      l,
      h,
      f = t;
  return 2 === i().getNumber("WEBGL_VERSION") ? (n = f.R32F, r = f.R16F, o = f.RGBA16F, a = f.RGBA32F, s = f.RED, u = 4, c = 1, l = f.HALF_FLOAT, h = f.FLOAT) : (n = t.RGBA, r = t.RGBA, o = t.RGBA, a = f.RGBA, s = t.RGBA, u = 4, c = 4, l = null != e ? e.HALF_FLOAT_OES : null, h = t.FLOAT), {
    internalFormatFloat: n,
    internalFormatHalfFloat: r,
    internalFormatPackedHalfFloat: o,
    internalFormatPackedFloat: a,
    textureFormatFloat: s,
    downloadTextureFormat: t.RGBA,
    downloadUnpackNumChannels: u,
    defaultNumChannels: c,
    textureTypeHalfFloat: l,
    textureTypeFloat: h
  };
}

function Jt(t, e, n) {
  var r = n();
  return e && function (t) {
    var e = t.getError();
    if (e !== t.NO_ERROR) throw new Error("WebGL Error: " + ne(t, e));
  }(t), r;
}

!function (t) {
  t[t.DENSE = 0] = "DENSE", t[t.SHARED_BATCH = 1] = "SHARED_BATCH";
}(Vt || (Vt = {})), function (t) {
  t[t.RENDER = 0] = "RENDER", t[t.UPLOAD = 1] = "UPLOAD", t[t.PIXELS = 2] = "PIXELS", t[t.DOWNLOAD = 3] = "DOWNLOAD";
}(zt || (zt = {})), function (t) {
  t[t.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t[t.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t[t.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t[t.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(Gt || (Gt = {}));
var Zt = 5.96e-8,
    te = 65504;

function ee(t) {
  return !!(i().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t || Zt < Math.abs(t) && Math.abs(t) < te);
}

function ne(t, e) {
  switch (e) {
    case t.NO_ERROR:
      return "NO_ERROR";

    case t.INVALID_ENUM:
      return "INVALID_ENUM";

    case t.INVALID_VALUE:
      return "INVALID_VALUE";

    case t.INVALID_OPERATION:
      return "INVALID_OPERATION";

    case t.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";

    case t.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";

    case t.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";

    default:
      return "Unknown error code " + e;
  }
}

function re(t, e, n) {
  return ke(t, e, function () {
    return t.getExtension(n);
  }, 'Extension "' + n + '" not supported on this browser.');
}

function oe(t, e, n) {
  var r = ke(t, e, function () {
    return t.createShader(t.VERTEX_SHADER);
  }, "Unable to create vertex WebGLShader.");
  if (Jt(t, e, function () {
    return t.shaderSource(r, n);
  }), Jt(t, e, function () {
    return t.compileShader(r);
  }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(r)), new Error("Failed to compile vertex shader.");
  return r;
}

function ae(t, e, n) {
  var r = ke(t, e, function () {
    return t.createShader(t.FRAGMENT_SHADER);
  }, "Unable to create fragment WebGLShader.");
  if (Jt(t, e, function () {
    return t.shaderSource(r, n);
  }), Jt(t, e, function () {
    return t.compileShader(r);
  }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw function (t, e) {
    var n = ue.exec(e);
    if (null == n) return console.log("Couldn't parse line number in error: " + e), void console.log(t);

    for (var r = +n[1], o = t.split("\n"), a = o.length.toString().length + 2, i = o.map(function (t, e) {
      return N((e + 1).toString(), a) + t;
    }), s = 0, u = 0; u < i.length; u++) s = Math.max(i[u].length, s);

    var c = i.slice(0, r - 1),
        l = i.slice(r - 1, r),
        h = i.slice(r);
    console.log(c.join("\n")), console.log(e.split("\n")[0]), console.log("%c " + N(l[0], s), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h.join("\n"));
  }(n, t.getShaderInfoLog(r)), new Error("Failed to compile fragment shader.");
  return r;
}

var ie,
    se,
    ue = /ERROR: [0-9]+:([0-9]+):/g;

function ce(t, e) {
  return ke(t, e, function () {
    return t.createProgram();
  }, "Unable to create WebGLProgram.");
}

function le(t, e, n) {
  if (Jt(t, e, function () {
    return t.linkProgram(n);
  }), !1 === t.getProgramParameter(n, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Failed to link vertex and fragment shaders.");
}

function he(t, e, n) {
  if (Jt(t, e, function () {
    return t.validateProgram(n);
  }), !1 === t.getProgramParameter(n, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Shader program validation failed.");
}

function fe(t, e, n) {
  var r = ke(t, e, function () {
    return t.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Jt(t, e, function () {
    return t.bindBuffer(t.ARRAY_BUFFER, r);
  }), Jt(t, e, function () {
    return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW);
  }), r;
}

function de(t, e, n) {
  var r = ke(t, e, function () {
    return t.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Jt(t, e, function () {
    return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r);
  }), Jt(t, e, function () {
    return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW);
  }), r;
}

function pe(t, e) {
  return ke(t, e, function () {
    return t.createTexture();
  }, "Unable to create WebGLTexture.");
}

function ve(t, e) {
  var n = i().getNumber("WEBGL_MAX_TEXTURE_SIZE");

  if (t <= 0 || e <= 0) {
    var r = "[" + t + "x" + e + "]";
    throw new Error("Requested texture size " + r + " is invalid.");
  }

  if (t > n || e > n) {
    r = "[" + t + "x" + e + "]";
    throw new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU " + ("[" + n + "x" + n + "]") + ".");
  }
}

function me(t, e) {
  return ke(t, e, function () {
    return t.createFramebuffer();
  }, "Unable to create WebGLFramebuffer.");
}

function ge(t, e, n, r, o, a, i, s) {
  var u = t.getAttribLocation(n, r);
  return -1 !== u && (Jt(t, e, function () {
    return t.bindBuffer(t.ARRAY_BUFFER, o);
  }), Jt(t, e, function () {
    return t.vertexAttribPointer(u, a, t.FLOAT, !1, i, s);
  }), Jt(t, e, function () {
    return t.enableVertexAttribArray(u);
  }), !0);
}

function ye(t, e, n, r) {
  Se(t, r), Jt(t, e, function () {
    return t.activeTexture(t.TEXTURE0 + r);
  }), Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, n);
  });
}

function xe(t, e, n, r) {
  return ke(t, e, function () {
    return t.getUniformLocation(n, r);
  }, 'uniform "' + r + '" not present in program.');
}

function be(t, e, n) {
  return t.getUniformLocation(e, n);
}

function we(t, e, n, r, o, a) {
  Jt(t, e, function () {
    return ye(t, e, r, a);
  }), Jt(t, e, function () {
    return t.uniform1i(o, a);
  });
}

function Ce(t, e, n, r) {
  Jt(t, e, function () {
    return t.bindFramebuffer(t.FRAMEBUFFER, r);
  }), Jt(t, e, function () {
    return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
  });
}

function Ee(t, e, n) {
  Jt(t, e, function () {
    return t.bindFramebuffer(t.FRAMEBUFFER, n);
  }), Jt(t, e, function () {
    return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0);
  });
}

function Re(t) {
  var e = t.checkFramebufferStatus(t.FRAMEBUFFER);
  if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + Ie(t, e));
}

function Ie(t, e) {
  switch (e) {
    case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

    case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

    case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

    case t.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";

    default:
      return "unknown error " + e;
  }
}

function ke(t, e, n, r) {
  var o = Jt(t, e, function () {
    return n();
  });
  if (null == o) throw new Error(r);
  return o;
}

function Se(t, e) {
  var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
      r = e + t.TEXTURE0;
  if (r < t.TEXTURE0 || r > n) throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + n + "]") + ".");
}

function Ae(t, e) {
  return void 0 === e && (e = 2), k(t.slice(0, t.length - e));
}

function De(t) {
  if (0 === t.length) throw Error("Cannot get rows and columns of an empty shape array.");
  return [t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]];
}

function Te(t) {
  var e = [1, 1, 1];
  return 0 === t.length || 1 === t.length && 1 === t[0] || (e = [Ae(t)].concat(De(t))), e;
}

function Ne(t, e) {
  var n;
  void 0 === e && (e = !1);
  var r = i().getNumber("WEBGL_MAX_TEXTURE_SIZE");

  if (e && (r *= 2, 1 === (t = t.map(function (e, n) {
    return n >= t.length - 2 ? b(t[n]) : t[n];
  })).length && (t = [2, t[0]])), 2 !== t.length) {
    var o = M(t);
    t = o.newShape;
  }

  var a = k(t);
  if (t.length <= 1 && a <= r) return [1, a];
  if (2 === t.length && t[0] <= r && t[1] <= r) return t;
  if (3 === t.length && t[0] * t[1] <= r && t[2] <= r) return [t[0] * t[1], t[2]];
  if (3 === t.length && t[0] <= r && t[1] * t[2] <= r) return [t[0], t[1] * t[2]];
  if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r) return [t[0] * t[1] * t[2], t[3]];
  if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r) return [t[0], t[1] * t[2] * t[3]];

  if (e) {
    var s = Ae(t),
        u = 2,
        c = 2;
    return t.length && (u = (n = De(t))[0], c = n[1]), T(a = s * (u / 2) * (c / 2)).map(function (t) {
      return 2 * t;
    });
  }

  return T(a);
}

function Fe(t) {
  return t % 2 == 0;
}

function _e(t, e) {
  if (S(t = t.slice(-2), e = e.slice(-2))) return !0;
  if (!t.length || !e.length) return !0;
  if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;

  if (t.length !== e.length) {
    var n = t.slice(-1)[0],
        r = e.slice(-1)[0];
    if (n === r) return !0;
    if (Fe(n) && Fe(r) && (1 === t[0] || 1 === e[0])) return !0;
  }

  return t[1] === e[1] && Fe(t[0]) && Fe(e[0]);
}

function Oe(t) {
  if (null == ie) {
    var e = jt(t);
    ie = e.getParameter(e.MAX_TEXTURE_SIZE);
  }

  return ie;
}

function Me(t) {
  if (null == se) {
    var e = jt(t);
    se = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
  }

  return Math.min(16, se);
}

function Be(t) {
  if (0 === t) return 0;
  var e = jt(t);
  return Pe(e, "EXT_disjoint_timer_query_webgl2") && 2 === t ? 2 : Pe(e, "EXT_disjoint_timer_query") ? 1 : 0;
}

function Pe(t, e) {
  return null != t.getExtension(e);
}

function Le(t) {
  try {
    if (null != jt(t)) return !0;
  } catch (t) {
    return !1;
  }

  return !1;
}

function We(t) {
  if (0 === t) return !1;
  var e = jt(t);

  if (1 === t) {
    if (!Pe(e, "OES_texture_float")) return !1;
  } else if (!Pe(e, "EXT_color_buffer_float")) return !1;

  return Ve(e);
}

function Ue(t) {
  if (0 === t) return !1;
  var e = jt(t);

  if (1 !== t) {
    if (Pe(e, "EXT_color_buffer_float")) return Ve(e);

    if (Pe(e, "EXT_color_buffer_half_float")) {
      var n = e.getExtension("EXT_color_buffer_half_float");
      return function (t, e) {
        var n = Qt(t, e),
            r = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, r);
        t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
        var o = t.createFramebuffer();
        t.bindFramebuffer(t.FRAMEBUFFER, o), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);
        var a = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
        return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(o), a;
      }(e, n);
    }

    return !1;
  }

  return !!Pe(e, "OES_texture_float") && !!Pe(e, "WEBGL_color_buffer_float") && Ve(e);
}

function Ve(t) {
  var e = Qt(t),
      n = t.createTexture();
  t.bindTexture(t.TEXTURE_2D, n);
  t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);
  var r = t.createFramebuffer();
  t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
  var o = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
  return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), o;
}

function ze(t) {
  return 2 === t && null != jt(t).fenceSync;
}

var Ge = Object.freeze({
  callAndCheck: Jt,
  canBeRepresented: ee,
  getWebGLErrorMessage: ne,
  getExtensionOrThrow: re,
  createVertexShader: oe,
  createFragmentShader: ae,
  createProgram: ce,
  linkProgram: le,
  validateProgram: he,
  createStaticVertexBuffer: fe,
  createStaticIndexBuffer: de,
  getNumChannels: function () {
    return 2 === i().getNumber("WEBGL_VERSION") ? 1 : 4;
  },
  createTexture: pe,
  validateTextureSize: ve,
  createFramebuffer: me,
  bindVertexBufferToProgramAttribute: ge,
  bindTextureUnit: ye,
  unbindTextureUnit: function (t, e, n) {
    Se(t, n), Jt(t, e, function () {
      return t.activeTexture(t.TEXTURE0 + n);
    }), Jt(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, null);
    });
  },
  getProgramUniformLocationOrThrow: xe,
  getProgramUniformLocation: be,
  bindTextureToProgramUniformSampler: we,
  bindCanvasToFramebuffer: function (t, e) {
    Jt(t, e, function () {
      return t.bindFramebuffer(t.FRAMEBUFFER, null);
    }), Jt(t, e, function () {
      return t.viewport(0, 0, t.canvas.width, t.canvas.height);
    }), Jt(t, e, function () {
      return t.scissor(0, 0, t.canvas.width, t.canvas.height);
    });
  },
  bindColorTextureToFramebuffer: Ce,
  unbindColorTextureFromFramebuffer: Ee,
  validateFramebuffer: Re,
  getFramebufferErrorMessage: Ie,
  getBatchDim: Ae,
  getRowsCols: De,
  getShapeAs3D: Te,
  getTextureShapeFromLogicalShape: Ne,
  isReshapeFree: _e,
  getWebGLMaxTextureSize: Oe,
  resetMaxTextureSize: function () {
    ie = null;
  },
  resetMaxTexturesInShader: function () {
    se = null;
  },
  getMaxTexturesInShader: Me,
  getWebGLDisjointQueryTimerVersion: Be,
  hasExtension: Pe,
  isWebGLVersionEnabled: Le,
  isCapableOfRenderingToFloatTexture: We,
  isDownloadFloatTextureEnabled: Ue,
  isWebGLFenceEnabled: ze
}),
    He = i();

function qe() {
  i().set("PROD", !0);
}

function Ke() {
  i().set("DEBUG", !0);
}

function je() {
  i().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}

function Xe(t) {
  i().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}

function Ye() {
  Lt.disposeVariables();
}

function $e() {
  return Lt;
}

function Qe() {
  return Lt.memory();
}

function Je(t) {
  return Lt.profile(t);
}

function Ze(t, e) {
  return Lt.tidy(t, e);
}

function tn(t) {
  _t(t).forEach(function (t) {
    return t.dispose();
  });
}

function en(t) {
  return Lt.keep(t);
}

function nn(t) {
  return Lt.time(t);
}

function rn(t) {
  return Lt.setBackend(t);
}

function on() {
  return Lt.ready();
}

function an() {
  return Lt.backendName;
}

function sn(t) {
  Lt.removeBackend(t);
}

function un(t) {
  return Lt.findBackend(t);
}

function cn(t) {
  return Lt.findBackendFactory(t);
}

function ln(t, e, n) {
  return void 0 === n && (n = 1), Lt.registerBackend(t, e, n);
}

function hn() {
  return Lt.backend;
}

function fn(t, e) {
  i().setPlatform(t, e);
}

function dn() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];

  i().getBool("IS_TEST") || console.warn.apply(console, t);
}

function pn(t, e) {
  var n = t;
  if (V(t)) return "string" === e ? [] : [t.length];
  if (!Array.isArray(t)) return [];

  for (var r = []; Array.isArray(n) || V(n) && "string" !== e;) r.push(n.length), n = n[0];

  return Array.isArray(t) && i().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t(e, n, r) {
    if (r = r || [], !Array.isArray(e) && !V(e)) return void C(0 === n.length, function () {
      return "Element arr[" + r.join("][") + "] is a primitive, but should be an array/TypedArray of " + n[0] + " elements";
    });
    C(n.length > 0, function () {
      return "Element arr[" + r.join("][") + "] should be a primitive, but is an array of " + e.length + " elements";
    }), C(e.length === n[0], function () {
      return "Element arr[" + r.join("][") + "] should have " + n[0] + " elements, but has " + e.length + " elements";
    });

    for (var o = n.slice(1), a = 0; a < e.length; ++a) t(e[a], o, r.concat(a));
  }(t, r, []), r;
}

function vn(t, e, n, r) {
  if (null != t && ("numeric" !== t && t !== e || "numeric" === t && "string" === e)) throw new Error("Argument '" + n + "' passed to '" + r + "' must be " + t + " tensor, but got " + e + " tensor");
}

function mn(t, e, n, r) {
  if (void 0 === r && (r = "numeric"), t instanceof wt) return vn(r, t.dtype, e, n), t;
  var o = j(t);

  if ("string" !== o && ["bool", "int32", "float32"].indexOf(r) >= 0 && (o = r), vn(r, o, e, n), null == t || !V(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) {
    var a = null == t ? "null" : t.constructor.name;
    throw new Error("Argument '" + e + "' passed to '" + n + "' must be a Tensor or TensorLike, but got '" + a + "'");
  }

  var s = pn(t, o);
  V(t) || Array.isArray(t) || (t = [t]);
  var u = "string" !== o ? Q(t, o, i().getBool("DEBUG")) : I(t, [], !0);
  return Lt.makeTensor(u, s, o);
}

function gn(t, e, n, r) {
  if (void 0 === r && (r = "numeric"), !Array.isArray(t)) throw new Error("Argument " + e + " passed to " + n + " must be a `Tensor[]` or `TensorLike[]`");
  return t.map(function (t, r) {
    return mn(t, e + "[" + r + "]", n);
  }, r);
}

function yn(t, e) {
  for (var n = 0; n < t.length; ++n) if (t[t.length - n - 1] !== e - 1 - n) return !1;

  return !0;
}

function xn(t, e, n) {
  for (var r = t.length + e.length, o = [], a = 0, i = 0, s = 0; s < r; s++) -1 === n.indexOf(s) ? o.push(t[a++]) : o.push(e[i++]);

  return o;
}

function bn(t, e) {
  for (var n = [], r = t.length, o = 0; o < r; o++) -1 === e.indexOf(o) && n.push(t[o]);

  return [n, e.map(function (e) {
    return t[e];
  })];
}

function wn(t, e) {
  return xn(t, e.map(function (t) {
    return 1;
  }), e);
}

function Cn(t, e, n) {
  C(yn(e, n), function () {
    return t + " supports only inner-most axes for now. Got axes " + e + " and rank-" + n + " input.";
  });
}

function En(t, e) {
  if (yn(t, e)) return null;

  for (var n = [], r = 0; r < e; ++r) -1 === t.indexOf(r) && n.push(r);

  return t.forEach(function (t) {
    return n.push(t);
  }), n;
}

function Rn(t) {
  return t.map(function (t, e) {
    return [e, t];
  }).sort(function (t, e) {
    return t[1] - e[1];
  }).map(function (t) {
    return t[0];
  });
}

function In(t, e) {
  for (var n = [], r = e - t; r < e; ++r) n.push(r);

  return n;
}

function kn(t, e) {
  var n = t[0].length;
  t.forEach(function (t, e) {
    C(t.length === n, function () {
      return "Error in concat" + n + "D: rank of tensors[" + e + "] must be the same as the rank of the rest (" + n + ")";
    });
  }), C(e >= 0 && e < n, function () {
    return "Error in concat" + n + "D: axis must be between 0 and " + (n - 1) + ".";
  });
  var r = t[0];
  t.forEach(function (t, o) {
    for (var a = 0; a < n; a++) C(a === e || t[a] === r[a], function () {
      return "Error in concat" + n + "D: Shape of tensors[" + o + "] (" + t + ") does not match the shape of the rest (" + r + ") along the non-concatenated axis " + o + ".";
    });
  });
}

function Sn(t, e) {
  for (var n = t[0].slice(), r = 1; r < t.length; r++) n[e] += t[r][e];

  return n;
}

function An(t) {
  var e = Object.keys(t);
  if (1 !== e.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e.length + " keys.");
  var n = e[0],
      r = t[n];
  n.endsWith("_") && (n = n.substring(0, n.length - 1));

  var o = function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];

    Lt.startScope(n);

    try {
      var o = r.apply(void 0, t);
      return o instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Lt.endScope(o), o;
    } catch (t) {
      throw Lt.endScope(null), t;
    }
  };

  return Object.defineProperty(o, "name", {
    value: n,
    configurable: !0
  }), o;
}

He.registerFlag("HAS_WEBGL", function () {
  return He.getNumber("WEBGL_VERSION") > 0;
}), He.registerFlag("WEBGL_VERSION", function () {
  return Le(2) ? 2 : Le(1) ? 1 : 0;
}), He.registerFlag("WEBGL_BUFFER_SUPPORTED", function () {
  return 2 === He.get("WEBGL_VERSION");
}), He.registerFlag("WEBGL_CPU_FORWARD", function () {
  return !0;
}), He.registerFlag("WEBGL_FORCE_F16_TEXTURES", function () {
  return !1;
}), He.registerFlag("WEBGL_PACK", function () {
  return He.getBool("HAS_WEBGL");
}), He.registerFlag("WEBGL_PACK_NORMALIZATION", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_CLIP", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_DEPTHWISECONV", function () {
  return !1;
}), He.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_REDUCE", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_LAZILY_UNPACK", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_CONV_IM2COL", function () {
  return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function () {
  return Oe(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function () {
  return Me(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function () {
  var t = He.getNumber("WEBGL_VERSION");
  return 0 === t ? 0 : Be(t);
}), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function () {
  return He.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))));
  var t;
}), He.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function () {
  return We(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function () {
  return !He.getBool("WEBGL_FORCE_F16_TEXTURES") && He.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), He.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function () {
  return Ue(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_FENCE_API_ENABLED", function () {
  return ze(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function () {
  return He.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), bt = Xe;
var Dn = An({
  complex_: function (t, e) {
    var n = mn(t, "real", "complex"),
        r = mn(e, "imag", "complex");
    return E(n.shape, r.shape, "real and imag shapes, " + n.shape + " and " + r.shape + ", must match in call to tf.complex()."), Lt.runKernelFunc(function (t) {
      return t.complex(n, r);
    }, {
      $real: n,
      $imag: r
    });
  }
}),
    Tn = An({
  real_: function (t) {
    var e = mn(t, "input", "real");
    return Lt.runKernelFunc(function (t) {
      return t.real(e);
    }, {
      $input: e
    });
  }
}),
    Nn = An({
  imag_: function (t) {
    var e = mn(t, "input", "imag");
    return Lt.runKernelFunc(function (t) {
      return t.imag(e);
    }, {
      $input: e
    });
  }
});
exports.imag = Nn;
exports.real = Tn;
exports.complex = Dn;

function Fn(t, e, n) {
  return _n(t, e, pn(t, n), n);
}

function _n(t, e, n, r) {
  if (null == r && (r = j(t)), "complex64" === r) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!V(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");

  if (null != e) {
    nt(e);
    var o = k(e),
        a = k(n);
    C(o === a, function () {
      return "Based on the provided shape, [" + e + "], the tensor should have " + o + " values but has " + a;
    });

    for (var s = 0; s < n.length; ++s) {
      var u = n[s],
          c = s !== n.length - 1 || u !== k(e.slice(s));
      C(n[s] === e[s] || !c, function () {
        return "Error creating a new Tensor. Inferred shape (" + n + ") does not match the provided shape (" + e + "). ";
      });
    }
  }

  return V(t) || Array.isArray(t) || (t = [t]), e = e || n, t = "string" !== r ? Q(t, r, i().getBool("DEBUG")) : I(t, [], !0), Lt.makeTensor(t, e, r);
}

function On(t, e) {
  if ((V(t) && "string" !== e || Array.isArray(t)) && "complex64" !== e) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === e && V(t) && !(t instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return _n(t, [], [], e);
}

function Mn(t, e) {
  R(t);
  var n = pn(t, e);
  if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return _n(t, null, n, e);
}

function Bn(t, e, n) {
  if (R(t), null != e && 2 !== e.length) throw new Error("tensor2d() requires shape to have two numbers");
  var r = pn(t, n);
  if (2 !== r.length && 1 !== r.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return _n(t, e, r, n);
}

function Pn(t, e, n) {
  if (R(t), null != e && 3 !== e.length) throw new Error("tensor3d() requires shape to have three numbers");
  var r = pn(t, n);
  if (3 !== r.length && 1 !== r.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return _n(t, e, r, n);
}

function Ln(t, e, n) {
  if (R(t), null != e && 4 !== e.length) throw new Error("tensor4d() requires shape to have four numbers");
  var r = pn(t, n);
  if (4 !== r.length && 1 !== r.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return _n(t, e, r, n);
}

function Wn(t, e, n) {
  if (R(t), null != e && 5 !== e.length) throw new Error("tensor5d() requires shape to have five numbers");
  var r = pn(t, n);
  if (5 !== r.length && 1 !== r.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return _n(t, e, r, n);
}

function Un(t, e, n) {
  if (R(t), null != e && 6 !== e.length) throw new Error("tensor6d() requires shape to have six numbers");
  var r = pn(t, n);
  if (6 !== r.length && 1 !== r.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (1 === r.length && null == e) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return _n(t, e = e || r, r, n);
}

function Vn(t, e, n, r) {
  return void 0 === e && (e = !0), Lt.makeVariable(t, e, n, r);
}

function zn(t, e) {
  if (void 0 === e && (e = "float32"), "complex64" === e) {
    var n = zn(t, "float32"),
        r = Gn(t, "float32");
    return Dn(n, r);
  }

  var o = Z(k(t), e);
  return Lt.makeTensor(o, t, e);
}

function Gn(t, e) {
  if (void 0 === e && (e = "float32"), "complex64" === e) {
    var n = Gn(t, "float32"),
        r = Gn(t, "float32");
    return Dn(n, r);
  }

  var o = tt(k(t), e);
  return Lt.makeTensor(o, t, e);
}

function Hn(t, e, n) {
  return Lt.runKernelFunc(function (r) {
    return r.fill(t, e, n);
  }, {});
}

function qn(t, e, n) {
  if (n <= 0) throw new Error("The number of values should be positive.");
  return Lt.runKernelFunc(function (r) {
    return r.linspace(t, e, n);
  }, {});
}

function Kn(t, e, n, r) {
  if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), 0 === n) throw new Error("Cannot have a step of zero");
  if (t === e || t < e && n < 0 || e < t && n > 1) return Gn([0], r);
  var o = tt(Math.abs(Math.ceil((e - t) / n)), r);
  e < t && 1 === n && (n = -1), o[0] = t;

  for (var a = 1; a < o.length; a++) o[a] = o[a - 1] + n;

  return Mn(o, r);
}

var jn = An({
  onesLike_: function (t) {
    var e = mn(t, "x", "onesLike");

    if ("complex64" === e.dtype) {
      var n = jn(Tn(e)),
          r = Xn(Nn(e));
      return Dn(n, r);
    }

    return Lt.runKernelFunc(function (t) {
      return t.onesLike(e);
    }, {
      $x: e
    }, function (t, e) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    Xn = An({
  zerosLike_: function (t) {
    var e = mn(t, "x", "zerosLike");
    return Lt.runKernelFunc(function (t) {
      return t.zerosLike(e);
    }, {
      $x: e
    }, function (t, e) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
});
exports.zerosLike = Xn;
exports.onesLike = jn;
var Yn = An({
  concat_: function (t, e) {
    void 0 === e && (e = 0), C(t.length >= 1, function () {
      return "Pass at least one tensor to concat";
    });
    var n = gn(t, "tensors", "concat");
    "complex64" === n[0].dtype && n.forEach(function (t) {
      if ("complex64" !== t.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t.dtype + ". ");
    }), e = O(e, n[0].shape)[0];
    var r = Sn(n.map(function (t) {
      return t.shape;
    }), e);
    if (0 === k(r)) return Fn([], r);
    if (1 === (n = n.filter(function (t) {
      return t.size > 0;
    })).length) return n[0];
    var o = n.map(function (t) {
      return t.shape;
    });
    kn(o, e);
    var a = n,
        i = {
      axis: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.concat(n, e);
    }, a, function (t) {
      var n = o.map(function (t) {
        return t[e];
      });
      return tr(t, n, e).map(function (t) {
        return function () {
          return t;
        };
      });
    }, "Concat", i);
  }
}),
    $n = An({
  concat1d_: function (t) {
    return Yn(t, 0);
  }
}),
    Qn = An({
  concat2d_: function (t, e) {
    return Yn(t, e);
  }
}),
    Jn = An({
  concat3d_: function (t, e) {
    return Yn(t, e);
  }
}),
    Zn = An({
  concat4d_: function (t, e) {
    return Yn(t, e);
  }
}),
    tr = An({
  split_: function (t, e, n) {
    void 0 === n && (n = 0);
    var r,
        o = mn(t, "x", "split");
    return n = O(n, o.shape)[0], "number" == typeof e ? (C(o.shape[n] % e == 0, function () {
      return "Number of splits must evenly divide the axis.";
    }), r = new Array(e).fill(o.shape[n] / e)) : (C(o.shape[n] === e.reduce(function (t, e) {
      return t + e;
    }), function () {
      return "The sum of sizes must match the size of the axis dimension.";
    }), r = e), Lt.runKernelFunc(function (t) {
      return t.split(o, r, n);
    }, {
      $x: o
    }, function (t) {
      return {
        $x: function () {
          return Yn(t, n);
        }
      };
    });
  }
});
exports.split = tr;
exports.concat4d = Zn;
exports.concat3d = Jn;
exports.concat2d = Qn;
exports.concat1d = $n;
exports.concat = Yn;
"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;

function er(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}

var nr = er(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e,
          n = this,
          r = (e = 4022871197, function (t) {
        t = t.toString();

        for (var n = 0; n < t.length; n++) {
          var r = .02519603282416938 * (e += t.charCodeAt(n));
          r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e);
        }

        return 2.3283064365386963e-10 * (e >>> 0);
      });
      n.next = function () {
        var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
        return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t);
      }, n.c = 1, n.s0 = r(" "), n.s1 = r(" "), n.s2 = r(" "), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null;
    }

    function o(t, e) {
      return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = n.next;
      return i.int32 = function () {
        return 4294967296 * n.next() | 0;
      }, i.double = function () {
        return i() + 11102230246251565e-32 * (2097152 * i() | 0);
      }, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.alea = a;
  }(0, t, !1);
}),
    rr = er(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this,
          n = "";
      e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {
        var t = e.x ^ e.x << 11;
        return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;
      }, t === (0 | t) ? e.x = t : n += t;

      for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next();
    }

    function o(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xor128 = a;
  }(0, t, !1);
}),
    or = er(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this,
          n = "";
      e.next = function () {
        var t = e.x ^ e.x >>> 2;
        return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;
      }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;

      for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();
    }

    function o(t, e) {
      return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xorwow = a;
  }(0, t, !1);
}),
    ar = er(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this;
      e.next = function () {
        var t,
            n,
            r = e.x,
            o = e.i;
        return t = r[o], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[o + 1 & 7]) ^ t >>> 10, n ^= (t = r[o + 3 & 7]) ^ t >>> 3, n ^= (t = r[o + 4 & 7]) ^ t << 7, t = r[o + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[o] = n, e.i = o + 1 & 7, n;
      }, function (t, e) {
        var n,
            r = [];
        if (e === (0 | e)) r[0] = e;else for (e = "" + e, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;

        for (; r.length < 8;) r.push(0);

        for (n = 0; n < 8 && 0 === r[n]; ++n);

        for (8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next();
      }(e, t);
    }

    function o(t, e) {
      return e.x = t.x.slice(), e.i = t.i, e;
    }

    function a(t, e) {
      null == t && (t = +new Date());

      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && (a.x && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xorshift7 = a;
  }(0, t, !1);
}),
    ir = er(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this;
      e.next = function () {
        var t,
            n,
            r = e.w,
            o = e.X,
            a = e.i;
        return e.w = r = r + 1640531527 | 0, n = o[a + 34 & 127], t = o[a = a + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = o[a] = n ^ t, e.i = a, n + (r ^ r >>> 16) | 0;
      }, function (t, e) {
        var n,
            r,
            o,
            a,
            i,
            s = [],
            u = 128;

        for (e === (0 | e) ? (r = e, e = null) : (e += "\0", r = 0, u = Math.max(u, e.length)), o = 0, a = -32; a < u; ++a) e && (r ^= e.charCodeAt((a + 32) % e.length)), 0 === a && (i = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, a >= 0 && (i = i + 1640531527 | 0, o = 0 == (n = s[127 & a] ^= r + i) ? o + 1 : 0);

        for (o >= 128 && (s[127 & (e && e.length || 0)] = -1), o = 127, a = 512; a > 0; --a) r = s[o + 34 & 127], n = s[o = o + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[o] = r ^ n;

        t.w = i, t.X = s, t.i = o;
      }(e, t);
    }

    function o(t, e) {
      return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e;
    }

    function a(t, e) {
      null == t && (t = +new Date());

      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && (a.X && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.xor4096 = a;
  }(0, t, !1);
}),
    sr = er(function (t) {
  !function (t, e, n) {
    function r(t) {
      var e = this,
          n = "";
      e.next = function () {
        var t = e.b,
            n = e.c,
            r = e.d,
            o = e.a;
        return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ o, o = o - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ o, e.a = o - t | 0;
      }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;

      for (var r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next();
    }

    function o(t, e) {
      return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e;
    }

    function a(t, e) {
      var n = new r(t),
          a = e && e.state,
          i = function () {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t);

        return t;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && o(a, n), i.state = function () {
        return o(n, {});
      }), i;
    }

    e && e.exports ? e.exports = a : n && n.amd ? n(function () {
      return a;
    }) : this.tychei = a;
  }(0, t, !1);
}),
    ur = er(function (t) {
  !function (e, n) {
    var r,
        o = this,
        a = 256,
        i = 6,
        s = "random",
        u = n.pow(a, i),
        c = n.pow(2, 52),
        l = 2 * c,
        h = a - 1;

    function f(t, h, f) {
      var g = [],
          y = v(function t(e, n) {
        var r,
            o = [],
            a = typeof e;
        if (n && "object" == a) for (r in e) try {
          o.push(t(e[r], n - 1));
        } catch (t) {}
        return o.length ? o : "string" == a ? e : e + "\0";
      }((h = 1 == h ? {
        entropy: !0
      } : h || {}).entropy ? [t, m(e)] : null == t ? function () {
        try {
          var t;
          return r && (t = r.randomBytes) ? t = t(a) : (t = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(t)), m(t);
        } catch (t) {
          var n = o.navigator,
              i = n && n.plugins;
          return [+new Date(), o, i, o.screen, m(e)];
        }
      }() : t, 3), g),
          x = new d(g),
          b = function () {
        for (var t = x.g(i), e = u, n = 0; t < c;) t = (t + n) * a, e *= a, n = x.g(1);

        for (; t >= l;) t /= 2, e /= 2, n >>>= 1;

        return (t + n) / e;
      };

      return b.int32 = function () {
        return 0 | x.g(4);
      }, b.quick = function () {
        return x.g(4) / 4294967296;
      }, b.double = b, v(m(x.S), e), (h.pass || f || function (t, e, r, o) {
        return o && (o.S && p(o, x), t.state = function () {
          return p(x, {});
        }), r ? (n[s] = t, e) : t;
      })(b, y, "global" in h ? h.global : this == n, h.state);
    }

    function d(t) {
      var e,
          n = t.length,
          r = this,
          o = 0,
          i = r.i = r.j = 0,
          s = r.S = [];

      for (n || (t = [n++]); o < a;) s[o] = o++;

      for (o = 0; o < a; o++) s[o] = s[i = h & i + t[o % n] + (e = s[o])], s[i] = e;

      (r.g = function (t) {
        for (var e, n = 0, o = r.i, i = r.j, s = r.S; t--;) e = s[o = h & o + 1], n = n * a + s[h & (s[o] = s[i = h & i + e]) + (s[i] = e)];

        return r.i = o, r.j = i, n;
      })(a);
    }

    function p(t, e) {
      return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e;
    }

    function v(t, e) {
      for (var n, r = t + "", o = 0; o < r.length;) e[h & o] = h & (n ^= 19 * e[h & o]) + r.charCodeAt(o++);

      return m(e);
    }

    function m(t) {
      return String.fromCharCode.apply(0, t);
    }

    if (n["seed" + s] = f, v(n.random(), e), t.exports) {
      t.exports = f;

      try {
        r = require("crypto");
      } catch (t) {}
    }
  }([], Math);
});
ur.alea = nr, ur.xor128 = rr, ur.xorwow = or, ur.xorshift7 = ar, ur.xor4096 = ir, ur.tychei = sr;

var cr = ur.alea,
    lr = function () {
  function t(t, e, n, r, o) {
    this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var a = o || Math.random();
    this.random = cr(a.toString());
  }

  return t.prototype.nextValue = function () {
    if (!isNaN(this.nextVal)) {
      var t = this.nextVal;
      return this.nextVal = NaN, t;
    }

    for (var e, n, r = !1; !r;) {
      var o = void 0,
          a = void 0,
          i = void 0;

      do {
        i = (o = 2 * this.random() - 1) * o + (a = 2 * this.random() - 1) * a;
      } while (i >= 1 || 0 === i);

      var s = Math.sqrt(-2 * Math.log(i) / i);
      e = this.mean + this.stdDev * o * s, n = this.mean + this.stdDev * a * s, this.truncated && !this.isValidTruncated(e) || (r = !0);
    }

    return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e);
  }, t.prototype.convertValue = function (t) {
    return null == this.dtype || "float32" === this.dtype ? t : Math.round(t);
  }, t.prototype.isValidTruncated = function (t) {
    return t <= this.upper && t >= this.lower;
  }, t;
}(),
    hr = function () {
  function t(t, e, n, r) {
    this.alpha = t, this.beta = 1 / e, this.dtype = n;
    var o = r || Math.random();
    this.randu = cr(o.toString()), this.randn = new lr(0, 1, n, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }

  return t.prototype.nextValue = function () {
    for (var t, e, n, r, o, a;;) {
      do {
        r = this.randn.nextValue(), a = 1 + this.c * r;
      } while (a <= 0);

      if (a *= a * a, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - a + Math.log(a)), (o = this.randu()) < e || Math.log(o) < n) break;
    }

    return a = 1 / this.beta * this.d * a, this.alpha < 1 && (a *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a);
  }, t.prototype.convertValue = function (t) {
    return "float32" === this.dtype ? t : Math.round(t);
  }, t;
}(),
    fr = function () {
  function t(t, e, n, r) {
    var o = this;
    if (void 0 === t && (t = 0), void 0 === e && (e = 1), this.canReturnFloat = function () {
      return null == o.dtype || "float32" === o.dtype;
    }, this.min = t, this.range = e - t, this.dtype = n, null == r && (r = Math.random()), "number" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + t + " - " + e + " <= 1 and dtype is not float");
    this.random = cr(r);
  }

  return t.prototype.convertValue = function (t) {
    return this.canReturnFloat() ? t : Math.round(t);
  }, t.prototype.nextValue = function () {
    return this.convertValue(this.min + this.range * this.random());
  }, t;
}();

function dr(t, e, n) {
  return void 0 === e && (e = "float32"), e = e || "float32", nt(t), new gt(t, e, n);
}

function pr(t, e) {
  void 0 === e && (e = !1), console.log(t.toString(e));
}

var vr = An({
  batchToSpaceND_: function (t, e, n) {
    var r = mn(t, "x", "batchToSpaceND"),
        o = e.reduce(function (t, e) {
      return t * e;
    });
    return C(r.rank >= 1 + e.length, function () {
      return "input rank is " + r.rank + " but should be > than blockShape.length " + e.length;
    }), C(n.length === e.length, function () {
      return "crops.length is " + n.length + " but should be equal to blockShape.length  " + e.length;
    }), C(r.shape[0] % o == 0, function () {
      return "input tensor batch is " + r.shape[0] + " but is not divisible by the product of the elements of blockShape " + e.join(" * ") + " === " + o;
    }), Lt.runKernelFunc(function (t) {
      return t.batchToSpaceND(r, e, n);
    }, {
      $x: r
    }, function (t) {
      return {
        $x: function () {
          return t.spaceToBatchND(e, n);
        }
      };
    });
  }
}),
    mr = An({
  broadcastTo_: function (t, e) {
    var n = mn(t, "broadcastTo", "x"),
        r = n.shape;
    if (e.some(function (t) {
      return !(t > 0) || t % 1 != 0;
    })) throw new Error("broadcastTo(): Invalid broadcast shape [" + e + "].");
    if (e.length < n.rank) throw new Error("broadcastTo(): shape.length=" + e.length + " < input.rank=" + n.rank + ".");

    if (e.length > n.rank) {
      for (var o = n.shape.slice(); o.length < e.length;) o.unshift(1);

      n = n.reshape(o);
    }

    for (var a = Array.from(e), i = e.length - 1; i >= 0; i--) if (n.shape[i] === e[i]) a[i] = 1;else if (1 !== n.shape[i]) throw new Error("broadcastTo(): [" + r + "] cannot be broadcast to [" + e + "].");

    var s = a.map(function (t, e) {
      return t > 1 ? e : -1;
    }).filter(function (t) {
      return t >= 0;
    });
    return 0 === s.length ? n.clone() : Lt.runKernelFunc(function (t) {
      return t.tile(n, a);
    }, {
      input: n
    }, function (t) {
      return {
        input: function () {
          return t.sum(s, !0);
        }
      };
    });
  }
}),
    gr = An({
  cast_: function (t, e) {
    var n = mn(t, "x", "cast");
    if (!W(e)) throw new Error("Failed to cast to unknown dtype " + e);
    if ("string" === e && "string" !== n.dtype || "string" !== e && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
    var r = {
      dtype: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.cast(n, e);
    }, {
      x: n
    }, function (t) {
      return {
        x: function () {
          return t.clone();
        }
      };
    }, "Cast", r);
  }
}),
    yr = An({
  clone_: function (t) {
    var e = mn(t, "x", "clone", null);
    return Lt.runKernelFunc(function () {
      return Lt.makeTensorFromDataId(e.dataId, e.shape, e.dtype);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return t.toFloat();
        }
      };
    });
  }
}),
    xr = An({
  cumsum_: function (t, e, n, r) {
    void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);
    var o = mn(t, "x", "cumsum"),
        a = En([e |= 0], o.rank),
        i = o;
    null != a && (i = o.transpose(a));
    var s = In(1, o.rank)[0],
        u = Lt.runKernelFunc(function (t) {
      return t.cumsum(i, s, n, r);
    }, {
      permutedX: i
    }, function (t) {
      return {
        permutedX: function () {
          return t.cumsum(e, n, !r);
        }
      };
    });
    return null != a && (u = u.transpose(a)), u;
  }
}),
    br = An({
  depthToSpace_: function (t, e, n) {
    void 0 === n && (n = "NHWC");
    var r = mn(t, "x", "depthToSpace"),
        o = "NHWC" === n ? r.shape[1] : r.shape[2],
        a = "NHWC" === n ? r.shape[2] : r.shape[3],
        i = "NHWC" === n ? r.shape[3] : r.shape[1];
    return C(o * e >= 0, function () {
      return "Negative dimension size caused by overflow when multiplying\n      " + o + " and " + e + "  for depthToSpace with input shape\n      " + r.shape;
    }), C(a * e >= 0, function () {
      return "Negative dimension size caused by overflow when multiplying\n      " + a + " and " + e + " for depthToSpace with input shape\n          " + r.shape;
    }), C(i % (e * e) == 0, function () {
      return "Dimension size must be evenly divisible by " + e * e + " but is " + i + " for depthToSpace with input shape " + r.shape;
    }), Lt.runKernelFunc(function (t) {
      return t.depthToSpace(r, e, n);
    }, {
      $x: r
    });
  }
}),
    wr = An({
  expandDims_: function (t, e) {
    void 0 === e && (e = 0);
    var n = mn(t, "x", "expandDims", null);
    C(e <= n.rank, function () {
      return "Axis must be <= rank of the tensor";
    });
    var r = n.shape.slice();
    return e < 0 && (C(-(n.rank + 1) <= e, function () {
      return "Axis must be in the interval [" + -(n.rank + 1) + ", " + n.rank + "]";
    }), e = n.rank + e + 1), r.splice(e, 0, 1), Or(n, r);
  }
}),
    Cr = An({
  eye_: function (t, e, n, r) {
    void 0 === r && (r = "float32"), null == e && (e = t);

    for (var o = dr([t, e], r), a = t <= e ? t : e, i = 0; i < a; ++i) o.set(1, i, i);

    var s = o.toTensor().as2D(t, e);
    if (null == n) return s;
    if (1 === n.length) return Lr(wr(s, 0), [n[0], 1, 1]);
    if (2 === n.length) return Lr(wr(wr(s, 0), 0), [n[0], n[1], 1, 1]);
    if (3 === n.length) return Lr(wr(wr(wr(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
    throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n.length + "D.");
  }
}),
    Er = An({
  multinomial_: function (t, e, n, r) {
    void 0 === r && (r = !1);
    var o = mn(t, "logits", "multinomial"),
        a = o.size,
        i = o.rank;
    if (a < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + a + ".");
    if (i > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + i);
    n = n || Math.random();
    var s = 1 === i ? o.as2D(1, -1) : o,
        u = Lt.runKernelFunc(function (t) {
      return t.multinomial(s, r, e, n);
    }, {
      logits2D: s
    });
    return 1 === i ? u.as1D() : u;
  }
}),
    Rr = An({
  oneHot_: function (t, e, n, r) {
    if (void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e);
    var o = mn(t, "indices", "oneHot", "int32"),
        a = o.shape.concat([e]);
    return o = o.flatten(), Lt.runKernelFunc(function (t) {
      return t.oneHot(o, e, n, r);
    }, {
      $indices: o
    }, function (t) {
      return {
        $indices: function () {
          return Gn(o.shape, "float32");
        }
      };
    }).reshape(a);
  }
}),
    Ir = An({
  pad_: function (t, e, n) {
    void 0 === n && (n = 0);
    var r = mn(t, "x", "pad");
    if (0 === r.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    var o = {
      paddings: e,
      constantValue: n
    };
    return Lt.runKernelFunc(function (t) {
      return t.pad(r, e, n);
    }, {
      x: r
    }, function (t) {
      var n = e.map(function (t) {
        return t[0];
      });
      return {
        x: function () {
          return t.slice(n, r.shape);
        }
      };
    }, "PadV2", o);
  }
}),
    kr = An({
  pad1d_: function (t, e, n) {
    return void 0 === n && (n = 0), C(2 === e.length, function () {
      return "Invalid number of paddings. Must be length of 2.";
    }), Ir(t, [e], n);
  }
}),
    Sr = An({
  pad2d_: function (t, e, n) {
    return void 0 === n && (n = 0), C(2 === e.length && 2 === e[0].length && 2 === e[1].length, function () {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), Ir(t, e, n);
  }
}),
    Ar = An({
  pad3d_: function (t, e, n) {
    return void 0 === n && (n = 0), C(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, function () {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), Ir(t, e, n);
  }
}),
    Dr = An({
  pad4d_: function (t, e, n) {
    return void 0 === n && (n = 0), C(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, function () {
      return "Invalid number of paddings. Must be length of 2 each.";
    }), Ir(t, e, n);
  }
}),
    Tr = An({
  rand_: function (t, e, n) {
    var r = k(t),
        o = null;
    if (null == n || "float32" === n) o = new Float32Array(r);else if ("int32" === n) o = new Int32Array(r);else {
      if ("bool" !== n) throw new Error("Unknown data type " + n);
      o = new Uint8Array(r);
    }

    for (var a = 0; a < r; a++) o[a] = e();

    return Lt.makeTensor(o, t, n);
  }
}),
    Nr = An({
  randomNormal_: function (t, e, n, r, o) {
    if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);

    for (var a = new lr(e, n, r, !1, o), i = dr(t, r), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();

    return i.toTensor();
  }
}),
    Fr = An({
  randomGamma_: function (t, e, n, r, o) {
    if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), null == n && (n = 1), null == r && (r = "float32"), "float32" !== r && "int32" !== r) throw new Error("Unsupported data type " + r);

    for (var a = new hr(e, n, r, o), i = dr(t, r), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();

    return i.toTensor();
  }
}),
    _r = An({
  randomUniform_: function (t, e, n, r, o) {
    void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = "float32");

    for (var a = dr(t, r), i = new fr(e, n, null, o), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue();

    return a.toTensor();
  }
}),
    Or = An({
  reshape_: function (t, e) {
    var n = mn(t, "x", "reshape", null);
    e = _(e, n.size), C(n.size === k(e), function () {
      return "new shape and old shape must have the same number of elements.";
    });
    var r = {
      shape: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.reshape(n, e);
    }, {
      x: n
    }, function (t) {
      return {
        x: function () {
          return t.reshape(n.shape);
        }
      };
    }, "Reshape", r);
  }
}),
    Mr = An({
  spaceToBatchND_: function (t, e, n) {
    var r = mn(t, "x", "spaceToBatchND");
    return C(r.rank >= 1 + e.length, function () {
      return "input rank " + r.rank + " should be > than [blockShape] " + e.length;
    }), C(n.length === e.length, function () {
      return "paddings.shape[0] " + n.length + " must be equal to [blockShape] " + e.length;
    }), C(r.shape.reduce(function (t, r, o) {
      return o > 0 && o <= e.length ? t && (r + n[o - 1][0] + n[o - 1][1]) % e[o - 1] == 0 : t;
    }, !0), function () {
      return "input spatial dimensions " + r.shape.slice(1) + " with paddings " + n.toString() + " must be divisible by blockShapes " + e.toString();
    }), Lt.runKernelFunc(function (t) {
      return t.spaceToBatchND(r, e, n);
    }, {
      $x: r
    }, function (t) {
      return {
        $x: function () {
          return t.batchToSpaceND(e, n);
        }
      };
    });
  }
}),
    Br = An({
  squeeze_: function (t, e) {
    var n = mn(t, "x", "squeeze");
    return Or(n, M(n.shape, e).newShape);
  }
}),
    Pr = An({
  stack_: function (t, e) {
    void 0 === e && (e = 0);
    var n = gn(t, "tensors", "stack");
    if (C(n.length >= 1, function () {
      return "Pass at least one tensor to tf.stack";
    }), 1 === n.length) return n[0].expandDims(e);
    var r = n[0].rank,
        o = n[0].shape,
        a = n[0].dtype;
    C(e <= r, function () {
      return "Axis must be <= rank of the tensor";
    }), n.forEach(function (t) {
      E(o, t.shape, "All tensors passed to stack must have matching shapes");
    }), n.forEach(function (t) {
      C(a === t.dtype, function () {
        return "All tensors passed to stack must have matching dtypes";
      });
    });
    var i = n.map(function (t) {
      return t.expandDims(e);
    });
    return Yn(i, e);
  }
}),
    Lr = An({
  tile_: function (t, e) {
    var n = mn(t, "x", "tile", null);
    C(n.rank === e.length, function () {
      return "Error in transpose: rank of input " + n.rank + " must match length of reps " + e + ".";
    });
    var r = [n],
        o = {
      reps: e
    };
    return Lt.runKernelFunc(function (t, r) {
      var o = t.tile(n, e);
      return r([n]), o;
    }, {
      x: n
    }, function (t, n) {
      var r = n[0];
      return {
        x: function () {
          var n = Xn(r);
          if (1 === r.rank) for (var o = 0; o < e[0]; ++o) n = n.add(t.slice([o * r.shape[0]], [r.shape[0]]));else if (2 === r.rank) for (o = 0; o < e[0]; ++o) for (var a = 0; a < e[1]; ++a) n = n.add(t.slice([o * r.shape[0], a * r.shape[1]], [r.shape[0], r.shape[1]]));else if (3 === r.rank) for (o = 0; o < e[0]; ++o) for (a = 0; a < e[1]; ++a) for (var i = 0; i < e[2]; ++i) n = n.add(t.slice([o * r.shape[0], a * r.shape[1], i * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));else {
            if (4 !== r.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r.rank + " tensors yet.");

            for (o = 0; o < e[0]; ++o) for (a = 0; a < e[1]; ++a) for (i = 0; i < e[2]; ++i) for (var s = 0; s < e[3]; ++s) n = n.add(t.slice([o * r.shape[0], a * r.shape[1], i * r.shape[2], s * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]));
          }
          return n;
        }
      };
    }, "Tile", o, r);
  }
}),
    Wr = An({
  truncatedNormal_: function (t, e, n, r, o) {
    if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);

    for (var a = new lr(e, n, r, !0, o), i = dr(t, r), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();

    return i.toTensor();
  }
}),
    Ur = An({
  unstack_: function (t, e) {
    void 0 === e && (e = 0), e = e || 0;
    var n = mn(t, "x", "unstack");
    C(e >= -n.shape.length && e < n.shape.length, function () {
      return "Axis = " + e + " is not in [-" + n.shape.length + ", " + n.shape.length + ")";
    }), e < 0 && (e += n.shape.length);
    var r = {
      axis: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.unstack(n, e);
    }, {
      x: n
    }, function (t) {
      return {
        x: function () {
          return Pr(t, e);
        }
      };
    }, "Unpack", r);
  }
}),
    Vr = function (t, e) {
  return n(this, void 0, void 0, function () {
    var n, o, a, i, s, u, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = mn(t, "x", "setdiff1d"), o = mn(e, "y", "setdiff1d"), C(n.dtype === o.dtype, function () {
            return "x and y should have the same dtype, but got x (" + n.dtype + ") and y (" + o.dtype + ").";
          }), C(1 === n.rank, function () {
            return "x should be 1D tensor, but got x (" + n.shape + ").";
          }), C(1 === o.rank, function () {
            return "y should be 1D tensor, but got y (" + o.shape + ").";
          }), [4, n.data()];

        case 1:
          return a = r.sent(), [4, o.data()];

        case 2:
          for (i = r.sent(), s = new Set(i), u = 0, h = 0; h < a.length; h++) s.has(a[h]) || u++;

          for (c = new gt([u], n.dtype), l = new gt([u], "int32"), h = 0, f = 0; h < a.length; h++) s.has(a[h]) || (c.values[f] = a[h], l.values[f] = h, f++);

          return [2, [c.toTensor(), l.toTensor()]];
      }
    });
  });
};

exports.setdiff1dAsync = Vr;
exports.unstack = Ur;
exports.truncatedNormal = Wr;
exports.tile = Lr;
exports.stack = Pr;
exports.squeeze = Br;
exports.spaceToBatchND = Mr;
exports.reshape = Or;
exports.randomUniform = _r;
exports.randomGamma = Fr;
exports.randomNormal = Nr;
exports.rand = Tr;
exports.pad4d = Dr;
exports.pad3d = Ar;
exports.pad2d = Sr;
exports.pad1d = kr;
exports.pad = Ir;
exports.oneHot = Rr;
exports.multinomial = Er;
exports.eye = Cr;
exports.expandDims = wr;
exports.depthToSpace = br;
exports.cumsum = xr;
exports.clone = yr;
exports.cast = gr;
exports.broadcastTo = mr;
exports.batchToSpaceND = vr;

function zr(t, e, n, r) {
  void 0 === r && (r = !0);
  var o = [];
  if (r) (o = o.concat(e.slice(0))).push(t[0] / n), o = o.concat(t.slice(1));else {
    o = o.concat(t[0]);

    for (var a = e.length, i = 0; i < a; ++i) o = o.concat([t[i + 1] / e[i], e[i]]);

    o = o.concat(t.slice(a + 1));
  }
  return o;
}

function Gr(t, e, n) {
  void 0 === n && (n = !0);
  var r = [];

  if (n) {
    r.push(e);

    for (var o = e + 1; o < t; ++o) o <= 2 * e ? (r.push(o), r.push(o - (e + 1))) : r.push(o);
  } else {
    var a = [],
        i = [];

    for (o = 1; o < t; ++o) o >= 2 * e + 1 || o % 2 == 1 ? i.push(o) : a.push(o);

    r.push.apply(r, a), r.push(0), r.push.apply(r, i);
  }

  return r;
}

function Hr(t, e, n, r) {
  void 0 === r && (r = !0);
  var o = [];
  r ? o.push(t[0] / n) : o.push(t[0] * n);

  for (var a = 1; a < t.length; ++a) a <= e.length ? r ? o.push(e[a - 1] * t[a]) : o.push(t[a] / e[a - 1]) : o.push(t[a]);

  return o;
}

function qr(t, e) {
  for (var n = [0], r = 0; r < e; ++r) n.push(t[r][0]);

  return n;
}

function Kr(t, e, n) {
  for (var r = t.slice(0, 1), o = 0; o < n; ++o) r.push(t[o + 1] - e[o][0] - e[o][1]);

  return r;
}

function jr(t, e) {
  if (t.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t.rank + ".");
  if (e.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
  if ("int32" !== e.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e.dtype + ".");
  if (e.shape[e.rank - 1] > t.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e.shape[e.rank - 1] + " vs. " + t.rank);
  if (0 === t.size) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t.shape + ".");

  for (var n = e.shape, r = n[n.length - 1], o = 1, a = 0; a < n.length - 1; ++a) o *= n[a];

  var i = t.shape,
      s = n.slice();
  s.pop();
  var u = 1;

  for (a = r; a < t.rank; ++a) u *= i[a], s.push(i[a]);

  var c = $(t.shape).map(function (t) {
    return t / u;
  }).concat([1]).slice(0, r);
  return [s, o, u, c];
}

var Xr = Object.freeze({
  prepareAndValidate: jr
}),
    Yr = 30;
exports.gather_util = Xr;

function $r(t) {
  return t <= Yr ? t : Y(t, Math.floor(Math.sqrt(t)));
}

function Qr(t, e, n) {
  var r = e.rank > 1 ? e.shape[e.rank - 1] : 1,
      o = e.rank > 1 ? e.rank - 1 : 1,
      a = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n.shape + ", indices.shape: " + e.shape + ", shape: " + t + ", sliceDim: " + r + ", and batchDim: " + o + ".";
  if (n.rank < o) throw new Error(a + " update.rank < " + o + ". ");
  if (t.length < r + (n.rank - o)) throw new Error(a + " Output shape length < " + (r + (n.rank - o)));
  if (n.rank !== o + t.length - r) throw new Error(a + " update.rank != " + (o + t.length - r));

  for (var i = 0; i < o; ++i) if (n.shape[i] !== e.shape[i]) throw new Error(a + " updates.shape[" + i + "] (" + n.shape[i] + ") != indices.shape[" + i + "] (" + e.shape[i] + ").");

  for (i = 0; i < n.rank - o; ++i) if (n.shape[i + o] !== t[i + r]) throw new Error(a + " updates.shape[" + (i + o) + "] (" + n.shape[i + o] + ") != shape[" + (i + o) + "] (" + t[i + o] + ")");
}

function Jr(t, e, n) {
  if (e.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
  if (t.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t.rank + ".");
  if ("int32" !== e.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e.dtype);
  if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n);

  if (0 === n.length) {
    if (0 === e.size) throw new Error("Indices specified for empty output. indices shape: " + e.shape);
    if (0 === t.size) throw new Error("Updates specified for empty output. updates shape: " + t.shape);
  }

  Qr(n, e, t);
}

function Zr(t, e, n) {
  for (var r = e.shape.length, o = r > 1 ? e.shape[r - 1] : 1, a = n.length, i = 1, s = o; s < a; ++s) i *= n[s];

  var u = o < 1 ? 1 : o;
  return {
    sliceRank: o,
    numUpdates: k(e.shape) / u,
    sliceSize: i,
    strides: $(n.slice(0, o)).concat([1]),
    outputSize: k(n)
  };
}

var to = Object.freeze({
  validateUpdateShape: Qr,
  validateInput: Jr,
  calculateShapes: Zr
});
exports.scatter_util = to;

function eo(t, e, n) {
  C(t.rank === e.length, function () {
    return "Error in slice" + t.rank + "D: Length of begin " + e + " must match the rank of the array (" + t.rank + ").";
  }), C(t.rank === n.length, function () {
    return "Error in slice" + t.rank + "D: Length of size " + n + " must match the rank of the array (" + t.rank + ").";
  });

  for (var r = function (r) {
    C(e[r] + n[r] <= t.shape[r], function () {
      return "Error in slice" + t.rank + "D: begin[" + r + "] + size[" + r + "] (" + (e[r] + n[r]) + ") would overflow input.shape[" + r + "] (" + t.shape[r] + ")";
    });
  }, o = 0; o < t.rank; ++o) r(o);
}

function no(t) {
  for (var e = [], n = 0; t > 0;) 1 & t && e.push(n), t /= 2, n++;

  return e;
}

function ro(t, e, n) {
  for (var r = [], o = 0; o < t.length; o++) r[o] = Math.ceil((e[o] - t[o]) / n[o]);

  return r;
}

function oo(t, e, n, r, o) {
  var a = e[o],
      i = n[o] || 1;
  (t & 1 << o || null == a) && (a = i > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var s = r[o];
  return a < 0 && (a += s), a = x(0, a, s - 1);
}

function ao(t, e, n, r, o) {
  var a = e[o],
      i = n[o] || 1;
  (t & 1 << o || null == a) && (a = i > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var s = r[o];
  return a < 0 && (a += s), a = i > 0 ? x(0, a, s) : x(-1, a, s - 1);
}

function io(t, e, n) {
  for (var r = n.length, o = 0; o < n.length; o++) if (n[o] > 1) {
    r = o;
    break;
  }

  for (o = r + 1; o < n.length; o++) if (e[o] > 0 || n[o] !== t[o]) return !1;

  return !0;
}

function so(t, e) {
  for (var n = t.length > 0 ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++) n += t[r] * e[r];

  return n;
}

var uo = Object.freeze({
  assertParamsValid: eo,
  maskToAxes: no,
  computeOutShape: ro,
  startForAxis: oo,
  stopForAxis: ao,
  isSliceContinous: io,
  computeFlatOffset: so
});
exports.slice_util = uo;

function co(t) {
  return C(X(t), function () {
    return "The f passed in grad(f) must be a function";
  }), function (e, n) {
    var r = mn(e, "x", "tf.grad", null),
        o = null != n ? mn(n, "dy", "tf.grad") : null;
    return Lt.tidy(function () {
      var e = Lt.gradients(function () {
        return t(r);
      }, [r], o),
          n = e.value,
          a = e.grads;
      return null != o && E(n.shape, o.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), mo(a), a[0];
    });
  };
}

function lo(t) {
  return C(X(t), function () {
    return "The f passed in grads(f) must be a function";
  }), function (e, n) {
    C(Array.isArray(e), function () {
      return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
    });
    var r = gn(e, "args", "tf.grads", null),
        o = null != n ? mn(n, "dy", "tf.grads") : null;
    return Lt.tidy(function () {
      var e = Lt.gradients(function () {
        return t.apply(void 0, r);
      }, r, o),
          n = e.value,
          a = e.grads;
      return null != o && E(n.shape, o.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), mo(a), a;
    });
  };
}

function ho(t) {
  return C(X(t), function () {
    return "The f passed in valueAndGrad(f) must be a function";
  }), function (e, n) {
    C(e instanceof wt, function () {
      return "The x passed in valueAndGrad(f)(x) must be a tensor";
    }), C(null == n || n instanceof wt, function () {
      return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
    });
    var r = Lt.gradients(function () {
      return t(e);
    }, [e], n),
        o = r.grads,
        a = r.value;
    return mo(o), {
      grad: o[0],
      value: a
    };
  };
}

function fo(t) {
  return C(X(t), function () {
    return "The f passed in valueAndGrads(f) must be a function";
  }), function (e, n) {
    C(Array.isArray(e) && e.every(function (t) {
      return t instanceof wt;
    }), function () {
      return "The args passed in valueAndGrads(f)(args) must be array of tensors";
    }), C(null == n || n instanceof wt, function () {
      return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
    });
    var r = Lt.gradients(function () {
      return t.apply(void 0, e);
    }, e, n);
    return null != n && E(r.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), mo(r.grads), r;
  };
}

function po(t, e) {
  C(X(t), function () {
    return "The f passed in variableGrads(f) must be a function";
  }), C(null == e || Array.isArray(e) && e.every(function (t) {
    return t instanceof St;
  }), function () {
    return "The varList passed in variableGrads(f, varList) must be an array of variables";
  });
  var n = null != e;
  if (!n) for (var r in e = [], Lt.registeredVariables) e.push(Lt.registeredVariables[r]);
  var o = n ? e.filter(function (t) {
    return !t.trainable;
  }) : null,
      a = e.length;
  C((e = e.filter(function (t) {
    return t.trainable;
  })).length > 0, function () {
    return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + a + " variables is trainable.";
  });
  var i = Lt.gradients(t, e, null, !0),
      s = i.value,
      u = i.grads;
  C(u.some(function (t) {
    return null != t;
  }), function () {
    return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
  }), C(0 === s.rank, function () {
    return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s.rank + " tensor";
  });
  var c = {};
  return e.forEach(function (t, e) {
    null != u[e] && (c[t.name] = u[e]);
  }), null != o && o.forEach(function (t) {
    return c[t.name] = null;
  }), {
    value: s,
    grads: c
  };
}

function vo(t) {
  return Lt.customGrad(t);
}

function mo(t) {
  if (t.filter(function (t) {
    return null == t;
  }).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
}

var go = An({
  softmax_: function (t, e) {
    void 0 === e && (e = -1);
    var n = mn(t, "logits", "softmax", "float32");
    if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and dim was " + e);
    return Lt.runKernelFunc(function (t, r) {
      var o = t.softmax(n, e);
      return r([o]), o;
    }, {
      logits: n
    }, function (t, n) {
      var r = n[0],
          o = t.mul(r);
      return {
        logits: function () {
          return o.sub(o.sum([e], !0).mul(r));
        }
      };
    }, "Softmax", {
      dim: e
    }, [], [!0]);
  }
}),
    yo = An({
  logSoftmax_: function (t, e) {
    void 0 === e && (e = -1);
    var n = mn(t, "logits", "logSoftmax");
    if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and axis was " + e);
    return vo(function (t, n) {
      var r = t.max(e, !0),
          o = t.sub(r),
          a = o.toFloat().sub(o.exp().sum(e, !0).log());
      n([a]);
      return {
        value: a,
        gradFunc: function (t, n) {
          var r = n[0].exp();
          return t.sub(t.sum(e, !0).mul(r));
        }
      };
    })(n);
  }
}),
    xo = function () {
  function t(t, e) {
    this.backend = t, this.dataMover = e, this.data = new WeakMap(), this.dataIdsCount = 0;
  }

  return t.prototype.get = function (t) {
    return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t);
  }, t.prototype.set = function (t, e) {
    this.dataIdsCount++, this.data.set(t, e);
  }, t.prototype.has = function (t) {
    return this.data.has(t);
  }, t.prototype.delete = function (t) {
    return this.dataIdsCount--, this.data.delete(t);
  }, t.prototype.numDataIds = function () {
    return this.dataIdsCount;
  }, t;
}(),
    bo = function () {
  function t() {}

  return t.prototype.time = function (t) {
    return wo("time");
  }, t.prototype.read = function (t) {
    return wo("read");
  }, t.prototype.readSync = function (t) {
    return wo("readSync");
  }, t.prototype.numDataIds = function () {
    return wo("numDataIds");
  }, t.prototype.disposeData = function (t) {
    return wo("disposeData");
  }, t.prototype.write = function (t, e, n) {
    return wo("write");
  }, t.prototype.move = function (t, e, n, r) {
    return wo("move");
  }, t.prototype.memory = function () {
    return wo("memory");
  }, t.prototype.floatPrecision = function () {
    return wo("floatPrecision");
  }, t.prototype.epsilon = function () {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, t.prototype.batchMatMul = function (t, e, n, r) {
    return wo("batchMatMul");
  }, t.prototype.fusedBatchMatMul = function (t) {
    t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights;
    return wo("fusedBatchMatMul");
  }, t.prototype.slice = function (t, e, n) {
    return wo("slice");
  }, t.prototype.stridedSlice = function (t, e, n, r) {
    return wo("stridedSlice");
  }, t.prototype.unstack = function (t, e) {
    return wo("unstack");
  }, t.prototype.reverse = function (t, e) {
    return wo("reverse");
  }, t.prototype.concat = function (t, e) {
    return wo("concat");
  }, t.prototype.neg = function (t) {
    return wo("neg");
  }, t.prototype.add = function (t, e) {
    return wo("add");
  }, t.prototype.addN = function (t) {
    return wo("addN");
  }, t.prototype.subtract = function (t, e) {
    return wo("subtract");
  }, t.prototype.multiply = function (t, e) {
    return wo("multiply");
  }, t.prototype.realDivide = function (t, e) {
    return wo("realDivide");
  }, t.prototype.floorDiv = function (t, e) {
    return wo("floorDiv");
  }, t.prototype.sum = function (t, e) {
    return wo("sum");
  }, t.prototype.prod = function (t, e) {
    return wo("prod");
  }, t.prototype.unsortedSegmentSum = function (t, e, n) {
    return wo("unsortedSegmentSum");
  }, t.prototype.argMin = function (t, e) {
    return wo("argMin");
  }, t.prototype.argMax = function (t, e) {
    return wo("argMax");
  }, t.prototype.equal = function (t, e) {
    return wo("equal");
  }, t.prototype.notEqual = function (t, e) {
    return wo("notEqual");
  }, t.prototype.less = function (t, e) {
    return wo("less");
  }, t.prototype.lessEqual = function (t, e) {
    return wo("lessEqual");
  }, t.prototype.greater = function (t, e) {
    return wo("greater");
  }, t.prototype.greaterEqual = function (t, e) {
    return wo("greaterEqual");
  }, t.prototype.logicalNot = function (t) {
    return wo("logicalNot");
  }, t.prototype.logicalAnd = function (t, e) {
    return wo("logicalAnd");
  }, t.prototype.logicalOr = function (t, e) {
    return wo("logicalOr");
  }, t.prototype.where = function (t) {
    return wo("where");
  }, t.prototype.select = function (t, e, n) {
    return wo("select");
  }, t.prototype.topk = function (t, e, n) {
    return wo("topk");
  }, t.prototype.min = function (t, e) {
    return wo("min");
  }, t.prototype.minimum = function (t, e) {
    return wo("minimum");
  }, t.prototype.mod = function (t, e) {
    return wo("mod");
  }, t.prototype.max = function (t, e) {
    return wo("max");
  }, t.prototype.maximum = function (t, e) {
    return wo("maximum");
  }, t.prototype.all = function (t, e) {
    return wo("all");
  }, t.prototype.any = function (t, e) {
    return wo("any");
  }, t.prototype.squaredDifference = function (t, e) {
    return wo("squaredDifference");
  }, t.prototype.ceil = function (t) {
    return wo("ceil");
  }, t.prototype.floor = function (t) {
    return wo("floor");
  }, t.prototype.round = function (t) {
    return wo("round");
  }, t.prototype.sign = function (t) {
    return wo("sign");
  }, t.prototype.isNaN = function (t) {
    return wo("isNaN");
  }, t.prototype.isInf = function (t) {
    return wo("isInf");
  }, t.prototype.isFinite = function (t) {
    return wo("isFinite");
  }, t.prototype.pow = function (t, e) {
    return wo("pow");
  }, t.prototype.exp = function (t) {
    return wo("exp");
  }, t.prototype.expm1 = function (t) {
    return wo("expm1");
  }, t.prototype.softmax = function (t, e) {
    return wo("softmax");
  }, t.prototype.log = function (t) {
    return wo("log");
  }, t.prototype.log1p = function (t) {
    return wo("log1p");
  }, t.prototype.sqrt = function (t) {
    return wo("sqrt");
  }, t.prototype.rsqrt = function (t) {
    return wo("rsqrt");
  }, t.prototype.square = function (t) {
    return wo("square");
  }, t.prototype.reciprocal = function (t) {
    return wo("reciprocal");
  }, t.prototype.relu = function (t) {
    return wo("relu");
  }, t.prototype.relu6 = function (t) {
    return wo("relu6");
  }, t.prototype.prelu = function (t, e) {
    return wo("prelu");
  }, t.prototype.elu = function (t) {
    return wo("elu");
  }, t.prototype.eluDer = function (t, e) {
    return wo("eluDer");
  }, t.prototype.selu = function (t) {
    return wo("selu");
  }, t.prototype.int = function (t) {
    return wo("int");
  }, t.prototype.clip = function (t, e, n) {
    return wo("clip");
  }, t.prototype.abs = function (t) {
    return wo("abs");
  }, t.prototype.complexAbs = function (t) {
    return wo("complexAbs");
  }, t.prototype.sigmoid = function (t) {
    return wo("sigmoid");
  }, t.prototype.softplus = function (t) {
    return wo("softplus");
  }, t.prototype.sin = function (t) {
    return wo("sin");
  }, t.prototype.cos = function (t) {
    return wo("cos");
  }, t.prototype.tan = function (t) {
    return wo("tan");
  }, t.prototype.asin = function (t) {
    return wo("asin");
  }, t.prototype.acos = function (t) {
    return wo("acos");
  }, t.prototype.atan = function (t) {
    return wo("atan");
  }, t.prototype.atan2 = function (t, e) {
    return wo("atan2");
  }, t.prototype.sinh = function (t) {
    return wo("sinh");
  }, t.prototype.cosh = function (t) {
    return wo("cosh");
  }, t.prototype.tanh = function (t) {
    return wo("tanh");
  }, t.prototype.asinh = function (t) {
    return wo("asinh");
  }, t.prototype.acosh = function (t) {
    return wo("acosh");
  }, t.prototype.atanh = function (t) {
    return wo("atanh");
  }, t.prototype.erf = function (t) {
    return wo("erf");
  }, t.prototype.step = function (t, e) {
    return wo("step");
  }, t.prototype.fusedConv2d = function (t) {
    t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;
    return wo("fusedConv2d");
  }, t.prototype.conv2d = function (t, e, n) {
    return wo("conv2d");
  }, t.prototype.conv2dDerInput = function (t, e, n) {
    return wo("conv2dDerInput");
  }, t.prototype.conv2dDerFilter = function (t, e, n) {
    return wo("conv2dDerFilter");
  }, t.prototype.fusedDepthwiseConv2D = function (t) {
    t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;
    return wo("fusedDepthwiseConv2D");
  }, t.prototype.depthwiseConv2D = function (t, e, n) {
    return wo("depthwiseConv2D");
  }, t.prototype.depthwiseConv2DDerInput = function (t, e, n) {
    return wo("depthwiseConv2DDerInput");
  }, t.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
    return wo("depthwiseConv2DDerFilter");
  }, t.prototype.conv3d = function (t, e, n) {
    return wo("conv3d");
  }, t.prototype.conv3dDerInput = function (t, e, n) {
    return wo("conv3dDerInput");
  }, t.prototype.conv3dDerFilter = function (t, e, n) {
    return wo("conv3dDerFilter");
  }, t.prototype.maxPool = function (t, e) {
    return wo("maxPool");
  }, t.prototype.maxPoolBackprop = function (t, e, n, r) {
    return wo("maxPoolBackprop");
  }, t.prototype.avgPool = function (t, e) {
    return wo("avgPool");
  }, t.prototype.avgPoolBackprop = function (t, e, n) {
    return wo("avgPoolBackprop");
  }, t.prototype.avgPool3d = function (t, e) {
    return wo("avgPool3d");
  }, t.prototype.avgPool3dBackprop = function (t, e, n) {
    return wo("avgPool3dBackprop");
  }, t.prototype.maxPool3d = function (t, e) {
    return wo("maxPool3d");
  }, t.prototype.maxPool3dBackprop = function (t, e, n, r) {
    return wo("maxPool3dBackprop");
  }, t.prototype.reshape = function (t, e) {
    return wo("reshape");
  }, t.prototype.cast = function (t, e) {
    return wo("cast");
  }, t.prototype.tile = function (t, e) {
    return wo("tile");
  }, t.prototype.pad = function (t, e, n) {
    return wo("pad");
  }, t.prototype.transpose = function (t, e) {
    return wo("transpose");
  }, t.prototype.gather = function (t, e, n) {
    return wo("gather");
  }, t.prototype.gatherND = function (t, e) {
    return wo("gatherND");
  }, t.prototype.scatterND = function (t, e, n) {
    return wo("scatterND");
  }, t.prototype.batchToSpaceND = function (t, e, n) {
    return wo("batchToSpaceND");
  }, t.prototype.spaceToBatchND = function (t, e, n) {
    return wo("spaceToBatchND");
  }, t.prototype.resizeBilinear = function (t, e, n, r) {
    return wo("resizeBilinear");
  }, t.prototype.resizeBilinearBackprop = function (t, e, n) {
    return wo("resizeBilinearBackprop");
  }, t.prototype.resizeNearestNeighbor = function (t, e, n, r) {
    return wo("resizeNearestNeighbor");
  }, t.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
    return wo("resizeNearestNeighborBackprop");
  }, t.prototype.batchNormalization = function (t, e, n, r, o, a) {
    return wo("batchNormalization");
  }, t.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
    return wo("localResponseNormalization4D");
  }, t.prototype.LRNGrad = function (t, e, n, r, o, a, i) {
    return wo("LRNGrad");
  }, t.prototype.multinomial = function (t, e, n, r) {
    return wo("multinomial");
  }, t.prototype.oneHot = function (t, e, n, r) {
    return wo("oneHot");
  }, t.prototype.cumsum = function (t, e, n, r) {
    return wo("cumsum");
  }, t.prototype.nonMaxSuppression = function (t, e, n, r, o) {
    return wo("nonMaxSuppression");
  }, t.prototype.fft = function (t) {
    return wo("fft");
  }, t.prototype.ifft = function (t) {
    return wo("ifft");
  }, t.prototype.complex = function (t, e) {
    return wo("complex");
  }, t.prototype.real = function (t) {
    return wo("real");
  }, t.prototype.imag = function (t) {
    return wo("imag");
  }, t.prototype.cropAndResize = function (t, e, n, r, o, a) {
    return wo("cropAndResize");
  }, t.prototype.depthToSpace = function (t, e, n) {
    return wo("depthToSpace");
  }, t.prototype.split = function (t, e, n) {
    return wo("split");
  }, t.prototype.sparseToDense = function (t, e, n, r) {
    return wo("sparseToDense");
  }, t.prototype.diag = function (t) {
    return wo("diag");
  }, t.prototype.fill = function (t, e, n) {
    return wo("fill");
  }, t.prototype.onesLike = function (t) {
    return wo("onesLike");
  }, t.prototype.zerosLike = function (t) {
    return wo("zerosLike");
  }, t.prototype.linspace = function (t, e, n) {
    return wo("linspace");
  }, t.prototype.dispose = function () {
    return wo("dispose");
  }, t;
}();

exports.KernelBackend = bo;
exports.DataStorage = xo;
exports.logSoftmax = yo;
exports.softmax = go;

function wo(t) {
  throw new Error("'" + t + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}

function Co(t, e) {
  for (var n = t.length, r = [], o = 0; o < n; o++) {
    var a = n - 1 - o,
        i = t[a] || 1;
    (e[e.length - 1 - o] || 1) > 1 && 1 === i && r.unshift(a);
  }

  return r;
}

function Eo(t, e) {
  for (var n = [], r = 0; r < e.length; r++) {
    var o = t[t.length - r - 1],
        a = e.length - r - 1,
        i = e[a];
    (null == o || 1 === o && i > 1) && n.unshift(a);
  }

  return n;
}

function Ro(t, e) {
  for (var n = [], r = Math.max(t.length, e.length), o = 0; o < r; o++) {
    var a = t[t.length - o - 1];
    null == a && (a = 1);
    var i = e[e.length - o - 1];
    if (null == i && (i = 1), 1 === a) n.unshift(i);else if (1 === i) n.unshift(a);else {
      if (a !== i) throw Error("Operands could not be broadcast together with shapes " + t + " and " + e + ".");
      n.unshift(a);
    }
  }

  return n;
}

function Io(t, e, n, r, o, a, i) {
  void 0 === i && (i = "channelsLast");
  var s,
      u = To(e),
      c = u[0],
      l = u[1];
  if ("channelsLast" === i) s = [c, l, t[3], t[3]];else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat " + i);
    s = [c, l, t[1], t[1]];
  }
  return So(t, s, n, r, o, a, !1, i);
}

function ko(t, e, n, r, o, a, i) {
  void 0 === i && (i = "NDHWC");
  var s,
      u,
      c = No(e),
      l = c[0],
      h = c[1],
      f = c[2];
  if ("NDHWC" === i) u = "channelsLast", s = [l, h, f, t[4], t[4]];else {
    if ("NCDHW" !== i) throw new Error("Unknown dataFormat " + i);
    u = "channelsFirst", s = [l, h, f, t[1], t[1]];
  }
  return Ao(t, s, n, r, o, !1, u, a);
}

function So(t, e, n, r, o, a, i, s) {
  void 0 === i && (i = !1), void 0 === s && (s = "channelsLast");
  var u = [-1, -1, -1, -1],
      c = u[0],
      l = u[1],
      h = u[2],
      f = u[3];
  if ("channelsLast" === s) c = t[0], l = t[1], h = t[2], f = t[3];else {
    if ("channelsFirst" !== s) throw new Error("Unknown dataFormat " + s);
    c = t[0], f = t[1], l = t[2], h = t[3];
  }

  var d,
      p = e[0],
      v = e[1],
      m = e[3],
      g = To(n),
      y = g[0],
      x = g[1],
      b = To(r),
      w = b[0],
      E = b[1],
      R = Fo(p, w),
      I = Fo(v, E),
      k = function (t, e, n, r, o, a, i, s) {
    var u, c, l;

    if ("number" == typeof t) {
      u = {
        top: t,
        bottom: t,
        left: t,
        right: t,
        type: 0 === t ? "VALID" : "NUMBER"
      };

      var h = function (t, e, n, r, o) {
        null == r && (r = Do(t, e, n));

        var a = t[0],
            i = t[1],
            s = _o((a - e + 2 * r) / n + 1, o);

        C(A(s), function () {
          return "The output # of rows (" + s + ") must be an integer. Change the stride and/or zero pad parameters";
        });

        var u = _o((i - e + 2 * r) / n + 1, o);

        return C(A(u), function () {
          return "The output # of columns (" + u + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [s, u];
      }([e, n], a, r, t, s);

      c = h[0], l = h[1];
    } else if ("same" === t) {
      c = Math.ceil(e / r), l = Math.ceil(n / o);
      var f = Math.max(0, (c - 1) * r + a - e),
          d = Math.max(0, (l - 1) * o + i - n),
          p = Math.floor(f / 2),
          v = f - p,
          m = Math.floor(d / 2);
      u = {
        top: p,
        bottom: v,
        left: m,
        right: d - m,
        type: "SAME"
      };
    } else {
      if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
      u = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        type: "VALID"
      }, c = Math.ceil((e - a + 1) / r), l = Math.ceil((n - i + 1) / o);
    }

    return {
      padInfo: u,
      outHeight: c,
      outWidth: l
    };
  }(o, l, h, y, x, R, I, a),
      S = k.padInfo,
      D = k.outHeight,
      T = k.outWidth,
      N = i ? m * f : m;

  return "channelsFirst" === s ? d = [c, N, D, T] : "channelsLast" === s && (d = [c, D, T, N]), {
    batchSize: c,
    dataFormat: s,
    inHeight: l,
    inWidth: h,
    inChannels: f,
    outHeight: D,
    outWidth: T,
    outChannels: N,
    padInfo: S,
    strideHeight: y,
    strideWidth: x,
    filterHeight: p,
    filterWidth: v,
    effectiveFilterHeight: R,
    effectiveFilterWidth: I,
    dilationHeight: w,
    dilationWidth: E,
    inShape: t,
    outShape: d,
    filterShape: e
  };
}

function Ao(t, e, n, r, o, a, i, s) {
  void 0 === a && (a = !1), void 0 === i && (i = "channelsLast");
  var u = [-1, -1, -1, -1, -1],
      c = u[0],
      l = u[1],
      h = u[2],
      f = u[3],
      d = u[4];
  if ("channelsLast" === i) c = t[0], l = t[1], h = t[2], f = t[3], d = t[4];else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat " + i);
    c = t[0], d = t[1], l = t[2], h = t[3], f = t[4];
  }

  var p,
      v = e[0],
      m = e[1],
      g = e[2],
      y = e[4],
      x = No(n),
      b = x[0],
      w = x[1],
      E = x[2],
      R = No(r),
      I = R[0],
      k = R[1],
      S = R[2],
      D = Fo(v, I),
      T = Fo(m, k),
      N = Fo(g, S),
      F = function (t, e, n, r, o, a, i, s, u, c, l) {
    var h, f, d, p;

    if ("number" == typeof t) {
      h = {
        top: t,
        bottom: t,
        left: t,
        right: t,
        front: t,
        back: t,
        type: 0 === t ? "VALID" : "NUMBER"
      };

      var v = function (t, e, n, r, o, a) {
        null == o && (o = Do(t, e, r));

        var i = t[0],
            s = t[1],
            u = t[2],
            c = _o((i - e + 2 * o) / r + 1, a);

        C(A(c), function () {
          return "The output # of depths (" + c + ") must be an integer. Change the stride and/or zero pad parameters";
        });

        var l = _o((s - e + 2 * o) / r + 1, a);

        C(A(l), function () {
          return "The output # of rows (" + l + ") must be an integer. Change the stride and/or zero pad parameters";
        });

        var h = _o((u - e + 2 * o) / r + 1, a);

        return C(A(h), function () {
          return "The output # of columns (" + h + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [c, l, h, n];
      }([e, n, r, 1], s, 1, o, t, l);

      f = v[0], d = v[1], p = v[2];
    } else if ("same" === t) {
      f = Math.ceil(e / o), d = Math.ceil(n / a), p = Math.ceil(r / i);
      var m = (f - 1) * o + s - e,
          g = (d - 1) * a + u - n,
          y = (p - 1) * i + c - r,
          x = Math.floor(m / 2),
          b = m - x,
          w = Math.floor(g / 2),
          E = g - w,
          R = Math.floor(y / 2);
      h = {
        top: w,
        bottom: E,
        left: R,
        right: y - R,
        front: x,
        back: b,
        type: "SAME"
      };
    } else {
      if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
      h = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        front: 0,
        back: 0,
        type: "VALID"
      }, f = Math.ceil((e - s + 1) / o), d = Math.ceil((n - u + 1) / a), p = Math.ceil((r - c + 1) / i);
    }

    return {
      padInfo: h,
      outDepth: f,
      outHeight: d,
      outWidth: p
    };
  }(o, l, h, f, b, w, E, D, T, N, s),
      _ = F.padInfo,
      O = F.outDepth,
      M = F.outHeight,
      B = F.outWidth,
      P = a ? y * d : y;

  return "channelsFirst" === i ? p = [c, P, O, M, B] : "channelsLast" === i && (p = [c, O, M, B, P]), {
    batchSize: c,
    dataFormat: i,
    inDepth: l,
    inHeight: h,
    inWidth: f,
    inChannels: d,
    outDepth: O,
    outHeight: M,
    outWidth: B,
    outChannels: P,
    padInfo: _,
    strideDepth: b,
    strideHeight: w,
    strideWidth: E,
    filterDepth: v,
    filterHeight: m,
    filterWidth: g,
    effectiveFilterDepth: D,
    effectiveFilterHeight: T,
    effectiveFilterWidth: N,
    dilationDepth: I,
    dilationHeight: k,
    dilationWidth: S,
    inShape: t,
    outShape: p,
    filterShape: e
  };
}

function Do(t, e, n, r) {
  void 0 === r && (r = 1);
  var o = Fo(e, r);
  return Math.floor((t[0] * (n - 1) - n + o) / 2);
}

function To(t) {
  return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t;
}

function No(t) {
  return "number" == typeof t ? [t, t, t] : t;
}

function Fo(t, e) {
  return e <= 1 ? t : t + (t - 1) * (e - 1);
}

function _o(t, e) {
  if (!e) return t;

  switch (e) {
    case "round":
      return Math.round(t);

    case "ceil":
      return Math.ceil(t);

    case "floor":
      return Math.floor(t);

    default:
      throw new Error("Unknown roundingMode " + e);
  }
}

function Oo(t) {
  var e = To(t),
      n = e[0],
      r = e[1],
      o = e[2];
  return 1 === n && 1 === r && 1 === o;
}

function Mo(t, e) {
  return Oo(t) || Oo(e);
}

function Bo(t) {
  if ("NHWC" === t) return "channelsLast";
  if ("NCHW" === t) return "channelsFirst";
  throw new Error("Unknown dataFormat " + t);
}

function Po(t, e, n) {
  if ("complex64" === e) {
    if ("complex64" === t.dtype) return t.clone();
    var r = Gn(t.shape),
        o = t.toFloat(),
        a = n.complex(o, r);
    return r.dispose(), o.dispose(), a;
  }

  if (!U(t.dtype, e)) return Lt.makeTensorFromDataId(t.dataId, t.shape, e);

  if ("complex64" === t.dtype) {
    var i = n.real(t);
    a = i.cast(e);
    return i.dispose(), a;
  }

  if ("int32" === e) return n.int(t);

  if ("bool" === e) {
    var s = On(0, t.dtype);
    a = n.notEqual(t, s);
    return s.dispose(), a;
  }

  throw new Error("Error in Cast: failed to cast " + t.dtype + " to " + e);
}

function Lo(t, e) {
  return Lt.makeTensorFromDataId(t.dataId, e, t.dtype);
}

function Wo(t, e, n) {
  var r = (e - t) / (n - 1),
      o = tt(n, "float32");
  o[0] = t;

  for (var a = 1; a < o.length; a++) o[a] = o[a - 1] + r;

  return Mn(o, "float32");
}

var Uo = Object.freeze({
  castTensor: Po,
  reshapeTensor: Lo,
  linspaceImpl: Wo,
  upcastType: Dt,
  axesAreInnerMostDims: yn,
  combineLocations: xn,
  computeOutAndReduceShapes: bn,
  expandShapeToKeepDim: wn,
  assertAxesAreInnerMostDims: Cn,
  getAxesPermutation: En,
  getUndoAxesPermutation: Rn,
  getInnerMostAxes: In,
  getBroadcastDims: Co,
  getReductionAxes: Eo,
  assertAndGetBroadcastShape: Ro,
  assertParamsConsistent: kn,
  computeOutShape: Sn,
  computePool2DInfo: Io,
  computePool3DInfo: ko,
  computeConv2DInfo: So,
  computeConv3DInfo: Ao,
  computeDefaultPad: Do,
  tupleValuesAreOne: Oo,
  eitherStridesOrDilationsAreOne: Mo,
  convertConv2DDataFormat: Bo,
  PARALLELIZE_THRESHOLD: Yr,
  computeOptimalWindowSize: $r
});
exports.backend_util = Uo;

function Vo(t, e) {
  if (t.length !== e.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t.length + ", imag: " + e.length + ".");

  for (var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2) n[r] = t[r / 2], n[r + 1] = e[r / 2];

  return n;
}

function zo(t, e) {
  return {
    real: t[2 * e],
    imag: t[2 * e + 1]
  };
}

function Go(t, e, n, r) {
  t[2 * r] = e, t[2 * r + 1] = n;
}

function Ho(t, e, n) {
  var r = (n ? 2 : -2) * Math.PI * (t / e);
  return {
    real: Math.cos(r),
    imag: Math.sin(r)
  };
}

function qo(t, e, n) {
  var r = function (t, e, n) {
    return function (t, e, n) {
      var r = 0,
          o = t.length,
          a = 0,
          i = !1;

      for (; r < o;) {
        var s = n(e, t[a = r + (o - r >>> 1)]);
        s > 0 ? r = a + 1 : (o = a, i = !s);
      }

      return i ? r : -r - 1;
    }(t, e, n || Ko);
  }(t, e, n),
      o = r < 0 ? -(r + 1) : r;

  t.splice(o, 0, e);
}

function Ko(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}

function jo(t, e, n, r, o) {
  return Yo(t, e, n, r, o, 0).selectedIndices;
}

function Xo(t, e, n, r, o, a) {
  var i = Yo(t, e, n, r, o, a, !0);
  return i.numValidOutputs.dispose(), {
    selectedIndices: i.selectedIndices,
    selectedScores: i.selectedScores
  };
}

function Yo(t, e, n, r, o, a, i, s) {
  void 0 === i && (i = !1), void 0 === s && (s = !1);

  for (var u = Array.from(e).map(function (t, e) {
    return {
      score: t,
      boxIndex: e,
      suppressBeginIndex: 0
    };
  }).filter(function (t) {
    return t.score > o;
  }).sort(Jo), c = a > 0 ? -.5 / a : 0, l = [], h = []; l.length < n && u.length > 0;) {
    var f = u.pop(),
        d = f.score,
        p = f.boxIndex,
        v = f.suppressBeginIndex;
    if (d < o) break;

    for (var m = !1, g = l.length - 1; g >= v; --g) {
      var y = $o(t, p, l[g]);

      if (y >= r) {
        m = !0;
        break;
      }

      if (f.score = f.score * Qo(r, c, y), f.score <= o) break;
    }

    f.suppressBeginIndex = l.length, m || (f.score === d ? (l.push(p), h.push(f.score)) : f.score > o && qo(u, f, Jo));
  }

  var x = l.length;
  return s && (l.fill(0, x), h.fill(0, x)), {
    selectedIndices: Mn(l, "int32"),
    selectedScores: Mn(h, "float32"),
    numValidOutputs: On(x, "int32")
  };
}

function $o(t, e, n) {
  var r = t.subarray(4 * e, 4 * e + 4),
      o = t.subarray(4 * n, 4 * n + 4),
      a = Math.min(r[0], r[2]),
      i = Math.min(r[1], r[3]),
      s = Math.max(r[0], r[2]),
      u = Math.max(r[1], r[3]),
      c = Math.min(o[0], o[2]),
      l = Math.min(o[1], o[3]),
      h = Math.max(o[0], o[2]),
      f = Math.max(o[1], o[3]),
      d = (s - a) * (u - i),
      p = (h - c) * (f - l);
  if (d <= 0 || p <= 0) return 0;
  var v = Math.max(a, c),
      m = Math.max(i, l),
      g = Math.min(s, h),
      y = Math.min(u, f),
      x = Math.max(g - v, 0) * Math.max(y - m, 0);
  return x / (d + p - x);
}

function Qo(t, e, n) {
  var r = Math.exp(e * n * n);
  return n <= t ? r : 0;
}

function Jo(t, e) {
  return t.score - e.score || t.score === e.score && e.boxIndex - t.boxIndex;
}

function Zo(t, e, n) {
  var r = new Array(t.rank).fill(0),
      o = t.shape.slice();
  return e.map(function (e) {
    o[n] = e;
    var a = t.slice(r, o);
    return r[n] += e, a;
  });
}

function ta(t, e) {
  for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[r] * e[r];

  var o = dr(n, t.dtype);

  for (r = 0; r < o.values.length; ++r) {
    for (var a = o.indexToLoc(r), i = new Array(t.rank), s = 0; s < i.length; s++) i[s] = a[s] % t.shape[s];

    var u = t.locToIndex(i);
    o.values[r] = t.values[u];
  }

  return o.toTensor();
}

function ea(t, e, n, r, o) {
  for (var a = e[e.length - 1], i = [t.length / a, a], s = i[0], u = i[1], c = B(n, s * r), l = B("int32", s * r), h = 0; h < s; h++) {
    for (var f = h * u, d = t.subarray(f, f + u), p = [], v = 0; v < d.length; v++) p.push({
      value: d[v],
      index: v
    });

    p.sort(function (t, e) {
      return e.value - t.value;
    });
    var m = h * r,
        g = c.subarray(m, m + r),
        y = l.subarray(m, m + r);

    for (v = 0; v < r; v++) g[v] = p[v].value, y[v] = p[v].index;
  }

  var x = e.slice();
  return x[x.length - 1] = r, [Fn(c, x, n), Fn(l, x, "int32")];
}

function na(t, e) {
  for (var n = [], r = 0; r < e.length; r++) e[r] && n.push(r);

  var o = dr(t, "int32"),
      a = dr([n.length, t.length], "int32");

  for (r = 0; r < n.length; r++) {
    var i = o.indexToLoc(n[r]),
        s = r * t.length;
    a.values.set(i, s);
  }

  return a.toTensor();
}

var ra = function (t, e) {
  this.outputShape = [], this.outputShape = t, this.variableNames = e.map(function (t, e) {
    return "T" + e;
  });
  var n = [];
  this.variableNames.forEach(function (t) {
    n.push("float v" + t + " = get" + t + "AtOutCoords();");
  });
  var r = this.variableNames.map(function (t) {
    return "v" + t;
  }).join(" + ");
  this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        float result = " + r + ";\n        setOutput(result);\n      }\n    ";
},
    oa = function (t, e) {
  this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map(function (t, e) {
    return "T" + e;
  });
  var n = [];
  this.variableNames.forEach(function (t) {
    n.push("vec4 v" + t + " = get" + t + "AtOutCoords();");
  });
  var r = this.variableNames.map(function (t) {
    return "v" + t;
  }).join(" + ");
  this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        vec4 result = " + r + ";\n        setOutput(result);\n      }\n    ";
},
    aa = function (t, e, n) {
  this.variableNames = ["A"];
  var r = t.windowSize,
      o = t.batchSize,
      a = t.inSize,
      i = Math.ceil(a / r);
  n || this.variableNames.push("bestIndicesA"), this.outputShape = [o, i];
  var s = "max" === e ? ">" : "<",
      u = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
  this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r + "; i++) {\n          int inIdx = " + u + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + s + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
};

function ia(t, e) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, e).map(function (e) {
    return t + "." + e;
  });
}

function sa(t, e) {
  return 1 === e ? [t] : ia(t, e);
}

function ua() {
  var t, e, n, r, o, a, s, u, c, l;
  return 2 === i().getNumber("WEBGL_VERSION") ? (t = "#version 300 es", e = "in", n = "out", r = "in", o = "texture", a = "outputColor", s = "out vec4 outputColor;", u = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", c = "", l = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t = "", e = "attribute", n = "varying", r = "varying", o = "texture2D", a = "gl_FragColor", s = "", u = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", c = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
    version: t,
    attribute: e,
    varyingVs: n,
    varyingFs: r,
    texture2D: o,
    output: a,
    defineOutput: s,
    defineSpecialNaN: u,
    defineSpecialInf: c,
    defineRound: l
  };
}

function ca(t, e, n) {
  void 0 === n && (n = "index");
  var r = $(e);
  return r.map(function (e, o) {
    return "int " + t[o] + " = " + n + " / " + e + "; " + (o === r.length - 1 ? "int " + t[o + 1] + " = " + n + " - " + t[o] + " * " + e : "index -= " + t[o] + " * " + e) + ";";
  }).join("");
}

function la(t) {
  var e = $(t).map(function (t) {
    return t.toString();
  });
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e[0] + " + coords.y * " + e[1] + " + coords.z;\n  }\n";
}

var ha = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";

function fa(t, e, n, r) {
  var o = [];
  t.forEach(function (t) {
    var e = k(t.shapeInfo.logicalShape);
    t.shapeInfo.isUniform ? o.push("uniform float " + t.name + (e > 1 ? "[" + e + "]" : "") + ";") : (o.push("uniform sampler2D " + t.name + ";"), o.push("uniform int offset" + t.name + ";"));
  });

  var a,
      i,
      s = o.join("\n"),
      u = t.map(function (t) {
    return function (t, e, n) {
      void 0 === n && (n = !1);
      var r = "";
      r += n ? pa(t) : da(t);
      var o = t.shapeInfo.logicalShape,
          a = e.logicalShape;
      o.length <= a.length && (r += n ? function (t, e) {
        var n,
            r = t.name,
            o = r.charAt(0).toUpperCase() + r.slice(1),
            a = "get" + o + "AtOutCoords",
            i = t.shapeInfo.logicalShape.length,
            s = e.logicalShape.length,
            u = Co(t.shapeInfo.logicalShape, e.logicalShape),
            c = wa(s),
            l = s - i,
            h = ["x", "y", "z", "w", "u", "v"];
        n = 0 === i ? "" : s < 2 && u.length >= 1 ? "coords = 0;" : u.map(function (t) {
          return "coords." + h[t + l] + " = 0;";
        }).join("\n");
        var f = "";
        f = s < 2 && i > 0 ? "coords" : t.shapeInfo.logicalShape.map(function (t, e) {
          return "coords." + h[e + l];
        }).join(", ");
        var d = "return outputValue;",
            p = 1 === k(t.shapeInfo.logicalShape),
            v = 1 === k(e.logicalShape);

        if (1 !== i || p || v) {
          if (p && !v) d = 1 === s ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";else if (u.length) {
            var m = i - 2,
                g = i - 1;
            u.indexOf(m) > -1 && u.indexOf(g) > -1 ? d = "return vec4(outputValue.x);" : u.indexOf(m) > -1 ? d = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u.indexOf(g) > -1 && (d = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else d = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";

        return "\n    vec4 " + a + "() {\n      " + c + " coords = getOutputCoords();\n      " + n + "\n      vec4 outputValue = get" + o + "(" + f + ");\n      " + d + "\n    }\n  ";
      }(t, e) : function (t, e) {
        var n = t.name,
            r = n.charAt(0).toUpperCase() + n.slice(1),
            o = "get" + r + "AtOutCoords",
            a = e.texShape,
            i = t.shapeInfo.texShape,
            s = t.shapeInfo.logicalShape.length,
            u = e.logicalShape.length;
        if (!t.shapeInfo.isUniform && s === u && null == t.shapeInfo.flatOffset && S(i, a)) return "\n      float " + o + "() {\n        return sampleTexture(" + n + ", resultUV);\n      }\n    ";
        var c,
            l = wa(u),
            h = Co(t.shapeInfo.logicalShape, e.logicalShape),
            f = u - s,
            d = ["x", "y", "z", "w", "u", "v"];
        c = 0 === s ? "" : u < 2 && h.length >= 1 ? "coords = 0;" : h.map(function (t) {
          return "coords." + d[t + f] + " = 0;";
        }).join("\n");
        var p = "";
        p = u < 2 && s > 0 ? "coords" : t.shapeInfo.logicalShape.map(function (t, e) {
          return "coords." + d[e + f];
        }).join(", ");
        return "\n    float " + o + "() {\n      " + l + " coords = getOutputCoords();\n      " + c + "\n      return get" + r + "(" + p + ");\n    }\n  ";
      }(t, e));
      return r;
    }(t, e, r);
  }).join("\n"),
      c = e.texShape,
      l = ua(),
      h = function (t) {
    return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t.texture2D + "(textureSampler, uv).r;\n    }\n  ";
  }(l),
      f = function (t) {
    return t.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t.varyingFs + " vec2 resultUV;\n    " + t.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t.defineSpecialNaN + "\n    " + t.defineSpecialInf + "\n    " + t.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + va + "\n    " + ma + "\n    " + ga + "\n  ";
  }(l);

  return e.isPacked ? (a = function (t, e) {
    switch (t.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (t, e) {
          var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
          if (1 === n[0]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n[1] + ".0);\n      }\n    ";
          if (1 === n[1]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      return 2 * (resTexRC.x * " + n[1] + " + resTexRC.y);\n    }\n  ";
        }(0, e);

      case 2:
        return function (t, e) {
          var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
          if (S(t, e)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n[0] + ", " + n[1] + "));\n      }\n    ";
          var r = Math.ceil(t[1] / 2);
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
        }(t, e);

      case 3:
        return n = t, r = e, o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], a = Math.ceil(n[2] / 2), i = a * Math.ceil(n[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + o[0] + ", " + o[1] + "));\n      int index = resTexRC.x * " + o[1] + " + resTexRC.y;\n\n      int b = index / " + i + ";\n      index -= b * " + i + ";\n\n      int r = 2 * (index / " + a + ");\n      int c = imod(index, " + a + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";

      default:
        return function (t, e) {
          for (var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)], r = Math.ceil(t[t.length - 1] / 2), o = r * Math.ceil(t[t.length - 2] / 2), a = o, i = "", s = "b, r, c", u = 2; u < t.length - 1; u++) a *= t[t.length - u - 1], i = "\n      int b" + u + " = index / " + a + ";\n      index -= b" + u + " * " + a + ";\n    " + i, s = "b" + u + ", " + s;

          return "\n    ivec" + t.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n\n      " + i + "\n\n      int b = index / " + o + ";\n      index -= b * " + o + ";\n\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec" + t.length + "(" + s + ");\n    }\n  ";
        }(t, e);
    }

    var n, r, o, a, i;
  }(e.logicalShape, c), i = function (t) {
    return "\n    void setOutput(vec4 val) {\n      " + t.output + " = val;\n    }\n  ";
  }(l)) : (a = function (t, e) {
    switch (t.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (t, e) {
          if (1 === e[0]) return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e[1] + ".0);\n      }\n    ";
          if (1 === e[1]) return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      return resTexRC.x * " + e[1] + " + resTexRC.y;\n    }\n  ";
        }(0, e);

      case 2:
        return function (t, e) {
          if (S(t, e)) return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e[0] + ", " + e[1] + "));\n      }\n    ";
          if (1 === t[1]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
          if (1 === t[0]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      int r = index / " + t[1] + ";\n      int c = index - r * " + t[1] + ";\n      return ivec2(r, c);\n    }\n  ";
        }(t, e);

      case 3:
        return n = e, r = ca(["r", "c", "d"], t), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      " + r + "\n      return ivec3(r, c, d);\n    }\n  ";

      case 4:
        return function (t, e) {
          var n = ca(["r", "c", "d", "d2"], t);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      " + n + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
        }(t, e);

      case 5:
        return function (t, e) {
          var n = ca(["r", "c", "d", "d2", "d3"], t);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e[0] + ",\n                             " + e[1] + "));\n\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
        }(t, e);

      case 6:
        return function (t, e) {
          var n = ca(["r", "c", "d", "d2", "d3", "d4"], t);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
        }(t, e);

      default:
        throw new Error(t.length + "-D output sampling is not yet supported");
    }

    var n, r;
  }(e.logicalShape, c), i = function (t) {
    return "\n    void setOutput(float val) {\n      " + t.output + " = vec4(val, 0, 0, 0);\n    }\n  ";
  }(l)), r && (f += ya), [f, h, i, s, a, u, n].join("\n");
}

function da(t) {
  var e = t.shapeInfo.logicalShape;

  switch (e.length) {
    case 0:
      return function (t) {
        var e = t.name,
            n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
        if (t.shapeInfo.isUniform) return "float " + n + "() {return " + e + ";}";
        var r = t.shapeInfo.texShape,
            o = r[0],
            a = r[1];
        if (1 === o && 1 === a) return "\n      float " + n + "() {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
        var i = t.shapeInfo.texShape,
            s = i[0],
            u = i[1],
            c = xa(e);
        return "\n    float " + n + "() {\n      vec2 uv = uvFromFlat(" + s + ", " + u + ", " + c + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  ";
      }(t);

    case 1:
      return function (t) {
        var e = t.name,
            n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
        if (t.shapeInfo.isUniform) return "\n      float " + n + "(int index) {\n        " + ba(t) + "\n      }\n    ";
        var r = t.shapeInfo.texShape,
            o = r[0],
            a = r[1];
        if (1 === a && 1 === o) return "\n      float " + n + "(int index) {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
        var i = xa(e);
        if (1 === a) return "\n      float " + n + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + i + ") + 0.5) / " + o + ".0);\n        return sampleTexture(" + e + ", uv);\n      }\n    ";
        if (1 === o) return "\n      float " + n + "(int index) {\n        vec2 uv = vec2((float(index + " + i + ") + 0.5) / " + a + ".0, 0.5);\n        return sampleTexture(" + e + ", uv);\n      }\n    ";
        return "\n    float " + n + "(int index) {\n      vec2 uv = uvFromFlat(" + o + ", " + a + ", index + " + i + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  ";
      }(t);

    case 2:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = t.shapeInfo.texShape;

        if (null != o && S(e, o)) {
          var a = o[0],
              i = o[1];
          return "\n    float " + r + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        }

        var s = M(e),
            u = s.newShape,
            c = s.keptDims,
            l = u;

        if (l.length < e.length) {
          var h = Ca(t, l);
          return "\n      " + da(h) + "\n      float " + r + "(int row, int col) {\n        return " + r + "(" + Ea(["row", "col"], c) + ");\n      }\n    ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e[1] + ", 1)));\n        " + ba(t) + "\n      }\n    ";
        var f = o[0],
            d = o[1],
            p = xa(n);
        if (1 === d) return "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        if (1 === f) return "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + d + ".0, 0.5);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        return "\n  float " + r + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e[1] + " + col + " + p + ";\n    vec2 uv = uvFromFlat(" + f + ", " + d + ", index);\n    return sampleTexture(" + n + ", uv);\n  }\n";
      }(t);

    case 3:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = e[1] * e[2],
            a = e[2],
            i = M(e),
            s = i.newShape,
            u = i.keptDims,
            c = s;

        if (c.length < e.length) {
          var l = Ca(t, c);
          return "\n        " + da(l) + "\n        float " + r + "(int row, int col, int depth) {\n          return " + r + "(" + Ea(["row", "col", "depth"], u) + ");\n        }\n      ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + o + ", " + a + ", 1)));\n        " + ba(t) + "\n      }\n    ";
        var h = t.shapeInfo.texShape,
            f = h[0],
            d = h[1],
            p = t.shapeInfo.flatOffset;
        if (d === o && null == p) return "\n        float " + r + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + a + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + d + ".0, " + f + ".0);\n          return sampleTexture(" + n + ", uv);\n        }\n      ";
        if (d === a && null == p) return "\n    float " + r + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + d + ".0, " + f + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
        var v = xa(n);
        return "\n      float " + r + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + o + " + col * " + a + " + depth + " + v + ";\n        vec2 uv = uvFromFlat(" + f + ", " + d + ", index);\n        return sampleTexture(" + n + ", uv);\n      }\n  ";
      }(t);

    case 4:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = e[3],
            a = e[2] * o,
            i = e[1] * a,
            s = M(e),
            u = s.newShape,
            c = s.keptDims;

        if (u.length < e.length) {
          var l = Ca(t, u);
          return "\n      " + da(l) + "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        return " + r + "(" + Ea(["row", "col", "depth", "depth2"], c) + ");\n      }\n    ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + i + ", " + a + ", " + o + ", 1)));\n        " + ba(t) + "\n      }\n    ";
        var h = t.shapeInfo.flatOffset,
            f = t.shapeInfo.texShape,
            d = f[0],
            p = f[1];
        if (p === i && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + a + ", " + o + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + p + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        if (p === o && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e[1] * e[2] + ", " + e[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + p + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        var v = xa(n);
        return "\n    float " + r + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + i + " + col * " + a + " +\n          depth * " + o + " + depth2;\n      vec2 uv = uvFromFlat(" + d + ", " + p + ", index + " + v + ");\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
      }(t);

    case 5:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = e[4],
            a = e[3] * o,
            i = e[2] * a,
            s = e[1] * i,
            u = M(e),
            c = u.newShape,
            l = u.keptDims;

        if (c.length < e.length) {
          var h = Ca(t, c);
          return "\n      " + da(h) + "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r + "(" + Ea(["row", "col", "depth", "depth2", "depth3"], l) + ");\n      }\n    ";
        }

        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + s + ", " + i + ", " + a + ", " + o + ")) +\n          depth3;\n        " + ba(t) + "\n      }\n    ";
        var f = t.shapeInfo.flatOffset,
            d = t.shapeInfo.texShape,
            p = d[0],
            v = d[1];
        if (v === s && null == f) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + i + ", " + a + ", " + o + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v + ".0, " + p + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        if (v === o && null == f) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] + ",\n               " + e[2] * e[3] + ", " + e[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v + ".0, " + p + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        var m = xa(n);
        return "\n    float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + s + " + col * " + i + " + depth * " + a + " +\n          depth2 * " + o + " + depth3 + " + m + ";\n      vec2 uv = uvFromFlat(" + p + ", " + v + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
      }(t);

    case 6:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = M(e),
            a = o.newShape,
            i = o.keptDims;

        if (a.length < e.length) {
          var s = Ca(t, a);
          return "\n      " + da(s) + "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r + "(" + Ea(["row", "col", "depth", "depth2", "depth3", "depth4"], i) + ");\n      }\n    ";
        }

        var u = e[5],
            c = e[4] * u,
            l = e[3] * c,
            h = e[2] * l,
            f = e[1] * h;
        if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f + ", " + h + ", " + l + ", " + c + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + u + ", 1)));\n        " + ba(t) + "\n      }\n    ";
        var d = t.shapeInfo.flatOffset,
            p = t.shapeInfo.texShape,
            v = p[0],
            m = p[1];
        if (m === f && null == d) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h + ", " + l + ", " + c + ", " + u + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        if (m === u && null == d) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] * e[4] + ",\n               " + e[2] * e[3] * e[4] + ",\n               " + e[3] * e[4] + ",\n               " + e[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
        var g = xa(n);
        return "\n    float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f + " + col * " + h + " + depth * " + l + " +\n          depth2 * " + c + " + depth3 * " + u + " + depth4 + " + g + ";\n      vec2 uv = uvFromFlat(" + v + ", " + m + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
      }(t);

    default:
      throw new Error(e.length + "-D input sampling is not yet supported");
  }
}

function pa(t) {
  var e, n, r;

  switch (t.shapeInfo.logicalShape.length) {
    case 0:
      return e = t.name, n = "get" + e.charAt(0).toUpperCase() + e.slice(1), r = ua(), "\n    vec4 " + n + "() {\n      return " + r.texture2D + "(" + e + ", halfCR);\n    }\n  ";

    case 1:
      return function (t) {
        var e = t.name,
            n = "get" + e.charAt(0).toUpperCase() + e.slice(1),
            r = t.shapeInfo.texShape,
            o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],
            a = ua();
        return "\n    vec4 " + n + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + o[0] + ", " + o[1] + ", index);\n      return " + a.texture2D + "(" + e + ", uv);\n    }\n  ";
      }(t);

    case 2:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = t.shapeInfo.texShape,
            a = o[0],
            i = o[1],
            s = ua();
        if (null != o && S(e, o)) return "\n      vec4 " + r + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n\n        return " + s.texture2D + "(" + n + ", uv);\n      }\n    ";
        var u = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],
            c = Math.ceil(e[1] / 2);
        return "\n    vec4 " + r + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c + ", " + u[0] + ", " + u[1] + ", row, col);\n      return " + s.texture2D + "(" + n + ", uv);\n    }\n  ";
      }(t);

    case 3:
      return function (t) {
        var e = t.shapeInfo.logicalShape,
            n = t.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            o = t.shapeInfo.texShape,
            a = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];

        if (1 === e[0]) {
          var i = e.slice(1),
              s = Ca(t, i);
          return "\n        " + pa(s) + "\n        vec4 " + r + "(int b, int row, int col) {\n          return " + r + "(" + Ea(["b", "row", "col"], [1, 2]) + ");\n        }\n      ";
        }

        var u = a[0],
            c = a[1],
            l = Math.ceil(e[2] / 2),
            h = l * Math.ceil(e[1] / 2),
            f = ua();
        return "\n    vec4 " + r + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + u + ", " + c + ", " + h + ", " + l + ", b, row, col);\n      return " + f.texture2D + "(" + n + ", uv);\n    }\n  ";
      }(t);

    default:
      return function (t) {
        for (var e = t.shapeInfo.logicalShape, n = e.length, r = t.name, o = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = t.shapeInfo.texShape, i = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)], s = i[0], u = i[1], c = Math.ceil(e[n - 1] / 2), l = c * Math.ceil(e[n - 2] / 2), h = "int b, int row, int col", f = "b * " + l + " + (row / 2) * " + c + " + (col / 2)", d = 2; d < n - 1; d++) h = "int b" + d + ", " + h, l *= e[n - d - 1], f = "b" + d + " * " + l + " + " + f;

        var p = ua();
        return "\n    vec4 " + o + "(" + h + ") {\n      int index = " + f + ";\n      int texR = index / " + u + ";\n      int texC = index - texR * " + u + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + u + ", " + s + ");\n      return " + p.texture2D + "(" + r + ", uv);\n    }\n  ";
      }(t);
  }
}

var va = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    ma = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    ga = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    ya = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

function xa(t) {
  return "offset" + t;
}

function ba(t) {
  var e = t.name,
      n = k(t.shapeInfo.logicalShape);
  return n < 2 ? "return " + e + ";" : "\n    for (int i = 0; i < " + n + "; i++) {\n      if (i == index) {\n        return " + e + "[i];\n      }\n    }\n  ";
}

function wa(t) {
  if (t <= 1) return "int";
  if (2 === t) return "ivec2";
  if (3 === t) return "ivec3";
  if (4 === t) return "ivec4";
  if (5 === t) return "ivec5";
  if (6 === t) return "ivec6";
  throw Error("GPU for rank " + t + " is not yet supported");
}

function Ca(t, e) {
  var n = JSON.parse(JSON.stringify(t));
  return n.shapeInfo.logicalShape = e, n;
}

function Ea(t, e) {
  return e.map(function (e) {
    return t[e];
  }).join(", ");
}

var Ra = function (t, e, n, r) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, C(t.length > 2, function () {
    return "Packed arg" + (n.charAt(0).toUpperCase() + n.slice(1)) + " supports only inputs with rank above 2.";
  });
  var o = t[t.length - 1],
      a = Math.ceil(o / e);
  this.outputShape = t.slice(0, -1), a > 1 && this.outputShape.push(a), r || this.variableNames.push("bestIndicesA");
  var i,
      s,
      u = this.outputShape,
      c = u.length,
      l = wa(c),
      h = sa("coords", c);

  if (1 === a) {
    var f = wa(s = c + 1);
    i = "\n        " + f + " sourceLocR = " + f + "(" + h.join() + ", 0);\n        ++" + h[c - 1] + ";\n        " + f + " sourceLocG = " + f + "(" + h.join() + ", 0);\n        ++" + h[c - 2] + ";\n        " + f + " sourceLocA = " + f + "(" + h.join() + ", 0);\n        --" + h[c - 1] + ";\n        " + f + " sourceLocB = " + f + "(" + h.join() + ", 0);\n        --" + h[c - 2] + ";";
  } else s = c, i = "\n        " + l + " sourceLocR = coords;\n        ++" + h[c - 1] + ";\n        " + l + " sourceLocG = coords;\n        ++" + h[c - 2] + ";\n        " + l + " sourceLocA = coords;\n        --" + h[c - 1] + ";\n        " + l + " sourceLocB = coords;\n        --" + h[c - 2] + ";";

  var d = ["x", "y", "z", "w", "u", "v"].slice(0, s),
      p = "." + d[s - 1],
      v = d.map(function (t) {
    return "int " + t;
  }),
      m = sa("sourceLocR", s - 1).concat("inIdx.r"),
      g = sa("sourceLocG", s - 1).concat("inIdx.g"),
      y = sa("sourceLocB", s - 1).concat("inIdx.b"),
      x = sa("sourceLocA", s - 1).concat("inIdx.a"),
      b = "max" === n ? "greaterThan" : "lessThan",
      w = r ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m.join() + "),\n                             getBestIndicesAChannel(" + g.join() + "),\n                             getBestIndicesAChannel(" + y.join() + "),\n                             getBestIndicesAChannel(" + x.join() + ")));",
      E = "vec4(\n            getAChannel(" + m.join() + "),\n            hasNextCol ? getAChannel(" + g.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + y.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + x.join() + ") : 0.)",
      R = r ? "" : "\n      float getBestIndicesAChannel(" + v.join() + ") {\n        return getChannel(getBestIndicesA(" + d.join() + "),\n                                          vec2(" + d.slice(-2).join() + "));\n      }";
  this.userCode = "\n      float getAChannel(" + v.join() + ") {\n        return getChannel(getA(" + d.join() + "),\n                               vec2(" + d.slice(-2).join() + "));\n      }\n      " + R + "\n      void main() {\n        " + l + " coords = getOutputCoords();\n        bool hasNextCol = " + h[c - 1] + " < " + (u[c - 1] - 1) + ";\n        bool hasNextRow = " + h[c - 2] + " < " + (u[c - 2] - 1) + ";\n        " + i + "\n        ivec4 srcIdx = ivec4(sourceLocR" + p + ", sourceLocG" + p + ",\n          sourceLocB" + p + ", sourceLocA" + p + ") * " + e + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + E + ";\n\n        for (int i = 0; i < " + e + "; i++) {\n          inIdx = srcIdx;\n          " + w + "\n          vec4 candidate = " + E + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + b + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
},
    Ia = function (t) {
  this.variableNames = ["dy"], this.outputShape = t.inShape;
  var e = t.filterHeight,
      n = t.filterWidth,
      r = t.strideHeight,
      o = t.strideWidth,
      a = t.dilationHeight,
      i = t.dilationWidth,
      s = t.effectiveFilterHeight,
      u = t.effectiveFilterWidth,
      c = s - 1 - t.padInfo.top,
      l = u - 1 - t.padInfo.left,
      h = 1 / (e * n);
  this.userCode = "\n      const ivec2 pads = ivec2(" + c + ", " + l + ");\n      const float avgMultiplier = float(" + h + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + s + ";\n            wR += " + a + ") {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + u + ";\n            wC+= " + i + ") {\n            float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    ka = function (t) {
  this.variableNames = ["dy"], this.outputShape = t.inShape;
  var e = t.filterDepth,
      n = t.filterHeight,
      r = t.filterWidth,
      o = t.strideDepth,
      a = t.strideHeight,
      i = t.strideWidth,
      s = t.dilationDepth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.effectiveFilterDepth,
      h = t.effectiveFilterHeight,
      f = t.effectiveFilterWidth,
      d = l - 1 - t.padInfo.front,
      p = h - 1 - t.padInfo.top,
      v = f - 1 - t.padInfo.left,
      m = 1 / (e * n * r);
  this.userCode = "\n      const ivec3 pads = ivec3(" + d + ", " + p + ", " + v + ");\n      const float avgMultiplier = float(" + m + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + s + ") {\n          float dyD = float(dyDCorner + wD) / " + o + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h + ";\n              wR += " + u + ") {\n            float dyR = float(dyRCorner + wR) / " + a + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + f + ";\n                wC += " + c + ") {\n              float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Sa = function (t, e, n, r, o, a) {
  this.outputShape = [], this.variableNames = ["x", "mean", "variance"], Ro(t, e), Ro(t, n);
  var i = "0.0";
  null != r && (Ro(t, r), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
  var s = "1.0";
  null != o && (Ro(t, o), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + i + ";\n        float scale = " + s + ";\n        float inv = scale * inversesqrt(variance + float(" + a + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
},
    Aa = function (t, e, n, r, o, a) {
  this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], Ro(t, e), Ro(t, n);
  var i = "vec4(0.0)";
  null != r && (Ro(t, r), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
  var s = "vec4(1.0)";
  null != o && (Ro(t, o), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        vec4 offset = " + i + ";\n        vec4 scale = " + s + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + a + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
},
    Da = "return areal * breal - aimag * bimag;",
    Ta = "return areal * bimag + aimag * breal;",
    Na = function (t, e, n) {
  this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = Ro(e, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
},
    Fa = "return a + b;",
    _a = "return a - b;",
    Oa = "return a * b;",
    Ma = "return (a < 0.) ? b * a : a;",
    Ba = function (t, e, n) {
  this.variableNames = ["A", "B"], this.outputShape = Ro(e, n), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
},
    Pa = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    La = function (t, e, n, r) {
  void 0 === r && (r = !1), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Ro(e, n);
  var o = this.outputShape.length,
      a = "";
  if (r) if (0 === o || 1 === k(this.outputShape)) a = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if (a = "\n          " + wa(o) + " coords = getOutputCoords();\n        ", 1 === o) a += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else {
    var i = sa("coords", o);
    a += "\n            bool nextRowOutOfBounds =\n              (" + i[o - 2] + " + 1) >= " + this.outputShape[o - 2] + ";\n            bool nextColOutOfBounds =\n              (" + i[o - 1] + " + 1) >= " + this.outputShape[o - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
  }
  this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + a + "\n\n        setOutput(result);\n      }\n    ";
},
    Wa = function () {
  function t(t) {
    this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t, e) {
    var n = this;
    return function (r, o) {
      null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(o, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);
    };
  }, t;
}(),
    Ua = function () {
  function t(t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t, e) {
    var n = this;
    return function (r, o) {
      null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(o, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);
    };
  }, t;
}(),
    Va = function (t) {
  this.variableNames = ["real", "imag"], this.outputShape = t, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
},
    za = function (t) {
  this.outputShape = [], this.outputShape = Sn(t, 1), this.variableNames = t.map(function (t, e) {
    return "T" + e;
  });
  var e = new Array(t.length - 1);
  e[0] = t[0][1];

  for (var n = 1; n < e.length; n++) e[n] = e[n - 1] + t[n][1];

  var r = ["if (yC < " + e[0] + ") setOutput(getT0(yR, yC));"];

  for (n = 1; n < e.length; n++) {
    var o = e[n - 1];
    r.push("else if (yC < " + e[n] + ") setOutput(getT" + n + "(yR, yC-" + o + "));");
  }

  var a = e.length,
      i = e[e.length - 1];
  r.push("else setOutput(getT" + a + "(yR, yC-" + i + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r.join("\n        ") + "\n      }\n    ";
},
    Ga = function (t, e) {
  this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = Sn(t, e);
  var n = this.outputShape,
      r = n.length,
      o = wa(r),
      a = sa("coords", r),
      i = ["x", "y", "z", "w", "u", "v"].slice(0, r);
  this.variableNames = t.map(function (t, e) {
    return "T" + e;
  });
  var s = new Array(t.length - 1);
  s[0] = t[0][e];

  for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + t[u][e];

  var c = i[e],
      l = i.slice(-2),
      h = i.join(),
      f = "if (" + c + " < " + s[0] + ") {\n        return getChannel(\n            getT0(" + h + "), vec2(" + l.join() + "));\n        }";

  for (u = 1; u < s.length; u++) {
    var d = s[u - 1];
    f += "\n        if (" + c + " < " + s[u] + "  && " + c + " >= " + s[u - 1] + ") {\n          return getChannel(\n            getT" + u + "(" + Ha(i, c, d) + "),\n            vec2(" + Ha(l, c, d) + "));\n        }";
  }

  var p = s.length,
      v = s[s.length - 1];
  f += "\n        return getChannel(\n          getT" + p + "(" + Ha(i, c, v) + "),\n          vec2(" + Ha(l, c, v) + "));", this.userCode = "\n      float getValue(" + i.map(function (t) {
    return "int " + t;
  }) + ") {\n        " + f + "\n      }\n\n      void main() {\n        " + o + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + a + "), 0., 0., 0.);\n\n        " + a[r - 1] + " = " + a[r - 1] + " + 1;\n        if (" + a[r - 1] + " < " + n[r - 1] + ") {\n          result.g = getValue(" + a + ");\n        }\n\n        " + a[r - 2] + " = " + a[r - 2] + " + 1;\n        if (" + a[r - 2] + " < " + n[r - 2] + ") {\n          result.a = getValue(" + a + ");\n        }\n\n        " + a[r - 1] + " = " + a[r - 1] + " - 1;\n        if (" + a[r - 2] + " < " + n[r - 2] + " &&\n            " + a[r - 1] + " < " + n[r - 1] + ") {\n          result.b = getValue(" + a + ");\n        }\n        setOutput(result);\n      }\n    ";
};

function Ha(t, e, n) {
  var r = t.indexOf(e);
  return t.map(function (t, e) {
    return e === r ? t + " - " + n : t;
  }).join();
}

var qa = function (t) {
  this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
  var e = t.strideHeight,
      n = t.strideWidth,
      r = t.padInfo.top,
      o = t.padInfo.left,
      a = "channelsLast" === t.dataFormat;
  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + o + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              if (" + a + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Ka = function (t) {
  this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
  var e = t.filterHeight,
      n = t.filterWidth,
      r = t.strideHeight,
      o = t.strideWidth,
      a = "channelsLast" === t.dataFormat,
      i = e - 1 - t.padInfo.top,
      s = n - 1 - t.padInfo.left,
      u = a ? 1 : 2,
      c = a ? 2 : 3,
      l = a ? 3 : 1;
  this.userCode = "\n      const ivec2 pads = ivec2(" + i + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l + "];\n\n        ivec2 dyCorner = ivec2(coords[" + u + "], coords[" + c + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n\n              if (" + a + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    ja = function (t) {
  this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
  var e = t.strideDepth,
      n = t.strideHeight,
      r = t.strideWidth,
      o = t.padInfo.front,
      a = t.padInfo.top,
      i = t.padInfo.left;
  this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t.outDepth + "; yF++) {\n            int xF = wF + yF * " + e + " - " + o + ";\n\n            if (xF < 0 || xF >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n              int xR = wR + yR * " + n + " - " + a + ";\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n                int xC = wC + yC * " + r + " - " + i + ";\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Xa = function (t) {
  this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
  var e = t.filterDepth,
      n = t.filterHeight,
      r = t.filterWidth,
      o = t.strideDepth,
      a = t.strideHeight,
      i = t.strideWidth,
      s = e - 1 - t.padInfo.front,
      u = n - 1 - t.padInfo.top,
      c = r - 1 - t.padInfo.left;
  this.userCode = "\n      const ivec3 pads = ivec3(" + s + ", " + u + ", " + c + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + o + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + a + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Ya = function (t) {
  this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
  var e = t.strideHeight,
      n = t.strideWidth,
      r = t.padInfo.top,
      o = t.padInfo.left,
      a = t.outChannels / t.inChannels;
  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + a + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + o + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    $a = function (t) {
  this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
  var e = t.filterHeight,
      n = t.filterWidth,
      r = t.strideHeight,
      o = t.strideWidth,
      a = e - 1 - t.padInfo.top,
      i = n - 1 - t.padInfo.left,
      s = t.outChannels / t.inChannels;
  this.userCode = "\n      const ivec2 pads = ivec2(" + a + ", " + i + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + s + "; dm++) {\n              int d2 = d1 * " + s + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Qa = function (t, e, n, r) {
  void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
  var o = t.padInfo.top,
      a = t.padInfo.left,
      i = t.strideHeight,
      s = t.strideWidth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.filterHeight,
      h = t.filterWidth,
      f = 4 * Math.floor(t.inChannels / 4),
      d = t.inChannels % 4,
      p = "channelsLast" === t.dataFormat,
      v = p ? 1 : 2,
      m = p ? 2 : 3,
      g = p ? 3 : 1,
      y = "",
      x = "";
  n && (y = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", x = "result = activation(result);");
  var b = e ? "result += getBiasAtOutCoords();" : "";
  e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y + "\n\n      const ivec2 strides = ivec2(" + i + ", " + s + ");\n      const ivec2 pads = ivec2(" + o + ", " + a + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v + "], coords[" + m + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l + "; wR++) {\n          int xR = xRCorner + wR * " + u + ";\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h + "; wC++) {\n            int xC = xCCorner + wC * " + c + ";\n\n            if (xC < 0 || xC >= " + t.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + p + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === d) + ") {\n\n              if (" + p + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f + ") *\n                    getW(wR, wC, " + f + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f + ", xR, xC) *\n                    getW(wR, wC, " + f + ", d2);\n              }\n\n            } else if (" + (2 === d) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f + ", d2),\n                getW(wR, wC, " + f + " + 1, d2)\n              );\n\n              if (" + p + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f + "),\n                  getX(batch, xR, xC, " + f + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f + ", xR, xC),\n                  getX(batch, " + f + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === d) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f + ", d2),\n                getW(wR, wC, " + f + " + 1, d2),\n                getW(wR, wC, " + f + " + 2, d2)\n              );\n\n              if (" + p + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f + "),\n                  getX(batch, xR, xC, " + f + " + 1),\n                  getX(batch, xR, xC, " + f + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f + ", xR, xC),\n                  getX(batch, " + f + " + 1, xR, xC),\n                  getX(batch, " + f + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + b + "\n        " + x + "\n        setOutput(result);\n      }\n    ";
},
    Ja = function (t) {
  this.variableNames = ["x", "W"], this.outputShape = t.outShape;
  var e = t.padInfo.front,
      n = t.padInfo.top,
      r = t.padInfo.left,
      o = t.strideDepth,
      a = t.strideHeight,
      i = t.strideWidth,
      s = t.dilationDepth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.filterDepth,
      h = t.filterHeight,
      f = t.filterWidth,
      d = 4 * Math.floor(t.inChannels / 4),
      p = t.inChannels % 4;
  this.userCode = "\n      const ivec3 strides = ivec3(" + o + ", " + a + ", " + i + ");\n      const ivec3 pads = ivec3(" + e + ", " + n + ", " + r + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l + "; wF++) {\n          int xF = xFCorner + wF * " + s + ";\n\n          if (xF < 0 || xF >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + "; wR++) {\n            int xR = xRCorner + wR * " + u + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + f + "; wC++) {\n              int xC = xCCorner + wC * " + c + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + d + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === p) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + d + ") *\n                  getW(wF, wR, wC, " + d + ", d2);\n              } else if (" + (2 === p) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + d + "),\n                  getX(batch, xF, xR, xC, " + d + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + d + ", d2),\n                  getW(wF, wR, wC, " + d + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === p) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + d + "),\n                  getX(batch, xF, xR, xC, " + d + " + 1),\n                  getX(batch, xF, xR, xC, " + d + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + d + ", d2),\n                  getW(wF, wR, wC, " + d + " + 1, d2),\n                  getW(wF, wR, wC, " + d + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Za = function (t, e, n, r) {
  void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
  var o = t.inHeight,
      a = t.inWidth,
      i = t.padInfo.top,
      s = t.padInfo.left,
      u = t.strideHeight,
      c = t.strideWidth,
      l = t.dilationHeight,
      h = t.dilationWidth,
      f = t.filterHeight,
      d = t.filterWidth,
      p = t.outChannels / t.inChannels,
      v = "",
      m = "";
  n && (v = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", m = "result = activation(result);");
  var g = e ? "result += getBiasAtOutCoords();" : "";
  e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v + "\n\n      const ivec2 strides = ivec2(" + u + ", " + c + ");\n      const ivec2 pads = ivec2(" + i + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + p + ";\n        int q = d2 - d1 * " + p + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f + "; wR++) {\n          int xR = xRCorner + wR * " + l + ";\n\n          if (xR < 0 || xR >= " + o + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + d + "; wC++) {\n            int xC = xCCorner + wC * " + h + ";\n\n            if (xC < 0 || xC >= " + a + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g + "\n        " + m + "\n        setOutput(result);\n      }\n    ";
},
    ti = function (t, e, n, r) {
  void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.outShape;

  for (var o = t.inHeight, a = t.inWidth, i = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, f = t.filterHeight, d = t.filterWidth, p = d, v = "int xR; int xC; int xCOffset;", m = 0; m < f; m++) for (var g = 0; g < d; g++) v += "\n          vec4 xTexelR" + m + "C" + 2 * g + " = vec4(0.);\n          vec4 wR" + m + "C" + g + " = vec4(0.);\n          vec4 xR" + m + "C" + g + " = vec4(0.);";

  for (m = 0; m < f; m++) for (var y = 0; y < p; y++) {
    if (v += "\n          xR = xRCorner + " + m * l + ";\n          xC = xCCorner + " + (g = 2 * y) * h + ";\n        ", 1 === c) {
      if (g < d && (v += s % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + o + " && xCOffset >= 0 && xCOffset < " + a + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a + ") {\n                    xTexelR" + m + "C" + g + ".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + o + " && xCOffset >= 0 && xCOffset < " + a + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a + ") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR" + m + "C" + g + " = vec4(previous.zw, xTexelR" + m + "C" + g + ".xy);\n                } else {\n                  xR" + m + "C" + g + " = vec4(0, 0, xTexelR" + m + "C" + g + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + o + " && xC >= 0 && xC < " + a + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = xTexelR" + m + "C" + g + ";\n              ", g + 1 < d)) {
        var x = s % 2 == 0 ? b(h) : h;
        h % 2 == 0 && s % 2 == 1 || h % 2 != 0 && s % 2 != 1 ? (v += "\n                  xCOffset = xC + " + s % 2 + " + " + x + ";\n\n                  if(xR >= 0 && xR < " + o + " &&\n                    xCOffset >= 0 && xCOffset < " + a + ") {\n                    xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h > 1 && (v += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + o + " &&\n                      xCOffset >= 0 && xCOffset < " + a + ") {\n                      xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + m + "C" + g + " = vec4(0.);\n                    }\n                  "), v += "\n                  xR" + m + "C" + (g + 1) + " = vec4(\n                    xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".xy);\n                ") : v += "\n                  xCOffset = xC + " + x + ";\n\n                  if(xR >= 0 && xR < " + o + " &&\n                    xCOffset >= 0 && xCOffset < " + a + ") {\n                    xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + m + "C" + (g + 1) + " = xTexelR" + m + "C" + (g + 2) + ";\n                ";
      }
    } else g < d && (v += "\n              if(xR >= 0 && xR < " + o + ") {\n            ", s % 2 == 1 ? (v += "\n                xCOffset = xC + 1 - " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + a + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + a + ") {\n                  xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + m + "C" + (g + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = vec4(\n                  xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".zw);\n              ", g + 1 < d && (v += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c + ";\n                  if(xCOffset >= 0 && xCOffset < " + a + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + m + "C" + (g + 1) + " = vec4(xTexelR" + m + "C" + (g + 2) + ".xy, final.xy);\n                ")) : (v += "\n                if(xC >= 0 && xC < " + a + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + a + ") {\n                  xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + (g + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = vec4(\n                  xTexelR" + m + "C" + g + ".xy, xTexelR" + m + "C" + (g + 2) + ".xy);\n              ", g + 1 < d && (v += "\n                  xR" + m + "C" + (g + 1) + " = vec4(\n                    xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".zw);\n                ")), v += "}");

    g < d && (v += "\n            vec4 wTexelR" + m + "C" + g + " = getW(" + m + ", " + g + ", d1, q);\n            wR" + m + "C" + g + " = vec4(wTexelR" + m + "C" + g + ".xz, wTexelR" + m + "C" + g + ".xz);\n          ", g + 1 < d && (v += "\n              vec4 wTexelR" + m + "C" + (g + 1) + " = getW(" + m + ", " + (g + 1) + ", d1, q);\n              wR" + m + "C" + (g + 1) + " =\n                vec4(wTexelR" + m + "C" + (g + 1) + ".xz, wTexelR" + m + "C" + (g + 1) + ".xz);"));
  }

  for (m = 0; m < f; m++) for (g = 0; g < d; g++) v += "dotProd += xR" + m + "C" + g + " * wR" + m + "C" + g + ";";

  var w = "",
      C = "";
  n && (w = r ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "vec4 activation(vec4 x) {\n          " + n + "\n        }", C = "result = activation(result);");
  var E = e ? "result += getBiasAtOutCoords();" : "";
  e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w + "\n\n      const ivec2 strides = ivec2(" + u + ", " + c + ");\n      const ivec2 pads = ivec2(" + i + ", " + s + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + v + "\n\n        vec4 result = dotProd;\n        " + E + "\n        " + C + "\n        setOutput(result);\n      }\n    ";
},
    ei = function (t, e, n, r, o) {
  this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
  var a = t[0],
      i = t[1],
      s = t[2],
      u = t[3],
      c = e[0],
      l = n[0],
      h = n[1];
  this.outputShape = [c, l, h, u];
  var f = "bilinear" === r ? 1 : 0,
      d = [i - 1 + ".0", s - 1 + ".0"],
      p = d[0],
      v = d[1],
      m = l > 1 ? ["" + (i - 1) / (l - 1), "(y2-y1) * height_ratio", "y1*" + p + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + p],
      g = m[0],
      y = m[1],
      x = m[2],
      b = h > 1 ? ["" + (s - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*" + v + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + v],
      w = b[0],
      C = b[1],
      E = b[2];
  this.userCode = "\n      const float height_ratio = float(" + g + ");\n      const float width_ratio = float(" + w + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + a + ") {\n          return;\n        }\n\n        float height_scale = " + y + ";\n        float width_scale = " + C + ";\n\n        float in_y = " + x + ";\n        if( in_y < 0.0 || in_y > " + p + " ) {\n          setOutput(float(" + o + "));\n          return;\n        }\n        float in_x = " + E + ";\n        if( in_x < 0.0 || in_x > " + v + " ) {\n          setOutput(float(" + o + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + f + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
},
    ni = function (t, e, n) {
  this.variableNames = ["x"], this.outputShape = t;
  var r = t.length,
      o = t[t.length - 1],
      a = n ? "<" : ">";

  this.userCode = "\n      int getIndex(int i) {\n        " + (n ? "return " + o + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + wa(r) + " coords = getOutputCoords();\n        int end = " + ri(r, "coords") + ";\n        float val = 0.0;\n        for (int i = " + o + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + a + " end) {\n            continue;\n          }\n          if (idx == end && " + e + ") {\n            continue;\n          }\n          " + ri(r, "coords") + " = idx;\n          val += getX(" + function (t, e) {
    if (1 === t) return "" + e;
    if (2 === t) return e + ".x, " + e + ".y";
    if (3 === t) return e + ".x, " + e + ".y, " + e + ".z";
    if (4 === t) return e + ".x, " + e + ".y, " + e + ".z, " + e + ".w";
    throw Error("Cumulative sum for rank " + t + " is not yet supported");
  }(r, "coords") + ");\n        }\n        setOutput(val);\n      }\n    ";
};

function ri(t, e) {
  if (1 === t) return "" + e;
  if (2 === t) return e + ".y";
  if (3 === t) return e + ".z";
  if (4 === t) return e + ".w";
  throw Error("Cumulative sum for rank " + t + " is not yet supported");
}

var oi = function (t) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;
  var e = Yt(t),
      n = ua();
  this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + ca(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n.output + " = result;\n      }\n    ";
},
    ai = function (t) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;
  var e = Yt(t),
      n = ua();
  this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + ca(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n.output + " = result;\n      }\n    ";
},
    ii = function () {
  function t(t, e, n) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e + ";\n      int offset_h = imod(h, " + e + ");\n      int in_w = w / " + e + ";\n      int offset_w = imod(w, " + e + ");\n      int offset_d = (offset_h * " + e + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
  }

  return t.prototype.getHeightCoordString = function () {
    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
  }, t.prototype.getWidthCoordString = function () {
    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
  }, t.prototype.getDepthCoordString = function () {
    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
  }, t.prototype.getOutputDepthSize = function () {
    return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
  }, t.prototype.getInputSamplingString = function () {
    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }, t;
}(),
    si = function (t) {
  this.variableNames = ["X"], this.outputShape = [t, t], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
},
    ui = function (t) {
  this.variableNames = ["A"], this.outTexUsage = zt.DOWNLOAD;
  var e = ua();
  this.outputShape = t, this.userCode = "\n      " + ha + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e.output + " = encode_float(x);\n      }\n    ";
},
    ci = function (t) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = zt.DOWNLOAD;
  var e = ua();
  this.outputShape = t, this.userCode = "\n      " + ha + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e.output + " = encode_float(x);\n      }\n    ";
},
    li = function (t, e, n) {
  void 0 === n && (n = !1), this.variableNames = ["A"];
  var r = ua(),
      o = e[0],
      a = e[1];
  this.outputShape = t;
  var i = "result";
  n && (i = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + la(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + a + ";\n        int c = imod(flatIndex, " + a + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n        vec4 values = " + r.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r.output + " = vec4(" + i + ", 0., 0., 0.);\n      }\n    ";
},
    hi = function (t, e, n) {
  void 0 === n && (n = !1), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
  var r = ua(),
      o = e[0],
      a = e[1];
  this.outputShape = t;
  var i = "",
      s = "result";
  n && (s = "floor(result * 255. + 0.5)");

  for (var u = 0; u <= 1; u++) for (var c = 0; c <= 1; c++) {
    var l = 2 * u + c;
    i += "\n          localCoords = coords;\n          if(localCoords[2] + " + c + " < " + t[2] + ") {\n            localCoords[2] += " + c + ";\n            if(localCoords[1] + " + u + " < " + t[1] + ") {\n              localCoords[1] += " + u + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + a + ";\n              c = imod(flatIndex, " + a + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n              values = " + r.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l + "] = values[2];\n              } else {\n                result[" + l + "] = values[3];\n              }\n            }\n          }\n        ";
  }

  this.userCode = "\n      " + la(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + i + "\n\n        " + r.output + " = " + s + ";\n      }\n    ";
},
    fi = "return real * expR - imag * expI;",
    di = "return real * expI + imag * expR;",
    pi = function (t, e, n) {
  this.variableNames = ["real", "imag"];
  var r = e[1];
  this.outputShape = e;
  var o = n ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI,
      a = n ? r + ".0" : "1.0";
  this.userCode = "\n      const float exponentMultiplier = " + o + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + a + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
},
    vi = function () {
  function t(t, e) {
    this.outputShape = [], this.variableNames = ["x"], this.outputShape = t, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    return function (n, r) {
      null == e.valueLoc && (e.valueLoc = n.getUniformLocationNoThrow(r, "value")), n.gl.uniform1f(e.valueLoc, t);
    };
  }, t;
}(),
    mi = function (t, e, n) {
  this.variableNames = ["A", "indices"];
  var r = t.slice();
  r[n] = e, this.outputShape = r, this.rank = r.length;

  var o = wa(this.rank),
      a = function (t, e) {
    var n = t.length;
    if (n > 4) throw Error("Gather for rank " + n + " is not yet supported");
    if (1 === n) return "int(getIndices(resRC))";

    for (var r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o = [], a = 0; a < t.length; a++) a === e ? o.push("int(getIndices(" + r[a] + "))") : o.push("" + r[a]);

    return o.join();
  }(t, n);

  this.userCode = "\n      void main() {\n        " + o + " resRC = getOutputCoords();\n        setOutput(getA(" + a + "));\n      }\n    ";
};

var gi = function (t, e, n) {
  this.sliceDim = t, this.strides = e, this.variableNames = ["x", "indices"], this.outputShape = n;
  var r = wa(e.length),
      o = wa(n.length),
      a = this.sliceDim > 1 ? "strides[j]" : "strides";
  this.userCode = "\n        " + r + " strides = " + r + "(" + this.strides + ");\n         void main() {\n          " + o + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + a + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
};

function yi(t, e) {
  var n = ua();
  return oe(t, e, n.version + "\n    precision highp float;\n    " + n.attribute + " vec3 clipSpacePos;\n    " + n.attribute + " vec2 uv;\n    " + n.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }");
}

function xi(t, e) {
  return fe(t, e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
}

function bi(t, e) {
  return de(t, e, new Uint16Array([0, 1, 2, 2, 1, 3]));
}

function wi(t, e, n, r, o, a, i) {
  ve(n, r);
  var s = pe(t, e),
      u = t.TEXTURE_2D;
  return Jt(t, e, function () {
    return t.bindTexture(u, s);
  }), Jt(t, e, function () {
    return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE);
  }), Jt(t, e, function () {
    return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
  }), Jt(t, e, function () {
    return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST);
  }), Jt(t, e, function () {
    return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST);
  }), Jt(t, e, function () {
    return t.texImage2D(u, 0, o, n, r, 0, a, i, null);
  }), Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, null);
  }), s;
}

function Ci(t, e, n, r, o) {
  var a = Xt(n, r);
  return wi(t, e, a[0], a[1], o.internalFormatFloat, o.textureFormatFloat, t.FLOAT);
}

function Ei(t, e, n, r, o) {
  var a = Xt(n, r);
  return wi(t, e, a[0], a[1], o.internalFormatHalfFloat, o.textureFormatFloat, o.textureTypeHalfFloat);
}

function Ri(t, e, n, r, o) {
  var a = Xt(n, r);
  return wi(t, e, a[0], a[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE);
}

function Ii(t, e, n, r, o) {
  var a = $t(n, r);
  return wi(t, e, a[0], a[1], o.internalFormatPackedFloat, t.RGBA, t.FLOAT);
}

function ki(t, e, n, r, o) {
  var a = $t(n, r);
  return wi(t, e, a[0], a[1], o.internalFormatPackedHalfFloat, t.RGBA, o.textureTypeHalfFloat);
}

function Si(t, e, n, r) {
  return Jt(t, e, function () {
    return t.bindBuffer(t.ARRAY_BUFFER, r);
  }), ge(t, e, n, "clipSpacePos", r, 3, 20, 0) && ge(t, e, n, "uv", r, 2, 20, 12);
}

function Ai(t, e, n, r, o, a, i) {
  var s, u, c;
  Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, n);
  }), a instanceof Uint8Array ? (s = new Uint8Array(r * o * 4), u = t.UNSIGNED_BYTE, c = t.RGBA) : (s = new Float32Array(r * o * 4), u = t.FLOAT, c = i.internalFormatPackedFloat), s.set(a), Jt(t, e, function () {
    return t.texImage2D(t.TEXTURE_2D, 0, c, r, o, 0, t.RGBA, u, s);
  }), Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, null);
  });
}

function Di(t, e, n, r) {
  Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, n);
  }), r.data instanceof Uint8Array ? Jt(t, e, function () {
    return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data);
  }) : Jt(t, e, function () {
    return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r);
  }), Jt(t, e, function () {
    return t.bindTexture(t.TEXTURE_2D, null);
  });
}

function Ti(t, e, n, r, o) {
  var a = t.createBuffer();
  Jt(t, e, function () {
    return t.bindBuffer(t.PIXEL_PACK_BUFFER, a);
  });
  var i = 16 * n * r;
  return Jt(t, e, function () {
    return t.bufferData(t.PIXEL_PACK_BUFFER, i, t.STREAM_READ);
  }), Jt(t, e, function () {
    return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0);
  }), Jt(t, e, function () {
    return t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
  }), a;
}

function Ni(t, e, n) {
  var r = t,
      o = new Float32Array(n);
  return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, o), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), o;
}

function Fi(t, e, n, r, o) {
  var a = Xt(n, r),
      i = a[0],
      s = a[1],
      u = new Uint8Array(n * r * 4);
  return Jt(t, e, function () {
    return t.readPixels(0, 0, i, s, o.downloadTextureFormat, t.UNSIGNED_BYTE, u);
  }), new Float32Array(u.buffer);
}

function _i(t, e, n, r, o, a, i, s) {
  var u = t,
      c = new Float32Array(function (t, e) {
    var n = $t(t, e);
    return n[0] * n[1] * 4;
  }(a, i));
  return u.bindBuffer(u.PIXEL_PACK_BUFFER, e), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), c;
}

function Oi(t, e, n, r) {
  var o = new Float32Array(n * r * 4);
  return Jt(t, e, function () {
    return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, o);
  }), o;
}

var Mi = Object.freeze({
  createVertexShader: yi,
  createVertexBuffer: xi,
  createIndexBuffer: bi,
  createFloat32MatrixTexture: Ci,
  createFloat16MatrixTexture: Ei,
  createUnsignedBytesMatrixTexture: Ri,
  createPackedMatrixTexture: Ii,
  createFloat16PackedMatrixTexture: ki,
  bindVertexProgramAttributeStreams: Si,
  uploadDenseMatrixToTexture: Ai,
  uploadPixelDataToTexture: Di,
  createBufferFromOutputTexture: Ti,
  downloadFloat32MatrixFromBuffer: Ni,
  downloadByteEncodedFloatMatrixFromOutputTexture: Fi,
  downloadPackedMatrixFromBuffer: _i,
  downloadMatrixFromPackedOutputTexture: Oi
}),
    Bi = function () {
  function t(t) {
    this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
    var e = i().getNumber("WEBGL_VERSION");
    null != t ? (this.gl = t, Kt(e, t)) : this.gl = jt(e);
    var n = "WEBGL_color_buffer_float";

    if (1 === i().getNumber("WEBGL_VERSION")) {
      if (this.textureFloatExtension = re(this.gl, this.debug, "OES_texture_float"), Pe(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = re(this.gl, this.debug, "OES_texture_half_float");else if (i().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(n), Pe(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = re(this.gl, this.debug, "EXT_color_buffer_half_float");else if (i().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (n = "EXT_color_buffer_float", Pe(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);else {
      if (!Pe(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
      this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
    }

    this.vertexBuffer = xi(this.gl, this.debug), this.indexBuffer = bi(this.gl, this.debug), this.framebuffer = me(this.gl, this.debug), this.textureConfig = Qt(this.gl, this.textureHalfFloatExtension);
  }

  return Object.defineProperty(t.prototype, "debug", {
    get: function () {
      return i().getBool("DEBUG");
    },
    enumerable: !0,
    configurable: !0
  }), t.prototype.dispose = function () {
    var t = this;

    if (!this.disposed) {
      null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      var e = this.gl;
      Jt(e, this.debug, function () {
        return e.finish();
      }), Jt(e, this.debug, function () {
        return e.bindFramebuffer(e.FRAMEBUFFER, null);
      }), Jt(e, this.debug, function () {
        return e.deleteFramebuffer(t.framebuffer);
      }), Jt(e, this.debug, function () {
        return e.bindBuffer(e.ARRAY_BUFFER, null);
      }), Jt(e, this.debug, function () {
        return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null);
      }), Jt(e, this.debug, function () {
        return e.deleteBuffer(t.indexBuffer);
      }), this.disposed = !0;
    }
  }, t.prototype.createFloat32MatrixTexture = function (t, e) {
    return this.throwIfDisposed(), Ci(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.createFloat16MatrixTexture = function (t, e) {
    return this.throwIfDisposed(), Ei(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.createUnsignedBytesMatrixTexture = function (t, e) {
    return this.throwIfDisposed(), Ri(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.uploadPixelDataToTexture = function (t, e) {
    this.throwIfDisposed(), Di(this.gl, this.debug, t, e);
  }, t.prototype.uploadDenseMatrixToTexture = function (t, e, n, r) {
    this.throwIfDisposed(), Ai(this.gl, this.debug, t, e, n, r, this.textureConfig);
  }, t.prototype.createFloat16PackedMatrixTexture = function (t, e) {
    return this.throwIfDisposed(), ki(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.createPackedMatrixTexture = function (t, e) {
    return this.throwIfDisposed(), Ii(this.gl, this.debug, t, e, this.textureConfig);
  }, t.prototype.deleteMatrixTexture = function (t) {
    var e = this;
    this.throwIfDisposed(), this.outputTexture === t && (Ee(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Jt(this.gl, this.debug, function () {
      return e.gl.deleteTexture(t);
    });
  }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (t, e, n) {
    var r = this;
    return this.downloadMatrixDriver(t, function () {
      return Fi(r.gl, r.debug, e, n, r.textureConfig);
    });
  }, t.prototype.downloadPackedMatrixFromBuffer = function (t, e, n, r, o, a) {
    return _i(this.gl, t, 0, 0, 0, o, a, this.textureConfig);
  }, t.prototype.downloadFloat32MatrixFromBuffer = function (t, e) {
    return Ni(this.gl, t, e);
  }, t.prototype.createBufferFromTexture = function (t, e, n) {
    this.bindTextureToFrameBuffer(t);
    var r = Ti(this.gl, this.debug, e, n, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), r;
  }, t.prototype.createAndWaitForFence = function () {
    var t = this.createFence(this.gl);
    return this.pollFence(t);
  }, t.prototype.createFence = function (t) {
    var e,
        n,
        r = this;

    if (i().getBool("WEBGL_FENCE_API_ENABLED")) {
      var o = t,
          a = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
      t.flush(), n = function () {
        var t = o.clientWaitSync(a, 0, 0);
        return t === o.ALREADY_SIGNALED || t === o.CONDITION_SATISFIED;
      }, e = a;
    } else i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e = this.beginQuery(), this.endQuery(), n = function () {
      return r.isQueryAvailable(e, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }) : n = function () {
      return !0;
    };

    return {
      query: e,
      isFencePassed: n
    };
  }, t.prototype.downloadMatrixFromPackedTexture = function (t, e, n) {
    var r = this;
    return this.downloadMatrixDriver(t, function () {
      return Oi(r.gl, r.debug, e, n);
    });
  }, t.prototype.createProgram = function (t) {
    this.throwIfDisposed();
    var e = this.gl,
        n = ae(e, this.debug, t),
        r = yi(e, this.debug),
        o = ce(e, this.debug);
    return Jt(e, this.debug, function () {
      return e.attachShader(o, r);
    }), Jt(e, this.debug, function () {
      return e.attachShader(o, n);
    }), le(e, this.debug, o), this.debug && he(e, this.debug, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = Si(e, this.debug, this.program, this.vertexBuffer)), o;
  }, t.prototype.deleteProgram = function (t) {
    var e = this;
    this.throwIfDisposed(), t === this.program && (this.program = null), null != t && Jt(this.gl, this.debug, function () {
      return e.gl.deleteProgram(t);
    });
  }, t.prototype.setProgram = function (t) {
    var e = this;
    this.throwIfDisposed(), this.program = t, null != this.program && this.debug && he(this.gl, this.debug, this.program), Jt(this.gl, this.debug, function () {
      return e.gl.useProgram(t);
    });
  }, t.prototype.getUniformLocation = function (t, e, n) {
    return void 0 === n && (n = !0), this.throwIfDisposed(), n ? xe(this.gl, this.debug, t, e) : be(this.gl, t, e);
  }, t.prototype.getAttributeLocation = function (t, e) {
    var n = this;
    return this.throwIfDisposed(), Jt(this.gl, this.debug, function () {
      return n.gl.getAttribLocation(t, e);
    });
  }, t.prototype.getUniformLocationNoThrow = function (t, e) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(t, e);
  }, t.prototype.setInputMatrixTexture = function (t, e, n) {
    this.throwIfDisposed(), this.throwIfNoProgram(), we(this.gl, this.debug, this.program, t, e, n);
  }, t.prototype.setOutputMatrixTexture = function (t, e, n) {
    this.setOutputMatrixTextureDriver(t, n, e);
  }, t.prototype.setOutputPackedMatrixTexture = function (t, e, n) {
    this.throwIfDisposed();
    var r = $t(e, n),
        o = r[0],
        a = r[1];
    this.setOutputMatrixTextureDriver(t, o, a);
  }, t.prototype.setOutputMatrixWriteRegion = function (t, e, n, r) {
    this.setOutputMatrixWriteRegionDriver(n, t, r, e);
  }, t.prototype.setOutputPackedMatrixWriteRegion = function (t, e, n, r) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }, t.prototype.debugValidate = function () {
    null != this.program && he(this.gl, this.debug, this.program), Re(this.gl);
  }, t.prototype.executeProgram = function () {
    this.throwIfDisposed(), this.throwIfNoProgram();
    var t = this.gl;
    this.debug && this.debugValidate(), Jt(t, this.debug, function () {
      return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0);
    });
  }, t.prototype.blockUntilAllProgramsCompleted = function () {
    var t = this;
    this.throwIfDisposed(), Jt(this.gl, this.debug, function () {
      return t.gl.finish();
    });
  }, t.prototype.getQueryTimerExtension = function () {
    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = re(this.gl, this.debug, 2 === i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }, t.prototype.getQueryTimerExtensionWebGL2 = function () {
    return this.getQueryTimerExtension();
  }, t.prototype.getQueryTimerExtensionWebGL1 = function () {
    return this.getQueryTimerExtension();
  }, t.prototype.beginQuery = function () {
    if (2 === i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t = this.gl,
          e = this.getQueryTimerExtensionWebGL2(),
          n = t.createQuery();
      return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;
    }

    var r = this.getQueryTimerExtensionWebGL1(),
        o = r.createQueryEXT();
    return r.beginQueryEXT(r.TIME_ELAPSED_EXT, o), o;
  }, t.prototype.endQuery = function () {
    if (2 !== i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t = this.getQueryTimerExtensionWebGL1();
      t.endQueryEXT(t.TIME_ELAPSED_EXT);
    } else {
      var e = this.gl,
          n = this.getQueryTimerExtensionWebGL2();
      e.endQuery(n.TIME_ELAPSED_EXT);
    }
  }, t.prototype.waitForQueryAndGetTime = function (t) {
    return n(this, void 0, void 0, function () {
      var e = this;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, F(function () {
              return e.disposed || e.isQueryAvailable(t, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
            })];

          case 1:
            return n.sent(), [2, this.getQueryTime(t, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];
        }
      });
    });
  }, t.prototype.getQueryTime = function (t, e) {
    if (0 === e) return null;

    if (2 === e) {
      var n = this.gl;
      return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;
    }

    var r = this.getQueryTimerExtensionWebGL1();
    return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6;
  }, t.prototype.isQueryAvailable = function (t, e) {
    if (0 === e) return !0;

    if (2 === e) {
      var n = this.gl,
          r = this.getQueryTimerExtensionWebGL2(),
          o = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);
      return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;
    }

    o = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT);
    return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;
  }, t.prototype.pollFence = function (t) {
    var e = this;
    return new Promise(function (n) {
      e.addItemToPoll(function () {
        return t.isFencePassed();
      }, function () {
        return n();
      });
    });
  }, t.prototype.pollItems = function () {
    for (var t = function (t) {
      for (var e = 0; e < t.length; ++e) {
        if (!t[e]()) break;
      }

      return e - 1;
    }(this.itemsToPoll.map(function (t) {
      return t.isDoneFn;
    })), e = 0; e <= t; ++e) {
      (0, this.itemsToPoll[e].resolveFn)();
    }

    this.itemsToPoll = this.itemsToPoll.slice(t + 1);
  }, t.prototype.addItemToPoll = function (t, e) {
    var n = this;
    this.itemsToPoll.push({
      isDoneFn: t,
      resolveFn: e
    }), this.itemsToPoll.length > 1 || F(function () {
      return n.pollItems(), 0 === n.itemsToPoll.length;
    });
  }, t.prototype.bindTextureToFrameBuffer = function (t) {
    this.throwIfDisposed(), Ce(this.gl, this.debug, t, this.framebuffer), this.debug && Re(this.gl);
  }, t.prototype.unbindTextureToFrameBuffer = function () {
    null != this.outputTexture ? (Ce(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Re(this.gl)) : Ee(this.gl, this.debug, this.framebuffer);
  }, t.prototype.downloadMatrixDriver = function (t, e) {
    this.bindTextureToFrameBuffer(t);
    var n = e();
    return this.unbindTextureToFrameBuffer(), n;
  }, t.prototype.setOutputMatrixTextureDriver = function (t, e, n) {
    this.throwIfDisposed();
    var r = this.gl;
    Ce(r, this.debug, t, this.framebuffer), this.debug && Re(r), this.outputTexture = t, Jt(r, this.debug, function () {
      return r.viewport(0, 0, e, n);
    }), Jt(r, this.debug, function () {
      return r.scissor(0, 0, e, n);
    });
  }, t.prototype.setOutputMatrixWriteRegionDriver = function (t, e, n, r) {
    var o = this;
    this.throwIfDisposed(), Jt(this.gl, this.debug, function () {
      return o.gl.scissor(t, e, n, r);
    });
  }, t.prototype.throwIfDisposed = function () {
    if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
  }, t.prototype.throwIfNoProgram = function () {
    if (null == this.program) throw new Error("No GPU program is currently set.");
  }, t;
}();

function Pi(t, e) {
  if (t.length !== e.length) throw Error("Binary was compiled with " + t.length + " inputs, but was executed with " + e.length + " inputs");
  t.forEach(function (t, n) {
    var r = t.logicalShape,
        o = e[n],
        a = o.shape;
    if (!S(r, a)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r + " and " + a + " must match");

    if (!t.isUniform || !o.isUniform) {
      var i = t.texShape,
          s = o.isUniform ? null : o.texData.texShape;
      if (!S(i, s)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + i + " and " + s + " must match");
    }
  });
}

var Li = function (t, e, n) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;

  for (var r = n.filterWidth, o = n.inChannels, a = n.strideWidth, i = n.strideHeight, s = n.padInfo, u = n.outWidth, c = n.dilationWidth, l = n.dilationHeight, h = n.dataFormat, f = s.left, d = s.top, p = o * r, v = ua(), m = "channelsLast" === h, g = m ? 0 : 1, y = m ? 1 : 2, x = "", b = 0; b <= 1; b++) for (var w = 0; w <= 1; w++) x += "\n          blockIndex = rc.y + " + w + ";\n          pos = rc.x + " + b + ";\n\n          if(blockIndex < " + t[1] + " && pos < " + t[0] + ") {\n            offsetY = int(blockIndex / (" + u + ")) * " + i + " - " + d + ";\n            d0 = offsetY + " + l + " * (pos / " + p + ");\n\n            if(d0 < " + e[g] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + u + ".) * " + a + ". - " + f + ".);\n              d1 = offsetX + " + c + " * (int(mod(float(pos), " + p + ".) / " + o + ".));\n\n              if(d1 < " + e[y] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + o + ".));\n\n                if (" + m + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * b + w) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * b + w) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";

  this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + x + "\n\n        " + v.output + " = result;\n      }\n    ";
},
    Wi = function (t, e, n, r, o) {
  this.variableNames = ["x"], this.outputShape = [];
  var a,
      i = e,
      s = t[3] - 1;
  this.outputShape = t;
  var u = "float(" + n + ") + float(" + r + ") * sum";
  a = .5 === o ? "inversesqrt(" + u + ")" : 1 === o ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + o + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + i + "; j <= " + i + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + s + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + a + ";\n        setOutput(val);\n      }\n    ";
},
    Ui = function (t, e, n, r, o) {
  this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = o, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r + ") * norm + float(" + n + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r + ")\n                * float(" + o + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + o + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
},
    Vi = function (t, e, n, r, o) {
  this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
  var a,
      i = e,
      s = t[3] - 1;
  this.outputShape = t;
  var u = "float(" + n + ") + float(" + r + ") * sum";
  a = .5 === o ? "inversesqrt(" + u + ")" : 1 === o ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + o + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + i + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + i + "; j <= " + i + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + s + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + a + ";\n        setOutput(result);\n      }\n    ";
},
    zi = function (t) {
  this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
  var e = t.strideHeight,
      n = t.strideWidth,
      r = t.dilationHeight,
      o = t.effectiveFilterHeight,
      a = t.effectiveFilterWidth,
      i = o - 1 - t.padInfo.top,
      s = a - 1 - t.padInfo.left,
      u = o * a - 1;
  this.userCode = "\n      const ivec2 pads = ivec2(" + i + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + o + ";\n          wR += " + r + ") {\n          float dyR = float(dyRCorner + wR) / " + e + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + a + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + u + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + a + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Gi = function (t) {
  this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
  var e = t.strideDepth,
      n = t.strideHeight,
      r = t.strideWidth,
      o = t.dilationDepth,
      a = t.dilationHeight,
      i = t.dilationWidth,
      s = t.effectiveFilterDepth,
      u = t.effectiveFilterHeight,
      c = t.effectiveFilterWidth,
      l = s - 1 - t.padInfo.front,
      h = u - 1 - t.padInfo.top,
      f = c - 1 - t.padInfo.left,
      d = s * u * c - 1;
  this.userCode = "\n      const ivec3 pads = ivec3(" + l + ", " + h + ", " + f + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + s + ";\n           wD += " + o + ") {\n          float dyD = float(dyDCorner + wD) / " + e + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + a + ") {\n            float dyR = float(dyRCorner + wR) / " + n + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + i + ") {\n              float dyC = float(dyCCorner + wC) / " + r + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + d + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + u + " * " + c + " +\n                  wR * " + c + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
},
    Hi = function (t, e, n, r, o, a, i) {
  void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === a && (a = null), void 0 === i && (i = !1), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
  var s = n ? t[1] : t[2],
      u = Math.ceil(s / 2),
      c = n ? "i * 2, rc.y" : "rc.y, i * 2",
      l = r ? "rc.z, i * 2" : "i * 2, rc.z",
      h = n ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
      f = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
      d = "",
      p = "";
  a && (d = i ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + a + "\n        }" : "vec4 activation(vec4 x) {\n          " + a + "\n        }", p = "result = activation(result);");
  var v = o ? "result += getBiasAtOutCoords();" : "";
  o && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + d + "\n\n      const float sharedDimension = " + u + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + u + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c + ");\n          vec4 b = getMatrixB(rc.x, " + l + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h[0] + " * " + f[0] + ");\n          result += (" + h[1] + " * " + f[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v + "\n\n        " + p + "\n\n        setOutput(result);\n      }\n    ";
},
    qi = function () {
  function t(t, e, n) {
    this.variableNames = ["probs"], this.outputShape = [t, n], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e - 1) + "));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    return function (n, r) {
      null == e.seedLoc && (e.seedLoc = n.getUniformLocation(r, "seed")), n.gl.uniform1f(e.seedLoc, t);
    };
  }, t;
}(),
    Ki = function (t, e, n, r) {
  this.variableNames = ["indices"], this.outputShape = [t, e], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r + "), float(" + n + "),\n                      float(index == coords.y)));\n      }\n    ";
},
    ji = function (t) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t;
  var e = t.length;
  if (0 === e) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else {
    var n = sa("rc", e),
        r = wa(e),
        o = function (t, e, n) {
      if (1 === t) return "rc > " + e[0];

      for (var r = "", o = t - 2; o < t; o++) r += n[o] + " >= " + e[o], o < t - 1 && (r += "||");

      return r;
    }(e, t, n),
        a = function (t, e, n, r) {
      if (1 === t) return "";
      var o = r.slice(-2);
      return "\n    int r = " + o[0] + ";\n    int c = " + o[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e + ";\n    bool rEdge = rp1 >= " + n + ";\n  ";
    }(e, t[t.length - 1], t[t.length - 2], n),
        i = function (t, e) {
      var n = t.length,
          r = function (t, e) {
        for (var n = [], r = 0; r <= 1; r++) for (var o = 0; o <= 1; o++) {
          for (var a = (0 === r ? "r" : "rp1") + ", " + (0 === o ? "c" : "cp1"), i = 2; i < t; i++) a = e[e.length - 1 - i] + "," + a;

          n.push(a);
        }

        return n;
      }(n, e);

      return 1 === n ? "getA(rc),\n            rc + 1 >= " + t[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r[0] + "),\n          cEdge ? 0. : getA(" + r[1] + "),\n          rEdge ? 0. : getA(" + r[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r[3] + ")";
    }(t, n);

    this.userCode = "\n        void main() {\n          " + r + " rc = getOutputCoords();\n\n          if(" + o + ") {\n            setOutput(vec4(0));\n          } else {\n            " + a + "\n\n            setOutput(vec4(" + i + "));\n          }\n        }\n      ";
  }
};

var Xi = function (t, e, n) {
  this.variableNames = ["x"], this.outputShape = e.map(function (e, n) {
    return e[0] + t[n] + e[1];
  });
  var r = t.length,
      o = wa(r),
      a = e.map(function (t) {
    return t[0];
  }).join(","),
      i = e.map(function (e, n) {
    return e[0] + t[n];
  }).join(","),
      s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
  this.userCode = 1 !== r ? "\n      " + o + " start = " + o + "(" + a + ");\n      " + o + " end = " + o + "(" + i + ");\n\n      void main() {\n        " + o + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n + "));\n        } else {\n          " + o + " coords = outC - start;\n          setOutput(getX(" + s + "));\n        }\n      }\n    " : "\n        int start = " + a + ";\n        int end = " + i + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
},
    Yi = function (t, e, n) {
  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map(function (e, n) {
    return e[0] + t[n] + e[1];
  });

  for (var r = t.length, o = wa(r), a = e.map(function (t) {
    return t[0];
  }).join(","), i = e.map(function (e, n) {
    return e[0] + t[n];
  }).join(","), s = sa("rc", r), u = sa("source", r), c = s[r - 1] + " < " + this.outputShape[r - 1], l = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")", h = [o + " rc = outputLoc;", s[r - 1] + " += 1;\n       if(" + c + ") {\n      ", 1 === r ? "" : "}\n       rc = outputLoc;\n       " + s[r - 2] + " += 1;\n       if(" + s[r - 2] + " < " + this.outputShape[r - 2] + ") {", 1 === r ? "" : "  " + s[r - 1] + " += 1;\n         if(" + c + ") {"], f = 1 === r ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", d = "", p = 0, v = 1 === r ? 2 : 4; p < v; p++) d += "\n        " + h[p] + "\n        if (" + f + ") {\n          result[" + p + "] = float(" + n + ");\n        } else {\n          " + o + " source = rc - start;\n          result[" + p + "] = getChannel(getX(" + u.join() + "), " + l + ");\n        }\n      ";

  d += 1 === r ? "} " : "}}", this.userCode = "\n      const " + o + " start = " + o + "(" + a + ");\n      const " + o + " end = " + o + "(" + i + ");\n\n      void main() {\n        " + o + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + d + "\n        setOutput(result);\n      }\n    ";
},
    $i = function (t, e, n) {
  if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
  var r = t.filterWidth,
      o = t.strideHeight,
      a = t.strideWidth,
      i = t.dilationHeight,
      s = t.dilationWidth,
      u = t.effectiveFilterHeight,
      c = t.effectiveFilterWidth,
      l = t.padInfo.top,
      h = t.padInfo.left;
  this.outputShape = t.outShape;
  var f = "avg" === e,
      d = "0.0";
  if (f || (d = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec2 strides = ivec2(" + o + ", " + a + ");\n        const ivec2 pads = ivec2(" + l + ", " + h + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + i + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + s + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else {
    var p = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    "avg" === e && (p = "avgValue / count");
    var v = 4 * Math.floor(r / 4),
        m = r % 4,
        g = "\n      if (" + f + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
    this.userCode = "\n      const ivec2 strides = ivec2(" + o + ", " + a + ");\n      const ivec2 pads = ivec2(" + l + ", " + h + ");\n      const float initializationValue = " + d + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + d + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + u + ";\n            wR += " + i + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v + "; wC += 4) {\n            int xC = xCCorner + wC * " + s + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              getValue(batch, xR, xC + 3 * " + s + ", d)\n            );\n\n            " + g + "\n          }\n\n          int xC = xCCorner + " + v + ";\n          if (" + (1 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (2 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (3 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              initializationValue\n            );\n\n            " + g + "\n          }\n        }\n        setOutput(" + p + ");\n      }\n    ";
  }
},
    Qi = function (t, e, n) {
  if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
  var r = t.filterWidth,
      o = t.strideDepth,
      a = t.strideHeight,
      i = t.strideWidth,
      s = t.dilationDepth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.effectiveFilterDepth,
      h = t.effectiveFilterHeight,
      f = t.effectiveFilterWidth,
      d = t.padInfo.front,
      p = t.padInfo.top,
      v = t.padInfo.left;
  this.outputShape = t.outShape;
  var m = "avg" === e,
      g = "0.0";
  if (m || (g = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + o + ", " + a + ", " + i + ");\n        const ivec3 pads = ivec3(" + d + ", " + p + ", " + v + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l + ";\n              wD += " + s + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h + ";\n                wR += " + u + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + f + ";\n                  wC += " + c + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h + " * " + f + " +\n                      wR * " + f + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else {
    var y = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    "avg" === e && (y = "avgValue / count");
    var x = 4 * Math.floor(r / 4),
        b = r % 4,
        w = "\n      if (" + m + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
    this.userCode = "\n      const ivec3 strides =\n        ivec3(" + o + ", " + a + ", " + i + ");\n      const ivec3 pads = ivec3(" + d + ", " + p + ", " + v + ");\n      const float initializationValue = " + g + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + s + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + ";\n            wR += " + u + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + x + "; wC += 4) {\n              int xC = xCCorner + wC * " + c + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c + ", ch)\n              );\n\n              " + w + "\n            }\n\n            int xC = xCCorner + " + x + ";\n            if (" + (1 === b) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (2 === b) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (3 === b) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                initializationValue\n              );\n\n              " + w + "\n            }\n          }\n          setOutput(" + y + ");\n        }\n      }\n    ";
  }
},
    Ji = function (t, e) {
  this.variableNames = ["x"];
  var n = t.windowSize,
      r = t.batchSize,
      o = t.inSize,
      a = Math.ceil(o / n);
  this.outputShape = [r, a];
  var i = "0.0",
      s = "";
  "prod" === e ? i = "1.0" : "min" === e ? (i = "1.0 / 1e-20", s = "min") : "max" === e && (i = "-1.0 / 1e-20", s = "max");
  var u = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
  "sum" === e ? u = "sumValue" : "prod" === e ? u = "prodValue" : "all" === e ? u = "allValue" : "any" === e && (u = "anyValue");
  var c = 4 * Math.floor(n / 4),
      l = n % 4,
      h = "\n      if (" + ("sum" === e) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + s + "(values, minMaxValue);\n      }\n    ",
      f = "vec4";
  "all" === e ? (i = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", f = "bvec4") : "any" === e && (i = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", f = "bvec4");
  var d = "";
  o % n > 0 && (d = "\n        if (inIdx < 0 || inIdx >= " + o + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + i + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + d + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n + ";\n\n        vec4 minMaxValue = vec4(" + i + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h + "\n        }\n\n        int inIdx = inOffset + " + c + ";\n        if (" + (1 === l) + ") {\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (2 === l) + ") {\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (3 === l) + ") {\n          " + f + " values = " + f + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h + "\n        }\n        setOutput(" + u + ");\n      }\n    ";
},
    Zi = function (t, e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;

  for (var n = "", r = 0; r < 4; r++) {
    var o = "thisRC = rc;";
    r % 2 == 1 && (o += "thisRC.z += 1;"), r > 1 && (o += "thisRC.y += 1;"), n += "\n        " + o + "\n        " + (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r > 0 ? "}" : "") + "\n      ";
  }

  this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + ca(["r", "c", "d"], e) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + la(t) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t[1] + ";\n        int cols = " + t[2] + ";\n\n        " + n + "\n\n        setOutput(result);\n      }\n    ";
};

var ts = function (t, e, n) {
  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
  var r = e.shape,
      o = r[1],
      a = r[2],
      i = t.shape,
      s = i[1],
      u = i[2],
      c = [n && s > 1 ? o - 1 : o, n && u > 1 ? a - 1 : a],
      l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
      h = c[0] / l[0],
      f = c[1] / l[1],
      d = 1 / h,
      p = 1 / f,
      v = 2 * Math.ceil(d) + 2,
      m = 2 * Math.ceil(p) + 2;
  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + f + ");\n\n        const float invHeightScale = float(" + d + ");\n        const float invWidthScale = float(" + p + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (o - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
},
    es = function (t, e, n, r) {
  this.variableNames = ["A"], this.outputShape = [];
  var o = t[0],
      a = t[1],
      i = t[2],
      s = t[3];
  this.outputShape = [o, e, n, s];
  var u = [r && e > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],
      c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
  this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + a + ".0, " + i + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
},
    ns = function (t, e, n, r) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
  var o = t[0],
      a = t[1],
      i = t[2],
      s = t[3];
  this.outputShape = [o, e, n, s];
  var u = [r && e > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],
      c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
  this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ",\n          " + u[1] / c[1] + ");\n      const vec3 inputShapeRC = vec3(" + a + ".0, " + i + ".0,\n                                     " + i + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (s - 1) + ";\n        bool hasNextRow = coords.z < " + (n - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
},
    rs = function (t, e, n) {
  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
  var r = e.shape,
      o = r[1],
      a = r[2],
      i = t.shape,
      s = i[1],
      u = i[2],
      c = [n && s > 1 ? o - 1 : o, n && u > 1 ? a - 1 : a],
      l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
      h = c[0] / l[0],
      f = c[1] / l[1],
      d = 1 / h,
      p = 1 / f,
      v = 2 * Math.ceil(d) + 2,
      m = 2 * Math.ceil(p) + 2;
  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + f + ");\n\n        const float invHeightScale = float(" + d + ");\n        const float invWidthScale = float(" + p + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c[0] + ") *\n                (float(dyR) / float(" + l[0] + "));\n\n            float sourceFracCol =\n                float(" + c[1] + ") *\n                  (float(dyC) / float(" + l[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + o + ") - 1),\n                " + n + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a + ") - 1),\n                " + n + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
},
    os = function (t, e, n, r) {
  this.variableNames = ["A"], this.outputShape = [];
  var o = t[0],
      a = t[1],
      i = t[2],
      s = t[3];
  this.outputShape = [o, e, n, s];
  var u = [r && e > 1 ? a - 1 : a, r && n > 1 ? i - 1 : i],
      c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],
      l = r ? "0.5" : "0.0";
  this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + a + ".0, " + i + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
},
    as = function (t, e) {
  this.variableNames = ["x"];
  var n = t.length;
  if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");

  if (this.outputShape = t, 1 !== n) {
    var r = t.map(function (n, r) {
      return function (n) {
        return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - coords[" + n + "] - 1" : "coords[" + n + "]";
      }(r);
    }).join(","),
        o = wa(n);
    this.userCode = "\n      void main() {\n        " + o + " coords = getOutputCoords();\n        setOutput(getX(" + r + "));\n      }\n    ";
  } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t[0] + " - coord - 1));\n        }\n      ";
},
    is = function (t, e) {
  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
  var n = t.length;
  if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
  this.outputShape = t;
  var r = sa("rc", n),
      o = r[n - 1] + " + 1 < " + this.outputShape[n - 1],
      a = r[n - 2] + " + 1 < " + this.outputShape[n - 2],
      i = wa(n);

  function s(n) {
    var r = t.map(function (r, o) {
      return function (n, r) {
        return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - " + r[n] + " - 1" : "" + r[n];
      }(o, n);
    });
    return "getChannel(getX(" + r.join(",") + "), vec2(" + r.slice(-2).join(",") + "))";
  }

  this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t[0] + " - rc - 1),\n            " + t[0] + " - rc - 1);\n          if(" + o + "){\n              result.g = getChannel(getX(" + t[0] + " - (rc  + 1) - 1),\n                " + t[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + i + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + function (t) {
    return s(t);
  }(r.slice()) + ";\n          if(" + o + "){\n            result.g = " + function (t) {
    return t[n - 1] = "(" + t[n - 1] + " + 1)", s(t);
  }(r.slice()) + ";\n          }\n          if(" + a + ") {\n            result.b = " + function (t) {
    return t[n - 2] = "(" + t[n - 2] + " + 1)", s(t);
  }(r.slice()) + ";\n            if(" + o + ") {\n              result.a = " + function (t) {
    return t[n - 1] = "(" + t[n - 1] + " + 1)", t[n - 2] = "(" + t[n - 2] + " + 1)", s(t);
  }(r.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
},
    ss = function (t, e, n, r, o, a, i) {
  void 0 === i && (i = !0), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a;
  var s = wa(o.length),
      u = wa(a.length),
      c = "";
  1 === n ? c = "i" : 2 === n && (c = "i, j");
  var l = "getIndices(" + c + ")",
      h = "";
  1 === r ? h = "i" : 2 === r && (h = "i, coords[1]");
  var f = "getUpdates(" + h + ")",
      d = e > 1 ? "strides[j]" : "strides";
  this.userCode = "\n        " + s + " strides = " + s + "(" + o + ");\n\n        void main() {\n          " + u + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e + "; j++) {\n              int index = round(" + l + ");\n              flattenedIndex += index * " + d + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + f + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
},
    us = function (t, e) {
  this.variableNames = ["x", "segmentIds"];
  var n = t.windowSize,
      r = t.batchSize,
      o = t.inSize,
      a = t.numSegments,
      i = a * Math.ceil(o / n);
  this.outputShape = [r, i];
  var s = 4 * Math.floor(n / 4),
      u = n % 4,
      c = "\n        sumValue += dot(values, segFilter);\n    ",
      l = "";
  o % n > 0 && (l = "\n        if (inIdx < 0 || inIdx >= " + o + ") {\n          return initializationValue;\n        }\n      ");
  var h = "";
  o % n > 0 && (h = "\n        if (inIdx < 0 || inIdx >= " + o + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + a + ")) * float(" + n + "));\n        int currentSeg = int(mod(float(outIdx), float(" + a + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + s + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c + "\n        }\n\n        int inIdx = inOffset + " + s + ";\n        if (" + (1 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c + "\n        } else if (" + (2 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c + "\n        } else if (" + (3 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c + "\n        }\n        setOutput(sumValue);\n      }\n    ";
},
    cs = function (t, e, n) {
  var r, o;
  if (this.variableNames = ["c", "a", "b"], this.outputShape = e, n > 4) throw Error("Where for rank " + n + " is not yet supported");
  if (1 === n) o = "resRC", r = "resRC";else {
    for (var a = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i = [], s = [], u = 0; u < e.length; u++) s.push("" + a[u]), u < t && i.push("" + a[u]);

    r = i.join(), o = s.join();
  }
  var c = wa(n);
  this.userCode = "\n      void main() {\n        " + c + " resRC = getOutputCoords();\n        float cVal = getC(" + r + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + o + "));\n        } else {\n          setOutput(getB(" + o + "));\n        }\n      }\n    ";
},
    ls = function () {
  function t(t) {
    this.variableNames = ["source"], this.outputShape = t, this.rank = t.length;

    var e,
        n = wa(this.rank),
        r = "uniform int start[" + this.rank + "];",
        o = function (t) {
      if (1 === t) return "sourceLoc";
      if (t <= 6) return hs.slice(0, t).map(function (t) {
        return "sourceLoc." + t;
      }).join(",");
      throw Error("Slicing for rank " + t + " is not yet supported");
    }(this.rank);

    e = "\n        " + n + " sourceLoc;\n        " + n + " coords = getOutputCoords();\n        " + t.map(function (t, e) {
      return "sourceLoc." + hs[e] + " = start[" + e + "] + coords." + hs[e] + ";";
    }).join("\n") + "\n      ", this.userCode = "\n      " + r + "\n      void main() {\n        " + e + "\n        setOutput(getSource(" + o + "));\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
    return function (n, r) {
      null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);
    };
  }, t;
}(),
    hs = ["x", "y", "z", "w", "u", "v"];

var fs = function () {
  function t(t) {
    this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length;
    var e = wa(this.rank),
        n = sa("coords", this.rank),
        r = sa("sourceLoc", this.rank),
        o = 1 === this.rank ? "sourceLoc" : "vec2(" + r.slice(-2).join() + ")",
        a = "getChannel(getSource(" + r.join() + "), " + o + ")",
        i = "\n      result.x = " + a + ";\n      if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n        ++" + r[this.rank - 1] + ";\n        result.y = " + a + ";\n        --" + r[this.rank - 1] + ";\n      }\n    ",
        s = 1 === this.rank ? "" : "\n      --" + n[this.rank - 1] + ";\n      if (++" + n[this.rank - 2] + " < " + t[this.rank - 2] + ") {\n        ++" + r[this.rank - 2] + ";\n        result.z = " + a + ";\n        if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n          ++" + r[this.rank - 1] + ";\n          result.w = " + a + ";\n        }\n      }\n    ",
        u = this.rank <= 4 ? "sourceLoc = coords +\n            " + e + "(" + t.map(function (t, e) {
      return "start[" + e + "]";
    }).join() + ");" : t.map(function (t, e) {
      return r[e] + " = " + n[e] + " + start[" + e + "];";
    }).join("\n");
    this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e + " coords = getOutputCoords();\n        " + e + " sourceLoc;\n        " + u + "\n        vec4 result = vec4(0.);\n        " + i + "\n        " + s + "\n        setOutput(result);\n      }\n    ";
  }

  return t.prototype.getCustomSetupFunc = function (t) {
    var e = this;
    if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
    return function (n, r) {
      null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);
    };
  }, t;
}(),
    ds = function (t, e, n) {
  this.variableNames = ["x"], this.outputShape = n;
  var r = n.length,
      o = wa(n.length),
      a = wa(n.length),
      i = "";
  if (1 === r) i = "coords * strides + begin";else {
    var s = 0;
    i = n.map(function (t, e) {
      return s++, 1 === n.length ? "coords * strides[" + e + "] + begin[" + e + "]" : "coords[" + (s - 1) + "] * strides[" + e + "] + begin[" + e + "]";
    }).join(",");
  }
  this.userCode = "\n      " + o + " begin = " + o + "(" + t + ");\n      " + o + " strides = " + o + "(" + e + ");\n\n      void main() {\n        " + a + " coords = getOutputCoords();\n        setOutput(getX(" + i + "));\n      }\n    ";
},
    ps = function () {
  function t(t) {
    this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};
  }

  return t.prototype.acquireTexture = function (t, e, n) {
    var r,
        o = vs(e, n),
        a = ms(t, o, n);

    if (a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []), this.freeTextures[a].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this.log();
      var i = this.freeTextures[a].shift();
      return this.usedTextures[a].push(i), i;
    }

    return this.numUsedTextures++, this.log(), o === Gt.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === Gt.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === Gt.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === Gt.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === Gt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[a].push(r), r;
  }, t.prototype.releaseTexture = function (t, e, n, r) {
    if (null != this.freeTextures) {
      var o = ms(e, vs(n, r), r);
      o in this.freeTextures || (this.freeTextures[o] = []), this.freeTextures[o].push(t), this.numFreeTextures++, this.numUsedTextures--;
      var a = this.usedTextures[o],
          i = a.indexOf(t);
      if (i < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      a.splice(i, 1), this.log();
    }
  }, t.prototype.log = function () {
    if (this.logEnabled) {
      var t = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t + ")");
    }
  }, t.prototype.getNumUsedTextures = function () {
    return this.numUsedTextures;
  }, t.prototype.getNumFreeTextures = function () {
    return this.numFreeTextures;
  }, t.prototype.dispose = function () {
    var t = this;

    if (null != this.freeTextures) {
      for (var e in this.freeTextures) this.freeTextures[e].forEach(function (e) {
        t.gpgpu.deleteMatrixTexture(e);
      });

      for (var e in this.usedTextures) this.usedTextures[e].forEach(function (e) {
        t.gpgpu.deleteMatrixTexture(e);
      });

      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
    }
  }, t;
}();

function vs(t, e) {
  if (t === zt.UPLOAD) return Gt.PACKED_2X2_FLOAT32;
  if (t === zt.RENDER || null == t) return function (t) {
    return i().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? Gt.PACKED_2X2_FLOAT32 : Gt.UNPACKED_FLOAT32 : t ? Gt.PACKED_2X2_FLOAT16 : Gt.UNPACKED_FLOAT16;
  }(e);
  if (t === zt.DOWNLOAD || t === zt.PIXELS) return Gt.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type " + t);
}

function ms(t, e, n) {
  return t[0] + "_" + t[1] + "_" + e + "_" + n;
}

var gs = function (t, e) {
  this.variableNames = ["A"];

  for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[r] * e[r];

  this.outputShape = n, this.rank = n.length;

  var o = wa(this.rank),
      a = function (t) {
    var e = t.length;
    if (e > 5) throw Error("Tile for rank " + e + " is not yet supported");
    if (1 === e) return "imod(resRC, " + t[0] + ")";

    for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r = [], o = 0; o < t.length; o++) r.push("imod(" + n[o] + ", " + t[o] + ")");

    return r.join();
  }(t);

  this.userCode = "\n      void main() {\n        " + o + " resRC = getOutputCoords();\n        setOutput(getA(" + a + "));\n      }\n    ";
};

var ys = function (t, e) {
  this.variableNames = ["A"];

  for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];

  this.outputShape = n, this.rank = n.length;

  var o = wa(this.rank),
      a = function (t) {
    var e = t.length;
    if (e > 6) throw Error("Transpose for rank " + e + " is not yet supported");

    for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r = new Array(e), o = 0; o < t.length; o++) r[t[o]] = n[o];

    return r.join();
  }(e);

  this.userCode = "\n    void main() {\n      " + o + " resRC = getOutputCoords();\n      setOutput(getA(" + a + "));\n    }\n    ";
};

var xs = function (t, e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;

  for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];

  if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
  var o = wa(this.rank),
      a = ia("rc", this.rank),
      i = new Array(this.rank);

  for (r = 0; r < e.length; r++) i[e[r]] = a[r];

  var s = "vec2(" + i.slice(-2).join() + ")",
      u = "++" + a[this.rank - 1] + " < " + n[this.rank - 1],
      c = "getChannel(getA(" + i.join() + "), " + s + ")";
  this.userCode = "\n    void main() {\n      " + o + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c + ";\n      if(" + u + ") {\n        result[1] = " + c + ";\n      }\n      --" + a[this.rank - 1] + ";\n      if(++" + a[this.rank - 2] + " < " + n[this.rank - 2] + ") {\n        result[2] = " + c + ";\n        if(" + u + ") {\n          result[3] = " + c + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
},
    bs = 1.7580993408473768,
    ws = 1.0507009873554805,
    Cs = function (t, e) {
  this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      float unaryOperation(float x) {\n        " + e + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
},
    Es = "if (isnan(x)) return x;",
    Rs = "return x;",
    Is = "return abs(x);",
    ks = Es + "\n  return (x < 0.0) ? 0.0 : x;\n",
    Ss = Es + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
    As = "return (x >= 0.0) ? x : (exp(x) - 1.0);",
    Ds = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + bs + ";\n  float scale = " + ws + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";

var Ts = "return -x;",
    Ns = "return ceil(x);",
    Fs = "return floor(x);",
    _s = "return exp(x);",
    Os = "return exp(x) - 1.0;",
    Ms = Es + "\n  return sin(x);\n",
    Bs = Es + "\n  return cos(x);\n",
    Ps = Es + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",
    Ls = Es + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",
    Ws = Es + "\n  return atan(x);\n",
    Us = Es + "return log(x + sqrt(x * x + 1.0));",
    Vs = Es + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",
    zs = Es + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",
    Gs = "return x;",
    Hs = "return x;",
    qs = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    Ks = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    js = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
    Xs = function (t, e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
},
    Ys = function (t) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t;

  var e = t.length,
      n = sa("rc", e),
      r = wa(e),
      o = function (t, e) {
    if (1 === t) return "rc";

    for (var n = "", r = 0; r < t; r++) n += e[r], r < t - 1 && (n += ",");

    return n;
  }(e, n),
      a = n.slice(-2),
      i = e <= 1 ? "rc" : "vec2(" + a.join(",") + ")";

  this.userCode = "\n      void main() {\n        " + r + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + o + ");\n\n        setOutput(getChannel(packedInput, " + i + "));\n      }\n    ";
},
    $s = {};

function Qs(t, e) {
  if (void 0 === e && (e = !1), "linear" === t) return e ? Hs : Rs;
  if ("relu" === t) return e ? qs : ks;
  if ("elu" === t) return e ? js : As;
  if ("relu6" === t) return e ? Ks : Ss;
  if ("prelu" === t) return e ? Pa : Ma;
  throw new Error("Activation " + t + " has not been implemented for the WebGL backend.");
}

var Js = 600;

var Zs = function (t) {
  function o(e) {
    var n,
        r = t.call(this) || this;
    if (r.pendingRead = new WeakMap(), r.pendingDisposal = new WeakSet(), r.dataRefCount = new WeakMap(), r.numBytesInGPU = 0, r.uploadWaitMs = 0, r.downloadWaitMs = 0, r.warnedAboutMemory = !1, r.pendingDeletes = 0, r.disposed = !1, !i().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");

    if (null == e) {
      var o = jt(i().getNumber("WEBGL_VERSION"));
      r.binaryCache = (n = i().getNumber("WEBGL_VERSION")) in $s ? $s[n] : ($s[n] = {}, $s[n]), r.gpgpu = new Bi(o), r.canvas = o.canvas, r.gpgpuCreatedLocally = !0;
    } else r.gpgpu = e, r.binaryCache = {}, r.gpgpuCreatedLocally = !1, r.canvas = e.gl.canvas;

    return r.textureManager = new ps(r.gpgpu), r.numMBBeforeWarning = null == i().global.screen ? 1024 : i().global.screen.height * i().global.screen.width * window.devicePixelRatio * Js / 1024 / 1024, r.texData = new xo(r, Lt), r;
  }

  return e(o, t), o.prototype.numDataIds = function () {
    return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
  }, o.prototype.write = function (t, e, n) {
    if (i().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === n && null != t) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    var r = {};
    return this.texData.set(r, {
      shape: e,
      dtype: n,
      values: t,
      usage: zt.UPLOAD
    }), r;
  }, o.prototype.move = function (t, e, n, r) {
    if (i().getBool("DEBUG") && this.checkNumericalProblems(e), "complex64" === r) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(t, {
      shape: n,
      dtype: r,
      values: e,
      usage: zt.UPLOAD
    });
  }, o.prototype.readSync = function (t) {
    var e = this.texData.get(t),
        n = e.values,
        r = e.dtype,
        o = e.complexTensors,
        a = e.slice,
        i = e.shape,
        s = e.isPacked;

    if (null != a) {
      var u = void 0;
      u = s ? new Xs(i, Gs) : new Cs(i, Gs);
      var c = this.runWebGLProgram(u, [{
        dataId: t,
        shape: i,
        dtype: r
      }], r),
          l = this.readSync(c.dataId);
      return this.disposeData(c.dataId), l;
    }

    if (null != n) return this.convertAndCacheOnCPU(t);
    if ("string" === r) return n;
    var h,
        f,
        d = null != this.activeTimers;
    (d && (h = et()), "complex64" === r) ? f = Vo(o.real.dataSync(), o.imag.dataSync()) : f = this.getValuesFromTexture(t);
    return d && (this.downloadWaitMs += et() - h), this.convertAndCacheOnCPU(t, f);
  }, o.prototype.read = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, s, u, c, l, h, f, d, p, v, m, g, y, x, b, w, C, E, R;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (this.pendingRead.has(t)) return e = this.pendingRead.get(t), [2, new Promise(function (t) {
              return e.push(t);
            })];
            if (n = this.texData.get(t), o = n.values, a = n.shape, s = n.slice, u = n.dtype, c = n.complexTensors, l = n.isPacked, null != s) return h = void 0, h = l ? new Xs(a, Gs) : new Cs(a, Gs), f = this.runWebGLProgram(h, [{
              dataId: t,
              shape: a,
              dtype: u
            }], u), d = this.read(f.dataId), this.disposeData(f.dataId), [2, d];
            if (null != o) return [2, this.convertAndCacheOnCPU(t)];
            if (!i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === i().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
            return p = null, "complex64" !== u && i().get("WEBGL_BUFFER_SUPPORTED") && (v = this.decode(t), m = this.texData.get(v.dataId), p = (R = this.gpgpu).createBufferFromTexture.apply(R, [m.texture].concat(Yt(a)))), this.pendingRead.set(t, []), "complex64" === u ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];

          case 1:
            r.sent(), r.label = 2;

          case 2:
            return "complex64" !== u ? [3, 4] : [4, Promise.all([c.real.data(), c.imag.data()])];

          case 3:
            return y = r.sent(), x = y[0], b = y[1], g = Vo(x, b), [3, 5];

          case 4:
            null == p ? g = this.getValuesFromTexture(t) : (w = k(a), g = this.gpgpu.downloadFloat32MatrixFromBuffer(p, w)), r.label = 5;

          case 5:
            return null != v && this.disposeData(v.dataId), C = this.convertAndCacheOnCPU(t, g), E = this.pendingRead.get(t), this.pendingRead.delete(t), E.forEach(function (t) {
              return t(C);
            }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [2, C];
        }
      });
    });
  }, o.prototype.checkNumericalProblems = function (t) {
    if (null != t) for (var e = 0; e < t.length; e++) {
      var n = t[e];

      if (!ee(n)) {
        if (i().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
        throw Error("The value " + n + " cannot be represented on this device.");
      }
    }
  }, o.prototype.getValuesFromTexture = function (t) {
    var e,
        n = this.texData.get(t),
        r = n.shape,
        o = n.dtype,
        a = n.isPacked,
        s = k(r);

    if (i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      var u = this.decode(t),
          c = this.texData.get(u.dataId),
          l = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [c.texture].concat(Yt(r))).subarray(0, s);
      return this.disposeData(u.dataId), l;
    }

    var h = i().getBool("WEBGL_PACK") && !0 === a,
        f = h ? Te(r) : r,
        d = h ? new ci(f) : new ui(f),
        p = this.runWebGLProgram(d, [{
      shape: f,
      dtype: o,
      dataId: t
    }], "float32"),
        v = this.texData.get(p.dataId),
        m = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture, v.texShape[0], v.texShape[1]).subarray(0, s);
    return this.disposeData(p.dataId), m;
  }, o.prototype.time = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, s, u, c;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return e = this.activeTimers, n = [], o = !1, null == this.programTimersStack ? (this.programTimersStack = n, o = !0) : this.activeTimers.push(n), this.activeTimers = n, t(), a = I(this.activeTimers.map(function (t) {
              return t.query;
            })).filter(function (t) {
              return null != t;
            }), s = I(this.activeTimers.map(function (t) {
              return t.name;
            })).filter(function (t) {
              return null != t;
            }), this.activeTimers = e, o && (this.programTimersStack = null), u = {
              uploadWaitMs: this.uploadWaitMs,
              downloadWaitMs: this.downloadWaitMs,
              kernelMs: null,
              wallMs: null
            }, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [4, Promise.all(a)] : [3, 2];

          case 1:
            return c = r.sent(), u.kernelMs = w(c), u.getExtraProfileInfo = function () {
              return c.map(function (t, e) {
                return {
                  name: s[e],
                  ms: t
                };
              }).map(function (t) {
                return t.name + ": " + t.ms;
              }).join(", ");
            }, [3, 3];

          case 2:
            u.kernelMs = {
              error: "WebGL query timers are not supported in this environment."
            }, r.label = 3;

          case 3:
            return this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, u];
        }
      });
    });
  }, o.prototype.memory = function () {
    return {
      unreliable: !1,
      numBytesInGPU: this.numBytesInGPU
    };
  }, o.prototype.startTimer = function () {
    return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
      startMs: et(),
      endMs: null
    };
  }, o.prototype.endTimer = function (t) {
    return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = et(), t);
  }, o.prototype.getQueryTime = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t)] : [2, (e = t).endMs - e.startMs];
      });
    });
  }, o.prototype.disposeData = function (t) {
    if (!this.pendingDisposal.has(t)) {
      if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;

      if (this.texData.has(t)) {
        this.releaseGPUData(t);
        var e = this.texData.get(t).complexTensors;
        null != e && (e.real.dispose(), e.imag.dispose()), this.texData.delete(t);
      }
    }
  }, o.prototype.releaseGPUData = function (t) {
    var e = this.texData.get(t),
        n = e.texture,
        r = e.dtype,
        o = e.texShape,
        a = e.usage,
        i = e.isPacked,
        s = e.slice,
        u = s && s.origDataId || t,
        c = this.dataRefCount.get(u);
    c > 1 ? this.dataRefCount.set(u, c - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(o, r), this.textureManager.releaseTexture(n, o, a, i)));
    var l = this.texData.get(t);
    l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null;
  }, o.prototype.getTexture = function (t) {
    return this.uploadToGPU(t), this.texData.get(t).texture;
  }, o.prototype.getDataInfo = function (t) {
    return this.texData.get(t);
  }, o.prototype.getCPUBackend = function () {
    return i().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Lt.findBackend("cpu")), this.cpuBackend) : null;
  }, o.prototype.shouldExecuteOnCPU = function (t, e) {
    var n = this;
    return void 0 === e && (e = 128), null != this.getCPUBackend() && t.every(function (t) {
      return null == n.texData.get(t.dataId).texture && t.size < e;
    });
  }, o.prototype.getGPGPUContext = function () {
    return this.gpgpu;
  }, o.prototype.complex = function (t, e) {
    var n = this.makeOutput(t.shape, "complex64");
    return this.texData.get(n.dataId).complexTensors = {
      real: Lt.keep(t.clone()),
      imag: Lt.keep(e.clone())
    }, n;
  }, o.prototype.real = function (t) {
    return this.texData.get(t.dataId).complexTensors.real.clone();
  }, o.prototype.imag = function (t) {
    return this.texData.get(t.dataId).complexTensors.imag.clone();
  }, o.prototype.slice = function (t, e, n) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, e, n);
    if (0 === k(n)) return Fn([], n, t.dtype);
    var r = this.texData.get(t.dataId).isPacked,
        o = io(t.shape, e, n);

    if (r || !o) {
      var a = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new fs(n) : new ls(n),
          s = a.getCustomSetupFunc(e);
      return this.compileAndRun(a, [t], null, s);
    }

    return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n);
  }, o.prototype.shallowSlice = function (t, e, n) {
    var r = this.texData.get(t.dataId),
        o = this.makeOutput(n, t.dtype),
        a = this.texData.get(o.dataId);
    Object.assign(a, r), a.shape = n, a.dtype = t.dtype;
    var i = so(e, t.strides);
    r.slice && (i += r.slice.flatOffset), a.slice = {
      flatOffset: i,
      origDataId: r.slice && r.slice.origDataId || t.dataId
    };
    var s = this.dataRefCount.get(a.slice.origDataId) || 1;
    return this.dataRefCount.set(a.slice.origDataId, s + 1), o;
  }, o.prototype.stridedSlice = function (t, e, n, r) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, e, n, r);
    var o = ro(e, n, r);
    if (o.some(function (t) {
      return 0 === t;
    })) return Fn([], o);
    var a = new ds(e, r, o);
    return this.compileAndRun(a, [t]);
  }, o.prototype.reverse = function (t, e) {
    var n = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new is(t.shape, e) : new as(t.shape, e);
    return this.compileAndRun(n, [t]);
  }, o.prototype.concat = function (t, e) {
    if ("complex64" === t[0].dtype) {
      var n = t.map(function (t) {
        return Tn(t);
      }),
          r = t.map(function (t) {
        return Nn(t);
      });
      return Dn(this.concat(n, e), this.concat(r, e));
    }

    if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);
    if (1 === t.length) return t[0];

    if (t.length > i().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var o = Math.floor(t.length / 2),
          a = this.concat(t.slice(0, o), e),
          s = this.concat(t.slice(o), e);
      return this.concat([a, s], e);
    }

    if (i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
      var u = new Ga(t.map(function (t) {
        return t.shape;
      }), e);
      return this.compileAndRun(u, t);
    }

    var c = Sn(t.map(function (t) {
      return t.shape;
    }), e),
        l = t.map(function (t) {
      return t.as2D(-1, k(t.shape.slice(e)));
    }),
        h = new za(l.map(function (t) {
      return t.shape;
    }));
    return this.compileAndRun(h, l).reshape(c);
  }, o.prototype.neg = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ts, t.dtype);
    var e = new Cs(t.shape, Ts);
    return this.compileAndRun(e, [t]);
  }, o.prototype.batchMatMul = function (t, e, n, r) {
    var o = n ? t.shape[2] : t.shape[1],
        a = r ? e.shape[1] : e.shape[2],
        i = n ? t.shape[1] : t.shape[2],
        s = t.shape[0];

    if ((1 === o || 1 === a) && i > 1e3) {
      n && (t = t.transpose([0, 2, 1])), r && (e = e.transpose([0, 2, 1]));
      var u = 1 === a ? t : t.as3D(s, i, 1),
          c = 1 === a ? 2 : 1,
          l = 1 === a ? e.as3D(s, 1, i) : e;
      return this.multiply(u, l).sum(c, !0);
    }

    var h = Dt(t.dtype, e.dtype),
        f = new Hi(t.shape, [s, o, a], n, r);
    return this.compileAndRun(f, [t, e], h);
  }, o.prototype.fusedBatchMatMul = function (t) {
    var e = t.a,
        n = t.b,
        r = t.transposeA,
        o = t.transposeB,
        a = t.bias,
        i = t.activation,
        s = t.preluActivationWeights,
        u = r ? e.shape[2] : e.shape[1],
        c = o ? n.shape[1] : n.shape[2],
        l = e.shape[0],
        h = Dt(e.dtype, n.dtype),
        f = null != a,
        d = null != s,
        p = i ? Qs(i, !0) : null,
        v = new Hi(e.shape, [l, u, c], r, o, f, p, d),
        m = [e, n];
    return a && m.push(a), s && m.push(s), this.compileAndRun(v, m, h);
  }, o.prototype.multiply = function (t, e) {
    if ("complex64" === t.dtype) {
      var n = this.texData.get(t.dataId),
          r = this.texData.get(e.dataId),
          o = new Na(Da, t.shape, e.shape),
          a = new Na(Ta, t.shape, e.shape),
          s = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag), this.makeComplexComponentTensorInfo(e, r.complexTensors.real), this.makeComplexComponentTensorInfo(e, r.complexTensors.imag)],
          u = this.compileAndRun(o, s),
          c = this.compileAndRun(a, s),
          l = this.complex(u, c);
      return u.dispose(), c.dispose(), l;
    }

    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.multiply(t, e);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, Oa, t.dtype);
    var h = new Ba(Oa, t.shape, e.shape);
    return this.compileAndRun(h, [t, e], t.dtype);
  }, o.prototype.batchNormalization = function (t, e, n, r, o, a) {
    var s = [t, e, n],
        u = null;
    null != a && (u = a.shape, s.push(a));
    var c = null;

    if (null != o && (c = o.shape, s.push(o)), i().getBool("WEBGL_PACK_NORMALIZATION")) {
      var l = new Aa(t.shape, e.shape, n.shape, u, c, r);
      return this.compileAndRun(l, s);
    }

    var h = new Sa(t.shape, e.shape, n.shape, u, c, r);
    return this.compileAndRun(h, s);
  }, o.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
    var a = i().getBool("WEBGL_PACK_NORMALIZATION") ? new Vi(t.shape, e, n, r, o) : new Wi(t.shape, e, n, r, o);
    return this.compileAndRun(a, [t]);
  }, o.prototype.LRNGrad = function (t, e, n, r, o, a, i) {
    var s = new Ui(e.shape, r, o, a, i);
    return this.compileAndRun(s, [e, n, t]);
  }, o.prototype.tile = function (t, e) {
    if ("string" === t.dtype) {
      var n = this.readSync(t.dataId).map(function (t) {
        return ot(t);
      });
      return ta(dr(t.shape, t.dtype, n), e);
    }

    var r = new gs(t.shape, e);
    return this.compileAndRun(r, [t]);
  }, o.prototype.pad = function (t, e, n) {
    var r = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Yi(t.shape, e, n) : new Xi(t.shape, e, n);
    return this.compileAndRun(r, [t]);
  }, o.prototype.transpose = function (t, e) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.transpose(t, e);
    var n = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new xs(t.shape, e) : new ys(t.shape, e);
    return this.compileAndRun(n, [t]);
  }, o.prototype.gather = function (t, e, n) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.gather(t, e, n);
    var r = new mi(t.shape, e.size, n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.batchToSpaceND = function (t, e, n) {
    C(t.rank <= 4, function () {
      return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = zr(t.shape, e, r),
        a = Gr(o.length, e.length),
        i = Hr(t.shape, e, r),
        s = qr(n, e.length),
        u = Kr(i, n, e.length);
    return t.reshape(o).transpose(a).reshape(i).slice(s, u);
  }, o.prototype.spaceToBatchND = function (t, e, n) {
    C(t.rank <= 4, function () {
      return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = [[0, 0]];
    o.push.apply(o, n);

    for (var a = 1 + e.length; a < t.shape.length; ++a) o.push([0, 0]);

    var i = t.pad(o),
        s = zr(i.shape, e, r, !1),
        u = Gr(s.length, e.length, !1),
        c = Hr(i.shape, e, r, !1);
    return i.reshape(s).transpose(u).reshape(c);
  }, o.prototype.reduce = function (t, e, n) {
    var r = t.shape[0],
        o = t.shape[1],
        a = $r(o),
        i = new Ji({
      windowSize: a,
      inSize: o,
      batchSize: r
    }, e),
        s = this.compileAndRun(i, [t], n);
    return 1 === s.shape[1] ? s : this.reduce(s, e, n);
  }, o.prototype.argReduce = function (t, e, n) {
    void 0 === n && (n = null);
    var r = t.shape[0],
        o = t.shape[1];
    null != n && (r = n.shape[0], o = n.shape[1]);
    var a = $r(o),
        i = new aa({
      windowSize: a,
      inSize: o,
      batchSize: r
    }, e, null == n),
        s = [t];
    null != n && s.push(n);
    var u = this.compileAndRun(i, s, "int32");
    return 1 === u.shape[1] ? u : this.argReduce(t, e, u);
  }, o.prototype.argReducePacked = function (t, e, n) {
    void 0 === n && (n = null);
    var r = null != n ? n.shape : t.shape,
        o = $r(r[r.length - 1]),
        a = new Ra(r, o, e, null == n),
        i = null == n ? [t] : [t, n],
        s = this.compileAndRun(a, i, "int32");
    return s.rank === t.rank ? this.argReducePacked(t, e, s) : s;
  }, o.prototype.sum = function (t, e) {
    Cn("sum", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o),
        i = Tt(t.dtype);
    return this.reduce(a, "sum", i).reshape(r);
  }, o.prototype.prod = function (t, e) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, e);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o),
        i = Tt(t.dtype);
    return this.reduce(a, "prod", i).reshape(r);
  }, o.prototype.unsortedSegmentSum = function (t, e, n) {
    var r = 0,
        o = En([r], t.rank),
        a = t;
    null != o && (a = t.transpose(o), r = In(1, t.rank)[0]);

    var i = function (t, e, n) {
      for (var r = [], o = t.length, a = 0; a < o; a++) a !== e ? r.push(t[a]) : r.push(n);

      return r;
    }(a.shape, r, n),
        s = k([a.shape[r]]),
        u = a.as2D(-1, s),
        c = Tt(t.dtype),
        l = this.segOpCompute(u, "unsortedSegmentSum", e, c, n).reshape(i);

    return null != o && (l = l.transpose(Rn(o))), l;
  }, o.prototype.segOpCompute = function (t, e, n, r, o) {
    var a = t.shape[0],
        i = t.shape[1],
        s = function (t, e) {
      var n,
          r = !1;

      for (t <= Yr ? (n = t, r = !0) : n = Y(t, Math.floor(Math.sqrt(t))); !r;) n > e || n === t ? r = !0 : n = Y(t, n + 1);

      return n;
    }(i, o),
        u = new us({
      windowSize: s,
      inSize: i,
      batchSize: a,
      numSegments: o
    }, e),
        c = this.compileAndRun(u, [t, n], r);

    return c.shape[1] === o ? c : (n = Kn(0, o).tile([i / s]), this.segOpCompute(c, e, n, r, o));
  }, o.prototype.argMinMaxReduce = function (t, e, n) {
    var r = [e];

    if (Cn("arg" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !i().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2) {
      var o = bn(t.shape, r),
          a = o[0],
          s = k(o[1]),
          u = t.as2D(-1, s);
      return this.argReduce(u, n).reshape(a);
    }

    return this.argReducePacked(t, n);
  }, o.prototype.argMin = function (t, e) {
    return this.argMinMaxReduce(t, e, "min");
  }, o.prototype.argMax = function (t, e) {
    return this.argMinMaxReduce(t, e, "max");
  }, o.prototype.cumsum = function (t, e, n, r) {
    if (e !== t.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);
    var o = new ni(t.shape, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.equal = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(equal(a, b));\n", "bool");
    var n = new Ba("return float(a == b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.notEqual = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(notEqual(a, b));\n", "bool");
    var n = new Ba("return float(a != b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.less = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.less(t, e);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThan(a, b));\n", "bool");
    var n = new Ba("return float(a < b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.lessEqual = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
    var n = new Ba("return float(a <= b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.greater = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.greater(t, e);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThan(a, b));\n", "bool");
    var n = new Ba("return float(a > b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.greaterEqual = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
    var n = new Ba("return float(a >= b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.logicalNot = function (t) {
    var e = new Cs(t.shape, "return float(!(x >= 1.0));");
    return this.compileAndRun(e, [t]);
  }, o.prototype.logicalAnd = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
    var n = new Ba("return float(a >= 1.0 && b >= 1.0);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.logicalOr = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
    var n = new Ba("return float(a >= 1.0 || b >= 1.0);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "bool");
  }, o.prototype.select = function (t, e, n) {
    var r = new cs(t.rank, e.shape, e.rank);
    return this.compileAndRun(r, [t, e, n], Dt(e.dtype, n.dtype));
  }, o.prototype.where = function (t) {
    dn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    var e = t.dataSync();
    return na(t.shape, e);
  }, o.prototype.topk = function (t, e, n) {
    return ea(t.dataSync(), t.shape, t.dtype, e);
  }, o.prototype.min = function (t, e) {
    Cn("min", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "min", a.dtype).reshape(r);
  }, o.prototype.minimum = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.minimum(t, e);
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.mod = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ba("if (b == 0.0) return NAN;\n  return mod(a, b);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.max = function (t, e) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, e);
    Cn("max", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "max", a.dtype).reshape(r);
  }, o.prototype.maximum = function (t, e) {
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.maximum(t, e);
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.all = function (t, e) {
    Cn("all", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "all", a.dtype).reshape(r);
  }, o.prototype.any = function (t, e) {
    Cn("any", e, t.rank);
    var n = bn(t.shape, e),
        r = n[0],
        o = k(n[1]),
        a = t.as2D(-1, o);
    return this.reduce(a, "any", a.dtype).reshape(r);
  }, o.prototype.realDivide = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
      return this.packedBinaryOp(t, e, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", !0);
    }

    var n = new Ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "float32");
  }, o.prototype.floorDiv = function (t, e) {
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
    var n = new Ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e], "int32");
  }, o.prototype.add = function (t, e) {
    if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, Fa);
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.add(t, e);
    var n = Dt(t.dtype, e.dtype);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, Fa, n);
    var r = new Ba(Fa, t.shape, e.shape);
    return this.compileAndRun(r, [t, e], n);
  }, o.prototype.packedUnaryOp = function (t, e, n) {
    var r = new Xs(t.shape, e);
    return this.compileAndRun(r, [t], n);
  }, o.prototype.packedBinaryOp = function (t, e, n, r, o) {
    void 0 === o && (o = !1);
    var a = new La(n, t.shape, e.shape, o);
    return this.compileAndRun(a, [t, e], r);
  }, o.prototype.complexSeparableBinaryOp = function (t, e, n) {
    var r = this,
        o = this.texData.get(t.dataId),
        a = this.texData.get(e.dataId),
        i = [[o.complexTensors.real, a.complexTensors.real], [o.complexTensors.imag, a.complexTensors.imag]].map(function (o) {
      var a = o[0],
          i = o[1],
          s = r.makeComplexComponentTensorInfo(t, a),
          u = r.makeComplexComponentTensorInfo(e, i),
          c = new Ba(n, t.shape, e.shape);
      return r.compileAndRun(c, [s, u], Dt(a.dtype, i.dtype));
    }),
        s = i[0],
        u = i[1],
        c = this.complex(s, u);
    return s.dispose(), u.dispose(), c;
  }, o.prototype.makeComplexComponentTensorInfo = function (t, e) {
    return {
      dataId: e.dataId,
      dtype: e.dtype,
      shape: t.shape
    };
  }, o.prototype.addN = function (t) {
    if (1 === t.length) return t[0];

    if (t.length > i().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var e = Math.floor(t.length / 2),
          n = this.addN(t.slice(0, e)),
          r = this.addN(t.slice(e));
      return this.addN([n, r]);
    }

    var o = t.map(function (t) {
      return t.dtype;
    }).reduce(function (t, e) {
      return Dt(t, e);
    }),
        a = t.map(function (t) {
      return t.shape;
    }),
        s = i().getBool("WEBGL_PACK") ? new oa(t[0].shape, a) : new ra(t[0].shape, a);
    return this.compileAndRun(s, t, o);
  }, o.prototype.subtract = function (t, e) {
    if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, _a);
    if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.subtract(t, e);
    var n = Dt(t.dtype, e.dtype);
    if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, _a, t.dtype);
    var r = new Ba(_a, t.shape, e.shape);
    return this.compileAndRun(r, [t, e], n);
  }, o.prototype.pow = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t.shape, e.shape),
        r = Dt(t.dtype, e.dtype);
    return this.compileAndRun(n, [t, e], r);
  }, o.prototype.ceil = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ns, t.dtype);
    var e = new Cs(t.shape, Ns);
    return this.compileAndRun(e, [t]);
  }, o.prototype.floor = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Fs, t.dtype);
    var e = new Cs(t.shape, Fs);
    return this.compileAndRun(e, [t]);
  }, o.prototype.sign = function (t) {
    var e = new Cs(t.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.isNaN = function (t) {
    var e = new Cs(t.shape, "return float(isnan(x));");
    return this.compileAndRun(e, [t], "bool");
  }, o.prototype.isInf = function (t) {
    var e = new Cs(t.shape, "return float(isinf(x));");
    return this.compileAndRun(e, [t], "bool");
  }, o.prototype.isFinite = function (t) {
    var e = new Cs(t.shape, "return float(!isnan(x) && !isinf(x));");
    return this.compileAndRun(e, [t], "bool");
  }, o.prototype.round = function (t) {
    var e = new Cs(t.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.exp = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, _s, t.dtype);
    var e = new Cs(t.shape, _s);
    return this.compileAndRun(e, [t]);
  }, o.prototype.expm1 = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Os, t.dtype);
    var e = new Cs(t.shape, Os);
    return this.compileAndRun(e, [t]);
  }, o.prototype.softmax = function (t, e) {
    var n = O([e], t.shape),
        r = this.max(t, n),
        o = wn(r.shape, n),
        a = this.subtract(t, r.reshape(o)),
        i = this.exp(a),
        s = this.sum(i, n).reshape(o);
    return this.realDivide(i, s);
  }, o.prototype.log = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t.dtype);
    var e = new Cs(t.shape, "if (x < 0.0) return NAN;\n  return log(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.log1p = function (t) {
    var e = new Cs(t.shape, "return log(1.0 + x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.sqrt = function (t) {
    var e = new Cs(t.shape, "return sqrt(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.rsqrt = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);
    var e = new Cs(t.shape, "return inversesqrt(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.reciprocal = function (t) {
    var e = new Cs(t.shape, "return 1.0 / x;");
    return this.compileAndRun(e, [t]);
  }, o.prototype.relu = function (t) {
    var e;
    return e = i().getBool("WEBGL_PACK") ? new Xs(t.shape, qs) : new Cs(t.shape, ks), this.compileAndRun(e, [t]);
  }, o.prototype.relu6 = function (t) {
    var e;
    return e = i().getBool("WEBGL_PACK") ? new Xs(t.shape, Ks) : new Cs(t.shape, Ss), this.compileAndRun(e, [t]);
  }, o.prototype.prelu = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La(Pa, t.shape, e.shape) : new Ba(Ma, t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.elu = function (t) {
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, js, t.dtype);
    var e = new Cs(t.shape, As);
    return this.compileAndRun(e, [t]);
  }, o.prototype.eluDer = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t.shape, e.shape) : new Ba("return (b >= 1.0) ? a : a * (b + 1.0);", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.selu = function (t) {
    var e = new Cs(t.shape, Ds);
    return this.compileAndRun(e, [t]);
  }, o.prototype.int = function (t) {
    var e = new Cs(t.shape, "return float(int(x));");
    return this.compileAndRun(e, [t], "int32");
  }, o.prototype.clip = function (t, e, n) {
    var r,
        o = (r = i().getBool("WEBGL_PACK_CLIP") ? new Ua(t.shape) : new Wa(t.shape)).getCustomSetupFunc(e, n);
    return this.compileAndRun(r, [t], null, o);
  }, o.prototype.abs = function (t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
    if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Is, t.dtype);
    var e = new Cs(t.shape, Is);
    return this.compileAndRun(e, [t]);
  }, o.prototype.complexAbs = function (t) {
    var e = this.texData.get(t.dataId),
        n = new Va(t.shape),
        r = [this.makeComplexComponentTensorInfo(t, e.complexTensors.real), this.makeComplexComponentTensorInfo(t, e.complexTensors.imag)];
    return this.compileAndRun(n, r);
  }, o.prototype.sigmoid = function (t) {
    var e = new Cs(t.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
    return this.compileAndRun(e, [t]);
  }, o.prototype.softplus = function (t) {
    var e = new Cs(t.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.sin = function (t) {
    var e = new Cs(t.shape, Ms);
    return this.compileAndRun(e, [t]);
  }, o.prototype.cos = function (t) {
    var e = new Cs(t.shape, Bs);
    return this.compileAndRun(e, [t]);
  }, o.prototype.tan = function (t) {
    var e = new Cs(t.shape, "return tan(x);");
    return this.compileAndRun(e, [t]);
  }, o.prototype.asin = function (t) {
    var e = new Cs(t.shape, Ps);
    return this.compileAndRun(e, [t]);
  }, o.prototype.acos = function (t) {
    var e = new Cs(t.shape, Ls);
    return this.compileAndRun(e, [t]);
  }, o.prototype.atan = function (t) {
    var e = new Cs(t.shape, Ws);
    return this.compileAndRun(e, [t]);
  }, o.prototype.atan2 = function (t, e) {
    var n = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t.shape, e.shape);
    return this.compileAndRun(n, [t, e]);
  }, o.prototype.sinh = function (t) {
    var e = new Cs(t.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.cosh = function (t) {
    var e = new Cs(t.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.tanh = function (t) {
    var e = new Cs(t.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
    return this.compileAndRun(e, [t]);
  }, o.prototype.asinh = function (t) {
    var e = new Cs(t.shape, Us);
    return this.compileAndRun(e, [t]);
  }, o.prototype.acosh = function (t) {
    var e = new Cs(t.shape, Vs);
    return this.compileAndRun(e, [t]);
  }, o.prototype.atanh = function (t) {
    var e = new Cs(t.shape, zs);
    return this.compileAndRun(e, [t]);
  }, o.prototype.erf = function (t) {
    var e = new Cs(t.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
    return this.compileAndRun(e, [t]);
  }, o.prototype.step = function (t, e) {
    var n = new Cs(t.shape, function (t) {
      return void 0 === t && (t = 0), Es + "\n    return x > 0.0 ? 1.0 : float(" + t + ");\n  ";
    }(e));
    return this.compileAndRun(n, [t]);
  }, o.prototype.conv2dByMatMul = function (t, e, n, r, o, a) {
    var s = t.shape,
        u = this.texData.get(t.dataId),
        c = n.inChannels,
        l = s[0] * s[1] * s[2],
        h = n.outChannels,
        f = "channelsLast" === n.dataFormat,
        d = (1 === l || 1 === h) && c > 1e3,
        p = s[2] % 2 != 0 && !!u.isPacked;

    if (d || !i().getBool("WEBGL_LAZILY_UNPACK") || !i().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !p) {
      var v = f ? s[0] * s[1] * s[2] : s[0] * s[2] * s[3],
          m = this.reshape(t, [1, v, n.inChannels]),
          g = this.reshape(e, [1, n.inChannels, n.outChannels]);
      return this.reshape(this.fusedBatchMatMul({
        a: m,
        b: g,
        transposeA: !1,
        transposeB: !1,
        bias: r,
        activation: o,
        preluActivationWeights: a
      }), n.outShape);
    }

    var y = f ? s[0] * s[1] * (s[2] + 1) : s[0] * s[2] * (s[3] + 1),
        x = {
      dataId: t.dataId,
      shape: [1, y, n.inChannels],
      dtype: t.dtype
    },
        b = u.shape;
    u.shape = u.shape.slice(), u.shape[u.shape.length - 2]++, C(_e(u.shape, x.shape), function () {
      return "packed reshape " + u.shape + " to " + x.shape + " isn't free";
    });
    var w = this.reshape(e, [1, n.inChannels, n.outChannels]),
        E = this.fusedBatchMatMul({
      a: x,
      b: w,
      transposeA: !1,
      transposeB: !1,
      bias: r,
      activation: o,
      preluActivationWeights: a
    }),
        R = this.texData.get(E.dataId);
    return C(R.isPacked, function () {
      return "batchMatMul result is expected to be packed";
    }), u.shape = b, R.shape = n.outShape, Lt.makeTensorFromDataId(E.dataId, n.outShape, E.dtype);
  }, o.prototype.conv2dWithIm2Row = function (t, e, n, r, o, a) {
    var i = n.filterWidth,
        s = n.filterHeight,
        u = n.inChannels,
        c = n.outWidth,
        l = n.outHeight,
        h = "channelsLast" === n.dataFormat,
        f = i * s * u,
        d = l * c,
        p = [f, d],
        v = t.squeeze([0]),
        m = e.reshape([1, f, -1]),
        g = new Li(p, v.shape, n),
        y = this.compileAndRun(g, [v]).reshape([1, p[0], p[1]]),
        x = null != r,
        b = null != a,
        w = o ? Qs(o, !0) : null,
        C = new Hi(y.shape, [1, d, n.outChannels], !0, !1, x, w, b),
        E = [y, m];
    r && E.push(r), b && E.push(a);
    var R = this.compileAndRun(C, E);
    return h ? R.reshape([1, l, c, n.outChannels]) : R.reshape([1, n.outChannels, l, c]);
  }, o.prototype.fusedConv2d = function (t) {
    var e = t.input,
        n = t.filter,
        r = t.convInfo,
        o = t.bias,
        a = t.activation,
        s = t.preluActivationWeights;
    if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && ("SAME" === r.padInfo.type || "VALID" === r.padInfo.type)) return this.conv2dByMatMul(e, n, r, o, a, s);
    if (i().getBool("WEBGL_CONV_IM2COL") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, o, a, s);
    var u = null != o,
        c = null != s,
        l = a ? Qs(a, !1) : null,
        h = new Qa(r, u, l, c),
        f = [e, n];
    return o && f.push(o), s && f.push(s), this.compileAndRun(h, f);
  }, o.prototype.conv2d = function (t, e, n) {
    if (1 === n.filterHeight && 1 === n.filterWidth && 1 === n.dilationHeight && 1 === n.dilationWidth && 1 === n.strideHeight && 1 === n.strideWidth && ("SAME" === n.padInfo.type || "VALID" === n.padInfo.type)) return this.conv2dByMatMul(t, e, n);
    if (i().getBool("WEBGL_CONV_IM2COL") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n);
    var r = new Qa(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv2dDerInput = function (t, e, n) {
    var r = new Ka(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv2dDerFilter = function (t, e, n) {
    var r = new qa(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.fusedDepthwiseConv2D = function (t) {
    var e,
        n = t.input,
        r = t.filter,
        o = t.convInfo,
        a = t.bias,
        s = t.activation,
        u = t.preluActivationWeights,
        c = i().getBool("WEBGL_PACK_DEPTHWISECONV") && o.strideWidth <= 2 && o.outChannels / o.inChannels == 1,
        l = s ? Qs(s, c) : null,
        h = [n, r],
        f = null != a,
        d = null != u;
    return f && h.push(a), d && h.push(u), c ? (e = new ti(o, f, l, d), this.compileAndRun(e, h)) : (e = new Za(o, f, l, d), this.compileAndRun(e, h));
  }, o.prototype.depthwiseConv2D = function (t, e, n) {
    var r;
    return i().getBool("WEBGL_PACK_DEPTHWISECONV") && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? (r = new ti(n), this.compileAndRun(r, [t, e])) : (r = new Za(n), this.compileAndRun(r, [t, e]));
  }, o.prototype.depthwiseConv2DDerInput = function (t, e, n) {
    var r = new $a(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
    var r = new Ya(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv3d = function (t, e, n) {
    var r = new Ja(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv3dDerInput = function (t, e, n) {
    var r = new Xa(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.conv3dDerFilter = function (t, e, n) {
    var r = new ja(n);
    return this.compileAndRun(r, [t, e]);
  }, o.prototype.maxPool = function (t, e) {
    var n = new $i(e, "max", !1);
    return this.compileAndRun(n, [t]);
  }, o.prototype.avgPool = function (t, e) {
    var n = new $i(e, "avg", !1);
    return this.compileAndRun(n, [t], "float32");
  }, o.prototype.maxPoolBackprop = function (t, e, n, r) {
    var o = new $i(r, "max", !0),
        a = this.compileAndRun(o, [e]),
        i = new zi(r),
        s = this.compileAndRun(i, [t, a], e.dtype);
    return a.dispose(), s;
  }, o.prototype.avgPoolBackprop = function (t, e, n) {
    var r = new Ia(n);
    return this.compileAndRun(r, [t], e.dtype);
  }, o.prototype.cast = function (t, e) {
    return Po(t, e, this);
  }, o.prototype.unstack = function (t, e) {
    for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++) a !== e && (r[o++] = t.shape[a]);

    var i = new Array(t.rank).fill(0),
        s = t.shape.slice();
    s[e] = 1;
    var u = new Array(n);

    for (a = 0; a < u.length; a++) i[e] = a, u[a] = this.slice(t, i, s).reshape(r);

    return u;
  }, o.prototype.avgPool3d = function (t, e) {
    var n = new Qi(e, "avg", !1);
    return this.compileAndRun(n, [t], "float32");
  }, o.prototype.avgPool3dBackprop = function (t, e, n) {
    var r = new ka(n);
    return this.compileAndRun(r, [t], e.dtype);
  }, o.prototype.maxPool3d = function (t, e) {
    var n = new Qi(e, "max", !1);
    return this.compileAndRun(n, [t], "float32");
  }, o.prototype.maxPool3dBackprop = function (t, e, n, r) {
    var o = new Qi(r, "max", !0),
        a = this.compileAndRun(o, [e]),
        i = new Gi(r),
        s = this.compileAndRun(i, [t, a], e.dtype);
    return a.dispose(), s;
  }, o.prototype.reshape = function (t, e) {
    var n = this.texData.get(t.dataId);

    if (n.isPacked && !_e(t.shape, e) && (null === n.texture || !_e(n.shape, e))) {
      var r = this.packedReshape(t, e);
      return Lt.makeTensorFromDataId(r.dataId, r.shape, r.dtype);
    }

    return Lo(t, e);
  }, o.prototype.resizeBilinear = function (t, e, n, r) {
    var o = i().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ns(t.shape, e, n, r) : new es(t.shape, e, n, r);
    return this.compileAndRun(o, [t], "float32");
  }, o.prototype.resizeBilinearBackprop = function (t, e, n) {
    var r = new ts(t, e, n);
    return this.compileAndRun(r, [t]);
  }, o.prototype.resizeNearestNeighbor = function (t, e, n, r) {
    var o = new os(t.shape, e, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
    var r = new rs(t, e, n);
    return this.compileAndRun(r, [t]);
  }, o.prototype.multinomial = function (t, e, n, r) {
    var o = e ? t : go(t),
        a = o.shape[0],
        i = o.shape[1],
        s = new qi(a, i, n),
        u = s.getCustomSetupFunc(r);
    return this.compileAndRun(s, [o], "int32", u);
  }, o.prototype.oneHot = function (t, e, n, r) {
    var o = new Ki(t.size, e, n, r);
    return this.compileAndRun(o, [t]);
  }, o.prototype.diag = function (t) {
    var e = new si(t.size);
    return this.compileAndRun(e, [t]);
  }, o.prototype.nonMaxSuppression = function (t, e, n, r, o) {
    return dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), jo(t.dataSync(), e.dataSync(), n, r, o);
  }, o.prototype.cropAndResize = function (t, e, n, r, o, a) {
    var i = new ei(t.shape, e.shape, r, o, a);
    return this.compileAndRun(i, [t, e, n], "float32");
  }, o.prototype.depthToSpace = function (t, e, n) {
    C(e > 1, function () {
      return "blockSize should be > 1 for depthToSpace, but was: " + e;
    });
    var r = t.shape[0],
        o = "NHWC" === n ? t.shape[1] : t.shape[2],
        a = "NHWC" === n ? t.shape[2] : t.shape[3],
        i = "NHWC" === n ? t.shape[3] : t.shape[1],
        s = o * e,
        u = a * e,
        c = i / (e * e),
        l = new ii("NHWC" === n ? [r, s, u, c] : [r, c, s, u], e, n);
    return this.compileAndRun(l, [t]);
  }, o.prototype.split = function (t, e, n) {
    return Zo(t, e, n);
  }, o.prototype.scatterND = function (t, e, n) {
    var r = Zr(0, t, n),
        o = r.sliceRank,
        a = r.numUpdates,
        i = r.sliceSize,
        s = r.strides,
        u = r.outputSize,
        c = [u / i, i],
        l = t.reshape([a, o]),
        h = e.reshape([a, i]);
    if (0 === u) return Lo(Fn([]), n);
    var f = On(0),
        d = new ss(a, o, l.rank, h.rank, s, c);
    return this.compileAndRun(d, [h, l, f]).reshape(n);
  }, o.prototype.sparseToDense = function (t, e, n, r) {
    var o = Zr(0, t, n),
        a = o.sliceRank,
        i = o.numUpdates,
        s = o.strides,
        u = o.outputSize,
        c = new ss(i, a, t.rank, e.rank, s, [u, 1], !1);
    return this.compileAndRun(c, [e, t, r]).reshape(n);
  }, o.prototype.fft = function (t) {
    return this.fftImpl(t, !1);
  }, o.prototype.ifft = function (t) {
    return this.fftImpl(t, !0);
  }, o.prototype.fftImpl = function (t, e) {
    var n = this.texData.get(t.dataId),
        r = new pi(fi, t.shape, e),
        o = new pi(di, t.shape, e),
        a = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag)],
        i = this.compileAndRun(r, a),
        s = this.compileAndRun(o, a),
        u = this.complex(i, s).as2D(t.shape[0], t.shape[1]);
    return i.dispose(), s.dispose(), u;
  }, o.prototype.gatherND = function (t, e) {
    var n = e.shape,
        r = n[n.length - 1],
        o = jr(t, e),
        a = o[0],
        i = o[1],
        s = o[2],
        u = o[3],
        c = e.reshape([i, r]),
        l = t.reshape([t.size / s, s]),
        h = new gi(r, u, [i, s]);
    return this.compileAndRun(h, [l, c]).reshape(a);
  }, o.prototype.fill = function (t, e, n) {
    if ("string" === (n = n || j(e))) {
      var r = P(n, k(t));
      return r.fill(e), Lt.makeTensor(r, t, n, this);
    }

    var o = new vi(t, e),
        a = o.getCustomSetupFunc(e);
    return this.compileAndRun(o, [], n, a);
  }, o.prototype.onesLike = function (t) {
    if ("string" === t.dtype) throw new Error("onesLike is not supported under string dtype");
    return this.fill(t.shape, 1, t.dtype);
  }, o.prototype.zerosLike = function (t) {
    return this.fill(t.shape, "string" === t.dtype ? "" : 0, t.dtype);
  }, o.prototype.linspace = function (t, e, n) {
    return Wo(t, e, n);
  }, o.prototype.makeTensorInfo = function (t, e) {
    var n = this.write(null, t, e);
    return this.texData.get(n).usage = null, {
      dataId: n,
      shape: t,
      dtype: e
    };
  }, o.prototype.makeOutput = function (t, e) {
    var n = this.makeTensorInfo(t, e).dataId;
    return Lt.makeTensorFromDataId(n, t, e, this);
  }, o.prototype.unpackTensor = function (t) {
    var e = new Ys(t.shape);
    return this.runWebGLProgram(e, [t], t.dtype);
  }, o.prototype.packTensor = function (t) {
    var e = new ji(t.shape);
    return this.runWebGLProgram(e, [t], t.dtype, null, !0);
  }, o.prototype.packedReshape = function (t, e) {
    var n = [Ae(t.shape)].concat(De(t.shape)),
        r = {
      dtype: t.dtype,
      shape: n,
      dataId: t.dataId
    },
        o = [Ae(e)].concat(De(e)),
        a = new Zi(o, n),
        i = this.runWebGLProgram(a, [r], t.dtype, null, !0);
    return {
      dataId: i.dataId,
      shape: e,
      dtype: i.dtype
    };
  }, o.prototype.decode = function (t) {
    var e,
        n = this.texData.get(t),
        r = n.isPacked,
        o = n.shape,
        a = n.dtype,
        i = Te(o);
    e = r ? new ai(i) : new oi(i);
    return {
      dtype: a,
      shape: o,
      dataId: this.runWebGLProgram(e, [{
        shape: i,
        dtype: a,
        dataId: t
      }], a, null, !0).dataId
    };
  }, o.prototype.runWebGLProgram = function (t, e, n, r, o) {
    var a = this;
    void 0 === o && (o = !1);
    var s = this.makeTensorInfo(t.outputShape, n),
        u = this.texData.get(s.dataId);

    if (t.packedOutput && (u.isPacked = !0), t.outPackingScheme === Vt.DENSE) {
      var c = Yt(t.outputShape);
      u.texShape = c.map(function (t) {
        return 2 * t;
      });
    }

    if (null != t.outTexUsage && (u.usage = t.outTexUsage), 0 === k(s.shape)) return u.values = B(s.dtype, 0), s;
    var l = [],
        h = e.map(function (e) {
      if ("complex64" === e.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      var n = a.texData.get(e.dataId);

      if (null == n.texture) {
        if (!t.packedInputs && k(e.shape) <= i().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
          shape: e.shape,
          texData: null,
          isUniform: !0,
          uniformValues: n.values
        };
        t.packedInputs && (n.isPacked = !0, n.shape = e.shape);
      } else if (!!n.isPacked != !!t.packedInputs) e = n.isPacked ? a.unpackTensor(e) : a.packTensor(e), l.push(e), n = a.texData.get(e.dataId);else if (n.isPacked && !_e(n.shape, e.shape)) {
        var r = e,
            o = e.shape;
        e.shape = n.shape, e = a.packedReshape(e, o), l.push(e), n = a.texData.get(e.dataId), r.shape = o;
      }

      return a.uploadToGPU(e.dataId), {
        shape: e.shape,
        texData: n,
        isUniform: !1
      };
    });
    this.uploadToGPU(s.dataId);

    var f,
        d = {
      shape: s.shape,
      texData: u,
      isUniform: !1
    },
        p = function (t, e, n) {
      var r = "";
      e.concat(n).forEach(function (t) {
        var e = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0,
            n = t.isUniform ? "uniform" : t.texData.texShape;
        r += t.shape + "_" + n + "_" + e;
      });
      var o = t.userCode,
          a = t.constructor.name;
      return a += "_" + r + "_" + o;
    }(t, h, d),
        v = this.getAndSaveBinary(p, function () {
      return function (t, e, n, r) {
        var o = e.userCode,
            a = n.map(function (t, n) {
          var r = {
            logicalShape: t.shape,
            texShape: t.isUniform ? null : t.texData.texShape,
            isUniform: t.isUniform,
            isPacked: !t.isUniform && t.texData.isPacked,
            flatOffset: null
          };
          return null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0 && (r.flatOffset = t.texData.slice.flatOffset), {
            name: e.variableNames[n],
            shapeInfo: r
          };
        }),
            s = a.map(function (t) {
          return t.shapeInfo;
        }),
            u = {
          logicalShape: r.shape,
          texShape: r.texData.texShape,
          isUniform: !1,
          isPacked: r.texData.isPacked,
          flatOffset: null
        },
            c = fa(a, u, o, e.packedInputs),
            l = t.createProgram(c),
            h = null,
            f = t.getUniformLocation(l, "NAN", !1);
        1 === i().getNumber("WEBGL_VERSION") && (h = t.getUniformLocation(l, "INFINITY", !1));

        for (var d = {}, p = 0; p < e.variableNames.length; p++) {
          var v = e.variableNames[p];
          d[v] = t.getUniformLocation(l, v, !1), d["offset" + v] = t.getUniformLocation(l, "offset" + v, !1);
        }

        return {
          program: e,
          source: c,
          webGLProgram: l,
          uniformLocations: d,
          inShapeInfos: s,
          outShapeInfo: u,
          infLoc: h,
          nanLoc: f
        };
      }(a.gpgpu, t, h, d);
    }),
        m = null != this.activeTimers;

    if (m && (f = this.startTimer()), function (t, e, n, r, o) {
      Pi(e.inShapeInfos, n), Pi([e.outShapeInfo], [r]);
      var a = r.texData.texture,
          s = r.texData.texShape;
      r.texData.isPacked ? t.setOutputPackedMatrixTexture(a, s[0], s[1]) : t.setOutputMatrixTexture(a, s[0], s[1]), t.setProgram(e.webGLProgram), 1 === i().getNumber("WEBGL_VERSION") && null !== e.infLoc && t.gl.uniform1f(e.infLoc, 1 / 0), null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN), n.forEach(function (n, r) {
        var o = e.program.variableNames[r],
            a = e.uniformLocations[o],
            i = e.uniformLocations["offset" + o];
        if (null != a) if (n.isUniform) {
          if (k(n.shape) < 2) t.gl.uniform1f(a, n.uniformValues[0]);else {
            var s = n.uniformValues;
            s instanceof Float32Array || (s = new Float32Array(s)), t.gl.uniform1fv(a, s);
          }
        } else null != n.texData.slice && null != i && t.gl.uniform1i(i, n.texData.slice.flatOffset), t.setInputMatrixTexture(n.texData.texture, a, r);
      }), null != o && o(t, e.webGLProgram), t.executeProgram();
    }(this.gpgpu, v, h, d, r), l.forEach(function (t) {
      return a.disposeData(t.dataId);
    }), m && (f = this.endTimer(f), this.activeTimers.push({
      name: t.constructor.name,
      query: this.getQueryTime(f)
    })), !i().getBool("WEBGL_LAZILY_UNPACK") && u.isPacked && !1 === o) {
      var g = this.unpackTensor(s);
      return this.disposeData(s.dataId), g;
    }

    return s;
  }, o.prototype.compileAndRun = function (t, e, n, r, o) {
    void 0 === o && (o = !1), n = n || e[0].dtype;
    var a = this.runWebGLProgram(t, e, n, r, o);
    return Lt.makeTensorFromDataId(a.dataId, a.shape, a.dtype);
  }, o.prototype.getAndSaveBinary = function (t, e) {
    return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t];
  }, o.prototype.getTextureManager = function () {
    return this.textureManager;
  }, o.prototype.dispose = function () {
    var t = this;

    if (!this.disposed) {
      if (!i().getBool("IS_TEST")) Object.keys(this.binaryCache).forEach(function (e) {
        t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram), delete t.binaryCache[e];
      });
      this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0;
    }
  }, o.prototype.floatPrecision = function () {
    var t = this;
    return null == this.floatPrecisionValue && (this.floatPrecisionValue = Ze(function () {
      if (!i().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        var e = i().getBool("DEBUG");
        i().set("DEBUG", !1);
        var n = t.abs(On(1e-8)).dataSync()[0];
        if (i().set("DEBUG", e), n > 0) return 32;
      }

      return 16;
    })), this.floatPrecisionValue;
  }, o.prototype.epsilon = function () {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, o.prototype.uploadToGPU = function (t) {
    var e,
        n = this.texData.get(t),
        r = n.shape,
        o = n.dtype,
        a = n.values,
        i = n.texture,
        s = n.usage,
        u = n.isPacked;

    if (null == i) {
      var c,
          l = null != this.activeTimers;
      l && (c = et());
      var h = n.texShape;

      if (null == h && (h = Ne(r, u), n.texShape = h), null != a) {
        var f = Te(r),
            d = void 0,
            p = h[1],
            v = h[0],
            m = a instanceof Uint8Array;
        u ? (p = (e = $t(h[0], h[1]))[0], v = e[1], d = new hi(f, [v, p], m)) : d = new li(f, [v, p], m);
        var g = this.makeTensorInfo([v, p], o);
        this.texData.get(g.dataId).usage = m ? zt.PIXELS : zt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId), p, v, a);
        var y = this.runWebGLProgram(d, [g], o, null, !0),
            x = this.texData.get(y.dataId);
        n.texture = x.texture, n.texShape = x.texShape, n.isPacked = x.isPacked, n.usage = x.usage, this.disposeData(g.dataId), this.texData.delete(y.dataId), n.values = null, l && (this.uploadWaitMs += et() - c);
      } else {
        var b = this.acquireTexture(h, s, o, u);
        n.texture = b;
      }
    }
  }, o.prototype.convertAndCacheOnCPU = function (t, e) {
    var n = this.texData.get(t),
        r = n.dtype;
    return this.releaseGPUData(t), null != e && (n.values = function (t, e) {
      if ("float32" === e || "complex64" === e) return t;

      if ("int32" === e || "bool" === e) {
        for (var n = "int32" === e ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r) n[r] = Math.round(t[r]);

        return n;
      }

      throw new Error("Unknown dtype " + e);
    }(e, r)), n.values;
  }, o.prototype.acquireTexture = function (t, e, n, r) {
    if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
      var o = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + o + " MB, most likely due to a memory leak");
    }

    return this.textureManager.acquireTexture(t, e, r);
  }, o.prototype.computeBytes = function (t, e) {
    return t[0] * t[1] * z(e);
  }, o;
}(bo);

Wt() && Lt.registerBackend("webgl", function () {
  return new Zs();
}, 2);
var tu = An({
  square_: function (t) {
    var e = mn(t, "x", "square"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      return n([e]), t.square(e);
    }, {
      x: e
    }, null, "Square", {}, n, []);
  }
}),
    eu = "SquaredDifference";
exports.square = tu;
var nu = An({
  squaredDifference_: function (t, e) {
    var n,
        r = mn(t, "a", "squaredDifference"),
        o = mn(e, "b", "squaredDifference");
    n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape);
    var a = {
      a: r,
      b: o
    },
        i = [r, o];
    return Lt.runKernelFunc(function (t, e) {
      var n = t.squaredDifference(r, o);
      return e([r, o]), n;
    }, a, function (t, e) {
      var n = e[0],
          r = e[1],
          o = On(2);
      return {
        a: function () {
          return t.mul(n.sub(r).mul(o));
        },
        b: function () {
          return t.mul(r.sub(n).mul(o));
        }
      };
    }, eu, {}, i, []);
  }
});
exports.squaredDifference = nu;

var ru = An({
  abs_: function (t) {
    var e = mn(t, "x", "abs");
    return "complex64" === e.dtype ? Lt.runKernelFunc(function (t) {
      return t.complexAbs(e);
    }, {
      $x: e
    }) : Lt.runKernelFunc(function (t, n) {
      var r = t.abs(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mul(n.toFloat().step(-1));
        }
      };
    }, "Abs");
  }
}),
    ou = An({
  acos_: function (t) {
    var e = mn(t, "x", "acos");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.acos(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(On(1).sub(n.toFloat().square()).sqrt()).neg();
        }
      };
    });
  }
}),
    au = An({
  acosh_: function (t) {
    var e = mn(t, "x", "acosh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.acosh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(n.toFloat().square().sub(1).sqrt());
        }
      };
    });
  }
}),
    iu = An({
  asin_: function (t) {
    var e = mn(t, "x", "asin");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.asin(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(On(1).sub(n.toFloat().square()).sqrt());
        }
      };
    });
  }
}),
    su = An({
  asinh_: function (t) {
    var e = mn(t, "x", "asinh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.asinh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.divStrict(On(1).add(n.toFloat().square()).sqrt());
        }
      };
    });
  }
}),
    uu = An({
  atan_: function (t) {
    var e = mn(t, "x", "atan");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.atan(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.toFloat().square().add(1));
        }
      };
    });
  }
}),
    cu = An({
  atanh_: function (t) {
    var e = mn(t, "x", "atanh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.atanh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(On(1).sub(n.toFloat().square()));
        }
      };
    });
  }
}),
    lu = An({
  ceil_: function (t) {
    var e = mn(t, "x", "ceil");
    return Lt.runKernelFunc(function (t) {
      return t.ceil(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    hu = An({
  clipByValue_: function (t, e, n) {
    var r = mn(t, "x", "clipByValue");
    C(e <= n, function () {
      return "Error in clip: min (" + e + ") must be less than or equal to max (" + n + ").";
    });
    var o = [r],
        a = {
      min: e,
      max: n
    };
    return Lt.runKernelFunc(function (t, o) {
      var a = t.clip(r, e, n);
      return o([r]), a;
    }, {
      x: r
    }, function (t, r) {
      var o = r[0];
      return {
        x: function () {
          return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)), Xn(t));
        }
      };
    }, "ClipByValue", a, o);
  }
}),
    fu = An({
  cos_: function (t) {
    var e = mn(t, "x", "cos"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      var r = t.cos(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return n.toFloat().sin().neg().mul(t);
        }
      };
    }, "Cos", {}, n);
  }
}),
    du = An({
  cosh_: function (t) {
    var e = mn(t, "x", "cosh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.cosh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return n.toFloat().sinh().mulStrict(t);
        }
      };
    });
  }
}),
    pu = An({
  erf_: function (t) {
    var e = mn(t, "x", "erf");
    return C("int32" === e.dtype || "float32" === e.dtype, function () {
      return "Input dtype must be `int32` or `float32`.";
    }), "int32" === e.dtype && (e = e.toFloat()), Lt.runKernelFunc(function (t, n) {
      var r = t.erf(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
        }
      };
    });
  }
}),
    vu = An({
  exp_: function (t) {
    var e = mn(t, "x", "exp");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.exp(e);
      return n([r]), r;
    }, {
      x: e
    }, function (t, e) {
      return {
        x: function () {
          return t.mulStrict(e[0]);
        }
      };
    }, "Exp", {}, [], [!0]);
  }
}),
    mu = An({
  expm1_: function (t) {
    var e = mn(t, "x", "expm1");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.expm1(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.exp());
        }
      };
    });
  }
}),
    gu = An({
  floor_: function (t) {
    var e = mn(t, "x", "floor");
    return Lt.runKernelFunc(function (t) {
      return t.floor(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    yu = An({
  log_: function (t) {
    var e = mn(t, "x", "log"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      var r = t.log(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.div(n.toFloat());
        }
      };
    }, "Log", {}, n);
  }
}),
    xu = An({
  log1p_: function (t) {
    var e = mn(t, "x", "log1p");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.log1p(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.add(1));
        }
      };
    });
  }
}),
    bu = An({
  logSigmoid_: function (t) {
    var e = mn(t, "x", "logSigmoid");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.softplus(e.neg()).neg();
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.neg().sigmoid());
        }
      };
    });
  }
}),
    wu = An({
  neg_: function (t) {
    var e = mn(t, "x", "neg"),
        n = [e];
    return Lt.runKernelFunc(function (t) {
      return t.neg(e);
    }, {
      x: e
    }, function (t) {
      return {
        x: function () {
          return t.neg();
        }
      };
    }, "Neg", {}, n);
  }
}),
    Cu = An({
  reciprocal_: function (t) {
    var e = mn(t, "x", "reciprocal");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.reciprocal(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.square().neg());
        }
      };
    });
  }
}),
    Eu = An({
  round_: function (t) {
    var e = mn(t, "x", "round");
    return Lt.runKernelFunc(function (t) {
      return t.round(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    Ru = An({
  rsqrt_: function (t) {
    var e = mn(t, "x", "rsqrt"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      var r = t.rsqrt(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.div(n.pow(1.5).mul(2)).neg();
        }
      };
    }, "Rsqrt", {}, n);
  }
}),
    Iu = An({
  sigmoid_: function (t) {
    var e = mn(t, "x", "sigmoid");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.sigmoid(e);
      return n([r]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mul(n.mul(On(1).sub(n)));
        }
      };
    }, "Sigmoid");
  }
}),
    ku = An({
  sign_: function (t) {
    var e = mn(t, "x", "sign");
    return Lt.runKernelFunc(function (t) {
      return t.sign(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    Su = An({
  isNaN_: function (t) {
    var e = mn(t, "x", "isNaN");
    return Lt.runKernelFunc(function (t) {
      return t.isNaN(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    Au = An({
  isInf_: function (t) {
    var e = mn(t, "x", "isInf");
    return Lt.runKernelFunc(function (t) {
      return t.isInf(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    Du = An({
  isFinite_: function (t) {
    var e = mn(t, "x", "isFinite");
    return Lt.runKernelFunc(function (t) {
      return t.isFinite(e);
    }, {
      $x: e
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    Tu = An({
  sin_: function (t) {
    var e = mn(t, "x", "sin"),
        n = [e];
    return Lt.runKernelFunc(function (t, n) {
      var r = t.sin(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return n.toFloat().cos().mul(t);
        }
      };
    }, "Sin", {}, n);
  }
}),
    Nu = An({
  sinh_: function (t) {
    var e = mn(t, "x", "sinh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.sinh(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return n.toFloat().cosh().mulStrict(t);
        }
      };
    });
  }
}),
    Fu = An({
  softplus_: function (t) {
    var e = mn(t, "x", "softplus");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.softplus(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.mul(n.sigmoid());
        }
      };
    });
  }
}),
    _u = An({
  sqrt_: function (t) {
    var e = mn(t, "x", "sqrt");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.sqrt(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.toFloat().sqrt().mul(2));
        }
      };
    });
  }
}),
    Ou = An({
  step_: function (t, e) {
    void 0 === e && (e = 0);
    var n = mn(t, "x", "step");
    return Lt.runKernelFunc(function (t) {
      return t.step(n, e);
    }, {
      $x: n
    }, function (t) {
      return {
        $x: function () {
          return Xn(t);
        }
      };
    });
  }
}),
    Mu = An({
  tan_: function (t) {
    var e = mn(t, "x", "tan");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.tan(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return t.div(n.cos().square());
        }
      };
    });
  }
}),
    Bu = An({
  tanh_: function (t) {
    var e = mn(t, "x", "tanh");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.tanh(e);
      return n([r]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return On(1).sub(n.square()).mulStrict(t);
        }
      };
    }, "Tanh", {}, null, [!0]);
  }
});

exports.tanh = Bu;
exports.tan = Mu;
exports.step = Ou;
exports.sqrt = _u;
exports.softplus = Fu;
exports.sinh = Nu;
exports.sin = Tu;
exports.isFinite = Du;
exports.isInf = Au;
exports.isNaN = Su;
exports.sign = ku;
exports.sigmoid = Iu;
exports.rsqrt = Ru;
exports.round = Eu;
exports.reciprocal = Cu;
exports.neg = wu;
exports.logSigmoid = bu;
exports.log1p = xu;
exports.log = yu;
exports.floor = gu;
exports.expm1 = mu;
exports.exp = vu;
exports.erf = pu;
exports.cosh = du;
exports.cos = fu;
exports.clipByValue = hu;
exports.ceil = lu;
exports.atanh = cu;
exports.atan = uu;
exports.asinh = su;
exports.asin = iu;
exports.acosh = au;
exports.acos = ou;
exports.abs = ru;

function Pu(t, e, n, r, o, a) {
  var i,
      s,
      u = mn(t, "x", "batchNorm"),
      c = mn(e, "mean", "batchNorm"),
      l = mn(n, "variance", "batchNorm");
  return null != o && (i = mn(o, "scale", "batchNorm")), null != r && (s = mn(r, "offset", "batchNorm")), C(2 === u.rank, function () {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + ".";
  }), C(2 === c.rank || 1 === c.rank, function () {
    return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c.rank + ".";
  }), C(2 === l.rank || 1 === l.rank, function () {
    return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l.rank + ".";
  }), null != i && C(2 === i.rank || 1 === i.rank, function () {
    return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i.rank + ".";
  }), null != s && C(2 === s.rank || 1 === s.rank, function () {
    return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s.rank + ".";
  }), Uu(u, c, l, s, i, a);
}

function Lu(t, e, n, r, o, a) {
  var i,
      s,
      u = mn(t, "x", "batchNorm"),
      c = mn(e, "mean", "batchNorm"),
      l = mn(n, "variance", "batchNorm");
  return null != o && (i = mn(o, "scale", "batchNorm")), null != r && (s = mn(r, "offset", "batchNorm")), C(3 === u.rank, function () {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + ".";
  }), C(3 === c.rank || 1 === c.rank, function () {
    return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c.rank + ".";
  }), C(3 === l.rank || 1 === l.rank, function () {
    return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l.rank + ".";
  }), null != i && C(3 === i.rank || 1 === i.rank, function () {
    return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i.rank + ".";
  }), null != s && C(3 === s.rank || 1 === s.rank, function () {
    return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s.rank + ".";
  }), Uu(u, c, l, s, i, a);
}

function Wu(t, e, n, r, o, a) {
  var i,
      s,
      u = mn(t, "x", "batchNorm"),
      c = mn(e, "mean", "batchNorm"),
      l = mn(n, "variance", "batchNorm");
  return null != o && (i = mn(o, "scale", "batchNorm")), null != r && (s = mn(r, "offset", "batchNorm")), C(4 === u.rank, function () {
    return "Error in batchNorm4D: x must be rank 4 but got rank " + u.rank + ".";
  }), C(4 === c.rank || 1 === c.rank, function () {
    return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c.rank + ".";
  }), C(4 === l.rank || 1 === l.rank, function () {
    return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l.rank + ".";
  }), null != i && C(4 === i.rank || 1 === i.rank, function () {
    return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i.rank + ".";
  }), null != s && C(4 === s.rank || 1 === s.rank, function () {
    return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s.rank + ".";
  }), Uu(u, c, l, s, i, a);
}

function Uu(t, e, n, r, o, a) {
  null == a && (a = .001);
  var i,
      s,
      u,
      c = mn(t, "x", "batchNorm"),
      l = mn(e, "mean", "batchNorm"),
      h = mn(n, "variance", "batchNorm");
  null != o && (i = mn(o, "scale", "batchNorm")), null != r && (s = mn(r, "offset", "batchNorm")), C(l.rank === h.rank, function () {
    return "Batch normalization gradient requires mean and variance to have equal ranks.";
  }), C(null == s || l.rank === s.rank, function () {
    return "Batch normalization gradient requires mean and offset to have equal ranks.";
  }), C(null == i || l.rank === i.rank, function () {
    return "Batch normalization gradient requires mean and scale to have equal ranks.";
  }), u = 0 === c.rank || 1 === c.rank ? c.as4D(1, 1, 1, c.size) : 2 === c.rank ? c.as4D(1, 1, c.shape[0], c.shape[1]) : 3 === c.rank ? c.as4D(1, c.shape[0], c.shape[1], c.shape[2]) : c;
  var f = [c, l, h, i];
  return Lt.runKernelFunc(function (t, e) {
    var n = t.batchNormalization(u, Vu(l), Vu(h), a, Vu(i), Vu(s));
    return e([c, l, h, i]), n;
  }, {
    x: c,
    mean: l,
    variance: h,
    scale: i,
    offset: s
  }, function (t, e) {
    var n = e,
        r = n[0],
        o = n[1],
        i = n[2],
        s = n[3],
        c = null == s ? On(1) : s,
        l = Eo(o.shape, u.shape),
        h = [];

    if (1 === o.rank) {
      for (var f = 0; f < u.shape.length - 1; ++f) h.push(u.shape[f]);

      h.push(1);
    }

    var d = r.sub(o),
        p = t.mul(c),
        v = Ru(i.add(On(a))),
        m = v.mul(v).mul(v).mul(On(-.5));
    return {
      x: function () {
        return 1 === o.rank ? t.mul(Lr(v.as4D(1, 1, 1, o.shape[0]), h)).mul(c).reshape(r.shape) : t.mul(v).mul(c).reshape(r.shape);
      },
      mean: function () {
        var t = v.mul(On(-1)).mul(p);
        return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);
      },
      variance: function () {
        var t = m.mul(d).mul(p);
        return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);
      },
      scale: function () {
        var e = d.mul(v),
            n = t.mul(e);
        return 1 === o.rank && (n = n.sum(l)), n.reshape(o.shape);
      },
      offset: function () {
        var e = t;
        return 1 === o.rank && (e = e.sum(l)), e.reshape(o.shape);
      }
    };
  }, "BatchNormalization", {
    varianceEpsilon: a
  }, f).reshape(c.shape);
}

function Vu(t) {
  return null == t ? null : 0 === t.rank ? t.as1D() : 1 === t.rank ? t : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t;
}

function zu() {
  Xe("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}

var Gu = An({
  batchNormalization2d_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), zu(), Pu(t, e, n, a, o, r);
  }
}),
    Hu = An({
  batchNormalization3d_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), zu(), Lu(t, e, n, a, o, r);
  }
}),
    qu = An({
  batchNormalization4d_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), zu(), Wu(t, e, n, a, o, r);
  }
}),
    Ku = An({
  batchNormalization_: function (t, e, n, r, o, a) {
    return void 0 === r && (r = .001), zu(), Uu(t, e, n, a, o, r);
  }
}),
    ju = An({
  batchNorm_: Uu
}),
    Xu = An({
  batchNorm2d_: Pu
}),
    Yu = An({
  batchNorm3d_: Lu
}),
    $u = An({
  batchNorm4d_: Wu
});
exports.batchNorm4d = $u;
exports.batchNorm3d = Yu;
exports.batchNorm2d = Xu;
exports.batchNorm = ju;
exports.batchNormalization = Ku;
exports.batchNormalization4d = qu;
exports.batchNormalization3d = Hu;
exports.batchNormalization2d = Gu;

var Qu = An({
  logicalAnd_: function (t, e) {
    var n = mn(t, "a", "logicalAnd", "bool"),
        r = mn(e, "b", "logicalAnd", "bool");
    return Ro(n.shape, r.shape), Lt.runKernelFunc(function (t) {
      return t.logicalAnd(n, r);
    }, {
      a: n,
      b: r
    }, null, "LogicalAnd");
  }
}),
    Ju = An({
  logicalNot_: function (t) {
    var e = mn(t, "x", "logicalNot", "bool");
    return Lt.runKernelFunc(function (t) {
      return t.logicalNot(e);
    }, {
      $x: e
    });
  }
}),
    Zu = An({
  logicalOr_: function (t, e) {
    var n = mn(t, "a", "logicalOr", "bool"),
        r = mn(e, "b", "logicalOr", "bool");
    return Ro(n.shape, r.shape), Lt.runKernelFunc(function (t) {
      return t.logicalOr(n, r);
    }, {
      $a: n,
      $b: r
    });
  }
}),
    tc = An({
  logicalXor_: function (t, e) {
    var n = mn(t, "a", "logicalXor", "bool"),
        r = mn(e, "b", "logicalXor", "bool");
    return Ro(n.shape, r.shape), Zu(t, e).logicalAnd(Qu(t, e).logicalNot());
  }
}),
    ec = An({
  where_: function (t, e, n) {
    var r = mn(e, "a", "where"),
        o = mn(n, "b", "where"),
        a = mn(t, "condition", "where", "bool");
    return E(r.shape, o.shape, "Error in where: "), 1 === a.rank ? C(a.shape[0] === r.shape[0], function () {
      return "The first dimension of `a` must match the size of `condition`.";
    }) : E(a.shape, o.shape, "Error in where: "), Lt.runKernelFunc(function (t, e) {
      var n = t.select(a, r, o);
      return e([a]), n;
    }, {
      $condition: a,
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0];
      return {
        $condition: function () {
          return Xn(n).toFloat();
        },
        $a: function () {
          return t.mul(n.cast(t.dtype));
        },
        $b: function () {
          return t.mul(n.logicalNot().cast(t.dtype));
        }
      };
    });
  }
}),
    nc = function (t) {
  return n(this, void 0, void 0, function () {
    var e, n, o;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return [4, (e = mn(t, "condition", "whereAsync", "bool")).data()];

        case 1:
          return n = r.sent(), o = na(e.shape, n), t !== e && e.dispose(), [2, o];
      }
    });
  });
};

exports.whereAsync = nc;
exports.where = ec;
exports.logicalXor = tc;
exports.logicalOr = Zu;
exports.logicalNot = Ju;
exports.logicalAnd = Qu;
var rc = An({
  add_: function (t, e) {
    var n,
        r = mn(t, "a", "add"),
        o = mn(e, "b", "add");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Ro(r.shape, o.shape);
    return Lt.runKernelFunc(function (t) {
      return t.add(r, o);
    }, {
      a: r,
      b: o
    }, function (t) {
      return {
        a: function () {
          var e = t,
              n = Eo(r.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);
        },
        b: function () {
          var e = t,
              n = Eo(o.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.reshape(o.shape);
        }
      };
    }, "Add");
  }
}),
    oc = An({
  addN_: function (t) {
    C(Array.isArray(t), function () {
      return "The argument passed to tf.addN() must be a list of tensors";
    }), C(t.length >= 1, function () {
      return "Must pass at least one tensor to tf.addN(), but got " + t.length;
    });
    var e = t.map(function (t, e) {
      return mn(t, "tensors" + e, "addN");
    }),
        n = e[0];
    e.forEach(function (t) {
      if (t.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
    }), e.forEach(function (t) {
      if (!S(t.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
    });
    var r = e;
    return Lt.runKernelFunc(function (t) {
      return t.addN(e);
    }, r, function (t) {
      var n = {};
      return e.forEach(function (e, r) {
        n[r] = function () {
          return t.clone();
        };
      }), n;
    }, "AddN");
  }
}),
    ac = An({
  addStrict_: function (t, e) {
    var n = mn(t, "a", "addStrict"),
        r = mn(e, "b", "addStrict");
    return E(n.shape, r.shape, "Error in addStrict: "), n.add(r);
  }
}),
    ic = An({
  atan2_: function (t, e) {
    var n,
        r = mn(t, "a", "atan2"),
        o = mn(e, "b", "atan2");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Ro(r.shape, o.shape);
    return Lt.runKernelFunc(function (t, e) {
      var n = t.atan2(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          var e = rc(n.square(), r.square()),
              o = t.mul(r.div(e)),
              i = Eo(n.shape, a);
          return i.length > 0 && (o = o.sum(i)), o.reshape(n.shape);
        },
        $b: function () {
          var e = rc(n.square(), r.square()),
              o = wu(t.mul(n.div(e))),
              i = Eo(r.shape, a);
          return i.length > 0 && (o = o.sum(i)), o.reshape(r.shape);
        }
      };
    });
  }
}),
    sc = An({
  div_: function (t, e) {
    var n,
        r = mn(t, "a", "div"),
        o = mn(e, "b", "div");
    if (n = Nt(r, o), r = n[0], o = n[1], "int32" === r.dtype && "int32" === o.dtype) return lc(r, o);
    var a = Ro(r.shape, o.shape);
    return Lt.runKernelFunc(function (t, e) {
      var n = t.realDivide(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          var e = t.div(r.toFloat()),
              o = Eo(n.shape, a);
          return o.length > 0 ? e.sum(o).reshape(n.shape) : e;
        },
        b: function () {
          var e = t.mul(n.toFloat()),
              o = Eo(r.shape, a);
          o.length > 0 && (e = e.sum(o).reshape(r.shape));
          var i = r.square();
          return e.div(i.toFloat()).neg();
        }
      };
    }, "Div");
  }
}),
    uc = An({
  divNoNan_: function (t, e) {
    var n,
        r = mn(t, "a", "div"),
        o = mn(e, "b", "div");
    r = (n = Nt(r, o))[0], o = n[1];
    var a = sc(r, o),
        i = Xn(a),
        s = o.equal(i);
    return ec(s, i, a);
  }
}),
    cc = An({
  divStrict_: function (t, e) {
    var n = mn(t, "a", "div"),
        r = mn(e, "b", "div");
    return E(n.shape, r.shape, "Error in divideStrict: "), n.div(r);
  }
}),
    lc = An({
  floorDiv_: function (t, e) {
    var n,
        r = mn(t, "a", "floorDiv"),
        o = mn(e, "b", "floorDiv");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Ro(r.shape, o.shape);
    return Lt.runKernelFunc(function (t, e) {
      var n = t.floorDiv(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          var e = t.div(r.toFloat()),
              o = Eo(n.shape, a);
          return o.length > 0 ? e.sum(o).reshape(n.shape) : e;
        },
        b: function () {
          var e = t.mul(n.toFloat()),
              o = Eo(r.shape, a);
          o.length > 0 && (e = e.sum(o).reshape(r.shape));
          var i = r.square();
          return e.div(i.toFloat()).neg();
        }
      };
    }, "FloorDiv");
  }
}),
    hc = An({
  maximum_: function (t, e) {
    var n,
        r = mn(t, "a", "maximum"),
        o = mn(e, "b", "maximum");
    return n = Nt(r, o), r = n[0], o = n[1], "bool" === r.dtype && (r = r.toInt(), o = o.toInt()), Ro(r.shape, o.shape), Lt.runKernelFunc(function (t, e) {
      var n = t.maximum(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          return t.mul(n.greaterEqual(r).toFloat());
        },
        b: function () {
          return t.mul(n.less(r).toFloat());
        }
      };
    }, "Maximum");
  }
}),
    fc = An({
  maximumStrict_: function (t, e) {
    var n = mn(t, "a", "maximumStrict"),
        r = mn(e, "b", "maximumStrict");
    return E(n.shape, r.shape, "Error in maximumStrict: "), n.maximum(r);
  }
}),
    dc = An({
  minimum_: function (t, e) {
    var n,
        r = mn(t, "a", "minimum"),
        o = mn(e, "b", "minimum");
    return n = Nt(r, o), r = n[0], o = n[1], "bool" === r.dtype && (r = r.toInt(), o = o.toInt()), Ro(r.shape, o.shape), Lt.runKernelFunc(function (t, e) {
      var n = t.minimum(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          return t.mul(n.lessEqual(r).toFloat());
        },
        b: function () {
          return t.mul(n.greater(r).toFloat());
        }
      };
    }, "Minimum");
  }
}),
    pc = An({
  minimumStrict_: function (t, e) {
    var n = mn(t, "a", "minimumStrict"),
        r = mn(e, "b", "minimumStrict");
    return E(n.shape, r.shape, "Error in minimumStrict: "), n.minimum(r);
  }
}),
    vc = An({
  mod_: function (t, e) {
    var n,
        r = mn(t, "a", "mod"),
        o = mn(e, "b", "mod");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Ro(r.shape, o.shape);
    return Lt.runKernelFunc(function (t, e) {
      var n = t.mod(r, o);
      return e([r, o]), n;
    }, {
      $a: r,
      $b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        $a: function () {
          var e = Eo(n.shape, a);
          return e.length > 0 ? t.sum(e).reshape(n.shape) : t;
        },
        $b: function () {
          var e = t.mul(n.div(r).floor().neg()),
              o = Eo(r.shape, a);
          return o.length > 0 ? e.sum(o).reshape(r.shape) : e;
        }
      };
    });
  }
}),
    mc = An({
  modStrict_: function (t, e) {
    var n = mn(t, "a", "modStrict"),
        r = mn(e, "b", "modStrict");
    return E(n.shape, r.shape, "Error in modStrict: "), n.mod(r);
  }
}),
    gc = An({
  mul_: function (t, e) {
    var n,
        r = mn(t, "a", "mul"),
        o = mn(e, "b", "mul");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Ro(r.shape, o.shape);
    return Lt.runKernelFunc(function (t, e) {
      var n = t.multiply(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          var e = t.mul(r.toFloat()),
              o = Eo(n.shape, a);
          return o.length > 0 ? e.sum(o).reshape(n.shape) : e;
        },
        b: function () {
          var e = t.mul(n.toFloat()),
              o = Eo(r.shape, a);
          return o.length > 0 ? e.sum(o).reshape(r.shape) : e;
        }
      };
    }, "Mul");
  }
}),
    yc = An({
  mulStrict_: function (t, e) {
    var n = mn(t, "a", "mul"),
        r = mn(e, "b", "mul");
    return E(n.shape, r.shape, "Error in multiplyStrict: "), n.mul(r);
  }
}),
    xc = An({
  pow_: function (t, e) {
    var n,
        r = mn(t, "base", "pow"),
        o = mn(e, "exp", "pow");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Ro(r.shape, o.shape),
        i = [r, o];
    return Lt.runKernelFunc(function (t, e) {
      var n = t.pow(r, o);
      return e([r, o, n]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1],
          o = e[2];
      return {
        a: function () {
          var e = r.toFloat(),
              o = t.mul(e.mul(n.pow(e.sub(On(1))))),
              i = Eo(n.shape, a);
          return i.length > 0 && (o = o.sum(i)), o.reshape(n.shape);
        },
        b: function () {
          var e = n.greater(0),
              i = n.log().where(e, Xn(n)),
              s = t.mul(o.mul(i)),
              u = Eo(r.shape, a);
          return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape);
        }
      };
    }, "Pow", {}, i, [!0]);
  }
}),
    bc = An({
  powStrict_: function (t, e) {
    return E(t.shape, e.shape, "Error in powStrict: "), t.pow(e);
  }
}),
    wc = An({
  squaredDifferenceStrict_: function (t, e) {
    var n = mn(t, "a", "squaredDifferenceStrict"),
        r = mn(e, "b", "squaredDifferenceStrict");
    return E(n.shape, r.shape, "Error in squaredDifferenceStrict: "), n.squaredDifference(r);
  }
}),
    Cc = An({
  sub_: function (t, e) {
    var n,
        r = mn(t, "a", "sub"),
        o = mn(e, "b", "sub");
    n = Nt(r, o), r = n[0], o = n[1];
    var a = Ro(r.shape, o.shape);
    return Lt.runKernelFunc(function (t) {
      return t.subtract(r, o);
    }, {
      a: r,
      b: o
    }, function (t) {
      return {
        a: function () {
          var e = t,
              n = Eo(r.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);
        },
        b: function () {
          var e = t,
              n = Eo(o.shape, a);
          return n.length > 0 && (e = e.sum(n)), e.neg().reshape(o.shape);
        }
      };
    }, "Sub");
  }
}),
    Ec = An({
  subStrict_: function (t, e) {
    var n = mn(t, "a", "subStrict"),
        r = mn(e, "b", "subStrict");
    return E(n.shape, r.shape, "Error in subStrict: "), n.sub(r);
  }
});
exports.subStrict = Ec;
exports.sub = Cc;
exports.squaredDifferenceStrict = wc;
exports.powStrict = bc;
exports.pow = xc;
exports.mulStrict = yc;
exports.mul = gc;
exports.modStrict = mc;
exports.mod = vc;
exports.minimumStrict = pc;
exports.minimum = dc;
exports.maximumStrict = fc;
exports.maximum = hc;
exports.floorDiv = lc;
exports.divStrict = cc;
exports.divNoNan = uc;
exports.div = sc;
exports.atan2 = ic;
exports.addStrict = ac;
exports.addN = oc;
exports.add = rc;

var Rc = An({
  equal_: function (t, e) {
    var n,
        r = mn(t, "a", "equal"),
        o = mn(e, "b", "equal");
    return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function (t) {
      return t.equal(r, o);
    }, {
      $a: r,
      $b: o
    });
  }
}),
    Ic = An({
  equalStrict_: function (t, e) {
    var n = mn(t, "a", "equalStrict"),
        r = mn(e, "b", "equalStrict");
    return E(n.shape, r.shape, "Error in equalStrict: "), n.equal(r);
  }
}),
    kc = An({
  greater_: function (t, e) {
    var n,
        r = mn(t, "a", "greater"),
        o = mn(e, "b", "greater");
    return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function (t) {
      return t.greater(r, o);
    }, {
      a: r,
      b: o
    }, null, "Greater");
  }
}),
    Sc = An({
  greaterEqual_: function (t, e) {
    var n,
        r = mn(t, "a", "greaterEqual"),
        o = mn(e, "b", "greaterEqual");
    return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function (t, e) {
      var n = t.greaterEqual(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, function (t, e) {
      var n = e[0],
          r = e[1];
      return {
        a: function () {
          return Xn(n);
        },
        b: function () {
          return Xn(r);
        }
      };
    }, "GreaterEqual");
  }
}),
    Ac = An({
  greaterEqualStrict_: function (t, e) {
    var n = mn(t, "a", "greaterEqualStrict"),
        r = mn(e, "b", "greaterEqualStrict");
    return E(n.shape, r.shape, "Error in greaterEqualStrict: "), n.greaterEqual(r);
  }
}),
    Dc = An({
  greaterStrict_: function (t, e) {
    var n = mn(t, "a", "greaterStrict"),
        r = mn(e, "b", "greaterStrict");
    return E(n.shape, r.shape, "Error in greaterStrict: "), n.greater(r);
  }
}),
    Tc = An({
  less_: function (t, e) {
    var n,
        r = mn(t, "a", "less"),
        o = mn(e, "b", "less");
    return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function (t) {
      return t.less(r, o);
    }, {
      a: r,
      b: o
    }, null, "Less");
  }
}),
    Nc = An({
  lessEqual_: function (t, e) {
    var n,
        r = mn(t, "a", "lessEqual"),
        o = mn(e, "b", "lessEqual");
    return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function (t, e) {
      var n = t.lessEqual(r, o);
      return e([r, o]), n;
    }, {
      a: r,
      b: o
    }, null, "LessEqual");
  }
}),
    Fc = An({
  lessEqualStrict_: function (t, e) {
    var n = mn(t, "a", "lessEqualStrict"),
        r = mn(e, "b", "lessEqualStrict");
    return E(n.shape, r.shape, "Error in lessEqualStrict: "), n.lessEqual(r);
  }
}),
    _c = An({
  lessStrict_: function (t, e) {
    var n = mn(t, "a", "lessStrict"),
        r = mn(e, "b", "lessStrict");
    return E(n.shape, r.shape, "Error in lessStrict: "), n.less(r);
  }
}),
    Oc = An({
  notEqual_: function (t, e) {
    var n,
        r = mn(t, "a", "notEqual"),
        o = mn(e, "b", "notEqual");
    return n = Nt(r, o), r = n[0], o = n[1], Ro(r.shape, o.shape), Lt.runKernelFunc(function (t) {
      return t.notEqual(r, o);
    }, {
      a: r,
      b: o
    }, null, "NotEqual");
  }
}),
    Mc = An({
  notEqualStrict_: function (t, e) {
    var n = mn(t, "a", "notEqualStrict"),
        r = mn(e, "b", "notEqualStrict");
    return E(n.shape, r.shape, "Error in notEqualStrict: "), n.notEqual(r);
  }
});

exports.notEqualStrict = Mc;
exports.notEqual = Oc;
exports.lessStrict = _c;
exports.lessEqualStrict = Fc;
exports.lessEqual = Nc;
exports.less = Tc;
exports.greaterStrict = Dc;
exports.greaterEqualStrict = Ac;
exports.greaterEqual = Sc;
exports.greater = kc;
exports.equalStrict = Ic;
exports.equal = Rc;

function Bc(t, e) {
  for (var n = [], r = t; r < e; ++r) n.push(r);

  return n;
}

function Pc(t) {
  for (var e = [], n = 0; n < t.length; ++n) for (var r = 0; r < t[n].length; ++r) e.push(t[n][r]);

  return e;
}

var Lc = An({
  gather_: function (t, e, n) {
    void 0 === n && (n = 0);
    var r = mn(t, "x", "gather"),
        o = mn(e, "indices", "gather", "int32");
    n = O(n, r.shape)[0];

    var a = function (t, e, n) {
      for (var r = t.shape[n], o = [], a = 1, i = 1, s = 0; s < n; s++) o.push(t.shape[s]), a *= t.shape[s];

      for (s = 0; s < e.rank; s++) o.push(e.shape[s]);

      for (s = n + 1; s < t.rank; s++) o.push(t.shape[s]), i *= t.shape[s];

      return {
        batchSize: a,
        sliceSize: i,
        dimSize: r,
        outputShape: o
      };
    }(r, o, n);

    return Lt.runKernelFunc(function (t, e) {
      var a = t.gather(r, o.flatten(), n);
      return e([o]), a;
    }, {
      x: r,
      indices: o
    }, function (t, e) {
      var o = e[0];
      return {
        x: function () {
          var e = r.shape,
              a = o.size,
              i = e.slice(0, n),
              s = i.length,
              u = e.slice(n, e.length).slice(1),
              c = u.length,
              l = Bc(0, s),
              h = Bc(s + 1, s + 1 + c),
              f = Pc([i, [a], u]),
              d = t.reshape(f),
              p = o.reshape([a]),
              v = Pc([[s], l, h]),
              m = d.transpose(v),
              g = Wc(m, p, r.shape[n]),
              y = Rn(v);
          return g = g.transpose(y);
        },
        indices: function () {
          return o;
        }
      };
    }, "Gather", {
      axis: n
    }).reshape(a.outputShape);
  }
}),
    Wc = An({
  unsortedSegmentSum_: function (t, e, n) {
    var r = mn(t, "x", "unsortedSegmentSum"),
        o = mn(e, "segmentIds", "unsortedSegmentSum", "int32");
    return C(A(n), function () {
      return "numSegments must be of dtype int";
    }), Lt.runKernelFunc(function (t, e) {
      var a = t.unsortedSegmentSum(r, o, n);
      return e([o]), a;
    }, {
      $x: r
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return function (t, e) {
            for (var n = hc(e, Xn(e)), r = Lc(t, n), o = Sc(e, On(0, "int32")), a = r.rank - o.rank, i = 0; i < a; ++i) o = wr(o, i + 1);

            o = Qu(o, zn(r.shape, "bool"));
            var s = Xn(r);
            return ec(o, r, s);
          }(t, n);
        }
      };
    });
  }
});
exports.unsortedSegmentSum = Wc;
exports.gather = Lc;

var Uc = function (t, e, o) {
  return n(this, void 0, void 0, function () {
    var n, a, i, s, u, c, l, h, f, d, p, v, m;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          for (n = mn(t, "tensor", "boolMask"), a = mn(e, "mask", "boolMask", "bool"), i = null == o ? 0 : o, s = a.rank, u = n.shape, C(s > 0, function () {
            return "mask cannot be scalar";
          }), E(u.slice(i, i + s), a.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c = 1, l = i; l < i + s; l++) c *= u[l];

          return h = u.slice(0, i).concat([c], u.slice(i + s)), f = n.reshape(h), d = a.reshape([-1]), [4, nc(d)];

        case 1:
          return p = r.sent(), v = p.squeeze([1]), m = Lc(f, v, i), t !== n && n.dispose(), e !== a && a.dispose(), v.dispose(), f.dispose(), d.dispose(), p.dispose(), [2, m];
      }
    });
  });
};

exports.booleanMaskAsync = Uc;

function Vc(t, e, n, r, o, a, i) {
  void 0 === a && (a = "NHWC"), C(t.length === e.rank, function () {
    return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match";
  });
  var s = t,
      u = e,
      c = !1;
  3 === e.rank && (c = !0, u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), s = [1, t[0], t[1], t[2]]), C(4 === s.length, function () {
    return "Error in conv2dDerInput: inShape must be length 4, but got length " + s.length + ".";
  }), C(4 === u.rank, function () {
    return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u.rank;
  }), C(4 === n.rank, function () {
    return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n.rank;
  });
  var l = "NHWC" === a ? s[3] : s[1],
      h = "NHWC" === a ? u.shape[3] : u.shape[1];
  C(l === n.shape[2], function () {
    return "Error in conv2dDerInput: depth of input (" + l + ") must match input depth for filter " + n.shape[2] + ".";
  }), C(h === n.shape[3], function () {
    return "Error in conv2dDerInput: depth of output (" + h + ") must match output depth for filter " + n.shape[3] + ".";
  }), null != i && C(A(o), function () {
    return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + o + ".";
  });
  var f = Bo(a),
      d = So(s, n.shape, r, 1, o, i, !1, f),
      p = Lt.runKernelFunc(function (t, e) {
    var r = t.conv2dDerInput(u, n, d);
    return e([n, u]), r;
  }, {
    dy4D: u,
    filter: n
  }, function (t, e) {
    var n = e[0],
        s = e[1];
    return {
      dy4D: function () {
        return qc(t, n, r, o, a, 1, i);
      },
      filter: function () {
        return jc(t, s, n.shape, r, o, a, i);
      }
    };
  });
  return c ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;
}

function zc(t) {
  var e = function (t) {
    return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t;
  }(t),
      n = e[0],
      r = e[1],
      o = e[2];

  return 1 === n && 1 === r && 1 === o;
}

function Gc(t, e, n, r, o) {
  C(t.length === e.rank, function () {
    return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match";
  });
  var a = t,
      i = e,
      s = !1;
  4 === e.rank && (s = !0, i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), a = [1, t[0], t[1], t[2], t[3]]);
  var u = a[4],
      c = i.shape[4];
  C(5 === a.length, function () {
    return "Error in conv3dDerInput: inShape must be length 5, but got length " + a.length + ".";
  }), C(5 === i.rank, function () {
    return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i.rank;
  }), C(5 === n.rank, function () {
    return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n.rank;
  }), C(u === n.shape[3], function () {
    return "Error in conv3dDerInput: depth of input (" + u + ") must match input depth for filter " + n.shape[3] + ".";
  }), C(c === n.shape[4], function () {
    return "Error in conv3dDerInput: depth of output (" + c + ") must match output depth for filter " + n.shape[4] + ".";
  });
  var l = Ao(a, n.shape, r, 1, o),
      h = Lt.runKernelFunc(function (t) {
    return t.conv3dDerInput(i, n, l);
  }, {
    dy5D: i
  });
  return s ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
}

var Hc = An({
  conv1d_: function (t, e, n, r, o, a, i) {
    void 0 === o && (o = "NWC"), void 0 === a && (a = 1);
    var s = mn(t, "x", "conv1d"),
        u = mn(e, "filter", "conv1d"),
        c = s,
        l = !1;
    2 === s.rank && (l = !0, c = s.as3D(1, s.shape[0], s.shape[1])), C(3 === c.rank, function () {
      return "Error in conv1d: input must be rank 3, but got rank " + c.rank + ".";
    }), C(3 === u.rank, function () {
      return "Error in conv1d: filter must be rank 3, but got rank " + u.rank + ".";
    }), null != i && C(A(r), function () {
      return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
    }), C(c.shape[2] === u.shape[1], function () {
      return "Error in conv1d: depth of input (" + c.shape[2] + ") must match input depth for filter " + u.shape[1] + ".";
    }), C(Mo(n, a), function () {
      return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n + " and dilation '" + a + "'";
    }), C("NWC" === o, function () {
      return "Error in conv1d: got dataFormat of " + o + " but only NWC is currently supported.";
    });
    var h = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]),
        f = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]),
        d = qc(f, h, [1, n], r, "NHWC", [1, a], i);
    return l ? d.as2D(d.shape[2], d.shape[3]) : d.as3D(d.shape[0], d.shape[2], d.shape[3]);
  }
}),
    qc = An({
  conv2d_: function (t, e, n, r, o, a, i) {
    void 0 === o && (o = "NHWC"), void 0 === a && (a = [1, 1]);
    var s = mn(t, "x", "conv2d"),
        u = mn(e, "filter", "conv2d"),
        c = s,
        l = !1;
    3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), C(4 === c.rank, function () {
      return "Error in conv2d: input must be rank 4, but got rank " + c.rank + ".";
    }), C(4 === u.rank, function () {
      return "Error in conv2d: filter must be rank 4, but got rank " + u.rank + ".";
    }), null != i && C(A(r), function () {
      return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
    });
    var h = "NHWC" === o ? c.shape[3] : c.shape[1];
    C(h === u.shape[2], function () {
      return "Error in conv2d: depth of input (" + h + ") must match input depth for filter " + u.shape[2] + ".";
    }), C(Mo(n, a), function () {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'";
    });
    var f = Bo(o),
        d = So(c.shape, u.shape, n, a, r, i, !1, f),
        p = [u, c],
        v = Lt.runKernelFunc(function (t, e) {
      var n = t.conv2d(c, u, d);
      return e([u, c]), n;
    }, {
      x: c,
      filter: u
    }, function (t, e) {
      var i = e,
          s = i[0],
          u = i[1];
      return C(Oo(a), function () {
        return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a + "'";
      }), {
        x: function () {
          return Xc(u.shape, t, s, n, r, o);
        },
        filter: function () {
          return jc(u, t, s.shape, n, r, o);
        }
      };
    }, "Conv2D", d, p);
    return l ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;
  }
}),
    Kc = An({
  conv3d_: function (t, e, n, r, o, a) {
    void 0 === o && (o = "NDHWC"), void 0 === a && (a = [1, 1, 1]);
    var i = mn(t, "x", "conv3d"),
        s = mn(e, "filter", "conv3d"),
        u = i,
        c = !1;
    4 === i.rank && (c = !0, u = i.as5D(1, i.shape[0], i.shape[1], i.shape[2], i.shape[3])), C(5 === u.rank, function () {
      return "Error in conv3d: input must be rank 5, but got rank " + u.rank + ".";
    }), C(5 === s.rank, function () {
      return "Error in conv3d: filter must be rank 5, but got rank " + s.rank + ".";
    }), C(u.shape[4] === s.shape[3], function () {
      return "Error in conv3d: depth of input (" + u.shape[4] + ") must match input depth for filter " + s.shape[3] + ".";
    }), C(function (t, e) {
      return zc(t) || zc(e);
    }(n, a), function () {
      return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'";
    }), C("NDHWC" === o, function () {
      return "Error in conv3d: got dataFormat of " + o + " but only NDHWC is currently supported.";
    });
    var l = Ao(u.shape, s.shape, n, a, r),
        h = Lt.runKernelFunc(function (t, e) {
      var n = t.conv3d(u, s, l);
      return e([u, s]), n;
    }, {
      x: u,
      $filter: s
    }, function (t, e) {
      C(zc(a), function () {
        return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a + "'";
      });
      var o = e[0],
          i = e[1];
      return {
        x: function () {
          return Gc(o.shape, t, i, n, r);
        },
        $filter: function () {
          return function (t, e, n, r, o) {
            var a = t;
            4 === t.rank && (a = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]));
            var i = e;
            4 === i.rank && (i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]));
            C(5 === a.rank, function () {
              return "Error in conv3dDerFilter: input must be rank 5, but got shape " + a.shape + ".";
            }), C(5 === i.rank, function () {
              return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + i.shape + ".";
            }), C(5 === n.length, function () {
              return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n + ".";
            }), C(a.shape[4] === n[3], function () {
              return "Error in conv3dDerFilter: depth of input " + a.shape[4] + ") must match input depth in filter (" + n[3] + ".";
            }), C(i.shape[4] === n[4], function () {
              return "Error in conv3dDerFilter: depth of dy (" + i.shape[4] + ") must match output depth for filter (" + n[4] + ").";
            });
            var s = Ao(a.shape, n, r, 1, o);
            return Lt.runKernelFunc(function (t) {
              return t.conv3dDerFilter(a, i, s);
            }, {
              x5D: a,
              dy5D: i
            });
          }(o, t, i.shape, n, r);
        }
      };
    });
    return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
}),
    jc = An({
  conv2dDerFilter_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = "NHWC");
    var s = t;
    3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
    var u = e;
    3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), C(4 === s.rank, function () {
      return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s.shape + ".";
    }), C(4 === u.rank, function () {
      return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u.shape + ".";
    }), C(4 === n.length, function () {
      return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n + ".";
    });
    var c = "NHWC" === a ? s.shape[3] : s.shape[1],
        l = "NHWC" === a ? u.shape[3] : u.shape[1];
    C(c === n[2], function () {
      return "Error in conv2dDerFilter: depth of input " + c + ") must match input depth in filter (" + n[2] + ".";
    }), C(l === n[3], function () {
      return "Error in conv2dDerFilter: depth of dy (" + l + ") must match output depth for filter (" + n[3] + ").";
    }), null != i && C(A(o), function () {
      return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + o + ".";
    });
    var h = Bo(a),
        f = So(s.shape, n, r, 1, o, i, !1, h);
    return Lt.runKernelFunc(function (t) {
      return t.conv2dDerFilter(s, u, f);
    }, {
      x4D: s,
      dy4D: u
    });
  }
}),
    Xc = An({
  conv2dDerInput_: Vc
}),
    Yc = An({
  depthwiseConv2d_: function (t, e, n, r, o, a, i) {
    void 0 === o && (o = "NHWC"), void 0 === a && (a = [1, 1]);
    var s = mn(t, "x", "depthwiseConv2d"),
        u = mn(e, "filter", "depthwiseConv2d"),
        c = s,
        l = !1;
    3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), C(4 === c.rank, function () {
      return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c.rank + ".";
    }), C(4 === u.rank, function () {
      return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u.rank + ".";
    }), C(c.shape[3] === u.shape[2], function () {
      return "Error in depthwiseConv2d: number of input channels (" + c.shape[3] + ") must match the inChannels dimension in filter " + u.shape[2] + ".";
    }), null == a && (a = [1, 1]), C(Mo(n, a), function () {
      return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'";
    }), null != i && C(A(r), function () {
      return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
    });
    var h = So(c.shape, u.shape, n, a, r, i, !0),
        f = [c, u],
        d = Lt.runKernelFunc(function (t, e) {
      var n = t.depthwiseConv2D(c, u, h);
      return e([c, u]), n;
    }, {
      x: c,
      filter: u
    }, function (t, e) {
      C(Oo(a), function () {
        return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + a + "'";
      });
      var n = e[0],
          r = e[1];
      return {
        x: function () {
          return $c(n.shape, t, r, h);
        },
        filter: function () {
          return Qc(n, t, r.shape, h);
        }
      };
    }, "DepthwiseConv2dNative", h, f);
    return l ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;
  }
}),
    $c = An({
  depthwiseConv2dDerInput_: function (t, e, n, r) {
    var o = e,
        a = !1;
    3 === e.rank && (a = !0, o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));
    var i = Lt.runKernelFunc(function (t) {
      return t.depthwiseConv2DDerInput(o, n, r);
    }, {
      dy4D: o
    });
    return a ? i.as3D(i.shape[1], i.shape[2], i.shape[3]) : i;
  }
}),
    Qc = An({
  depthwiseConv2dDerFilter_: function (t, e, n, r) {
    var o = t;
    3 === t.rank && (o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
    var a = e;
    return 3 === a.rank && (a = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), Lt.runKernelFunc(function (t) {
      return t.depthwiseConv2DDerFilter(o, a, r);
    }, {
      x4D: o,
      dy4D: a
    });
  }
}),
    Jc = An({
  separableConv2d_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = [1, 1]), void 0 === i && (i = "NHWC");
    var s = mn(t, "x", "separableConv2d"),
        u = mn(e, "depthwiseFilter", "separableConv2d"),
        c = mn(n, "pointwiseFilter", "separableConv2d"),
        l = s,
        h = !1;
    if (3 === s.rank && (h = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), "NCHW" === i) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    C(4 === l.rank, function () {
      return "Error in separableConv2d: input must be rank 4, but got rank " + l.rank + ".";
    }), C(4 === u.rank, function () {
      return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u.rank + ".";
    }), C(4 === c.rank, function () {
      return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u.rank + ".";
    }), C(1 === c.shape[0], function () {
      return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c.shape[0] + ".";
    }), C(1 === c.shape[1], function () {
      return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c.shape[1] + ".";
    });
    var f = u.shape[2],
        d = u.shape[3];
    C(c.shape[2] === f * d, function () {
      return "Error in separableConv2d: the third dimension of pointwise filter must be " + f * d + ", but got " + c.shape[2] + ".";
    });
    var p = Yc(l, u, r, o, i, a),
        v = qc(p, c, 1, "valid", i);
    return h ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;
  }
}),
    Zc = An({
  conv2dTranspose_: function (t, e, n, r, o, a) {
    return Vc(n, mn(t, "x", "conv2dTranspose"), mn(e, "filter", "conv2dTranspose"), r, o, "NHWC", a);
  }
}),
    tl = An({
  conv3dTranspose_: function (t, e, n, r, o) {
    return Gc(n, mn(t, "x", "conv3dTranspose"), mn(e, "filter", "conv3dTranspose"), r, o);
  }
});
exports.conv3dTranspose = tl;
exports.conv2dTranspose = Zc;
exports.separableConv2d = Jc;
exports.depthwiseConv2d = Yc;
exports.conv3d = Kc;
exports.conv2d = qc;
exports.conv1d = Hc;
var el = An({
  matMul_: function (t, e, n, r) {
    var o;
    void 0 === n && (n = !1), void 0 === r && (r = !1);
    var a = mn(t, "a", "matMul"),
        i = mn(e, "b", "matMul");
    o = Nt(a, i), a = o[0], i = o[1];
    var s = n ? a.shape[a.rank - 2] : a.shape[a.rank - 1],
        u = r ? i.shape[i.rank - 1] : i.shape[i.rank - 2],
        c = n ? a.shape[a.rank - 1] : a.shape[a.rank - 2],
        l = r ? i.shape[i.rank - 2] : i.shape[i.rank - 1],
        h = a.shape.slice(0, -2),
        f = i.shape.slice(0, -2),
        d = k(h),
        p = k(f);
    C(a.rank >= 2 && i.rank >= 2 && a.rank === i.rank, function () {
      return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + a.rank + " and " + i.rank + ".";
    }), C(S(h, f), function () {
      return "Error in matMul: outer dimensions (" + h + ") and (" + f + ") of Tensors with shapes " + a.shape + " and " + i.shape + " must match.";
    }), C(s === u, function () {
      return "Error in matMul: inner shapes (" + s + ") and (" + u + ") of Tensors with shapes " + a.shape + " and " + i.shape + " and transposeA=" + n + " and transposeB=" + r + " must match.";
    });
    var v = a.shape.slice(0, -2).concat([c, l]),
        m = n ? a.as3D(d, s, c) : a.as3D(d, c, s),
        g = r ? i.as3D(p, l, u) : i.as3D(p, u, l),
        y = {
      transposeA: n,
      transposeB: r
    };
    return Lt.runKernelFunc(function (t, e) {
      var o = t.batchMatMul(m, g, n, r);
      return e([m, g]), o;
    }, {
      a: m,
      b: g
    }, function (t, e) {
      var o = e,
          a = o[0],
          i = o[1];
      return n || r ? !n && r ? {
        a: function () {
          return t.matMul(i, !1, !1);
        },
        b: function () {
          return t.matMul(a, !0, !1);
        }
      } : n && !r ? {
        a: function () {
          return i.matMul(t, !1, !0);
        },
        b: function () {
          return a.matMul(t, !1, !1);
        }
      } : {
        a: function () {
          return i.matMul(t, !0, !0);
        },
        b: function () {
          return t.matMul(a, !0, !0);
        }
      } : {
        a: function () {
          return t.matMul(i, !1, !0);
        },
        b: function () {
          return a.matMul(t, !0, !1);
        }
      };
    }, "BatchMatMul", y).reshape(v);
  }
}),
    nl = An({
  dot_: function (t, e) {
    var n = mn(t, "t1", "dot"),
        r = mn(e, "t2", "dot");
    C(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), function () {
      return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n.rank + " and " + r.rank + ".";
    });
    var o = 1 === n.rank ? n.size : n.shape[1],
        a = 1 === r.rank ? r.size : r.shape[0];
    return C(o === a, function () {
      return "Error in dot: inner dimensions of inputs must match, but got " + o + " and " + a + ".";
    }), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]));
  }
}),
    rl = An({
  outerProduct_: function (t, e) {
    var n = mn(t, "v1", "outerProduct"),
        r = mn(e, "v2", "outerProduct");
    return C(1 === n.rank && 1 === r.rank, function () {
      return "Error in outerProduct: inputs must be rank 1, but got ranks " + n.rank + " and " + r.rank + ".";
    }), n.as2D(-1, 1).matMul(r.as2D(1, -1));
  }
});
exports.outerProduct = rl;
exports.dot = nl;
exports.matMul = el;
var ol = An({
  reverse_: function (t, e) {
    var n = mn(t, "x", "reverse");
    if (0 === n.rank) return n.clone();
    var r = O(e, n.shape);
    return Lt.runKernelFunc(function (t) {
      return t.reverse(n, r);
    }, {
      $x: n
    }, function (t) {
      return {
        $x: function () {
          return t.reverse(r);
        }
      };
    }).reshapeAs(n);
  }
}),
    al = An({
  reverse1d_: function (t) {
    var e = mn(t, "x", "reverse");
    return C(1 === e.rank, function () {
      return "Error in reverse1D: x must be rank 1 but got rank " + e.rank + ".";
    }), ol(e, 0);
  }
}),
    il = An({
  reverse2d_: function (t, e) {
    var n = mn(t, "x", "reverse");
    return C(2 === n.rank, function () {
      return "Error in reverse2D: x must be rank 2 but got rank " + n.rank + ".";
    }), ol(n, e);
  }
}),
    sl = An({
  reverse3d_: function (t, e) {
    var n = mn(t, "x", "reverse");
    return C(3 === n.rank, function () {
      return "Error in reverse3D: x must be rank 3 but got rank " + n.rank + ".";
    }), ol(n, e);
  }
}),
    ul = An({
  reverse4d_: function (t, e) {
    var n = mn(t, "x", "reverse");
    return C(4 === n.rank, function () {
      return "Error in reverse4D: x must be rank 4 but got rank " + n.rank + ".";
    }), ol(n, e);
  }
});
exports.reverse4d = ul;
exports.reverse3d = sl;
exports.reverse2d = il;
exports.reverse1d = al;
exports.reverse = ol;

function cl(t, e, n, r, o, a) {
  var i = mn(t, "x", "maxPool"),
      s = i,
      u = !1;
  3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), null == r && (r = [1, 1]), C(4 === s.rank, function () {
    return "Error in maxPool: input must be rank 4 but got rank " + s.rank + ".";
  }), C(Mo(n, r), function () {
    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'";
  }), null != a && C(A(o), function () {
    return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + ".";
  });
  var c = Io(s.shape, e, n, r, o, a);
  if (1 === c.filterWidth && 1 === c.filterHeight && S(c.inShape, c.outShape)) return i.clone();
  var l = [s],
      h = Lt.runKernelFunc(function (t, e) {
    var n = t.maxPool(s, c);
    return e([s, n]), n;
  }, {
    x: s
  }, function (t, a) {
    var i = a[0],
        s = a[1];
    return {
      x: function () {
        return function (t, e, n, r, o, a, i, s) {
          var u = mn(t, "dy", "maxPoolBackprop"),
              c = mn(e, "input", "maxPoolBackprop"),
              l = mn(n, "output", "maxPoolBackprop");
          C(c.rank === u.rank, function () {
            return "Rank of input (" + c.rank + ") does not match rank of dy (" + u.rank + ")";
          }), null == a && (a = [1, 1]);
          C(Mo(o, a), function () {
            return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + a + "'";
          }), C(4 === u.rank, function () {
            return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + u.rank + ".";
          }), C(4 === c.rank, function () {
            return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c.rank + ".";
          }), null != s && C(A(i), function () {
            return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + s + " but got pad " + i + ".";
          });
          var h = Io(c.shape, r, o, a, i, s);
          return Lt.runKernelFunc(function (t) {
            return t.maxPoolBackprop(u, c, l, h);
          }, {
            $dy: u,
            $input: c
          });
        }(t, i, s, e, n, r, o);
      }
    };
  }, "MaxPool", c, l);
  return u ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h;
}

function ll(t, e, n, r, o, a) {
  var i = mn(t, "x", "avgPool", "float32");
  null == r && (r = [1, 1]), C(Mo(n, r), function () {
    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'";
  });
  var s = i,
      u = !1;
  3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), C(4 === s.rank, function () {
    return "Error in avgPool: x must be rank 4 but got rank " + s.rank + ".";
  }), null != a && C(A(o), function () {
    return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + ".";
  });
  var c = Io(s.shape, e, n, r, o, a);
  if (1 === c.filterWidth && 1 === c.filterHeight && S(c.inShape, c.outShape)) return i.clone();
  var l = Lt.runKernelFunc(function (t) {
    return t.avgPool(s, c);
  }, {
    x: s
  }, function (t) {
    return {
      x: function () {
        return function (t, e, n, r, o, a) {
          var i = mn(t, "dy", "avgPoolBackprop"),
              s = mn(e, "input", "avgPoolBackprop");
          C(s.rank === i.rank, function () {
            return "Rank of input (" + s.rank + ") does not match rank of dy (" + i.rank + ")";
          }), null == o && (o = [1, 1]);
          C(Mo(r, o), function () {
            return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + o + "'";
          });
          var u = s,
              c = i,
              l = !1;
          3 === s.rank && (l = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), c = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]));
          C(4 === c.rank, function () {
            return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c.rank + ".";
          }), C(4 === u.rank, function () {
            return "Error in avgPoolBackprop: input must be rank 4 but got rank " + u.rank + ".";
          });
          var h = Io(u.shape, n, r, o, a),
              f = Lt.runKernelFunc(function (t) {
            return t.avgPoolBackprop(c, u, h);
          }, {
            dy4D: c,
            input4D: u
          });
          if (l) return f.as3D(f.shape[1], f.shape[2], f.shape[3]);
          return f;
        }(t, s, e, n, r, o);
      }
    };
  }, "AvgPool", c);
  return l = l.cast(i.dtype), u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;
}

var hl = An({
  maxPool_: function (t, e, n, r, o) {
    return cl(t, e, n, 1, r, o);
  }
}),
    fl = An({
  avgPool_: function (t, e, n, r, o) {
    return ll(t, e, n, 1, r, o);
  }
}),
    dl = An({
  pool_: function (t, e, n, r, o, a) {
    null == o && (o = [1, 1]), null == a && (a = 1), 0 === r && (r = "valid");
    var i = mn(t, "x", "maxPool"),
        s = i,
        u = !1;
    3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), C(Mo(a, o), function () {
      return "Error in pool: Either strides or dilations must be 1. Got strides " + a + " and dilations '" + o + "'";
    });
    var c,
        l = Io(s.shape, e, a, o, r),
        h = [l.dilationHeight, l.dilationWidth];
    c = "same" === r ? function (t, e) {
      var n = t.map(function (t, n) {
        return t + (t - 1) * (e[n] - 1);
      }).map(function (t) {
        return t - 1;
      }),
          r = n.map(function (t) {
        return Math.floor(t / 2);
      }),
          o = n.map(function (t, e) {
        return t - r[e];
      });
      return n.map(function (t, e) {
        return [r[e], o[e]];
      });
    }([l.filterHeight, l.filterWidth], h) : [[0, 0], [0, 0]];

    var f = 1 === h[0] && 1 === h[1],
        d = function (t, e, n) {
      var r = n.map(function (t) {
        return t[0];
      }),
          o = n.map(function (t) {
        return t[1];
      }),
          a = t.concat(r, o),
          i = e.map(function (t, e) {
        return (t - a[e] % t) % t;
      }),
          s = o.map(function (t, e) {
        return t + i[e];
      }),
          u = e.map(function (t, e) {
        return [r[e], s[e]];
      }),
          c = e.map(function (t, e) {
        return [0, i[e]];
      });
      return [u, c];
    }([l.inHeight, l.inWidth], h, c),
        p = d[0],
        v = d[1],
        m = f ? r : "valid",
        g = f ? s : Mr(s, h, p),
        y = ("avg" === n ? function () {
      return ll(g, e, a, 1, m);
    } : function () {
      return cl(g, e, a, 1, m);
    })(),
        x = f ? y : vr(y, h, v);

    return u ? x.as3D(x.shape[1], x.shape[2], x.shape[3]) : x;
  }
}),
    pl = An({
  maxPool3d_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = "NDHWC");
    var s = mn(t, "x", "maxPool3d"),
        u = s,
        c = !1;
    4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == i && (i = [1, 1, 1]), C(5 === u.rank, function () {
      return "Error in maxPool3d: x must be rank 5 but got rank " + u.rank + ".";
    }), C("NDHWC" === a, function () {
      return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + a;
    }), C(Mo(n, i), function () {
      return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'";
    }), null != o && C(A(r), function () {
      return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + ".";
    });
    var l = ko(u.shape, e, n, i, r, o, a),
        h = Lt.runKernelFunc(function (t, e) {
      var n = t.maxPool3d(u, l);
      return e([u, n]), n;
    }, {
      x: u
    }, function (t, a) {
      var s = a[0],
          u = a[1];
      return {
        x: function () {
          return function (t, e, n, r, o, a, i, s) {
            var u = mn(t, "dy", "maxPool3dBackprop"),
                c = mn(e, "input", "maxPool3dBackprop"),
                l = mn(n, "output", "maxPool3dBackprop"),
                h = u,
                f = c,
                d = l,
                p = !1;
            4 === c.rank && (p = !0, h = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]), f = c.as5D(1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]), d = l.as5D(1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]));
            C(5 === h.rank, function () {
              return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h.rank + ".";
            }), C(5 === f.rank, function () {
              return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + f.rank + ".";
            }), C(5 === d.rank, function () {
              return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + d.rank + ".";
            }), null == a && (a = [1, 1, 1]);
            C(Mo(o, a), function () {
              return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + a + "'";
            }), null != s && C(A(i), function () {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + s + " but got pad " + i + ".";
            });
            var v = ko(f.shape, r, o, a, i, s),
                m = Lt.runKernelFunc(function (t) {
              return t.maxPool3dBackprop(h, f, d, v);
            }, {
              dy5D: h,
              input5D: f
            });
            if (p) return m.as4D(m.shape[1], m.shape[2], m.shape[3], m.shape[4]);
            return m;
          }(t, s, u, e, n, i, r, o);
        }
      };
    });
    return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
}),
    vl = An({
  avgPool3d_: function (t, e, n, r, o, a, i) {
    void 0 === a && (a = "NDHWC");
    var s = mn(t, "x", "avgPool3d", "float32"),
        u = s,
        c = !1;
    4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == i && (i = [1, 1, 1]), C(5 === u.rank, function () {
      return "Error in avgPool3d: x must be rank 5 but got rank " + u.rank + ".";
    }), C("NDHWC" === a, function () {
      return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + a;
    }), C(Mo(n, i), function () {
      return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'";
    }), null != o && C(A(r), function () {
      return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + ".";
    });
    var l = ko(u.shape, e, n, i, r, o, a),
        h = Lt.runKernelFunc(function (t) {
      return t.avgPool3d(u, l);
    }, {
      x: u
    }, function (t) {
      return {
        x: function () {
          return function (t, e, n, r, o, a, i) {
            var s = mn(t, "dy", "avgPool3dBackprop"),
                u = mn(e, "input", "avgPool3dBackprop"),
                c = s,
                l = u,
                h = !1;
            4 === u.rank && (h = !0, c = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]), l = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]));
            C(5 === c.rank, function () {
              return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c.rank + ".";
            }), C(5 === l.rank, function () {
              return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l.rank + ".";
            }), null == o && (o = [1, 1, 1]);
            C(Mo(r, o), function () {
              return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + o + "'";
            }), null != i && C(A(a), function () {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + a + ".";
            });
            var f = ko(l.shape, n, r, o, a, i),
                d = Lt.runKernelFunc(function (t) {
              return t.avgPool3dBackprop(c, l, f);
            }, {
              dy5D: c,
              input5D: l
            });
            if (h) return d.as4D(d.shape[1], d.shape[2], d.shape[3], d.shape[4]);
            return d;
          }(t, u, e, n, i, r, o);
        }
      };
    });
    return h = h.cast(u.dtype), c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
  }
});
exports.avgPool3d = vl;
exports.maxPool3d = pl;
exports.pool = dl;
exports.avgPool = fl;
exports.maxPool = hl;
var ml = An({
  slice_: function (t, e, n) {
    var r,
        o,
        a = mn(t, "x", "slice");
    if (0 === a.rank) throw new Error("Slicing scalar is not possible");
    (r = "number" == typeof e ? [e].concat(new Array(a.rank - 1).fill(0)) : e.length < a.rank ? e.concat(new Array(a.rank - e.length).fill(0)) : e.slice()).forEach(function (t) {
      C(-1 !== t, function () {
        return "slice() does not support negative begin indexing.";
      });
    }), o = (o = null == n ? new Array(a.rank).fill(-1) : "number" == typeof n ? [n].concat(new Array(a.rank - 1).fill(-1)) : n.length < a.rank ? n.concat(new Array(a.rank - n.length).fill(-1)) : n).map(function (t, e) {
      return t >= 0 ? t : (C(-1 === t, function () {
        return "Negative size values should be exactly -1 but got " + t + " for the slice() size at index " + e + ".";
      }), a.shape[e] - r[e]);
    }), eo(a, r, o);
    var i = a.shape,
        s = {
      begin: r,
      size: o
    };
    return Lt.runKernelFunc(function (t) {
      return t.slice(a, r, o);
    }, {
      x: a
    }, function (t) {
      for (var e = [], n = 0; n < t.rank; n++) e.push([r[n], i[n] - r[n] - o[n]]);

      return {
        x: function () {
          return t.pad(e);
        }
      };
    }, "Slice", s);
  }
}),
    gl = An({
  slice1d_: function (t, e, n) {
    var r = mn(t, "x", "slice1d");
    return C(1 === r.rank, function () {
      return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor";
    }), ml(r, [e], [n]);
  }
}),
    yl = An({
  slice2d_: function (t, e, n) {
    var r = mn(t, "x", "slice2d");
    return C(2 === r.rank, function () {
      return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor";
    }), ml(r, e, n);
  }
}),
    xl = An({
  slice3d_: function (t, e, n) {
    var r = mn(t, "x", "slice3d");
    return C(3 === r.rank, function () {
      return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor";
    }), ml(r, e, n);
  }
}),
    bl = An({
  slice4d_: function (t, e, n) {
    var r = mn(t, "x", "slice4d");
    return C(4 === r.rank, function () {
      return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor";
    }), ml(r, e, n);
  }
});
exports.slice4d = bl;
exports.slice3d = xl;
exports.slice2d = yl;
exports.slice1d = gl;
exports.slice = ml;

function wl(t, e, n, r, o) {
  return e.rank < n.rank && (e = e.reshape(wn(e.shape, r))), t.rank < n.rank && (t = t.reshape(wn(t.shape, r))), {
    x: function () {
      var r = t.mul(n.equal(e).cast(t.dtype));
      return null == o ? r : r.transpose(o);
    }
  };
}

var Cl = An({
  all_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "all", "bool"),
        o = O(e, r.shape),
        a = o,
        i = En(a, r.rank);
    null != i && (r = r.transpose(i), a = In(a.length, r.rank));
    var s = Lt.runKernelFunc(function (t) {
      return t.all(r, a);
    }, {
      $x: r
    });

    if (n) {
      var u = wn(s.shape, o);
      return s.reshape(u);
    }

    return s;
  }
}),
    El = An({
  any_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "any", "bool"),
        o = O(e, r.shape),
        a = o,
        i = En(a, r.rank);
    null != i && (r = r.transpose(i), a = In(a.length, r.rank));
    var s = Lt.runKernelFunc(function (t) {
      return t.any(r, a);
    }, {
      $x: r
    });

    if (n) {
      var u = wn(s.shape, o);
      return s.reshape(u);
    }

    return s;
  }
}),
    Rl = An({
  argMax_: function (t, e) {
    void 0 === e && (e = 0);
    var n = mn(t, "x", "argMax");
    null == e && (e = 0);
    var r = O(e, n.shape),
        o = En(r, n.rank);
    null != o && (n = n.transpose(o), r = In(r.length, n.rank));
    var a = {
      axis: r[0]
    },
        i = [n];
    return Lt.runKernelFunc(function (t, e) {
      var o = t.argMax(n, r[0]);
      return e([n]), o;
    }, {
      x: n
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return Xn(n);
        }
      };
    }, "ArgMax", a, i);
  }
}),
    Il = An({
  argMin_: function (t, e) {
    void 0 === e && (e = 0);
    var n = mn(t, "x", "argMin");
    null == e && (e = 0);
    var r = O(e, n.shape),
        o = En(r, n.rank);
    return null != o && (n = n.transpose(o), r = In(r.length, n.rank)), Lt.runKernelFunc(function (t, e) {
      var o = t.argMin(n, r[0]);
      return e([n]), o;
    }, {
      $x: n
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return Xn(n);
        }
      };
    });
  }
}),
    kl = An({
  logSumExp_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "logSumExp"),
        o = O(e, r.shape),
        a = r.max(o, !0),
        i = r.sub(a).exp().sum(o).log(),
        s = a.reshape(i.shape).add(i);

    if (n) {
      var u = wn(s.shape, o);
      return s.reshape(u);
    }

    return s;
  }
}),
    Sl = An({
  max_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "max"),
        o = r,
        a = O(e, r.shape),
        i = a,
        s = En(i, r.rank);
    null != s && (r = r.transpose(s), i = In(i.length, r.rank));
    var u = [r],
        c = Lt.runKernelFunc(function (t, e) {
      var n = t.max(r, i);
      return e([o, n]), n;
    }, {
      x: r
    }, function (t, e) {
      return wl(t, e[1], e[0], a, s);
    }, "Max", {
      axes: i
    }, u, [!0]);

    if (n) {
      var l = wn(c.shape, a);
      c = c.reshape(l);
    }

    return c;
  }
}),
    Al = An({
  mean_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "mean"),
        o = O(e, r.shape),
        a = k(bn(r.shape, o)[1]);
    return vo(function (t) {
      var r = On(a);
      return {
        value: (r.dtype === t.dtype ? t : t.cast(r.dtype)).div(r).sum(e, n),
        gradFunc: function (e) {
          var n = t.shape.slice();
          return o.forEach(function (t) {
            n[t] = 1;
          }), e.reshape(n).mul(zn(t.shape, "float32")).div(a);
        }
      };
    })(r);
  }
}),
    Dl = An({
  min_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "min"),
        o = r,
        a = O(e, r.shape),
        i = a,
        s = En(i, r.rank);
    null != s && (r = r.transpose(s), i = In(i.length, r.rank));
    var u = [r],
        c = Lt.runKernelFunc(function (t, e) {
      var n = t.min(r, i);
      return e([o, n]), n;
    }, {
      x: r
    }, function (t, e) {
      return wl(t, e[1], e[0], a, s);
    }, "Min", {
      axes: i
    }, u, [!0]);

    if (n) {
      var l = wn(c.shape, a);
      c = c.reshape(l);
    }

    return c;
  }
}),
    Tl = An({
  moments_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = O(e, (t = mn(t, "x", "moments")).shape),
        o = t.mean(r, n),
        a = o.shape;
    n || (a = wn(o.shape, r));
    var i = t.toFloat().sub(o.reshape(a)).square();
    return {
      mean: o,
      variance: i.mean(r, n)
    };
  }
}),
    Nl = An({
  sum_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "sum");
    "bool" === r.dtype && (r = r.toInt());
    var o = O(e, r.shape);
    return vo(function (t) {
      var e = En(o, t.rank),
          r = o,
          a = t;
      null != e && (a = t.transpose(e), r = In(r.length, t.rank));

      var i = function (e) {
        var n = t.shape.slice();
        return o.forEach(function (t) {
          n[t] = 1;
        }), e.reshape(n).mul(zn(t.shape, "float32"));
      },
          s = {
        axes: r
      },
          u = Lt.runKernelFunc(function (t) {
        return t.sum(a, r);
      }, {
        x: a
      }, function (t) {
        return {
          x: function () {
            return i(t);
          }
        };
      }, "Sum", s);

      if (n) {
        var c = wn(u.shape, o);
        u = u.reshape(c);
      }

      return {
        value: u,
        gradFunc: i
      };
    })(r);
  }
}),
    Fl = An({
  prod_: function (t, e, n) {
    void 0 === e && (e = null), void 0 === n && (n = !1);
    var r = mn(t, "x", "prod");
    "bool" === r.dtype && (r = r.toInt());
    var o = O(e, r.shape),
        a = En(o, r.rank),
        i = o,
        s = r;
    null != a && (s = r.transpose(a), i = In(i.length, r.rank));
    var u = Lt.runKernelFunc(function (t) {
      return t.prod(s, i);
    }, {
      permutedX: s
    });

    if (n) {
      var c = wn(u.shape, o);
      u = u.reshape(c);
    }

    return u;
  }
});
exports.prod = Fl;
exports.sum = Nl;
exports.moments = Tl;
exports.min = Dl;
exports.mean = Al;
exports.max = Sl;
exports.logSumExp = kl;
exports.argMin = Il;
exports.argMax = Rl;
exports.any = El;
exports.all = Cl;

var _l = An({
  elu_: function (t) {
    var e = mn(t, "x", "elu");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.elu(e);
      return n([r]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          return Lt.runKernelFunc(function (e) {
            return e.eluDer(t, n);
          }, {
            dy: t,
            y: n
          });
        }
      };
    });
  }
}),
    Ol = An({
  leakyRelu_: function (t, e) {
    void 0 === e && (e = .2);
    var n = mn(t, "x", "leakyRelu");
    return hc(On(e).mul(n), n);
  }
}),
    Ml = An({
  prelu_: function (t, e) {
    var n = mn(t, "x", "prelu"),
        r = mn(e, "alpha", "prelu");
    return Lt.runKernelFunc(function (t, e) {
      var o = t.prelu(n, r);
      return e([n, r]), o;
    }, {
      x: n,
      alpha: r
    }, function (t, e) {
      var n = e[0],
          r = e[1],
          o = n.greater(0);
      return {
        x: function () {
          return ec(o, t, t.mul(r));
        },
        alpha: function () {
          var e = ec(o, Xn(t), t.mul(n)),
              a = Eo(r.shape, t.shape);
          return a.length > 0 && (e = e.sum(a)), e.reshape(r.shape);
        }
      };
    }, "Prelu");
  }
}),
    Bl = An({
  relu_: function (t) {
    var e = mn(t, "x", "relu");
    return "bool" === e.dtype ? e.toInt() : Lt.runKernelFunc(function (t, n) {
      var r = t.relu(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mulStrict(n.step().toFloat());
        }
      };
    }, "Relu");
  }
}),
    Pl = An({
  relu6_: function (t) {
    var e = mn(t, "x", "relu6");
    return "bool" === e.dtype ? e.toInt() : Lt.runKernelFunc(function (t, n) {
      var r = t.relu6(e);
      return n([e]), r;
    }, {
      x: e
    }, function (t, e) {
      var n = e[0],
          r = n.lessEqual(6).mul(n.step());
      return {
        x: function () {
          return t.mulStrict(r.toFloat());
        }
      };
    }, "Relu6");
  }
}),
    Ll = An({
  selu_: function (t) {
    var e = mn(t, "x", "selu");
    return Lt.runKernelFunc(function (t, n) {
      var r = t.selu(e);
      return n([e]), r;
    }, {
      $x: e
    }, function (t, e) {
      var n = e[0];
      return {
        $x: function () {
          var e = n.greater(On(0)),
              r = On(bs),
              o = On(ws),
              a = t.mul(o),
              i = t.mul(r).mul(n.toFloat().exp());
          return ec(e, a, i);
        }
      };
    });
  }
});

exports.selu = Ll;
exports.relu6 = Pl;
exports.relu = Bl;
exports.prelu = Ml;
exports.leakyRelu = Ol;
exports.elu = _l;
var Wl = An({
  transpose_: function (t, e) {
    var n = mn(t, "x", "transpose");
    if (null == e && (e = n.shape.map(function (t, e) {
      return e;
    }).reverse()), C(n.rank === e.length, function () {
      return "Error in transpose: rank of input " + n.rank + " must match length of perm " + e + ".";
    }), e.forEach(function (t) {
      C(t >= 0 && t < n.rank, function () {
        return "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got " + e;
      });
    }), n.rank <= 1) return n.clone();
    var r = {
      perm: e
    };
    return Lt.runKernelFunc(function (t) {
      return t.transpose(n, e);
    }, {
      x: n
    }, function (t) {
      var n = Rn(e);
      return {
        x: function () {
          return t.transpose(n);
        }
      };
    }, "Transpose", r);
  }
});
exports.transpose = Wl;
var Ul = An({
  localResponseNormalization_: function (t, e, n, r, o) {
    void 0 === e && (e = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === o && (o = .5);
    var a = mn(t, "x", "localResponseNormalization");
    C(4 === a.rank || 3 === a.rank, function () {
      return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + a.rank + ".";
    }), C(A(e), function () {
      return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e + ".";
    });
    var i = a,
        s = !1;
    3 === a.rank && (s = !0, i = a.as4D(1, a.shape[0], a.shape[1], a.shape[2]));
    var u = Lt.runKernelFunc(function (t, a) {
      var s = t.localResponseNormalization4D(i, e, n, r, o);
      return a([i, s]), s;
    }, {
      x4D: i
    }, function (t, a) {
      var i = a[0],
          s = a[1];
      return {
        x4D: function () {
          return Lt.runKernelFunc(function (a) {
            return a.LRNGrad(t, i, s, e, n, r, o);
          }, {});
        }
      };
    });
    return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
  }
});
exports.localResponseNormalization = Ul;
var Vl = An({
  norm_: function (t, e, n, r) {
    void 0 === e && (e = "euclidean"), void 0 === n && (n = null), void 0 === r && (r = !1);

    var o = function t(e, n, r) {
      void 0 === r && (r = null);
      if (0 === e.rank) return e.abs();
      if (1 !== e.rank && null === r) return t(e.reshape([-1]), n, r);

      if (1 === e.rank || "number" == typeof r || Array.isArray(r) && 1 === r.length) {
        if (1 === n) return e.abs().sum(r);
        if (n === 1 / 0) return e.abs().max(r);
        if (n === -1 / 0) return e.abs().min(r);
        if ("euclidean" === n || 2 === n) return e.abs().pow(On(2, "int32")).sum(r).sqrt();
        throw new Error("Error in norm: invalid ord value: " + n);
      }

      if (Array.isArray(r) && 2 === r.length) {
        if (1 === n) return e.abs().sum(r[0]).max(r[1] - 1);
        if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);
        if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);
        if ("fro" === n || "euclidean" === n) return e.square().sum(r).sqrt();
        throw new Error("Error in norm: invalid ord value: " + n);
      }

      throw new Error("Error in norm: invalid axis: " + r);
    }(t = mn(t, "x", "norm"), e, n),
        a = o.shape;

    if (r) {
      var i = O(n, t.shape);
      a = wn(o.shape, i);
    }

    return o.reshape(a);
  }
});
exports.norm = Vl;
var zl = An({
  basicLSTMCell_: function (t, e, n, r, o, a) {
    var i = mn(t, "forgetBias", "basicLSTMCell"),
        s = mn(e, "lstmKernel", "basicLSTMCell"),
        u = mn(n, "lstmBias", "basicLSTMCell"),
        c = mn(r, "data", "basicLSTMCell"),
        l = mn(o, "c", "basicLSTMCell"),
        h = mn(a, "h", "basicLSTMCell"),
        f = c.concat(h, 1).matMul(s).add(u),
        d = f.shape[0],
        p = f.shape[1] / 4,
        v = [d, p],
        m = f.slice([0, 0], v),
        g = f.slice([0, p], v),
        y = f.slice([0, 2 * p], v),
        x = f.slice([0, 3 * p], v),
        b = m.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(i.add(y).sigmoid())),
        w = b.tanh().mulStrict(x.sigmoid());
    return [b, w];
  }
}),
    Gl = An({
  multiRNNCell_: function (t, e, n, r) {
    for (var o = mn(e, "data", "multiRNNCell"), a = gn(n, "c", "multiRNNCell"), i = gn(r, "h", "multiRNNCell"), s = o, u = [], c = 0; c < t.length; c++) {
      var l = t[c](s, a[c], i[c]);
      u.push(l[0]), u.push(l[1]), s = l[1];
    }

    var h = [],
        f = [];

    for (c = 0; c < u.length; c += 2) h.push(u[c]), f.push(u[c + 1]);

    return [h, f];
  }
});
exports.multiRNNCell = Gl;
exports.basicLSTMCell = zl;
var Hl = An({
  movingAverage_: function (t, e, n, r, o) {
    void 0 === o && (o = !0);
    var a = mn(t, "v", "movingAverage"),
        i = mn(e, "x", "movingAverage"),
        s = mn(n, "decay", "movingAverage");
    Ft(a, i), C(S(a.shape, i.shape), function () {
      return "Shape mismatch in v and x";
    });
    var u = On(1),
        c = u.sub(s),
        l = i.sub(a).mul(c);

    if (o) {
      C(null != r, function () {
        return "When using zeroDebias: true, step is required.";
      });
      var h = mn(r, "step", "movingAverage");
      l = l.div(u.sub(xc(s, h)));
    }

    return a.add(l);
  }
});
exports.movingAverage = Hl;
var ql = An({
  stridedSlice_: function (t, e, n, r, o, a, i, s, u) {
    if (void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), null == r && (r = new Array(e.length)), 0 !== i) throw new Error("ellipsis mask is not yet supported");
    var c = mn(t, "x", "stridedSlice"),
        l = no(s),
        h = c.shape.slice();
    l.forEach(function (t) {
      e[t] = 0, n[t] = 1, h.splice(t, 0, 1);
    }), c = c.reshape(h);

    for (var f = 0; f < c.rank; f++) e[f] = oo(o, e, r, c.shape, f), n[f] = ao(a, n, r, c.shape, f), r[f] = r[f] || 1;

    var d = no(u);
    d.forEach(function (t) {
      n[t] = e[t] + 1, r[t] = 1;
    });
    var p = ro(e, n, r),
        v = p.filter(function (t, e) {
      return -1 === d.indexOf(e);
    });
    return r.every(function (t) {
      return 1 === t;
    }) ? ml(c, e, p).reshape(v) : Lt.runKernelFunc(function (t) {
      return t.stridedSlice(c, e, n, r);
    }, {
      $x: c
    }).reshape(v);
  }
});
exports.stridedSlice = ql;
var Kl = An({
  topk_: function (t, e, n) {
    void 0 === e && (e = 1), void 0 === n && (n = !0);
    var r = mn(t, "x", "topk");
    if (0 === r.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
    var o = r.shape[r.shape.length - 1];
    if (e > o) throw new Error("'k' passed to topk() must be <= the last dimension (" + o + ") but got " + e);
    var a = Lt.runKernelFunc(function (t) {
      return t.topk(r, e, n);
    }, {
      $x: r
    });
    return {
      values: a[0],
      indices: a[1]
    };
  }
});
exports.topk = Kl;
var jl = An({
  scatterND_: function (t, e, n) {
    var r = mn(t, "indices", "scatterND", "int32"),
        o = mn(e, "updates", "scatterND");
    return Jr(o, r, n), Lt.runKernelFunc(function (t) {
      return t.scatterND(r, o, n);
    }, {
      indices: r,
      updates: o
    }, null, "ScatterNd", {
      shape: n
    });
  }
});
exports.scatterND = jl;
var Xl = An({
  fft_: function (t) {
    C("complex64" === t.dtype, function () {
      return "The dtype for tf.spectral.fft() must be complex64 but got " + t.dtype + ".";
    });
    var e = t.shape[t.shape.length - 1],
        n = t.size / e,
        r = t.as2D(n, e);
    return Lt.runKernelFunc(function (t) {
      return t.fft(r);
    }, {
      input: t
    }).reshape(t.shape);
  }
}),
    Yl = An({
  ifft_: function (t) {
    C("complex64" === t.dtype, function () {
      return "The dtype for tf.spectral.ifft() must be complex64 but got " + t.dtype + ".";
    });
    var e = t.shape[t.shape.length - 1],
        n = t.size / e,
        r = t.as2D(n, e);
    return Lt.runKernelFunc(function (t) {
      return t.ifft(r);
    }, {
      input: t
    }).reshape(t.shape);
  }
}),
    $l = An({
  rfft_: function (t, e) {
    C("float32" === t.dtype, function () {
      return "The dtype for rfft() must be real value but got " + t.dtype;
    });
    var n,
        r = t.shape[t.shape.length - 1],
        o = t.size / r;

    if (null != e && e < r) {
      var a = t.shape.map(function (t) {
        return 0;
      }),
          i = t.shape.map(function (t) {
        return t;
      });
      i[t.shape.length - 1] = e, n = t.slice(a, i), r = e;
    } else if (null != e && e > r) {
      var s = t.shape.map(function (t) {
        return t;
      });
      s[t.shape.length - 1] = e - r, n = t.concat(Gn(s), t.shape.length - 1), r = e;
    } else n = t;

    var u = n.zerosLike(),
        c = Dn(n, u).as2D(o, r),
        l = Xl(c),
        h = Math.floor(r / 2) + 1,
        f = Tn(l),
        d = Nn(l),
        p = f.split([h, r - h], f.shape.length - 1),
        v = d.split([h, r - h], d.shape.length - 1),
        m = n.shape.slice();
    return m[n.shape.length - 1] = h, Dn(p[0], v[0]).reshape(m);
  }
}),
    Ql = An({
  irfft_: function (t) {
    var e = t.shape[t.shape.length - 1],
        n = t.size / e;

    if (e <= 2) {
      var r = t.as2D(n, e),
          o = Yl(r);
      return Tn(o);
    }

    var a = [n, 2 * (e - 1)],
        i = Tn(t).as2D(n, e),
        s = Nn(t).as2D(n, e),
        u = i.slice([0, 1], [n, e - 2]).reverse(1),
        c = s.slice([0, 1], [n, e - 2]).reverse(1).mul(On(-1)),
        l = i.concat(u, 1),
        h = s.concat(c, 1);
    return r = Dn(l, h).as2D(a[0], a[1]), o = Yl(r), Tn(o);
  }
}),
    Jl = Object.freeze({
  fft: Xl,
  ifft: Yl,
  rfft: $l,
  irfft: Ql
});
exports.spectral = Jl;
exports.irfft = Ql;
exports.rfft = $l;
exports.ifft = Yl;
exports.fft = Xl;
var Zl = An({
  sparseToDense_: function (t, e, n, r) {
    void 0 === r && (r = 0);
    var o = mn(t, "sparseIndices", "sparseToDense", "int32"),
        a = mn(e, "sparseValues", "sparseToDense"),
        i = mn(r, "defaultValue", "sparseToDense", a.dtype);
    return function (t, e, n, r) {
      if ("int32" !== t.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t.dtype + ".");
      if (t.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t.shape + ".");
      var o = t.rank > 0 ? t.shape[0] : 1,
          a = t.rank > 1 ? t.shape[1] : 1;
      if (n.length !== a) throw new Error("outputShape has incorrect number of elements:, " + n.length + ", should be: " + a + ".");
      var i = e.size;
      if (0 !== e.rank && (1 !== e.rank || i !== o)) throw new Error("sparseValues has incorrect shape " + e.shape + ", should be [] or [" + o + "]");
      if (e.dtype !== r.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
    }(o, a, n, i), Lt.runKernelFunc(function (t) {
      return t.sparseToDense(o, a, n, i);
    }, {
      $sparseIndices: o,
      $sparseValues: a,
      $defaultValue: i
    });
  }
});
exports.sparseToDense = Zl;
var th = An({
  gatherND_: function (t, e) {
    var n = mn(e, "indices", "gatherND", "int32"),
        r = mn(t, "x", "gatherND");
    return Lt.runKernelFunc(function (t) {
      return t.gatherND(r, n);
    }, {
      x: r,
      indices: n
    }, null, "GatherNd");
  }
});
exports.gatherND = th;
var eh = An({
  diag_: function (t) {
    var e = mn(t, "x", "diag").flatten(),
        n = t.shape.concat(t.shape);
    return Lt.runKernelFunc(function (t) {
      return t.diag(e);
    }, {
      $x: e
    }).reshape(n);
  }
});
exports.diag = eh;
var nh = An({
  dropout_: function (t, e, n, r) {
    var o = mn(t, "x", "dropout");
    if (C("float32" === o.dtype, function () {
      return "x has to be a floating point tensor since it's going to be scaled, but got a " + o.dtype + " tensor instead.";
    }), C(e >= 0 && e < 1, function () {
      return "rate must be a float in the range [0, 1), but got " + e + ".";
    }), 0 === e) return t instanceof wt ? o.clone() : o;

    var a = function (t, e) {
      if (null == e) return t.shape.slice();
      if (S(t.shape, e)) return e;

      if (t.shape.length === e.length) {
        for (var n = [], r = 0; r < t.shape.length; r++) null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r]);

        return n;
      }

      return e;
    }(o, n),
        i = 1 - e,
        s = _r(a, 0, 1, "float32", r).add(i).floor().div(i);

    return o.mul(s);
  }
});
exports.dropout = nh;

function rh(t, e, n) {
  for (var r = 1 - t % 2, o = new Float32Array(t), a = 0; a < t; ++a) {
    var i = 2 * Math.PI * a / (t + r - 1);
    o[a] = e - n * Math.cos(i);
  }

  return Mn(o, "float32");
}

var oh = An({
  hannWindow_: function (t) {
    return rh(t, .5, .5);
  }
}),
    ah = An({
  hammingWindow_: function (t) {
    return rh(t, .54, .46);
  }
}),
    ih = An({
  frame_: function (t, e, n, r, o) {
    void 0 === r && (r = !1), void 0 === o && (o = 0);

    for (var a = 0, i = []; a + e <= t.size;) i.push(ml(t, a, e)), a += n;

    if (r) for (; a < t.size;) {
      var s = a + e - t.size,
          u = Yn([ml(t, a, e - s), Hn([s], o)]);
      i.push(u), a += n;
    }
    return 0 === i.length ? Bn([], [0, e]) : Yn(i).as2D(i.length, e);
  }
}),
    sh = An({
  stft_: function (t, e, n, r, o) {
    var a;
    void 0 === o && (o = oh), null == r && (a = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(a) / Math.log(2)))));

    for (var i = ih(t, e, n), s = gc(i, o(e)), u = [], c = 0; c < i.shape[0]; c++) u.push($l(s.slice([c, 0], [1, e]), r));

    return Yn(u);
  }
}),
    uh = Object.freeze({
  hannWindow: oh,
  hammingWindow: ah,
  frame: ih,
  stft: sh
});
exports.signal = uh;
exports.stft = sh;
exports.frame = ih;
exports.hammingWindow = ah;
exports.hannWindow = oh;

var ch,
    lh = function (t, e, o) {
  return void 0 === o && (o = 1), n(this, void 0, void 0, function () {
    var n, a, i, s, u, c, l, h, f, d, p, v, m, g;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = mn(t, "predictions", "inTopK"), a = mn(e, "targets", "inTopK"), C(n.rank > 1, function () {
            return "inTopK() expects the predictions to be of rank 2 or higher, but got " + n.rank;
          }), C(n.rank - 1 === a.rank, function () {
            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + n.rank + " and targets rank " + a.rank;
          }), E(n.shape.slice(0, n.shape.length - 1), a.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i = n.shape[n.shape.length - 1], C(o > 0 && o <= i, function () {
            return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i + "), but got " + o;
          }), [4, n.data()];

        case 1:
          return s = r.sent(), [4, a.data()];

        case 2:
          for (u = r.sent(), c = [s.length / i, i], h = c[1], f = B("bool", l = c[0]), d = 0; d < l; d++) {
            for (p = d * h, v = s.subarray(p, p + h), m = [], g = 0; g < v.length; g++) m.push({
              value: v[g],
              index: g
            });

            for (m.sort(function (t, e) {
              return e.value - t.value;
            }), f[d] = 0, g = 0; g < o; g++) if (m[g].index === u[d]) {
              f[d] = 1;
              break;
            }
          }

          return t !== n && n.dispose(), e !== a && a.dispose(), [2, Fn(f, a.shape, "bool")];
      }
    });
  });
};

exports.inTopKAsync = lh;
exports.Reduction = ch;
!function (t) {
  t[t.NONE = 0] = "NONE", t[t.MEAN = 1] = "MEAN", t[t.SUM = 2] = "SUM", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(ch || (exports.Reduction = ch = {}));
var hh = An({
  absoluteDifference_: function (t, e, n, r) {
    void 0 === r && (r = ch.SUM_BY_NONZERO_WEIGHTS);
    var o = mn(t, "labels", "absoluteDifference"),
        a = mn(e, "predictions", "absoluteDifference"),
        i = null;
    null != n && (i = mn(n, "weights", "absoluteDifference")), E(o.shape, a.shape, "Error in absoluteDifference: ");
    var s = o.sub(a).abs();
    return fh(s, i, r);
  }
}),
    fh = An({
  computeWeightedLoss_: function (t, e, n) {
    void 0 === n && (n = ch.SUM_BY_NONZERO_WEIGHTS);
    var r = mn(t, "losses", "computeWeightedLoss"),
        o = null;
    null != e && (o = mn(e, "weights", "computeWeightedLoss"));
    var a = null == o ? r : r.mul(o);
    if (n === ch.NONE) return a;
    if (n === ch.SUM) return a.sum();

    if (n === ch.MEAN) {
      if (null == o) return a.mean();
      var i = r.size / o.size,
          s = a.sum().div(o.sum());
      return i > 1 ? s.div(On(i)) : s;
    }

    if (n === ch.SUM_BY_NONZERO_WEIGHTS) {
      if (null == o) return a.sum().div(On(r.size));
      var u = o.mul(zn(r.shape)).notEqual(On(0)).sum().toFloat();
      return a.sum().div(u);
    }

    throw Error("Unknown reduction: " + n);
  }
}),
    dh = An({
  cosineDistance_: function (t, e, n, r, o) {
    void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "labels", "cosineDistance"),
        i = mn(e, "predictions", "cosineDistance"),
        s = null;
    null != r && (s = mn(r, "weights", "cosineDistance")), E(a.shape, i.shape, "Error in cosineDistance: ");
    var u = On(1).sub(a.mul(i).sum(n, !0));
    return fh(u, s, o);
  }
}),
    ph = An({
  hingeLoss_: function (t, e, n, r) {
    void 0 === r && (r = ch.SUM_BY_NONZERO_WEIGHTS);
    var o = mn(t, "labels", "hingeLoss"),
        a = mn(e, "predictions", "hingeLoss"),
        i = null;
    null != n && (i = mn(n, "weights", "hingeLoss")), E(o.shape, a.shape, "Error in hingeLoss: ");
    var s = On(1);
    o = On(2).mul(o).sub(s);
    var u = s.sub(o.mul(a)).relu();
    return fh(u, i, r);
  }
}),
    vh = An({
  huberLoss_: function (t, e, n, r, o) {
    void 0 === r && (r = 1), void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "labels", "huberLoss"),
        i = mn(e, "predictions", "huberLoss"),
        s = null;
    null != n && (s = mn(n, "weights", "huberLoss")), E(a.shape, i.shape, "Error in huberLoss: ");
    var u = On(r),
        c = i.sub(a).abs(),
        l = dc(c, u),
        h = c.sub(l),
        f = On(.5).mul(l.square()).add(u.mul(h));
    return fh(f, s, o);
  }
}),
    mh = An({
  logLoss_: function (t, e, n, r, o) {
    void 0 === r && (r = 1e-7), void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "labels", "logLoss"),
        i = mn(e, "predictions", "logLoss"),
        s = null;
    null != n && (s = mn(n, "weights", "logLoss")), E(a.shape, i.shape, "Error in logLoss: ");
    var u = On(1),
        c = On(r),
        l = a.mul(i.add(c).log()).neg().sub(u.sub(a).mul(u.sub(i).add(c).log()));
    return fh(l, s, o);
  }
}),
    gh = An({
  meanSquaredError_: function (t, e, n, r) {
    void 0 === r && (r = ch.SUM_BY_NONZERO_WEIGHTS);
    var o = mn(t, "labels", "meanSquaredError"),
        a = mn(e, "predictions", "meanSquaredError"),
        i = null;
    null != n && (i = mn(n, "weights", "meanSquaredError")), E(o.shape, a.shape, "Error in meanSquaredError: ");
    var s = o.squaredDifference(a);
    return fh(s, i, r);
  }
}),
    yh = An({
  sigmoidCrossEntropy_: function (t, e, n, r, o) {
    void 0 === r && (r = 0), void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "multiClassLabels", "sigmoidCrossEntropy"),
        i = mn(e, "logits", "sigmoidCrossEntropy"),
        s = null;

    if (null != n && (s = mn(n, "weights", "sigmoidCrossEntropy")), E(a.shape, i.shape, "Error in sigmoidCrossEntropy: "), r > 0) {
      var u = On(r),
          c = On(1),
          l = On(.5);
      a = a.mul(c.sub(u)).add(l.mul(u));
    }

    var h = function (t, e) {
      var n = mn(t, "labels", "sigmoidCrossEntropyWithLogits"),
          r = mn(e, "logits", "sigmoidCrossEntropyWithLogits");
      E(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
      var o = r.relu(),
          a = r.mul(n),
          i = r.abs().neg().exp().log1p();
      return o.sub(a).add(i);
    }(a, i);

    return fh(h, s, o);
  }
}),
    xh = An({
  softmaxCrossEntropy_: function (t, e, n, r, o) {
    void 0 === r && (r = 0), void 0 === o && (o = ch.SUM_BY_NONZERO_WEIGHTS);
    var a = mn(t, "onehotLabels", "softmaxCrossEntropy"),
        i = mn(e, "logits", "softmaxCrossEntropy"),
        s = null;

    if (null != n && (s = mn(n, "weights", "softmaxCrossEntropy")), E(a.shape, i.shape, "Error in softmaxCrossEntropy: "), r > 0) {
      var u = On(r),
          c = On(1),
          l = On(a.shape[1]);
      a = a.mul(c.sub(u)).add(u.div(l));
    }

    var h = function (t, e, n) {
      if (void 0 === n && (n = -1), -1 === n && (n = e.rank - 1), n !== e.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e.rank + " and dim was " + n);
      return vo(function (t, e, r) {
        var o = e.logSumExp([n], !0),
            a = e.toFloat().sub(o);
        r([t, a]);
        return {
          value: a.mul(t).neg().sum([n]),
          gradFunc: function (t, e) {
            var r = e[0],
                o = e[1],
                a = wn(t.shape, [n]);
            return [t.reshape(a).mul(r.toFloat().sub(o.exp())), t.reshape(a).mul(o.exp().sub(r.toFloat()))];
          }
        };
      })(t, e);
    }(a, i);

    return fh(h, s, o);
  }
}),
    bh = Object.freeze({
  get Reduction() {
    return ch;
  },

  absoluteDifference: hh,
  computeWeightedLoss: fh,
  cosineDistance: dh,
  hingeLoss: ph,
  huberLoss: vh,
  logLoss: mh,
  meanSquaredError: gh,
  sigmoidCrossEntropy: yh,
  softmaxCrossEntropy: xh
});
exports.losses = bh;

function wh(t, e) {
  return void 0 === e && (e = !1), Lt.tidy(function () {
    if (2 !== t.shape.length) throw new Error("qr2d() requires a 2D Tensor, but got a " + t.shape.length + "D Tensor.");

    for (var n = t.shape[0], r = t.shape[1], o = Cr(n), a = t.clone(), i = Bn([[1]], [1, 1]), s = i.clone(), u = n >= r ? r : n, c = function (t) {
      var e,
          u = a,
          c = s,
          l = o;
      e = Lt.tidy(function () {
        var e = a.slice([t, t], [n - t, 1]),
            u = e.norm(),
            c = a.slice([t, t], [1, 1]),
            l = Bn([[-1]]).where(c.greater(0), Bn([[1]])),
            h = c.sub(l.mul(u)),
            f = e.div(h);
        s = 1 === f.shape[0] ? i.clone() : i.concat(f.slice([1, 0], [f.shape[0] - 1, f.shape[1]]), 0);
        var d = l.matMul(h).div(u).neg(),
            p = a.slice([t, 0], [n - t, r]),
            v = d.mul(s);
        if (0 === t) a = p.sub(v.matMul(s.transpose().matMul(p)));else {
          var m = p.sub(v.matMul(s.transpose().matMul(p)));
          a = a.slice([0, 0], [t, r]).concat(m, 0);
        }
        var g = o.slice([0, t], [n, o.shape[1] - t]);
        if (0 === t) o = g.sub(g.matMul(s).matMul(v.transpose()));else {
          var y = g.sub(g.matMul(s).matMul(v.transpose()));
          o = o.slice([0, 0], [n, t]).concat(y, 1);
        }
        return [s, a, o];
      }), s = e[0], a = e[1], o = e[2], tn([u, c, l]);
    }, l = 0; l < u; ++l) c(l);

    return !e && n > r && (o = o.slice([0, 0], [n, r]), a = a.slice([0, 0], [r, r])), [o, a];
  });
}

var Ch = An({
  bandPart_: function (t, e, n) {
    if (e % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + e + ".");
    if (n % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + n + ".");
    var r = mn(t, "a", "bandPart");
    if (r.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r.rank + ".");
    var o = r.shape,
        a = r.shape.slice(-2),
        i = a[0],
        s = a[1];
    if (!(e <= i)) throw new Error("bandPart(): numLower (" + e + ") must not be greater than the number of rows (" + i + ").");
    if (!(n <= s)) throw new Error("bandPart(): numUpper (" + n + ") must not be greater than the number of columns (" + s + ").");
    e < 0 && (e = i), n < 0 && (n = s);
    var u = Kn(0, i, 1, "int32").reshape([-1, 1]),
        c = Kn(0, s, 1, "int32"),
        l = Cc(u, c),
        h = Qu(l.lessEqual(On(+e, "int32")), l.greaterEqual(On(-n, "int32"))),
        f = Gn([i, s], r.dtype);
    return Pr(Ur(r.reshape([-1, i, s])).map(function (t) {
      return ec(h, t, f);
    })).reshape(o);
  }
}),
    Eh = An({
  gramSchmidt_: function (t) {
    var e;

    if (Array.isArray(t)) {
      e = !1, C(null != t && t.length > 0, function () {
        return "Gram-Schmidt process: input must not be null, undefined, or empty";
      });

      for (var n = t[0].shape[0], r = function (e) {
        C(t[e].shape[0] === n, function () {
          return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t[e].shape[0] + " vs. " + n + ")";
        });
      }, o = 1; o < t.length; ++o) r(o);
    } else e = !0, t = tr(t, t.shape[0], 0).map(function (t) {
      return Br(t, [0]);
    });

    C(t.length <= t[0].shape[0], function () {
      return "Gram-Schmidt: Number of vectors (" + t.length + ") exceeds number of dimensions (" + t[0].shape[0] + ").";
    });

    var a = [],
        i = t,
        s = function (t) {
      a.push(Lt.tidy(function () {
        var e = i[t];
        if (t > 0) for (var n = 0; n < t; ++n) {
          var r = Nl(a[n].mulStrict(e)).mul(a[n]);
          e = e.sub(r);
        }
        return e.div(Vl(e, "euclidean"));
      }));
    };

    for (o = 0; o < t.length; ++o) s(o);

    return e ? Pr(a, 0) : a;
  }
}),
    Rh = An({
  qr_: function (t, e) {
    if (void 0 === e && (e = !1), t.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t.rank);
    if (2 === t.rank) return wh(t, e);
    var n = t.shape.slice(0, t.shape.length - 2).reduce(function (t, e) {
      return t * e;
    }),
        r = Ur(t.reshape([n, t.shape[t.shape.length - 2], t.shape[t.shape.length - 1]]), 0),
        o = [],
        a = [];
    return r.forEach(function (t) {
      var n = wh(t, e),
          r = n[0],
          i = n[1];
      o.push(r), a.push(i);
    }), [Pr(o, 0).reshape(t.shape), Pr(a, 0).reshape(t.shape)];
  }
}),
    Ih = Object.freeze({
  bandPart: Ch,
  gramSchmidt: Eh,
  qr: Rh
});
exports.linalg = Ih;

function kh(t, e, n, r, o, a) {
  null == r && (r = .5), null == o && (o = Number.NEGATIVE_INFINITY), null == a && (a = 0);
  var i = t.shape[0];
  return n = Math.min(n, i), C(0 <= r && r <= 1, function () {
    return "iouThreshold must be in [0, 1], but was '" + r + "'";
  }), C(2 === t.rank, function () {
    return "boxes must be a 2D tensor, but was of rank '" + t.rank + "'";
  }), C(4 === t.shape[1], function () {
    return "boxes must have 4 columns, but 2nd dimension was " + t.shape[1];
  }), C(1 === e.rank, function () {
    return "scores must be a 1D tensor";
  }), C(e.shape[0] === i, function () {
    return "scores has incompatible shape with boxes. Expected " + i + ", but was " + e.shape[0];
  }), C(0 <= a && a <= 1, function () {
    return "softNmsSigma must be in [0, 1], but was '" + a + "'";
  }), {
    maxOutputSize: n,
    iouThreshold: r,
    scoreThreshold: o,
    softNmsSigma: a
  };
}

var Sh = An({
  resizeBilinear_: function (t, e, n) {
    void 0 === n && (n = !1);
    var r = mn(t, "images", "resizeBilinear");
    C(3 === r.rank || 4 === r.rank, function () {
      return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r.rank + ".";
    }), C(2 === e.length, function () {
      return "Error in resizeBilinear: new shape must 2D, but got shape " + e + ".";
    });
    var o = r,
        a = !1;
    3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
    var i = e[0],
        s = e[1],
        u = Lt.runKernelFunc(function (t, e) {
      return e([o]), t.resizeBilinear(o, i, s, n);
    }, {
      x: o
    }, function (t, e) {
      return {
        x: function () {
          return Lt.runKernelFunc(function (r) {
            return r.resizeBilinearBackprop(t, e[0], n);
          }, {});
        }
      };
    }, "ResizeBilinear", {
      alignCorners: n,
      newHeight: i,
      newWidth: s
    });
    return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
  }
}),
    Ah = An({
  resizeNearestNeighbor_: function (t, e, n) {
    void 0 === n && (n = !1);
    var r = mn(t, "images", "resizeNearestNeighbor");
    C(3 === r.rank || 4 === r.rank, function () {
      return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r.rank + ".";
    }), C(2 === e.length, function () {
      return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e + ".";
    }), C("float32" === r.dtype || "int32" === r.dtype, function () {
      return "`images` must have `int32` or `float32` as dtype";
    });
    var o = r,
        a = !1;
    3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
    var i = e[0],
        s = e[1],
        u = Lt.runKernelFunc(function (t, e) {
      return e([o]), t.resizeNearestNeighbor(o, i, s, n);
    }, {
      batchImages: o
    }, function (t, e) {
      return {
        batchImages: function () {
          return Lt.runKernelFunc(function (r) {
            return r.resizeNearestNeighborBackprop(t, e[0], n);
          }, {});
        }
      };
    });
    return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
  }
}),
    Dh = An({
  nonMaxSuppression_: function (t, e, n, r, o) {
    void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY);
    var a = mn(t, "boxes", "nonMaxSuppression"),
        i = mn(e, "scores", "nonMaxSuppression"),
        s = kh(a, i, n, r, o);
    n = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold;
    var u = {
      maxOutputSize: n,
      iouThreshold: r,
      scoreThreshold: o
    };
    return Lt.runKernelFunc(function (t) {
      return t.nonMaxSuppression(a, i, n, r, o);
    }, {
      boxes: a,
      scores: i
    }, null, "NonMaxSuppressionV3", u);
  }
}),
    Th = function (t, e, o, a, i) {
  return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function () {
    var n, s, u, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = mn(t, "boxes", "nonMaxSuppressionAsync"), s = mn(e, "scores", "nonMaxSuppressionAsync"), u = kh(n, s, o, a, i), o = u.maxOutputSize, a = u.iouThreshold, i = u.scoreThreshold, [4, Promise.all([n.data(), s.data()])];

        case 1:
          return c = r.sent(), l = c[0], h = c[1], f = jo(l, h, o, a, i), n !== t && n.dispose(), s !== e && s.dispose(), [2, f];
      }
    });
  });
},
    Nh = An({
  nonMaxSuppressionWithScore_: function (t, e, n, r, o, a) {
    void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY), void 0 === a && (a = 0);
    var i = mn(t, "boxes", "nonMaxSuppression"),
        s = mn(e, "scores", "nonMaxSuppression"),
        u = kh(i, s, n, r, o, a),
        c = {
      maxOutputSize: n = u.maxOutputSize,
      iouThreshold: r = u.iouThreshold,
      scoreThreshold: o = u.scoreThreshold,
      softNmsSigma: a = u.softNmsSigma
    },
        l = Lt.runKernel("NonMaxSuppressionV5", {
      boxes: i,
      scores: s
    }, c);
    return {
      selectedIndices: l[0],
      selectedScores: l[1]
    };
  }
}),
    Fh = function (t, e, o, a, i, s) {
  return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === s && (s = 0), n(this, void 0, void 0, function () {
    var n, u, c, l, h, f, d;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return n = mn(t, "boxes", "nonMaxSuppressionAsync"), u = mn(e, "scores", "nonMaxSuppressionAsync"), c = kh(n, u, o, a, i, s), o = c.maxOutputSize, a = c.iouThreshold, i = c.scoreThreshold, s = c.softNmsSigma, [4, Promise.all([n.data(), u.data()])];

        case 1:
          return l = r.sent(), h = l[0], f = l[1], d = Xo(h, f, o, a, i, s), n !== t && n.dispose(), u !== e && u.dispose(), [2, d];
      }
    });
  });
},
    _h = An({
  cropAndResize_: function (t, e, n, r, o, a) {
    var i = mn(t, "image", "cropAndResize"),
        s = mn(e, "boxes", "cropAndResize", "float32"),
        u = mn(n, "boxInd", "cropAndResize", "int32");
    o = o || "bilinear", a = a || 0;
    var c = s.shape[0];
    return C(4 === i.rank, function () {
      return "Error in cropAndResize: image must be rank 4,but got rank " + i.rank + ".";
    }), C(2 === s.rank && 4 === s.shape[1], function () {
      return "Error in cropAndResize: boxes must be have size [" + c + ",4] but had shape " + s.shape + ".";
    }), C(1 === u.rank && u.shape[0] === c, function () {
      return "Error in cropAndResize: boxInd must be have size [" + c + "] but had shape " + s.shape + ".";
    }), C(2 === r.length, function () {
      return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + ".";
    }), C(r[0] >= 1 && r[1] >= 1, function () {
      return "cropSize must be atleast [1,1], but was " + r;
    }), C("bilinear" === o || "nearest" === o, function () {
      return "method must be bilinear or nearest, but was " + o;
    }), Lt.runKernelFunc(function (t, e) {
      return t.cropAndResize(i, s, u, r, o, a);
    }, {
      images: i,
      boxes: s,
      boxInd: u
    }, null, "CropAndResize", {
      method: o,
      extrapolationValue: a,
      cropSize: r
    });
  }
}),
    Oh = Object.freeze({
  resizeBilinear: Sh,
  resizeNearestNeighbor: Ah,
  nonMaxSuppression: Dh,
  nonMaxSuppressionAsync: Th,
  nonMaxSuppressionWithScore: Nh,
  nonMaxSuppressionWithScoreAsync: Fh,
  cropAndResize: _h
}),
    Mh = function (t, e) {
  return !(t > 0) || "linear" === e;
},
    Bh = function (t, e, n) {
  if (null == n || "linear" === n) return t;
  if ("relu" === n) return t.mul(e.step());
  throw new Error("Gradient for activation " + n + " has not been implemented yet.");
},
    Ph = function (t, e) {
  var n = e,
      r = Eo(t.shape, e.shape);
  return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape);
},
    Lh = function (t, e, n) {
  if ("linear" === e) return t;
  if ("relu" === e) return Bl(t);
  if ("elu" === e) return _l(t);
  if ("relu6" === e) return Pl(t);
  if ("prelu" === e) return Ml(t, n);
  throw new Error("Unknown fused activation " + e + ".");
};

exports.image = Oh;
var Wh = An({
  fusedMatMul_: function (t) {
    var e,
        n = t.a,
        r = t.b,
        o = t.transposeA,
        a = void 0 !== o && o,
        i = t.transposeB,
        s = void 0 !== i && i,
        u = t.bias,
        c = t.activation,
        l = void 0 === c ? "linear" : c,
        h = t.preluActivationWeights;

    if (!1 === Mh(Lt.state.gradientDepth, l)) {
      var f = el(n, r, a, s);
      return null != u && (f = rc(f, u)), Lh(f, l, h);
    }

    var d = mn(n, "a", "fused matMul"),
        p = mn(r, "b", "fused matMul");
    e = Nt(d, p), d = e[0], p = e[1];
    var v = a ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
        m = s ? p.shape[p.rank - 1] : p.shape[p.rank - 2],
        g = a ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
        y = s ? p.shape[p.rank - 2] : p.shape[p.rank - 1],
        x = d.shape.slice(0, -2),
        b = p.shape.slice(0, -2),
        w = k(x),
        E = k(b);
    C(d.rank >= 2 && p.rank >= 2 && d.rank === p.rank, function () {
      return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + d.rank + " and " + p.rank + ".";
    }), C(S(x, b), function () {
      return "Error in fused matMul: outer dimensions (" + x + ") and (" + b + ") of Tensors with shapes " + d.shape + " and " + p.shape + " must match.";
    }), C(v === m, function () {
      return "Error in fused matMul: inner shapes (" + v + ") and (" + m + ") of Tensors with shapes " + d.shape + " and " + p.shape + " and transposeA=" + a + " and transposeB=" + s + " must match.";
    });
    var R,
        I,
        A = d.shape.slice(0, -2).concat([g, y]),
        D = a ? d.as3D(w, v, g) : d.as3D(w, g, v),
        T = s ? p.as3D(E, y, m) : p.as3D(E, m, y);
    null != u && Ro(A, (R = Nt(R = mn(u, "bias", "fused matMul"), d)[0]).shape), null != h && (I = mn(h, "prelu weights", "fused matMul"));
    var N = {
      a: D,
      b: T
    };
    null != u && (N.bias = R), null != h && (N.preluActivationWeights = I);
    var F = [D, T];
    return Lt.runKernelFunc(function (t, e) {
      var n = t.fusedBatchMatMul({
        a: D,
        b: T,
        transposeA: a,
        transposeB: s,
        bias: R,
        activation: l,
        preluActivationWeights: I
      });
      return e([D, T, n]), n;
    }, N, function (t, e) {
      var n = e[0],
          r = e[1],
          o = e[2],
          i = Bh(t, o, l),
          c = {};
      return null != u && (c = {
        bias: function () {
          return Ph(R, i);
        }
      }), a || s ? !a && s ? Object.assign({
        a: function () {
          return i.matMul(r, !1, !1);
        },
        b: function () {
          return i.matMul(n, !0, !1);
        }
      }, c) : a && !s ? Object.assign({
        a: function () {
          return r.matMul(i, !1, !0);
        },
        b: function () {
          return n.matMul(i, !1, !1);
        }
      }, c) : Object.assign({
        a: function () {
          return r.matMul(i, !0, !0);
        },
        b: function () {
          return i.matMul(n, !0, !0);
        }
      }, c) : Object.assign({
        a: function () {
          return i.matMul(r, !1, !0);
        },
        b: function () {
          return n.matMul(i, !0, !1);
        }
      }, c);
    }, "_FusedMatMul", {
      transposeA: a,
      transposeB: s,
      activation: l
    }, F, [!0]).reshape(A);
  }
}),
    Uh = An({
  fusedConv2d_: function (t) {
    var e = t.x,
        n = t.filter,
        r = t.strides,
        o = t.pad,
        a = t.dataFormat,
        i = void 0 === a ? "NHWC" : a,
        s = t.dilations,
        u = void 0 === s ? [1, 1] : s,
        c = t.dimRoundingMode,
        l = t.bias,
        h = t.activation,
        f = void 0 === h ? "linear" : h,
        d = t.preluActivationWeights;

    if (f = f || "linear", !1 === Mh(Lt.state.gradientDepth, f)) {
      var p = qc(e, n, r, o, i, u, c);
      return null != l && (p = rc(p, l)), Lh(p, f, d);
    }

    var v = mn(e, "x", "conv2d"),
        m = mn(n, "filter", "conv2d"),
        g = v,
        y = !1;
    3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === g.rank, function () {
      return "Error in fused conv2d: input must be rank 4, but got rank " + g.rank + ".";
    }), C(4 === m.rank, function () {
      return "Error in fused conv2d: filter must be rank 4, but got rank " + m.rank + ".";
    }), null != c && C(A(o), function () {
      return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c + " but got pad " + o + ".";
    }), C(g.shape[3] === m.shape[2], function () {
      return "Error in conv2d: depth of input (" + g.shape[3] + ") must match input depth for filter " + m.shape[2] + ".";
    }), C(Mo(r, u), function () {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'";
    }), C("NHWC" === i, function () {
      return "Error in conv2d: got dataFormat of " + i + " but only NHWC is currently supported.";
    });
    var x,
        b,
        w = So(g.shape, m.shape, r, u, o, c);
    null != l && (x = Nt(x = mn(l, "bias", "fused conv2d"), v)[0], Ro(w.outShape, x.shape)), null != d && (b = mn(d, "prelu weights", "fused conv2d"));
    var E = {
      x: g,
      filter: m
    };
    null != l && (E.bias = x), null != d && (E.preluActivationWeights = b);
    var R = [m, g],
        I = Lt.runKernelFunc(function (t, e) {
      var n = t.fusedConv2d({
        input: g,
        filter: m,
        convInfo: w,
        bias: x,
        activation: f,
        preluActivationWeights: b
      });
      return e([m, g, n]), n;
    }, E, function (t, e) {
      var n = e,
          a = n[0],
          i = n[1],
          s = n[2],
          c = Bh(t, s, f);
      C(Oo(u), function () {
        return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u + "'";
      });
      var h = {};
      return null != l && (h = {
        bias: function () {
          return Ph(x, c);
        }
      }), Object.assign({
        x: function () {
          return Xc(i.shape, c, a, r, o);
        },
        filter: function () {
          return jc(i, c, a.shape, r, o);
        }
      }, h);
    }, "FusedConv2D", {
      convInfo: w,
      activation: f
    }, R, [!0]);
    return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;
  }
}),
    Vh = An({
  fusedDepthwiseConv2d_: function (t) {
    var e = t.x,
        n = t.filter,
        r = t.strides,
        o = t.pad,
        a = t.dataFormat,
        i = void 0 === a ? "NHWC" : a,
        s = t.dilations,
        u = void 0 === s ? [1, 1] : s,
        c = t.dimRoundingMode,
        l = t.bias,
        h = t.activation,
        f = void 0 === h ? "linear" : h,
        d = t.preluActivationWeights;

    if (!1 === Mh(Lt.state.gradientDepth, f)) {
      var p = Yc(e, n, r, o, i, u, c);
      return null != l && (p = rc(p, l)), Lh(p, f, d);
    }

    var v = mn(e, "x", "depthwiseConv2d"),
        m = mn(n, "filter", "depthwiseConv2d"),
        g = v,
        y = !1;
    3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === g.rank, function () {
      return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + g.rank + ".";
    }), C(4 === m.rank, function () {
      return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m.rank + ".";
    }), C(g.shape[3] === m.shape[2], function () {
      return "Error in fused depthwiseConv2d: number of input channels (" + g.shape[3] + ") must match the inChannels dimension in filter " + m.shape[2] + ".";
    }), null == u && (u = [1, 1]), C(Mo(r, u), function () {
      return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'";
    }), null != c && C(A(o), function () {
      return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c + " but got pad " + o + ".";
    });
    var x,
        b,
        w = So(g.shape, m.shape, r, u, o, c, !0);
    null != l && (x = Nt(x = mn(l, "bias", "fused conv2d"), v)[0], Ro(w.outShape, x.shape)), null != d && (b = mn(d, "prelu weights", "fused depthwiseConv2d"));
    var E = {
      x: g,
      filter: m
    };
    null != l && (E.bias = x), null != d && (E.preluActivationWeights = b);
    var R = [m, g],
        I = Lt.runKernelFunc(function (t, e) {
      var n = t.fusedDepthwiseConv2D({
        input: g,
        filter: m,
        convInfo: w,
        bias: x,
        activation: f,
        preluActivationWeights: b
      });
      return e([m, g, n]), n;
    }, E, function (t, e) {
      C(Oo(u), function () {
        return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u + "'";
      });
      var n = e[0],
          r = e[1],
          o = e[2],
          a = Bh(t, o, f),
          i = {};
      return null != l && (i = {
        bias: function () {
          return Ph(x, a);
        }
      }), Object.assign({
        x: function () {
          return $c(r.shape, a, n, w);
        },
        filter: function () {
          return Qc(r, a, n.shape, w);
        }
      }, i);
    }, "FusedDepthwiseConv2D", {
      convInfo: w,
      activation: f
    }, R, [!0]);
    return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;
  }
}),
    zh = Object.freeze({
  matMul: Wh,
  conv2d: Uh,
  depthwiseConv2d: Vh
}),
    Gh = Object.freeze({
  image: Oh,
  linalg: Ih,
  losses: bh,
  spectral: Jl,
  fused: zh,
  signal: uh,
  square: tu,
  squaredDifference: nu,
  conv1d: Hc,
  conv2d: qc,
  conv3d: Kc,
  depthwiseConv2d: Yc,
  separableConv2d: Jc,
  conv2dTranspose: Zc,
  conv3dTranspose: tl,
  op: An,
  batchNormalization2d: Gu,
  batchNormalization3d: Hu,
  batchNormalization4d: qu,
  batchNormalization: Ku,
  batchNorm: ju,
  batchNorm2d: Xu,
  batchNorm3d: Yu,
  batchNorm4d: $u,
  booleanMaskAsync: Uc,
  complex: Dn,
  real: Tn,
  imag: Nn,
  concat: Yn,
  concat1d: $n,
  concat2d: Qn,
  concat3d: Jn,
  concat4d: Zn,
  split: tr,
  matMul: el,
  dot: nl,
  outerProduct: rl,
  reverse: ol,
  reverse1d: al,
  reverse2d: il,
  reverse3d: sl,
  reverse4d: ul,
  maxPool: hl,
  avgPool: fl,
  pool: dl,
  maxPool3d: pl,
  avgPool3d: vl,
  slice: ml,
  slice1d: gl,
  slice2d: yl,
  slice3d: xl,
  slice4d: bl,
  abs: ru,
  acos: ou,
  acosh: au,
  asin: iu,
  asinh: su,
  atan: uu,
  atanh: cu,
  ceil: lu,
  clipByValue: hu,
  cos: fu,
  cosh: du,
  erf: pu,
  exp: vu,
  expm1: mu,
  floor: gu,
  log: yu,
  log1p: xu,
  logSigmoid: bu,
  neg: wu,
  reciprocal: Cu,
  round: Eu,
  rsqrt: Ru,
  sigmoid: Iu,
  sign: ku,
  isNaN: Su,
  isInf: Au,
  isFinite: Du,
  sin: Tu,
  sinh: Nu,
  softplus: Fu,
  sqrt: _u,
  step: Ou,
  tan: Mu,
  tanh: Bu,
  all: Cl,
  any: El,
  argMax: Rl,
  argMin: Il,
  logSumExp: kl,
  max: Sl,
  mean: Al,
  min: Dl,
  moments: Tl,
  sum: Nl,
  prod: Fl,
  equal: Rc,
  equalStrict: Ic,
  greater: kc,
  greaterEqual: Sc,
  greaterEqualStrict: Ac,
  greaterStrict: Dc,
  less: Tc,
  lessEqual: Nc,
  lessEqualStrict: Fc,
  lessStrict: _c,
  notEqual: Oc,
  notEqualStrict: Mc,
  add: rc,
  addN: oc,
  addStrict: ac,
  atan2: ic,
  div: sc,
  divNoNan: uc,
  divStrict: cc,
  floorDiv: lc,
  maximum: hc,
  maximumStrict: fc,
  minimum: dc,
  minimumStrict: pc,
  mod: vc,
  modStrict: mc,
  mul: gc,
  mulStrict: yc,
  pow: xc,
  powStrict: bc,
  squaredDifferenceStrict: wc,
  sub: Cc,
  subStrict: Ec,
  elu: _l,
  leakyRelu: Ol,
  prelu: Ml,
  relu: Bl,
  relu6: Pl,
  selu: Ll,
  logicalAnd: Qu,
  logicalNot: Ju,
  logicalOr: Zu,
  logicalXor: tc,
  where: ec,
  whereAsync: nc,
  buffer: dr,
  print: pr,
  batchToSpaceND: vr,
  broadcastTo: mr,
  cast: gr,
  clone: yr,
  cumsum: xr,
  depthToSpace: br,
  expandDims: wr,
  eye: Cr,
  multinomial: Er,
  oneHot: Rr,
  pad: Ir,
  pad1d: kr,
  pad2d: Sr,
  pad3d: Ar,
  pad4d: Dr,
  rand: Tr,
  randomNormal: Nr,
  randomGamma: Fr,
  randomUniform: _r,
  reshape: Or,
  spaceToBatchND: Mr,
  squeeze: Br,
  stack: Pr,
  tile: Lr,
  truncatedNormal: Wr,
  unstack: Ur,
  setdiff1dAsync: Vr,
  fill: Hn,
  linspace: qn,
  ones: zn,
  range: Kn,
  scalar: On,
  tensor: Fn,
  tensor1d: Mn,
  tensor2d: Bn,
  tensor3d: Pn,
  tensor4d: Ln,
  tensor5d: Wn,
  tensor6d: Un,
  variable: Vn,
  zeros: Gn,
  onesLike: jn,
  zerosLike: Xn,
  transpose: Wl,
  softmax: go,
  logSoftmax: yo,
  localResponseNormalization: Ul,
  norm: Vl,
  gather: Lc,
  unsortedSegmentSum: Wc,
  basicLSTMCell: zl,
  multiRNNCell: Gl,
  movingAverage: Hl,
  stridedSlice: ql,
  topk: Kl,
  scatterND: jl,
  fft: Xl,
  ifft: Yl,
  rfft: $l,
  irfft: Ql,
  sparseToDense: Zl,
  gatherND: th,
  diag: eh,
  dropout: nh,
  hannWindow: oh,
  hammingWindow: ah,
  frame: ih,
  stft: sh,
  inTopKAsync: lh
});
exports.fused = zh;

function Hh(t, e) {
  Array.isArray(t) || (t = [t]), t.forEach(function (t) {
    null != t && C("complex64" !== t.dtype, function () {
      return e + " does not support complex64 tensors.";
    });
  });
}

function qh(t, e, n, r) {
  if ("linear" === n) return t.linear(e);
  if ("relu" === n) return t.relu(e);
  if ("elu" === n) return t.elu(e);
  if ("relu6" === n) return t.relu6(e);
  if ("prelu" === n) return t.prelu(e, r);
  throw new Error("Activation " + n + " has not been implemented for the CPU backend.");
}

var Kh = function (t) {
  function o() {
    var e = t.call(this) || this;
    return e.blockSize = 48, e.firstUse = !0, e.data = new xo(e, Lt), e;
  }

  return e(o, t), o.prototype.write = function (t, e, n) {
    this.firstUse && (this.firstUse = !1, i().get("IS_NODE") && dn("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
    var r = {};
    return this.data.set(r, {
      values: t,
      dtype: n
    }), r;
  }, o.prototype.move = function (t, e, n, r) {
    this.data.set(t, {
      values: e,
      dtype: r
    });
  }, o.prototype.numDataIds = function () {
    return this.data.numDataIds();
  }, o.prototype.read = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        return [2, this.readSync(t)];
      });
    });
  }, o.prototype.readSync = function (t) {
    var e = this.data.get(t),
        n = e.dtype,
        r = e.complexTensors;
    return "complex64" === n ? Vo(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(t).values;
  }, o.prototype.bufferSync = function (t) {
    var e = this.readSync(t.dataId),
        n = e;
    if ("string" === t.dtype) try {
      n = e.map(function (t) {
        return ot(t);
      });
    } catch (t) {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return dr(t.shape, t.dtype, n);
  }, o.prototype.makeOutput = function (t, e, n) {
    var r = this.write(t, e, n);
    return Lt.makeTensorFromDataId(r, e, n, this);
  }, o.prototype.disposeData = function (t) {
    if (this.data.has(t)) {
      var e = this.data.get(t).complexTensors;
      null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t);
    }
  }, o.prototype.time = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        return e = et(), t(), [2, {
          kernelMs: et() - e
        }];
      });
    });
  }, o.prototype.memory = function () {
    return {
      unreliable: !0,
      reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
    };
  }, o.prototype.complex = function (t, e) {
    var n = this.makeOutput(null, t.shape, "complex64");
    return this.data.get(n.dataId).complexTensors = {
      real: Lt.keep(t.clone()),
      imag: Lt.keep(e.clone())
    }, n;
  }, o.prototype.real = function (t) {
    return this.data.get(t.dataId).complexTensors.real.clone();
  }, o.prototype.imag = function (t) {
    return this.data.get(t.dataId).complexTensors.imag.clone();
  }, o.prototype.slice = function (t, e, n) {
    if (Hh(t, "slice"), io(t.shape, e, n)) {
      var r = so(e, t.strides),
          o = k(n);
      return Fn(this.readSync(t.dataId).subarray(r, r + o), n, t.dtype);
    }

    for (var a = dr(n, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; ++s) {
      var u = a.indexToLoc(s).map(function (t, n) {
        return t + e[n];
      });
      a.values[s] = i.get.apply(i, u);
    }

    return a.toTensor();
  }, o.prototype.stridedSlice = function (t, e, n, r) {
    Hh(t, "stridedSlice");
    var o = ro(e, n, r);
    if (o.some(function (t) {
      return 0 === t;
    })) return Fn([], o);

    for (var a = dr(o, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; s++) {
      for (var u = a.indexToLoc(s), c = new Array(u.length), l = 0; l < c.length; l++) c[l] = u[l] * r[l] + e[l];

      a.set.apply(a, [i.get.apply(i, c)].concat(u));
    }

    return a.toTensor();
  }, o.prototype.diag = function (t) {
    for (var e = this.readSync(t.dataId), n = dr([t.size, t.size], t.dtype), r = n.values, o = 0; o < e.length; o++) r[o * t.size + o] = e[o];

    return n.toTensor();
  }, o.prototype.unstack = function (t, e) {
    for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++) a !== e && (r[o++] = t.shape[a]);

    var i = new Array(t.rank).fill(0),
        s = t.shape.slice();
    s[e] = 1;
    var u = new Array(n);

    for (a = 0; a < u.length; a++) i[e] = a, u[a] = this.slice(t, i, s).reshape(r);

    return u;
  }, o.prototype.reverse = function (t, e) {
    Hh(t, "reverse");

    for (var n = dr(t.shape, t.dtype), r = this.bufferSync(t), o = function (o) {
      var a = n.indexToLoc(o),
          i = a.slice();
      e.forEach(function (e) {
        return i[e] = t.shape[e] - 1 - i[e];
      }), n.set.apply(n, [r.get.apply(r, i)].concat(a));
    }, a = 0; a < n.size; a++) o(a);

    return n.toTensor();
  }, o.prototype.concat = function (t, e) {
    var n = this;

    if ("complex64" === t[0].dtype) {
      var r = t.map(function (t) {
        return Tn(t);
      }),
          o = t.map(function (t) {
        return Nn(t);
      });
      return Dn(this.concat(r, e), this.concat(o, e));
    }

    var a = t.map(function (t) {
      var n = k(t.shape.slice(e));
      return t.as2D(-1, n);
    }),
        i = Sn(a.map(function (t) {
      return t.shape;
    }), 1),
        s = dr(i, t[0].dtype).values;

    if (1 === a[0].shape[0]) {
      var u = 0;
      a.forEach(function (t) {
        s.set(n.readSync(t.dataId), u), u += t.size;
      });
    } else {
      var c = 0;
      a.forEach(function (t) {
        for (var e = n.readSync(t.dataId), r = 0, o = 0; o < t.shape[0]; ++o) for (var a = o * i[1] + c, u = 0; u < t.shape[1]; ++u) s[a + u] = e[r++];

        c += t.shape[1];
      });
    }

    var l = Sn(t.map(function (t) {
      return t.shape;
    }), e);
    return Fn(s, l, t[0].dtype);
  }, o.prototype.neg = function (t) {
    return Hh(t, "neg"), this.multiply(On(-1), t);
  }, o.prototype.add = function (t, e) {
    return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
      return {
        real: t + n,
        imag: e + r
      };
    }) : this.broadcastedBinaryOp(t, e, Dt(t.dtype, e.dtype), function (t, e) {
      return t + e;
    });
  }, o.prototype.addN = function (t) {
    var e = this;
    Hh(t, "addN");

    for (var n = t.map(function (t) {
      return e.readSync(t.dataId);
    }), r = dr(t[0].shape, t[0].dtype), o = r.values, a = 0; a < t.length; a++) for (var i = n[a], s = 0; s < o.length; s++) o[s] += i[s];

    return r.toTensor();
  }, o.prototype.softmax = function (t, e) {
    var n = O([e], t.shape),
        r = this.max(t, n),
        o = wn(r.shape, n),
        a = this.subtract(t, r.reshape(o)),
        i = this.exp(a),
        s = this.sum(i, n).reshape(o);
    return this.realDivide(i, s);
  }, o.prototype.subtract = function (t, e) {
    return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
      return {
        real: t - n,
        imag: e - r
      };
    }) : this.broadcastedBinaryOp(t, e, Dt(t.dtype, e.dtype), function (t, e) {
      return t - e;
    });
  }, o.prototype.pow = function (t, e) {
    return Hh([t, e], "pow"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.pow(t, e);
    });
  }, o.prototype.batchMatMul = function (t, e, n, r) {
    Hh([t, e], "matMul");

    for (var o = n ? t.shape[1] : t.shape[2], a = n ? t.shape[2] : t.shape[1], i = r ? e.shape[1] : e.shape[2], s = t.shape[0], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = n ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], h = l[0], f = l[1], d = l[2], p = r ? [1, e.strides[1], e.strides[0]] : [e.strides[1], 1, e.strides[0]], v = p[0], m = p[1], g = p[2], y = a * i, x = dr([s, a, i], t.dtype), b = x.values, w = this.blockSize, C = 0; C < s; C++) for (var E = 0; E < a; E += w) for (var R = 0; R < i; R += w) for (var I = 0; I < o; I += w) for (var k = Math.min(E + w, a), S = Math.min(R + w, i), A = Math.min(I + w, o), D = E; D < k; D++) for (var T = R; T < S; T++) {
      for (var N = 0, F = I; F < A; F++) N += u[C * h + D * f + F * d] * c[F * v + T * m + C * g];

      b[C * y + (D * i + T)] += N;
    }

    return x.toTensor();
  }, o.prototype.fusedBatchMatMul = function (t) {
    var e = t.a,
        n = t.b,
        r = t.transposeA,
        o = t.transposeB,
        a = t.bias,
        i = t.activation,
        s = t.preluActivationWeights,
        u = this.batchMatMul(e, n, r, o);
    return a && (u = this.add(u, a)), i && (u = qh(this, u, i, s)), u;
  }, o.prototype.multiply = function (t, e) {
    return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
      return {
        real: t * n - e * r,
        imag: t * r + e * n
      };
    }) : this.broadcastedBinaryOp(t, e, Dt(t.dtype, e.dtype), function (t, e) {
      return t * e;
    });
  }, o.prototype.realDivide = function (t, e) {
    Hh([t, e], "realDivide");
    return this.broadcastedBinaryOp(t, e, "float32", function (t, e) {
      return t / e;
    });
  }, o.prototype.floorDiv = function (t, e) {
    Hh([t, e], "floorDiv");
    return this.broadcastedBinaryOp(t, e, "int32", function (t, e) {
      return Math.floor(t / e);
    });
  }, o.prototype.sum = function (t, e) {
    Hh(t, "sum"), Cn("sum", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, Dt(t.dtype, "int32")), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = 0, f = 0; f < i; ++f) h += u[l + f];

      s[c] = h;
    }

    return a;
  }, o.prototype.prod = function (t, e) {
    Hh(t, "sum");

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, Dt(t.dtype, "int32")), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = 1, f = 0; f < i; ++f) h *= u[l + f];

      s[c] = h;
    }

    return a;
  }, o.prototype.unsortedSegmentSum = function (t, e, n) {
    Hh(t, "unsortedSegmentSum");

    for (var r = [], o = t.rank - e.rank, a = 0; a < o; ++a) e = e.expandDims(a + 1);

    for (a = 0; a < n; ++a) {
      var i = On(a, "int32"),
          s = Rc(i, e).asType("float32").mul(t).sum(0);
      r.push(s);
    }

    return Pr(r);
  }, o.prototype.argMin = function (t, e) {
    Hh(t, "argMin");
    var n = [e];
    Cn("argMin", n, t.rank);

    for (var r = bn(t.shape, n), o = r[0], a = r[1], i = Gn(o, "int32"), s = k(a), u = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {
      for (var h = l * s, f = c[h], d = 0, p = 0; p < s; ++p) {
        var v = c[h + p];
        v < f && (f = v, d = p);
      }

      u[l] = d;
    }

    return i;
  }, o.prototype.argMax = function (t, e) {
    Hh(t, "argMax");
    var n = [e];
    Cn("argMax", n, t.rank);

    for (var r = bn(t.shape, n), o = r[0], a = r[1], i = Gn(o, "int32"), s = k(a), u = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {
      for (var h = l * s, f = c[h], d = 0, p = 0; p < s; ++p) {
        var v = c[h + p];
        v > f && (f = v, d = p);
      }

      u[l] = d;
    }

    return i;
  }, o.prototype.cumsum = function (t, e, n, r) {
    if (Hh(t, "cumsum"), e !== t.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);

    for (var o = Dt(t.dtype, "int32"), a = Gn(t.shape, o), i = this.readSync(a.dataId), s = this.readSync(t.dataId), u = t.shape[t.rank - 1], c = r ? function (t, e) {
      return t + u - e - 1;
    } : function (t, e) {
      return t + e;
    }, l = 0; l < s.length; l += u) for (var h = 0; h < u; h++) {
      var f = c(l, h);
      if (0 === h) i[f] = n ? 0 : s[f];else {
        var d = c(l, h - 1);
        i[f] = n ? s[d] + i[d] : s[f] + i[d];
      }
    }

    return a;
  }, o.prototype.equal = function (t, e) {
    return Hh([t, e], "equal"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t === e ? 1 : 0;
    });
  }, o.prototype.notEqual = function (t, e) {
    return Hh([t, e], "notEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t !== e ? 1 : 0;
    });
  }, o.prototype.less = function (t, e) {
    return Hh([t, e], "less"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t < e ? 1 : 0;
    });
  }, o.prototype.lessEqual = function (t, e) {
    return Hh([t, e], "lessEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t <= e ? 1 : 0;
    });
  }, o.prototype.greater = function (t, e) {
    return Hh([t, e], "greater"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t > e ? 1 : 0;
    });
  }, o.prototype.greaterEqual = function (t, e) {
    return Hh([t, e], "greaterEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t >= e ? 1 : 0;
    });
  }, o.prototype.logicalNot = function (t) {
    Hh(t, "logicalNot");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e[r] ? 0 : 1;

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.logicalAnd = function (t, e) {
    return Hh([t, e], "logicalAnd"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t && e;
    });
  }, o.prototype.logicalOr = function (t, e) {
    return Hh([t, e], "logicalOr"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
      return t || e;
    });
  }, o.prototype.select = function (t, e, n) {
    Hh([t, e, n], "select");

    for (var r = this.readSync(t.dataId), o = this.readSync(e.dataId), a = this.readSync(n.dataId), i = Gn(e.shape, Dt(e.dtype, n.dtype)), s = this.readSync(i.dataId), u = 0, c = 0 === t.rank || t.rank > 1 || 1 === e.rank ? 1 : k(e.shape.slice(1)), l = 0; l < r.length; l++) for (var h = 0; h < c; h++) 1 === r[l] ? s[u++] = o[l] : s[u++] = a[l];

    return i;
  }, o.prototype.where = function (t) {
    Hh([t], "where");
    var e = this.readSync(t.dataId);
    return na(t.shape, e);
  }, o.prototype.topk = function (t, e, n) {
    return Hh(t, "topk"), ea(this.readSync(t.dataId), t.shape, t.dtype, e);
  }, o.prototype.min = function (t, e) {
    Hh(t, "min"), Cn("min", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = u[l], f = 0; f < i; ++f) {
        var d = u[l + f];
        d < h && (h = d);
      }

      s[c] = h;
    }

    return a;
  }, o.prototype.minimum = function (t, e) {
    return Hh([t, e], "minimum"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.min(t, e);
    });
  }, o.prototype.mod = function (t, e) {
    return Hh([t, e], "mod"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      var n = t % e;
      return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e;
    });
  }, o.prototype.max = function (t, e) {
    Hh(t, "max"), Cn("max", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = u[l], f = 0; f < i; ++f) {
        var d = u[l + f];
        d > h && (h = d);
      }

      s[c] = h;
    }

    return a;
  }, o.prototype.maximum = function (t, e) {
    return Hh([t, e], "maximum"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.max(t, e);
    });
  }, o.prototype.all = function (t, e) {
    Hh(t, "all"), Cn("all", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = u[l], f = 0; f < i; ++f) {
        var d = u[l + f];
        h = h && d;
      }

      s[c] = h;
    }

    return a;
  }, o.prototype.any = function (t, e) {
    Hh(t, "any"), Cn("any", e, t.rank);

    for (var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
      for (var l = c * i, h = u[l], f = 0; f < i; ++f) {
        var d = u[l + f];
        h = h || d;
      }

      s[c] = h;
    }

    return a;
  }, o.prototype.squaredDifference = function (t, e) {
    return Hh([t, e], "squaredDifference"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      var n = t - e;
      return n * n;
    });
  }, o.prototype.ceil = function (t) {
    Hh(t, "ceil");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.ceil(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.floor = function (t) {
    Hh(t, "floor");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.floor(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.sign = function (t) {
    Hh(t, "x");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.isNaN = function (t) {
    Hh(t, "x");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isNaN(e[r]) && (n[r] = 1);

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.isInf = function (t) {
    Hh(t, "x");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Math.abs(e[r]) === 1 / 0 && (n[r] = 1);

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.isFinite = function (t) {
    Hh(t, "x");

    for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isFinite(e[r]) && (n[r] = 1);

    return this.makeOutput(n, t.shape, "bool");
  }, o.prototype.round = function (t) {
    Hh(t, "round");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = Math.floor(e[r]);
      e[r] - o < .5 ? n[r] = Math.floor(e[r]) : e[r] - o > .5 ? n[r] = Math.ceil(e[r]) : n[r] = o % 2 == 0 ? o : o + 1;
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.exp = function (t) {
    Hh(t, "exp");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.exp(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.expm1 = function (t) {
    Hh(t, "expm1");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.expm1(e[r]);

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.log = function (t) {
    Hh(t, "log");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = Math.log(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.log1p = function (t) {
    Hh(t, "log1p");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = Math.log1p(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.sqrt = function (t) {
    Hh(t, "sqrt");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = Math.sqrt(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.rsqrt = function (t) {
    Hh(t, "rsqrt");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
      var o = e[r];
      n[r] = 1 / Math.sqrt(o);
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.reciprocal = function (t) {
    Hh(t, "reciprocal");

    for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = 1 / e[r];

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.linear = function (t) {
    return t;
  }, o.prototype.relu = function (t) {
    Hh(t, "relu");

    for (var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) n[o] = Math.max(0, r[o]);

    return e;
  }, o.prototype.relu6 = function (t) {
    Hh(t, "relu");

    for (var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) n[o] = Math.min(Math.max(0, r[o]), 6);

    return e;
  }, o.prototype.prelu = function (t, e) {
    return Hh([t, e], "prelu"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return t < 0 ? e * t : t;
    });
  }, o.prototype.elu = function (t) {
    Hh(t, "elu");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
      var o = n[r];
      e[r] = o >= 0 ? o : Math.exp(o) - 1;
    }

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.eluDer = function (t, e) {
    Hh([t, e], "eluDer");

    for (var n = new Float32Array(e.size), r = this.readSync(e.dataId), o = this.readSync(t.dataId), a = 0; a < r.length; ++a) {
      var i = r[a];
      n[a] = i >= 1 ? o[a] : o[a] * (i + 1);
    }

    return this.makeOutput(n, e.shape, "float32");
  }, o.prototype.selu = function (t) {
    Hh(t, "selu");

    for (var e = bs, n = ws, r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a) {
      var i = o[a];
      r[a] = i >= 0 ? n * i : e * (Math.exp(i) - 1);
    }

    return this.makeOutput(r, t.shape, "float32");
  }, o.prototype.clip = function (t, e, n) {
    Hh(t, "clip");

    for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a) {
      var i = o[a];
      r[a] = i > n ? n : i < e ? e : i;
    }

    return this.makeOutput(r, t.shape, "float32");
  }, o.prototype.abs = function (t) {
    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.abs(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.complexAbs = function (t) {
    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r) {
      var o = n[2 * r],
          a = n[2 * r + 1];
      e[r] = Math.hypot(o, a);
    }

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.int = function (t) {
    Hh(t, "int");

    for (var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = n[r];

    return this.makeOutput(e, t.shape, "int32");
  }, o.prototype.sigmoid = function (t) {
    Hh(t, "sigmoid");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = 1 / (1 + Math.exp(-n[r]));

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.softplus = function (t) {
    Hh(t, "softplus");

    for (var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) {
      var a = r[o] > -e,
          i = r[o] < e,
          s = Math.exp(r[o]),
          u = void 0;
      u = i ? s : a ? r[o] : Math.log(1 + s), n[o] = u;
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.sin = function (t) {
    Hh(t, "sin");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sin(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.cos = function (t) {
    Hh(t, "cos");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cos(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.tan = function (t) {
    Hh(t, "tan");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.tan(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.asin = function (t) {
    Hh(t, "asin");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asin(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.acos = function (t) {
    Hh(t, "acos");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acos(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.atan = function (t) {
    Hh(t, "atan");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atan(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.atan2 = function (t, e) {
    return Hh([t, e], "atan2"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
      return Math.atan2(t, e);
    });
  }, o.prototype.sinh = function (t) {
    Hh(t, "sinh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sinh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.cosh = function (t) {
    Hh(t, "cosh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cosh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.tanh = function (t) {
    Hh(t, "tanh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = D(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.asinh = function (t) {
    Hh(t, "asinh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asinh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.acosh = function (t) {
    Hh(t, "acosh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acosh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.atanh = function (t) {
    Hh(t, "atanh");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atanh(n[r]);

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.erf = function (t) {
    Hh(t, "erf");

    for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
      var o = Math.sign(n[r]),
          a = Math.abs(n[r]),
          i = 1 / (1 + .3275911 * a);
      e[r] = o * (1 - ((((1.061405429 * i - 1.453152027) * i + 1.421413741) * i - .284496736) * i + .254829592) * i * Math.exp(-a * a));
    }

    return this.makeOutput(e, t.shape, "float32");
  }, o.prototype.step = function (t, e) {
    void 0 === e && (e = 0), Hh(t, "step");

    for (var n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) {
      var a = r[o];
      isNaN(a) ? n[o] = NaN : n[o] = a > 0 ? 1 : e;
    }

    return this.makeOutput(n, t.shape, "float32");
  }, o.prototype.fusedConv2d = function (t) {
    var e = t.input,
        n = t.filter,
        r = t.convInfo,
        o = t.bias,
        a = t.activation,
        i = t.preluActivationWeights,
        s = this.conv2d(e, n, r);
    return o && (s = this.add(s, o)), a && (s = qh(this, s, a, i)), s;
  }, o.prototype.conv2d = function (t, e, n) {
    Hh([t, e], "conv2d");

    for (var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = "channelsLast" === n.dataFormat, l = dr(n.outShape, t.dtype), h = t.strides[0], f = c ? t.strides[1] : t.strides[2], d = c ? t.strides[2] : 1, p = c ? 1 : t.strides[1], v = l.strides[0], m = c ? l.strides[1] : l.strides[2], g = c ? l.strides[2] : 1, y = c ? 1 : l.strides[1], x = this.readSync(t.dataId), b = this.readSync(e.dataId), w = l.values, C = 0; C < n.batchSize; ++C) for (var E = C * h, R = C * v, I = 0; I < n.outHeight; ++I) for (var k = R + I * m, S = I * n.strideHeight - u, A = 0; A < r; A++) {
      var D = S + A * a;
      if (!(D < 0 || D >= n.inHeight)) for (var T = A * e.strides[0], N = E + D * f, F = 0; F < n.outWidth; ++F) for (var _ = k + F * g, O = F * n.strideWidth - s, M = 0; M < o; M++) {
        var B = O + M * i;
        if (!(B < 0 || B >= n.inWidth)) for (var P = N + B * d, L = T + M * e.strides[1], W = 0; W < n.inChannels; ++W) {
          for (var U = x[P + W * p], V = 0; V < n.outChannels; ++V) w[_ + V * y] += U * b[L + V];

          L += n.outChannels;
        }
      }
    }

    return l.toTensor();
  }, o.prototype.conv3d = function (t, e, n) {
    for (var r = n.filterDepth, o = n.filterHeight, a = n.filterWidth, i = n.dilationDepth, s = n.dilationHeight, u = n.dilationWidth, c = n.padInfo.front, l = n.padInfo.left, h = n.padInfo.top, f = dr(n.outShape, t.dtype), d = this.readSync(t.dataId), p = this.readSync(e.dataId), v = f.values, m = 0; m < n.batchSize; ++m) for (var g = m * t.strides[0], y = m * f.strides[0], x = 0; x < n.outDepth; ++x) for (var b = y + x * f.strides[1], w = x * n.strideDepth - c, C = 0; C < r; C++) {
      var E = w + C * i;
      if (!(E < 0 || E >= n.inDepth)) for (var R = C * e.strides[0], I = g + E * t.strides[1], k = 0; k < n.outHeight; ++k) for (var S = b + k * f.strides[2], A = k * n.strideHeight - h, D = 0; D < o; D++) {
        var T = A + D * s;
        if (!(T < 0 || T >= n.inHeight)) for (var N = R + D * e.strides[1], F = I + T * t.strides[2], _ = 0; _ < n.outWidth; ++_) for (var O = S + _ * n.outChannels, M = _ * n.strideWidth - l, B = 0; B < a; B++) {
          var P = M + B * u;
          if (!(P < 0 || P >= n.inWidth)) for (var L = N + B * e.strides[2], W = F + P * n.inChannels, U = L, V = 0; V < n.inChannels; ++V) {
            for (var z = d[W + V], G = 0; G < n.outChannels; ++G) v[O + G] += z * p[U + G];

            U += n.outChannels;
          }
        }
      }
    }

    return f.toTensor();
  }, o.prototype.conv2dDerInput = function (t, e, n) {
    Hh([t, e], "conv2dDerInput");

    for (var r = dr(n.inShape, "float32"), o = r.values, a = this.readSync(t.dataId), i = this.readSync(e.dataId), s = e.strides, u = s[0], c = s[1], l = s[2], h = n.batchSize, f = n.filterHeight, d = n.filterWidth, p = n.inChannels, v = n.inHeight, m = n.inWidth, g = n.outChannels, y = n.outHeight, x = n.outWidth, b = n.strideHeight, w = n.strideWidth, C = n.dataFormat, E = f - 1 - n.padInfo.top, R = d - 1 - n.padInfo.left, I = "channelsLast" === C, k = r.strides[0], S = I ? r.strides[1] : r.strides[2], A = I ? r.strides[2] : 1, D = I ? 1 : r.strides[1], T = t.strides[0], N = I ? t.strides[1] : t.strides[2], F = I ? t.strides[2] : 1, _ = I ? 1 : t.strides[1], O = 0; O < h; ++O) for (var M = 0; M < p; ++M) for (var B = 0; B < v; ++B) for (var P = B - E, L = Math.max(0, Math.ceil(P / b)), W = Math.min(y, (f + P) / b), U = 0; U < m; ++U) {
      for (var V = U - R, z = Math.max(0, Math.ceil(V / w)), G = Math.min(x, (d + V) / w), H = 0, q = L; q < W; ++q) for (var K = q * b - P, j = z; j < G; ++j) for (var X = T * O + N * q + F * j, Y = u * (f - 1 - K) + c * (d - 1 - (j * w - V)) + l * M, $ = 0; $ < g; ++$) {
        H += a[X + _ * $] * i[Y + $];
      }

      o[k * O + S * B + A * U + D * M] = H;
    }

    return r.toTensor();
  }, o.prototype.conv3dDerInput = function (t, e, n) {
    for (var r = dr(n.inShape, "float32"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], c = a[3], l = this.readSync(t.dataId), h = t.strides, f = h[0], d = h[1], p = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], x = g[1], b = g[2], w = g[3], C = n.batchSize, E = n.filterDepth, R = n.filterHeight, I = n.filterWidth, k = n.inChannels, S = n.inDepth, A = n.inHeight, D = n.inWidth, T = n.outChannels, N = n.outDepth, F = n.outHeight, _ = n.outWidth, O = n.strideDepth, M = n.strideHeight, B = n.strideWidth, P = E - 1 - n.padInfo.front, L = R - 1 - n.padInfo.top, W = I - 1 - n.padInfo.left, U = 0; U < C; ++U) for (var V = 0; V < k; ++V) for (var z = 0; z < S; ++z) for (var G = z - P, H = Math.max(0, Math.ceil(G / O)), q = Math.min(N, (E + G) / O), K = 0; K < A; ++K) for (var j = K - L, X = Math.max(0, Math.ceil(j / M)), Y = Math.min(F, (R + j) / M), $ = 0; $ < D; ++$) {
      for (var Q = $ - W, J = Math.max(0, Math.ceil(Q / B)), Z = Math.min(_, (I + Q) / B), tt = 0, et = H; et < q; ++et) for (var nt = et * O - G, rt = X; rt < Y; ++rt) for (var ot = rt * M - j, at = J; at < Z; ++at) for (var it = f * U + d * et + p * rt + v * at, st = y * (E - 1 - nt) + x * (R - 1 - ot) + b * (I - 1 - (at * B - Q)) + w * V, ut = 0; ut < T; ++ut) {
        tt += l[it + ut] * m[st + ut];
      }

      o[i * U + s * z + u * K + c * $ + V] = tt;
    }

    return r.toTensor();
  }, o.prototype.conv2dDerFilter = function (t, e, n) {
    Hh([t, e], "conv2dDerFilter");

    for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = "channelsLast" === n.dataFormat, u = dr(n.filterShape, "float32"), c = n.padInfo.left, l = n.padInfo.top, h = this.bufferSync(t), f = this.bufferSync(e), d = 0; d < a; ++d) for (var p = Math.max(0, Math.ceil((l - d) / r)), v = Math.min(n.outHeight, (n.inHeight + l - d) / r), m = 0; m < i; ++m) for (var g = Math.max(0, Math.ceil((c - m) / o)), y = Math.min(n.outWidth, (n.inWidth + c - m) / o), x = 0; x < n.inChannels; ++x) for (var b = 0; b < n.outChannels; ++b) {
      for (var w = 0, C = 0; C < n.batchSize; ++C) for (var E = p; E < v; ++E) for (var R = d + E * r - l, I = g; I < y; ++I) {
        var k = m + I * o - c;
        w += s ? h.get(C, R, k, x) * f.get(C, E, I, b) : h.get(C, x, R, k) * f.get(C, b, E, I);
      }

      u.set(w, d, m, x, b);
    }

    return u.toTensor();
  }, o.prototype.conv3dDerFilter = function (t, e, n) {
    for (var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = dr(n.filterShape, "float32"), l = c.values, h = c.strides, f = h[0], d = h[1], p = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], x = g[1], b = g[2], w = g[3], C = this.readSync(t.dataId), E = t.strides, R = E[0], I = E[1], k = E[2], S = E[3], A = n.padInfo.front, D = n.padInfo.left, T = n.padInfo.top, N = 0; N < i; ++N) for (var F = Math.max(0, Math.ceil((A - N) / r)), _ = Math.min(n.outDepth, (n.inDepth + A - N) / r), O = N * f, M = 0; M < s; ++M) for (var B = Math.max(0, Math.ceil((T - M) / o)), P = Math.min(n.outHeight, (n.inHeight + T - M) / o), L = M * d + O, W = 0; W < u; ++W) for (var U = Math.max(0, Math.ceil((D - W) / a)), V = Math.min(n.outWidth, (n.inWidth + D - W) / a), z = W * p + L, G = 0; G < n.inChannels; ++G) for (var H = G * v + z, q = 0; q < n.outChannels; ++q) {
      for (var K = 0, j = 0; j < n.batchSize; ++j) for (var X = j * R, Y = j * y, $ = F; $ < _; ++$) for (var Q = (N + $ * r - A) * I + X, J = $ * x + Y, Z = B; Z < P; ++Z) for (var tt = (M + Z * o - T) * k + Q, et = Z * b + J, nt = U; nt < V; ++nt) {
        var rt = nt * w + et;
        K += C[(W + nt * a - D) * S + tt + G] * m[rt + q];
      }

      l[H + q] = K;
    }

    return c.toTensor();
  }, o.prototype.fusedDepthwiseConv2D = function (t) {
    var e = t.input,
        n = t.filter,
        r = t.convInfo,
        o = t.bias,
        a = t.activation,
        i = t.preluActivationWeights,
        s = this.depthwiseConv2D(e, n, r);
    return o && (s = this.add(s, o)), a && (s = qh(this, s, a, i)), s;
  }, o.prototype.depthwiseConv2D = function (t, e, n) {
    Hh([t, e], "depthwiseConv2D");

    for (var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = n.outChannels / n.inChannels, l = dr(n.outShape, t.dtype), h = this.readSync(t.dataId), f = this.readSync(e.dataId), d = l.values, p = 0; p < n.batchSize; ++p) for (var v = p * t.strides[0], m = p * l.strides[0], g = 0; g < n.outHeight; ++g) for (var y = m + g * l.strides[1], x = g * n.strideHeight - s, b = 0; b < r; ++b) {
      var w = x + b * a;
      if (!(w < 0 || w >= n.inHeight)) for (var C = b * e.strides[0], E = v + w * t.strides[1], R = 0; R < n.outWidth; ++R) for (var I = y + R * l.strides[2], k = R * n.strideWidth - u, S = 0; S < o; ++S) {
        var A = k + S * i;
        if (!(A < 0 || A >= n.inWidth)) for (var D = C + S * e.strides[1], T = E + A * n.inChannels, N = I, F = D, _ = 0; _ < n.inChannels; ++_) {
          for (var O = h[T + _], M = 0; M < c; ++M) d[N + M] += O * f[F + M];

          N += c, F += c;
        }
      }
    }

    return l.toTensor();
  }, o.prototype.depthwiseConv2DDerInput = function (t, e, n) {
    Hh([t, e], "depthwiseConv2DDerInput");

    for (var r = dr(n.inShape, "float32"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], c = this.readSync(t.dataId), l = t.strides, h = l[0], f = l[1], d = l[2], p = this.readSync(e.dataId), v = e.strides, m = v[0], g = v[1], y = v[2], x = n.batchSize, b = n.filterHeight, w = n.filterWidth, C = n.inChannels, E = n.inHeight, R = n.inWidth, I = n.outChannels, k = n.outHeight, S = n.outWidth, A = n.strideHeight, D = n.strideWidth, T = b - 1 - n.padInfo.top, N = w - 1 - n.padInfo.left, F = I / C, _ = 0; _ < x; ++_) for (var O = 0; O < C; ++O) for (var M = 0; M < E; ++M) for (var B = M - T, P = Math.max(0, Math.ceil(B / A)), L = Math.min(k, (b + B) / A), W = 0; W < R; ++W) {
      for (var U = W - N, V = Math.max(0, Math.ceil(U / D)), z = Math.min(S, (w + U) / D), G = 0, H = P; H < L; ++H) for (var q = H * A - B, K = V; K < z; ++K) for (var j = h * _ + f * H + d * K, X = m * (b - 1 - q) + g * (w - 1 - (K * D - U)) + y * O, Y = 0; Y < F; ++Y) {
        G += c[j + (O * F + Y)] * p[X + Y];
      }

      o[i * _ + s * M + u * W + O] = G;
    }

    return r.toTensor();
  }, o.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
    Hh([t, e], "depthwiseConv2DDerFilter");

    for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = dr(n.filterShape, "float32"), u = n.padInfo.left, c = n.padInfo.top, l = n.outChannels / n.inChannels, h = this.bufferSync(t), f = this.bufferSync(e), d = 0; d < a; ++d) for (var p = Math.max(0, Math.ceil((c - d) / r)), v = Math.min(n.outHeight, (n.inHeight + c - d) / r), m = 0; m < i; ++m) for (var g = Math.max(0, Math.ceil((u - m) / o)), y = Math.min(n.outWidth, (n.inWidth + u - m) / o), x = 0; x < n.outChannels; ++x) {
      for (var b = Math.trunc(x / l), w = x % l, C = 0, E = 0; E < n.batchSize; ++E) for (var R = p; R < v; ++R) for (var I = d + R * r - c, k = g; k < y; ++k) {
        var S = m + k * o - u;
        C += h.get(E, I, S, b) * f.get(E, R, k, x);
      }

      s.set(C, d, m, b, w);
    }

    return s.toTensor();
  }, o.prototype.tile = function (t, e) {
    return Hh(t, "tile"), ta(this.bufferSync(t), e);
  }, o.prototype.pad = function (t, e, n) {
    Hh(t, "pad");
    var r = e.map(function (e, n) {
      return e[0] + t.shape[n] + e[1];
    }),
        o = e.map(function (t) {
      return t[0];
    }),
        a = this.bufferSync(t),
        i = dr(r, t.dtype);
    0 !== n && i.values.fill(n);

    for (var s = 0; s < t.size; s++) {
      var u = a.indexToLoc(s),
          c = u.map(function (t, e) {
        return t + o[e];
      });
      i.set.apply(i, [a.get.apply(a, u)].concat(c));
    }

    return i.toTensor();
  }, o.prototype.transpose = function (t, e) {
    Hh(t, "transpose");

    for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[e[r]];

    var o = this.readSync(t.dataId),
        a = dr(n, t.dtype),
        i = this.bufferSync(t);

    for (r = 0; r < t.size; ++r) {
      for (var s = i.indexToLoc(r), u = new Array(s.length), c = 0; c < u.length; c++) u[c] = s[e[c]];

      var l = a.locToIndex(u);
      a.values[l] = o[r];
    }

    return a.toTensor();
  }, o.prototype.gather = function (t, e, n) {
    Hh([t, e], "gather");
    var r = t.shape.slice(),
        o = this.readSync(e.dataId);
    r[n] = o.length;

    for (var a = dr(r, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; ++s) {
      var u = a.indexToLoc(s),
          c = u.slice();
      c[n] = o[u[n]];
      var l = i.locToIndex(c);
      a.values[s] = i.values[l];
    }

    return a.toTensor();
  }, o.prototype.batchToSpaceND = function (t, e, n) {
    Hh([t], "batchToSpaceND");
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = zr(t.shape, e, r),
        a = Gr(o.length, e.length),
        i = Hr(t.shape, e, r),
        s = qr(n, e.length),
        u = Kr(i, n, e.length);
    return t.reshape(o).transpose(a).reshape(i).slice(s, u);
  }, o.prototype.spaceToBatchND = function (t, e, n) {
    Hh([t], "spaceToBatchND");
    var r = e.reduce(function (t, e) {
      return t * e;
    }),
        o = [[0, 0]];
    o.push.apply(o, n);

    for (var a = 1 + e.length; a < t.shape.length; ++a) o.push([0, 0]);

    var i = t.pad(o),
        s = zr(i.shape, e, r, !1),
        u = Gr(s.length, e.length, !1),
        c = Hr(i.shape, e, r, !1);
    return i.reshape(s).transpose(u).reshape(c);
  }, o.prototype.pool = function (t, e, n) {
    Hh(t, "pool");

    for (var r = e.strideHeight, o = e.strideWidth, a = e.dilationHeight, i = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f = this.readSync(t.dataId), d = dr(e.outShape, t.dtype), p = d.values, v = e.outShape[1] * e.outShape[2] * e.outShape[3], m = e.outShape[2] * e.outShape[3], g = e.outShape[3], y = 0; y < e.batchSize; ++y) for (var x = y * v, b = y * t.strides[0], w = 0; w < e.inChannels; ++w) for (var C = 0; C < e.outHeight; ++C) for (var E = C * r - c, R = Math.max(0, E), I = Math.min(e.inHeight, s + E), k = x + C * m, S = 0; S < e.outWidth; ++S) {
      for (var A = S * o - l, D = Math.max(0, A), T = Math.min(e.inWidth, u + A), N = h, F = 0, _ = 0, O = R; O < I; O += a) {
        for (var M = b + O * t.strides[1], B = D; B < T; B += i) {
          var P = f[M + B * t.strides[2] + w];
          "max" === n && P > N ? N = P : "avg" === n && (F += P, _++);
        }

        if (isNaN(N)) break;
      }

      p[k + S * g + w] = "avg" === n ? F / _ : N;
    }

    return d.toTensor();
  }, o.prototype.maxPool = function (t, e) {
    return this.pool(t, e, "max");
  }, o.prototype.maxPoolPositions = function (t, e) {
    for (var n = dr(e.outShape, "int32"), r = e.strideHeight, o = e.strideWidth, a = e.dilationHeight, i = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = this.bufferSync(t), f = 0; f < e.batchSize; ++f) for (var d = 0; d < e.inChannels; ++d) for (var p = 0; p < e.outHeight; ++p) {
      for (var v = p * r - c, m = v; m < 0;) m += a;

      for (var g = Math.min(e.inHeight, s + v), y = 0; y < e.outWidth; ++y) {
        for (var x = y * o - l, b = x; b < 0;) b += i;

        for (var w = Math.min(e.inWidth, u + x), C = Number.NEGATIVE_INFINITY, E = -1, R = m; R < g; R += a) for (var I = R - v, k = b; k < w; k += i) {
          var S = k - x,
              A = h.get(f, R, k, d);
          A > C && (C = A, E = I * u + S);
        }

        n.set(E, f, p, y, d);
      }
    }

    return n.toTensor();
  }, o.prototype.maxPoolBackprop = function (t, e, n, r) {
    Hh([e, n], "maxPoolBackprop");

    for (var o = this.maxPoolPositions(e, r), a = r.strideHeight, i = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, c = r.effectiveFilterHeight, l = r.effectiveFilterWidth, h = l - 1 - r.padInfo.left, f = c - 1 - r.padInfo.top, d = dr(e.shape, "float32"), p = this.bufferSync(o), v = this.bufferSync(t), m = 0; m < r.batchSize; ++m) for (var g = 0; g < r.inChannels; ++g) for (var y = 0; y < r.inHeight; ++y) for (var x = 0; x < r.inWidth; ++x) {
      for (var b = y - f, w = x - h, C = 0, E = 0; E < c; E += s) {
        var R = (b + E) / a;
        if (!(R < 0 || R >= r.outHeight || Math.floor(R) !== R)) for (var I = 0; I < l; I += u) {
          var k = (w + I) / i;

          if (!(k < 0 || k >= r.outWidth || Math.floor(k) !== k)) {
            var S = c * l - 1 - p.get(m, R, k, g) === E * l + I ? 1 : 0;
            if (0 !== S) C += v.get(m, R, k, g) * S;
          }
        }
      }

      d.set(C, m, y, x, g);
    }

    return d.toTensor();
  }, o.prototype.avgPoolBackprop = function (t, e, n) {
    Hh([t, e], "avgPoolBackprop");

    for (var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = n.dilationHeight, u = n.dilationWidth, c = n.effectiveFilterHeight, l = n.effectiveFilterWidth, h = l - 1 - n.padInfo.left, f = c - 1 - n.padInfo.top, d = dr(e.shape, "float32"), p = 1 / (a * i), v = this.bufferSync(t), m = 0; m < n.batchSize; ++m) for (var g = 0; g < n.inChannels; ++g) for (var y = 0; y < n.inHeight; ++y) for (var x = 0; x < n.inWidth; ++x) {
      for (var b = y - f, w = x - h, C = 0, E = 0; E < c; E += s) {
        var R = (b + E) / r;
        if (!(R < 0 || R >= n.outHeight || Math.floor(R) !== R)) for (var I = 0; I < l; I += u) {
          var k = (w + I) / o;
          if (!(k < 0 || k >= n.outWidth || Math.floor(k) !== k)) C += v.get(m, R, k, g);
        }
      }

      d.set(C * p, m, y, x, g);
    }

    return d.toTensor();
  }, o.prototype.pool3d = function (t, e, n) {
    Hh(t, "pool3d");

    for (var r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, d = e.padInfo.top, p = e.padInfo.left, v = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = this.readSync(t.dataId), g = dr(e.outShape, t.dtype), y = g.values, x = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4], b = e.outShape[2] * e.outShape[3] * e.outShape[4], w = e.outShape[3] * e.outShape[4], C = e.outShape[4], E = 0; E < e.batchSize; ++E) for (var R = E * x, I = E * t.strides[0], k = 0; k < e.inChannels; ++k) for (var S = 0; S < e.outDepth; ++S) {
      for (var A = S * r - f, D = A; D < 0;) D += i;

      for (var T = Math.min(e.inDepth, c + A), N = R + S * b, F = 0; F < e.outHeight; ++F) {
        for (var _ = F * o - d, O = _; O < 0;) O += s;

        for (var M = Math.min(e.inHeight, l + _), B = N + F * w, P = 0; P < e.outWidth; ++P) {
          for (var L = P * a - p, W = L; W < 0;) W += u;

          for (var U = Math.min(e.inWidth, h + L), V = B + P * C, z = v, G = 0, H = 0, q = D; q < T; q += i) {
            for (var K = I + q * t.strides[1], j = O; j < M; j += s) {
              for (var X = K + j * t.strides[2], Y = W; Y < U; Y += u) {
                var $ = m[X + Y * t.strides[3] + k];
                if ("max" === n && $ > z ? z = $ : "avg" === n && (G += $, H++), isNaN(z)) break;
              }

              if (isNaN(z)) break;
            }

            if (isNaN(z)) break;
          }

          y[V + k] = "avg" === n ? G / H : z;
        }
      }
    }

    return g.toTensor();
  }, o.prototype.avgPool3d = function (t, e) {
    return Hh(t, "avgPool3d"), this.pool3d(t, e, "avg").toFloat();
  }, o.prototype.avgPool3dBackprop = function (t, e, n) {
    Hh([t, e], "avgPool3dBackprop");

    for (var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = n.dilationDepth, l = n.dilationHeight, h = n.dilationWidth, f = n.effectiveFilterDepth, d = n.effectiveFilterHeight, p = n.effectiveFilterWidth, v = f - 1 - n.padInfo.front, m = p - 1 - n.padInfo.left, g = d - 1 - n.padInfo.top, y = dr(e.shape, "float32"), x = 1 / (i * s * u), b = this.bufferSync(t), w = 0; w < n.batchSize; ++w) for (var C = 0; C < n.inChannels; ++C) for (var E = 0; E < n.inDepth; ++E) for (var R = 0; R < n.inHeight; ++R) for (var I = 0; I < n.inWidth; ++I) {
      for (var k = E - v, S = R - g, A = I - m, D = 0, T = 0; T < f; T += c) {
        var N = (k + T) / r;
        if (!(N < 0 || N >= n.outDepth || Math.floor(N) !== N)) for (var F = 0; F < d; F += l) {
          var _ = (S + F) / o;

          if (!(_ < 0 || _ >= n.outHeight || Math.floor(_) !== _)) for (var O = 0; O < p; O += h) {
            var M = (A + O) / a;
            if (!(M < 0 || M >= n.outWidth || Math.floor(M) !== M)) D += b.get(w, N, _, M, C);
          }
        }
      }

      y.set(D * x, w, E, R, I, C);
    }

    return y.toTensor();
  }, o.prototype.maxPool3d = function (t, e) {
    return Hh(t, "maxPool3d"), this.pool3d(t, e, "max").toFloat();
  }, o.prototype.maxPool3dPositions = function (t, e) {
    for (var n = dr(e.outShape, "int32"), r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, d = e.padInfo.top, p = e.padInfo.left, v = this.bufferSync(t), m = 0; m < e.batchSize; ++m) for (var g = 0; g < e.inChannels; ++g) for (var y = 0; y < e.outDepth; ++y) {
      for (var x = y * r - f, b = x; b < 0;) b += i;

      for (var w = Math.min(e.inDepth, c + x), C = 0; C < e.outHeight; ++C) {
        for (var E = C * o - d, R = E; R < 0;) R += s;

        for (var I = Math.min(e.inHeight, l + E), k = 0; k < e.outWidth; ++k) {
          for (var S = k * a - p, A = S; A < 0;) A += u;

          for (var D = Math.min(e.inWidth, h + S), T = Number.NEGATIVE_INFINITY, N = -1, F = b; F < w; F += i) for (var _ = F - x, O = R; O < I; O += s) for (var M = O - E, B = A; B < D; B += u) {
            var P = B - S,
                L = v.get(m, F, O, B, g);
            L >= T && (T = L, N = _ * l * h + M * l + P);
          }

          n.set(N, m, y, C, k, g);
        }
      }
    }

    return n.toTensor();
  }, o.prototype.maxPool3dBackprop = function (t, e, n, r) {
    Hh([e, n], "maxPool3dBackprop");

    for (var o = this.maxPool3dPositions(e, r), a = r.strideDepth, i = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterDepth, f = r.effectiveFilterHeight, d = r.effectiveFilterWidth, p = h - 1 - r.padInfo.front, v = d - 1 - r.padInfo.left, m = f - 1 - r.padInfo.top, g = dr(e.shape, "float32"), y = this.bufferSync(o), x = this.bufferSync(t), b = 0; b < r.batchSize; ++b) for (var w = 0; w < r.inChannels; ++w) for (var C = 0; C < r.inDepth; ++C) for (var E = 0; E < r.inHeight; ++E) for (var R = 0; R < r.inWidth; ++R) {
      for (var I = C - p, k = E - m, S = R - v, A = 0, D = 0; D < h; D += u) {
        var T = (I + D) / a;
        if (!(T < 0 || T >= r.outDepth || Math.floor(T) !== T)) for (var N = 0; N < f; N += c) {
          var F = (k + N) / i;
          if (!(F < 0 || F >= r.outHeight || Math.floor(F) !== F)) for (var _ = 0; _ < d; _ += l) {
            var O = (S + _) / s;

            if (!(O < 0 || O >= r.outWidth || Math.floor(O) !== O)) {
              var M = h * f * d - 1 - y.get(b, T, F, O, w) === D * f * d + N * d + _ ? 1 : 0;
              if (0 !== M) A += x.get(b, T, F, O, w) * M;
            }
          }
        }
      }

      g.set(A, b, C, E, R, w);
    }

    return g.toTensor();
  }, o.prototype.cast = function (t, e) {
    return Po(t, e, this);
  }, o.prototype.reshape = function (t, e) {
    return Lo(t, e);
  }, o.prototype.avgPool = function (t, e) {
    return Hh(t, "avgPool"), this.pool(t, e, "avg").toFloat();
  }, o.prototype.resizeBilinear = function (t, e, n, r) {
    Hh(t, "resizeBilinear");

    for (var o = t.shape, a = o[0], i = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(k([a, e, n, u])), h = [r && e > 1 ? i - 1 : i, r && n > 1 ? s - 1 : s], f = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], d = 0, p = h[0] / f[0], v = h[1] / f[1], m = 0; m < a; m++) for (var g = 0; g < e; g++) for (var y = p * g, x = Math.floor(y), b = y - x, w = Math.min(i - 1, Math.ceil(y)), C = m * t.strides[0] + x * t.strides[1], E = m * t.strides[0] + w * t.strides[1], R = 0; R < n; R++) for (var I = v * R, S = Math.floor(I), A = I - S, D = Math.min(s - 1, Math.ceil(I)), T = C + S * t.strides[2], N = E + S * t.strides[2], F = C + D * t.strides[2], _ = E + D * t.strides[2], O = 0; O < u; O++) {
      var M = c[T + O],
          B = c[N + O],
          P = M + (c[F + O] - M) * A,
          L = P + (B + (c[_ + O] - B) * A - P) * b;
      l[d++] = L;
    }

    return Fn(l, [a, e, n, u]);
  }, o.prototype.resizeBilinearBackprop = function (t, e, n) {
    Hh([t, e], "resizeBilinearBackprop");

    for (var r = e.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * a * i * s), f = [n && c > 1 ? a - 1 : a, n && l > 1 ? i - 1 : i], d = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], p = f[0] / d[0], v = f[1] / d[1], m = this.readSync(t.dataId), g = 0, y = 0; y < o; y++) for (var x = y * e.strides[0], b = 0; b < c; b++) for (var w = b * p, C = Math.floor(w), E = Math.min(Math.ceil(w), a - 1), R = x + C * e.strides[1], I = x + E * e.strides[1], k = w - C, S = 1 - k, A = 0; A < l; A++) for (var D = A * v, T = Math.floor(D), N = Math.min(Math.ceil(D), i - 1), F = D - T, _ = 1 - F, O = R + T * e.strides[2], M = R + N * e.strides[2], B = I + T * e.strides[2], P = I + N * e.strides[2], L = S * _, W = S * F, U = k * _, V = k * F, z = 0; z < s; z++) {
      var G = m[g++];
      h[O + z] += G * L, h[M + z] += G * W, h[B + z] += G * U, h[P + z] += G * V;
    }

    return Ln(h, [o, i, a, s], e.dtype);
  }, o.prototype.resizeNearestNeighbor = function (t, e, n, r) {
    Hh(t, "resizeNearestNeighbor");

    for (var o = t.shape, a = o[0], i = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(a * e * n * u), h = [r && e > 1 ? i - 1 : i, r && n > 1 ? s - 1 : s], f = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], d = h[0] / f[0], p = h[1] / f[1], v = 0, m = 0; m < a; m++) for (var g = m * t.strides[0], y = 0; y < e; y++) for (var x = d * y, b = g + Math.min(i - 1, r ? Math.round(x) : Math.floor(x)) * t.strides[1], w = 0; w < n; w++) for (var C = p * w, E = b + Math.min(s - 1, r ? Math.round(C) : Math.floor(C)) * t.strides[2], R = 0; R < u; R++) {
      var I = c[E + R];
      l[v++] = I;
    }

    return Fn(l, [a, e, n, u], t.dtype);
  }, o.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
    Hh([t, e], "resizeNearestNeighborBackprop");

    for (var r = e.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * a * i * s), f = this.readSync(t.dataId), d = [n && c > 1 ? a - 1 : a, n && l > 1 ? i - 1 : i], p = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], v = d[0] / p[0], m = d[1] / p[1], g = 1 / v, y = 1 / m, x = 2 * Math.ceil(g) + 2, b = 2 * Math.ceil(y) + 2, w = 0; w < o; w++) for (var C = w * e.strides[0], E = 0; E < a; E++) for (var R = C + E * e.strides[1], I = Math.floor(E * g), k = Math.floor(I - x / 2), S = 0; S < i; S++) for (var A = R + S * e.strides[2], D = Math.floor(S * y), T = Math.floor(D - b / 2), N = 0; N < s; N++) {
      for (var F = 0, _ = 0; _ < x; _++) {
        var O = _ + k;

        if (!(O < 0 || O >= c)) {
          var M = C + O * t.strides[1],
              B = O * v;
          if (E === Math.min(a - 1, n ? Math.round(B) : Math.floor(B))) for (var P = 0; P < b; P++) {
            var L = P + T;

            if (!(L < 0 || L >= l)) {
              var W = M + L * t.strides[2],
                  U = L * m;
              S === Math.min(i - 1, n ? Math.round(U) : Math.floor(U)) && (F += f[W + N]);
            }
          }
        }
      }

      h[A + N] = F;
    }

    return Ln(h, e.shape, e.dtype);
  }, o.prototype.batchNormalization = function (t, e, n, r, o, a) {
    Hh([t, e, n, o, a], "batchNorm");

    for (var i = this.readSync(t.dataId), s = this.readSync(e.dataId), u = this.readSync(n.dataId), c = o ? this.readSync(o.dataId) : new Float32Array([1]), l = a ? this.readSync(a.dataId) : new Float32Array([0]), h = new Float32Array(i.length), f = l.length, d = c.length, p = u.length, v = s.length, m = 0, g = 0, y = 0, x = 0, b = 0; b < i.length; ++b) h[b] = l[m++] + (i[b] - s[g++]) * c[y++] / Math.sqrt(u[x++] + r), m >= f && (m = 0), g >= v && (g = 0), y >= d && (y = 0), x >= p && (x = 0);

    return Ln(h, t.shape);
  }, o.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
    Hh(t, "localResponseNormalization4D");
    var a = t.shape[3],
        i = a - 1,
        s = this.readSync(t.dataId),
        u = t.size,
        c = new Float32Array(u);

    function l(t) {
      for (var n = t % a, r = t - n + Math.max(0, n - e), o = t - n + Math.min(n + e, i), u = 0; r <= o; r++) {
        var c = s[r];
        u += c * c;
      }

      return u;
    }

    for (var h = 0; h < u; h++) {
      var f = l(h),
          d = s[h] * Math.pow(n + r * f, -o);
      c[h] = d;
    }

    return Ln(c, t.shape);
  }, o.prototype.LRNGrad = function (t, e, n, r, o, a, i) {
    Hh(t, "LRNGrad");

    for (var s = t.shape[3], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = this.readSync(n.dataId), h = new Float32Array(t.size), f = t.size, d = 0; d < f; d++) {
      for (var p = d % s, v = d - p + Math.max(0, p - r), m = d - p + Math.min(s, p + r + 1), g = 0, y = v; y < m; y++) g += Math.pow(c[y], 2);

      g = a * g + o;

      for (y = v; y < m; y++) {
        var x = -2 * a * i * c[y] * l[d] / g;
        d === y && (x += Math.pow(g, -i)), x *= u[d], h[y] += x;
      }
    }

    return Ln(h, t.shape);
  }, o.prototype.multinomial = function (t, e, n, r) {
    Hh(t, "multinomial");

    for (var o = e ? t : go(t), a = o.shape[0], i = o.shape[1], s = Gn([a, n], "int32"), u = this.readSync(s.dataId), c = this.readSync(o.dataId), l = 0; l < a; ++l) {
      var h = l * i,
          f = new Float32Array(i - 1);
      f[0] = c[h];

      for (var d = 1; d < f.length; ++d) f[d] = f[d - 1] + c[h + d];

      for (var p = cr(r.toString()), v = l * n, m = 0; m < n; ++m) {
        var g = p();
        u[v + m] = f.length;

        for (var y = 0; y < f.length; y++) if (g < f[y]) {
          u[v + m] = y;
          break;
        }
      }
    }

    return s;
  }, o.prototype.oneHot = function (t, e, n, r) {
    Hh(t, "oneHot");
    var o = new Float32Array(t.size * e);
    o.fill(r);

    for (var a = this.readSync(t.dataId), i = 0; i < t.size; ++i) a[i] >= 0 && a[i] < e && (o[i * e + a[i]] = n);

    return Bn(o, [t.size, e], "int32");
  }, o.prototype.nonMaxSuppression = function (t, e, n, r, o) {
    return Hh(t, "nonMaxSuppression"), jo(this.readSync(t.dataId), this.readSync(e.dataId), n, r, o);
  }, o.prototype.fft = function (t) {
    return this.fftBatch(t, !1);
  }, o.prototype.ifft = function (t) {
    return this.fftBatch(t, !0);
  }, o.prototype.fftBatch = function (t, e) {
    for (var n = t.shape[0], r = t.shape[1], o = dr(t.shape, "float32"), a = dr(t.shape, "float32"), i = Tn(t).as2D(n, r), s = Nn(t).as2D(n, r), u = 0; u < n; u++) for (var c = i.slice([u, 0], [1, r]), l = s.slice([u, 0], [1, r]), h = Dn(c, l), f = this.readSync(this.fftImpl(h, e).dataId), d = 0; d < r; d++) {
      var p = zo(f, d);
      o.values[u * r + d] = p.real, a.values[u * r + d] = p.imag;
    }

    return Dn(o.toTensor(), a.toTensor()).as2D(n, r);
  }, o.prototype.fftImpl = function (t, e) {
    var n = t.as1D(),
        r = n.size;

    if (this.isExponentOf2(r)) {
      var o = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);
      return e && (o = Dn(Tn(o).div(On(r)), Nn(o).div(On(r)))), o;
    }

    var a = this.readSync(t.dataId),
        i = function (t) {
      for (var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2) e[r / 2] = t[r], n[r / 2] = t[r + 1];

      return {
        real: e,
        imag: n
      };
    }(this.fourierTransformByMatmul(a, r, e));

    return Dn(i.real, i.imag).as2D(t.shape[0], t.shape[1]);
  }, o.prototype.isExponentOf2 = function (t) {
    return 0 == (t & t - 1);
  }, o.prototype.fftRadix2 = function (t, e, n) {
    if (1 === e) return t;

    var r = this.readSync(t.dataId),
        o = e / 2,
        a = function (t) {
      for (var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 0; o < t.length; o += 4) n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];

      return {
        real: n,
        imag: r
      };
    }(r),
        i = Dn(a.real, a.imag).as1D(),
        s = function (t) {
      for (var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 2; o < t.length; o += 4) n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];

      return {
        real: n,
        imag: r
      };
    }(r),
        u = Dn(s.real, s.imag).as1D();

    i = this.fftRadix2(i, o, n), u = this.fftRadix2(u, o, n);

    var c = function (t, e) {
      for (var n = new Float32Array(t / 2), r = new Float32Array(t / 2), o = 0; o < Math.ceil(t / 2); o++) {
        var a = (e ? 2 : -2) * Math.PI * (o / t);
        n[o] = Math.cos(a), r[o] = Math.sin(a);
      }

      return {
        real: n,
        imag: r
      };
    }(e, n),
        l = Dn(c.real, c.imag).mul(u),
        h = i.add(l),
        f = i.sub(l),
        d = Tn(h).concat(Tn(f)),
        p = Nn(h).concat(Nn(f));

    return Dn(d, p).as1D();
  }, o.prototype.fourierTransformByMatmul = function (t, e, n) {
    for (var r = new Float32Array(2 * e), o = 0; o < e; o++) {
      for (var a = 0, i = 0, s = 0; s < e; s++) {
        var u = Ho(o * s, e, n),
            c = zo(t, s);
        a += c.real * u.real - c.imag * u.imag, i += c.real * u.imag + c.imag * u.real;
      }

      n && (a /= e, i /= e), Go(r, a, i, o);
    }

    return r;
  }, o.prototype.depthToSpace = function (t, e, n) {
    C("NHWC" === n, function () {
      return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n;
    }), C(e > 1, function () {
      return "blockSize should be > 1 for depthToSpace, but was: " + e;
    });

    for (var r = t.shape[0], o = t.shape[1], a = t.shape[2], i = t.shape[3], s = o * e, u = a * e, c = i / (e * e), l = this.readSync(t.dataId), h = new Float32Array(r * s * u * c), f = 0, d = 0; d < r; ++d) for (var p = 0; p < s; ++p) for (var v = Math.floor(p / e), m = p % e, g = 0; g < u; ++g) for (var y = Math.floor(g / e), x = (m * e + g % e) * c, b = 0; b < c; ++b) {
      var w = b + x + i * (y + a * (v + o * d));
      h[f++] = l[w];
    }

    return Ln(h, [r, s, u, c]);
  }, o.prototype.broadcastedBinaryOp = function (t, e, n, r) {
    var o = Ro(t.shape, e.shape),
        a = dr(o, n),
        i = this.readSync(t.dataId),
        s = this.readSync(e.dataId),
        u = Co(t.shape, o),
        c = Co(e.shape, o),
        l = a.values;
    if (u.length + c.length === 0) for (var h = 0; h < l.length; ++h) l[h] = r(i[h % i.length], s[h % s.length]);else {
      var f = this.bufferSync(t),
          d = this.bufferSync(e),
          p = function (n) {
        var o = a.indexToLoc(n),
            h = o.slice(-t.rank);
        u.forEach(function (t) {
          return h[t] = 0;
        });
        var p = f.locToIndex(h),
            v = o.slice(-e.rank);
        c.forEach(function (t) {
          return v[t] = 0;
        });
        var m = d.locToIndex(v);
        l[n] = r(i[p], s[m]);
      };

      for (h = 0; h < l.length; ++h) p(h);
    }
    return a.toTensor();
  }, o.prototype.broadcastedBinaryComplexOp = function (t, e, n) {
    var r = Ro(t.shape, e.shape),
        o = dr(r, "float32"),
        a = dr(r, "float32"),
        i = this.readSync(t.dataId),
        s = this.readSync(e.dataId),
        u = Co(t.shape, r),
        c = Co(e.shape, r),
        l = o.values,
        h = a.values;
    if (u.length + c.length === 0) for (var f = 0; f < l.length; f++) {
      var d = f % i.length,
          p = f % s.length,
          v = n(i[2 * d], i[2 * d + 1], s[2 * p], s[2 * p + 1]);
      l[f] = v.real, h[f] = v.imag;
    } else {
      var m = this.bufferSync(this.data.get(t.dataId).complexTensors.real),
          g = this.bufferSync(this.data.get(e.dataId).complexTensors.real),
          y = function (r) {
        var a = o.indexToLoc(r),
            f = a.slice(-t.rank);
        u.forEach(function (t) {
          return f[t] = 0;
        });
        var d = m.locToIndex(f),
            p = a.slice(-e.rank);
        c.forEach(function (t) {
          return p[t] = 0;
        });
        var v = g.locToIndex(p),
            y = n(i[2 * d], i[2 * d + 1], s[2 * v], s[2 * v + 1]);
        l[r] = y.real, h[r] = y.imag;
      };

      for (f = 0; f < l.length; f++) y(f);
    }
    return this.complex(o.toTensor(), a.toTensor());
  }, o.prototype.split = function (t, e, n) {
    return Zo(t, e, n);
  }, o.prototype.dispose = function () {}, o.prototype.floatPrecision = function () {
    return 32;
  }, o.prototype.epsilon = function () {
    return 1e-7;
  }, o.prototype.cropAndResize = function (t, e, n, r, o, a) {
    for (var i = t.shape, s = i[0], u = i[1], c = i[2], l = i[3], h = e.shape[0], f = r[0], d = r[1], p = dr([h, f, d, l], "float32"), v = this.readSync(e.dataId), m = this.readSync(n.dataId), g = this.readSync(t.dataId), y = t.strides, x = p.strides, b = 0; b < h; b++) {
      var w = 4 * b,
          C = v[w],
          E = v[w + 1],
          R = v[w + 2],
          I = v[w + 3],
          k = m[b];
      if (!(k >= s)) for (var S = f > 1 ? (R - C) * (u - 1) / (f - 1) : 0, A = d > 1 ? (I - E) * (c - 1) / (d - 1) : 0, D = 0; D < f; D++) {
        var T = f > 1 ? C * (u - 1) + D * S : .5 * (C + R) * (u - 1);
        if (T < 0 || T > u - 1) for (var N = 0; N < d; N++) for (var F = 0; F < l; F++) {
          var _ = F + N * x[2] + D * x[1] + b * x[0];

          p.values[_] = a;
        } else if ("bilinear" === o) {
          var O = Math.floor(T),
              M = Math.ceil(T),
              B = T - O;

          for (N = 0; N < d; N++) {
            if ((q = d > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for (F = 0; F < l; F++) {
              _ = F + N * x[2] + D * x[1] + b * x[0];
              p.values[_] = a;
            } else {
              var P = Math.floor(q),
                  L = Math.ceil(q),
                  W = q - P;

              for (F = 0; F < l; F++) {
                var U = g[_ = F + P * y[2] + O * y[1] + k * y[0]],
                    V = g[_ = F + L * y[2] + O * y[1] + k * y[0]],
                    z = g[_ = F + P * y[2] + M * y[1] + k * y[0]],
                    G = U + (V - U) * W,
                    H = z + (g[_ = F + L * y[2] + M * y[1] + k * y[0]] - z) * W;
                _ = F + N * x[2] + D * x[1] + b * x[0], p.values[_] = G + (H - G) * B;
              }
            }
          }
        } else for (N = 0; N < d; ++N) {
          var q;
          if ((q = d > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for (F = 0; F < l; F++) {
            _ = F + N * x[2] + D * x[1] + b * x[0];
            p.values[_] = a;
          } else {
            var K = Math.round(q),
                j = Math.round(T);

            for (F = 0; F < l; F++) {
              var X = F + K * y[2] + j * y[1] + k * y[0],
                  Y = F + N * x[2] + D * x[1] + b * x[0];
              p.values[Y] = g[X];
            }
          }
        }
      }
    }

    return p.toTensor();
  }, o.prototype.sparseToDense = function (t, e, n, r) {
    var o = Zr(0, t, n),
        a = o.sliceRank,
        i = o.numUpdates,
        s = o.sliceSize,
        u = o.strides,
        c = o.outputSize;
    return this.scatter(t, e, n, c, s, i, a, u, r, !1);
  }, o.prototype.gatherND = function (t, e) {
    var n = e.shape,
        r = n[n.length - 1],
        o = jr(t, e),
        a = o[0],
        i = o[1],
        s = o[2],
        u = o[3];
    if (0 === i) return Fn([], a, t.dtype);

    for (var c = new gt([i, s], t.dtype), l = this.readSync(e.dataId), h = this.readSync(t.dataId), f = 0; f < i; f++) {
      for (var d = [], p = 0, v = 0; v < r; v++) {
        var m = l[f * r + v];
        p += m * u[v], d.push(m);
      }

      if (p < 0 || p >= t.size / s) throw new Error("Invalid indices: " + d + " does not index into " + t.shape);

      for (var g = 0; g < s; g++) c.values[f * s + g] = h[p * s + g];
    }

    return c.toTensor().reshape(a);
  }, o.prototype.scatterND = function (t, e, n) {
    var r = Zr(0, t, n),
        o = r.sliceRank,
        a = r.numUpdates,
        i = r.sliceSize,
        s = r.strides,
        u = r.outputSize,
        c = On(0);
    return this.scatter(t, e, n, u, i, a, o, s, c, !0);
  }, o.prototype.fill = function (t, e, n) {
    var r = P(n = n || j(e), k(t));
    return r.fill(e), Lt.makeTensor(r, t, n, this);
  }, o.prototype.onesLike = function (t) {
    if ("string" === t.dtype) throw new Error("onesLike is not supported for string tensors");
    return this.fill(t.shape, 1, t.dtype);
  }, o.prototype.zerosLike = function (t) {
    var e = P(t.dtype, k(t.shape));
    return this.makeOutput(e, t.shape, t.dtype);
  }, o.prototype.linspace = function (t, e, n) {
    return Wo(t, e, n);
  }, o.prototype.scatter = function (t, e, n, r, o, a, i, s, u, c) {
    var l = [r / o, o],
        h = this.readSync(t.dataId),
        f = this.readSync(e.dataId);
    if (0 === r) return Fn([], n, e.dtype);
    var d = new gt(l, e.dtype);
    d.values.fill(this.readSync(u.dataId)[0]);

    for (var p = 0; p < a; p++) {
      for (var v = [], m = 0, g = 0; g < i; g++) {
        var y = h[p * i + g];
        v.push(y), m += y * s[g];
      }

      if (m < 0 || m >= r / o) throw new Error("Invalid indices: " + v + " does not index into " + n);

      for (var x = 0; x < o; x++) c ? d.values[m * o + x] += f[p * o + x] : d.values[m * o + x] = 0 === e.rank ? f[0] : f[p * o + x];
    }

    return d.toTensor().reshape(n);
  }, o;
}(bo);

Lt.registerBackend("cpu", function () {
  return new Kh();
}, 1);

for (var jh = 0, Xh = [{
  kernelName: "NonMaxSuppressionV5",
  backendName: "cpu",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = t.attrs,
        o = e,
        a = o.boxes,
        i = o.scores,
        s = r,
        u = s.maxOutputSize,
        c = s.iouThreshold,
        l = s.scoreThreshold,
        h = s.softNmsSigma,
        f = n;
    Hh(a, "NonMaxSuppressionWithScore");
    var d = Xo(f.data.get(a.dataId).values, f.data.get(i.dataId).values, u, c, l, h);
    return [d.selectedIndices, d.selectedScores];
  }
}, {
  kernelName: "Square",
  backendName: "cpu",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e.x,
        o = n;
    Hh(r, "square");

    for (var a = o.data.get(r.dataId).values, i = new Float32Array(a.length), s = 0; s < a.length; ++s) {
      var u = a[s];
      i[s] = u * u;
    }

    return {
      dataId: o.write(i, r.shape, r.dtype),
      shape: r.shape,
      dtype: r.dtype
    };
  }
}, {
  kernelName: eu,
  backendName: "cpu",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e,
        o = r.a,
        a = r.b,
        i = n;
    Hh([o, a], eu);

    var s = i.data.get(o.dataId).values,
        u = i.data.get(a.dataId).values,
        c = function (t, e, n, r, o, a) {
      var i = Ro(t, e),
          s = i.length,
          u = $(i),
          c = B(o, k(i)),
          l = t.length,
          h = e.length,
          f = $(t),
          d = $(e),
          p = Co(t, i),
          v = Co(e, i);
      if (p.length + v.length === 0) for (var m = 0; m < c.length; ++m) c[m] = a(n[m % n.length], r[m % r.length]);else {
        var g = function (t) {
          var e = it(t, s, u),
              o = e.slice(-l);
          p.forEach(function (t) {
            return o[t] = 0;
          });
          var i = at(o, l, f),
              m = e.slice(-h);
          v.forEach(function (t) {
            return m[t] = 0;
          });
          var g = at(m, h, d);
          c[t] = a(n[i], r[g]);
        };

        for (m = 0; m < c.length; ++m) g(m);
      }
      return [c, i];
    }(o.shape, a.shape, s, u, o.dtype, function (t, e) {
      var n = t - e;
      return n * n;
    }),
        l = c[0],
        h = c[1];

    return {
      dataId: i.write(l, h, o.dtype),
      shape: h,
      dtype: o.dtype
    };
  }
}]; jh < Xh.length; jh++) {
  d(Xh[jh]);
}

var Yh,
    $h = function (t) {
  this.variableNames = ["A"];
  var e = ua(),
      n = t[0],
      r = t[1];
  this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r + ".0, " + n + ".0);\n\n        vec4 values = " + e.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
},
    Qh = function (t) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
  var e = ua(),
      n = t[0],
      r = t[1];
  this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r + ".0, " + n + ".0);\n            vec4 values = " + e.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e.output + " = result;\n      }\n    ";
};

for (var Jh = 0, Zh = [{
  kernelName: "FromPixels",
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = t.attrs,
        o = e.pixels,
        a = r.numChannels,
        s = "undefined" != typeof HTMLVideoElement && o instanceof HTMLVideoElement,
        u = "undefined" != typeof HTMLImageElement && o instanceof HTMLImageElement,
        c = s ? [o.videoWidth, o.videoHeight] : [o.width, o.height],
        l = c[0],
        h = c[1],
        f = [h, l],
        d = [h, l, a];
    (u || s) && (null == Yh && (Yh = document.createElement("canvas").getContext("2d")), Yh.canvas.width = l, Yh.canvas.height = h, Yh.drawImage(o, 0, 0, l, h), o = Yh.canvas);
    var p = n.makeTensorInfo(f, "int32");
    n.texData.get(p.dataId).usage = zt.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId), o);
    var v = i().getBool("WEBGL_PACK") ? new Qh(d) : new $h(d),
        m = n.runWebGLProgram(v, [p], "int32");
    return n.disposeData(p.dataId), m;
  }
}, {
  kernelName: "NonMaxSuppressionV5",
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = t.attrs;
    dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    var o = e,
        a = o.boxes,
        i = o.scores,
        s = r,
        u = s.maxOutputSize,
        c = s.iouThreshold,
        l = s.scoreThreshold,
        h = s.softNmsSigma,
        f = n,
        d = Xo(f.readSync(a.dataId), f.readSync(i.dataId), u, c, l, h);
    return [d.selectedIndices, d.selectedScores];
  }
}, {
  kernelName: "Square",
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e.x,
        o = n,
        a = new Cs(r.shape, "return x * x;");
    return o.runWebGLProgram(a, [r], r.dtype);
  }
}, {
  kernelName: eu,
  backendName: "webgl",
  kernelFunc: function (t) {
    var e = t.inputs,
        n = t.backend,
        r = e,
        o = r.a,
        a = r.b,
        s = n,
        u = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("return (a - b) * (a - b);", o.shape, a.shape) : new Ba("return (a - b) * (a - b);", o.shape, a.shape);
    return s.compileAndRun(u, [o, a]);
  }
}]; Jh < Zh.length; Jh++) {
  d(Zh[Jh]);
}

for (var tf = 0, ef = [{
  kernelName: "Square",
  gradFunc: function (t, e) {
    var n = e[0];
    return {
      x: function () {
        return t.mul(n.toFloat().mul(2));
      }
    };
  }
}, {
  kernelName: eu,
  gradFunc: function (t, e) {
    var n = e[0],
        r = e[1],
        o = On(2);
    return {
      a: function () {
        return gc(t, gc(o, Cc(n, r)));
      },
      b: function () {
        return gc(t, gc(o, Cc(r, n)));
      }
    };
  }
}]; tf < ef.length; tf++) {
  p(ef[tf]);
}

var nf = function () {
  function t() {}

  return t.prototype.fetch = function (t, e) {
    return fetch(t, e);
  }, t.prototype.now = function () {
    return performance.now();
  }, t.prototype.encode = function (t, e) {
    if ("utf-8" !== e && "utf8" !== e) throw new Error("Browser's encoder only supports utf-8, but got " + e);
    return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t);
  }, t.prototype.decode = function (t, e) {
    return new TextDecoder(e).decode(t);
  }, t;
}();

i().get("IS_BROWSER") && i().setPlatform("browser", new nf());

var rf,
    of = function () {
  return require("node-fetch");
},
    af = function () {
  function t() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }

  return t.prototype.fetch = function (t, e) {
    return null != i().global.fetch ? i().global.fetch(t, e) : (null == rf && (rf = of()), rf(t, e));
  }, t.prototype.now = function () {
    var t = process.hrtime();
    return 1e3 * t[0] + t[1] / 1e6;
  }, t.prototype.encode = function (t, e) {
    if ("utf-8" !== e && "utf8" !== e) throw new Error("Node built-in encoder only supports utf-8, but got " + e);
    return this.textEncoder.encode(t);
  }, t.prototype.decode = function (t, e) {
    return 0 === t.length ? "" : new this.util.TextDecoder(e).decode(t);
  }, t;
}();

i().get("IS_NODE") && i().setPlatform("node", new af());
var sf = {
  float32: 4,
  int32: 4,
  uint16: 2,
  uint8: 1,
  bool: 1
},
    uf = 4;

function cf(t, e) {
  for (var n = {}, r = 0, o = function (e) {
    var o = e.name,
        a = e.dtype,
        i = e.shape,
        s = k(i),
        u = void 0;

    if (("quantization" in e)) {
      var c = e.quantization;
      if ("uint8" !== c.dtype && "uint16" !== c.dtype) throw new Error("Weight " + e.name + " has unknown quantization dtype " + c.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
      var l = sf[c.dtype],
          h = t.slice(r, r + s * l),
          f = "uint8" === c.dtype ? new Uint8Array(h) : new Uint16Array(h);
      if ("float32" === a) u = Float32Array.from(f, function (t) {
        return t * c.scale + c.min;
      });else {
        if ("int32" !== a) throw new Error("Unsupported dtype in weight '" + o + "': " + a);
        u = Int32Array.from(f, function (t) {
          return Math.round(t * c.scale + c.min);
        });
      }
      r += s * l;
    } else if ("string" === a) {
      var d = k(e.shape);
      u = [];

      for (var p = 0; p < d; p++) {
        var v = new Uint32Array(t.slice(r, r + uf))[0];
        r += uf;
        var m = new Uint8Array(t.slice(r, r + v));
        u.push(m), r += v;
      }
    } else {
      var g = sf[a];
      h = t.slice(r, r + s * g);
      if ("float32" === a) u = new Float32Array(h);else if ("int32" === a) u = new Int32Array(h);else {
        if ("bool" !== a) throw new Error("Unsupported dtype in weight '" + o + "': " + a);
        u = new Uint8Array(h);
      }
      r += s * g;
    }

    n[o] = Fn(u, i, a);
  }, a = 0, i = e; a < i.length; a++) {
    o(i[a]);
  }

  return n;
}

function lf(t) {
  if (null === t) throw new Error("Invalid input value: " + JSON.stringify(t));
  var e = 0,
      n = [];
  t.forEach(function (t) {
    if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + t.constructor.name);
  });
  var r = new Uint8Array(e),
      o = 0;
  return n.forEach(function (t) {
    r.set(new Uint8Array(t.buffer), o), o += t.byteLength;
  }), r.buffer;
}

var hf = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

function ff(t) {
  return hf ? Buffer.byteLength(t) : new Blob([t]).size;
}

function df(t) {
  var e = 0;
  t.forEach(function (t) {
    e += t.byteLength;
  });
  var n = new Uint8Array(e),
      r = 0;
  return t.forEach(function (t) {
    n.set(new Uint8Array(t), r), r += t.byteLength;
  }), n.buffer;
}

function pf(t) {
  for (t = t.trim(); t.endsWith("/");) t = t.slice(0, t.length - 1);

  var e = t.split("/");
  return e[e.length - 1];
}

function vf(t) {
  if (t.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {
    dateSaved: new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: null == t.modelTopology ? 0 : ff(JSON.stringify(t.modelTopology)),
    weightSpecsBytes: null == t.weightSpecs ? 0 : ff(JSON.stringify(t.weightSpecs)),
    weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength
  };
}

var mf = function () {
  function t() {
    this.saveRouters = [], this.loadRouters = [];
  }

  return t.getInstance = function () {
    return null == t.instance && (t.instance = new t()), t.instance;
  }, t.registerSaveRouter = function (e) {
    t.getInstance().saveRouters.push(e);
  }, t.registerLoadRouter = function (e) {
    t.getInstance().loadRouters.push(e);
  }, t.getSaveHandlers = function (e) {
    return t.getHandlers(e, "save");
  }, t.getLoadHandlers = function (e, n) {
    return t.getHandlers(e, "load", n);
  }, t.getHandlers = function (e, n, r) {
    var o = [];
    return ("load" === n ? t.getInstance().loadRouters : t.getInstance().saveRouters).forEach(function (t) {
      var n = t(e, r);
      null !== n && o.push(n);
    }), o;
  }, t;
}(),
    gf = "://",
    yf = function () {
  function t() {
    this.managers = {};
  }

  return t.getInstance = function () {
    return null == t.instance && (t.instance = new t()), t.instance;
  }, t.registerManager = function (e, n) {
    C(null != e, function () {
      return "scheme must not be undefined or null.";
    }), e.endsWith(gf) && (e = e.slice(0, e.indexOf(gf))), C(e.length > 0, function () {
      return "scheme must not be an empty string.";
    });
    var r = t.getInstance();
    C(null == r.managers[e], function () {
      return "A model store manager is already registered for scheme '" + e + "'.";
    }), r.managers[e] = n;
  }, t.getManager = function (t) {
    var e = this.getInstance().managers[t];
    if (null == e) throw new Error("Cannot find model manager for scheme '" + t + "'");
    return e;
  }, t.getSchemes = function () {
    return Object.keys(this.getInstance().managers);
  }, t;
}();

function xf(t) {
  if (-1 === t.indexOf(gf)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + yf.getSchemes().join(","));
  return {
    scheme: t.split(gf)[0],
    path: t.split(gf)[1]
  };
}

function bf(t, e, o) {
  return void 0 === o && (o = !1), n(this, void 0, void 0, function () {
    var n, a, i, s, u, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return C(t !== e, function () {
            return "Old path and new path are the same: '" + t + "'";
          }), C((n = mf.getLoadHandlers(t)).length > 0, function () {
            return "Copying failed because no load handler is found for source URL " + t + ".";
          }), C(n.length < 2, function () {
            return "Copying failed because more than one (" + n.length + ") load handlers for source URL " + t + ".";
          }), a = n[0], C((i = mf.getSaveHandlers(e)).length > 0, function () {
            return "Copying failed because no save handler is found for destination URL " + e + ".";
          }), C(i.length < 2, function () {
            return "Copying failed because more than one (" + n.length + ") save handlers for destination URL " + e + ".";
          }), s = i[0], u = xf(t).scheme, c = xf(t).path, l = u === xf(t).scheme, [4, a.load()];

        case 1:
          return h = r.sent(), o && l ? [4, yf.getManager(u).removeModel(c)] : [3, 3];

        case 2:
          r.sent(), r.label = 3;

        case 3:
          return [4, s.save(h)];

        case 4:
          return f = r.sent(), !o || l ? [3, 6] : [4, yf.getManager(u).removeModel(c)];

        case 5:
          r.sent(), r.label = 6;

        case 6:
          return [2, f.modelArtifactsInfo];
      }
    });
  });
}

var wf = "models_store",
    Cf = "model_info_store";

function Ef() {
  if (!i().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var t = window || self,
      e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;
  if (null == e) throw new Error("The current browser does not appear to support IndexedDB.");
  return e;
}

function Rf(t) {
  var e = t.result;
  e.createObjectStore(wf, {
    keyPath: "modelPath"
  }), e.createObjectStore(Cf, {
    keyPath: "modelPath"
  });
}

var If = function () {
  function t(t) {
    if (this.indexedDB = Ef(), null == t || !t) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = t;
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        return [2, this.databaseAction(this.modelPath, t)];
      });
    });
  }, t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        return [2, this.databaseAction(this.modelPath)];
      });
    });
  }, t.prototype.databaseAction = function (t, e) {
    var n = this;
    return new Promise(function (t, r) {
      var o = n.indexedDB.open("tensorflowjs", 1);
      o.onupgradeneeded = function () {
        return Rf(o);
      }, o.onsuccess = function () {
        var a = o.result;

        if (null == e) {
          var i = a.transaction(wf, "readonly"),
              s = i.objectStore(wf).get(n.modelPath);
          s.onsuccess = function () {
            if (null == s.result) return a.close(), r(new Error("Cannot find model with path '" + n.modelPath + "' in IndexedDB."));
            t(s.result.modelArtifacts);
          }, s.onerror = function (t) {
            return a.close(), r(s.error);
          }, i.oncomplete = function () {
            return a.close();
          };
        } else {
          var u,
              c = vf(e),
              l = a.transaction(Cf, "readwrite"),
              h = l.objectStore(Cf),
              f = h.put({
            modelPath: n.modelPath,
            modelArtifactsInfo: c
          });
          f.onsuccess = function () {
            var o = (u = a.transaction(wf, "readwrite")).objectStore(wf).put({
              modelPath: n.modelPath,
              modelArtifacts: e,
              modelArtifactsInfo: c
            });
            o.onsuccess = function () {
              return t({
                modelArtifactsInfo: c
              });
            }, o.onerror = function (t) {
              var e = (h = l.objectStore(Cf)).delete(n.modelPath);
              e.onsuccess = function () {
                return a.close(), r(o.error);
              }, e.onerror = function (t) {
                return a.close(), r(o.error);
              };
            };
          }, f.onerror = function (t) {
            return a.close(), r(f.error);
          }, l.oncomplete = function () {
            null == u ? a.close() : u.oncomplete = function () {
              return a.close();
            };
          };
        }
      }, o.onerror = function (t) {
        return r(o.error);
      };
    });
  }, t.URL_SCHEME = "indexeddb://", t;
}(),
    kf = function (t) {
  return i().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(If.URL_SCHEME) ? (e = t.slice(If.URL_SCHEME.length), new If(e)) : null;
  var e;
};

mf.registerSaveRouter(kf), mf.registerLoadRouter(kf);

var Sf = function () {
  function t() {
    this.indexedDB = Ef();
  }

  return t.prototype.listModels = function () {
    return n(this, void 0, void 0, function () {
      var t = this;
      return r(this, function (e) {
        return [2, new Promise(function (e, n) {
          var r = t.indexedDB.open("tensorflowjs", 1);
          r.onupgradeneeded = function () {
            return Rf(r);
          }, r.onsuccess = function () {
            var t = r.result,
                o = t.transaction(Cf, "readonly"),
                a = o.objectStore(Cf).getAll();
            a.onsuccess = function () {
              for (var t = {}, n = 0, r = a.result; n < r.length; n++) {
                var o = r[n];
                t[o.modelPath] = o.modelArtifactsInfo;
              }

              e(t);
            }, a.onerror = function (e) {
              return t.close(), n(a.error);
            }, o.oncomplete = function () {
              return t.close();
            };
          }, r.onerror = function (t) {
            return n(r.error);
          };
        })];
      });
    });
  }, t.prototype.removeModel = function (t) {
    return n(this, void 0, void 0, function () {
      var e = this;
      return r(this, function (n) {
        var r;
        return t = (r = t).startsWith(If.URL_SCHEME) ? r.slice(If.URL_SCHEME.length) : r, [2, new Promise(function (n, r) {
          var o = e.indexedDB.open("tensorflowjs", 1);
          o.onupgradeneeded = function () {
            return Rf(o);
          }, o.onsuccess = function () {
            var e,
                a = o.result,
                i = a.transaction(Cf, "readwrite"),
                s = i.objectStore(Cf),
                u = s.get(t);
            u.onsuccess = function () {
              if (null == u.result) return a.close(), r(new Error("Cannot find model with path '" + t + "' in IndexedDB."));

              var o = s.delete(t),
                  i = function () {
                var o = (e = a.transaction(wf, "readwrite")).objectStore(wf).delete(t);
                o.onsuccess = function () {
                  return n(u.result.modelArtifactsInfo);
                }, o.onerror = function (t) {
                  return r(u.error);
                };
              };

              o.onsuccess = i, o.onerror = function (t) {
                return i(), a.close(), r(u.error);
              };
            }, u.onerror = function (t) {
              return a.close(), r(u.error);
            }, i.oncomplete = function () {
              null == e ? a.close() : e.oncomplete = function () {
                return a.close();
              };
            };
          }, o.onerror = function (t) {
            return r(o.error);
          };
        })];
      });
    });
  }, t;
}();

if (i().getBool("IS_BROWSER")) try {
  yf.registerManager(If.URL_SCHEME, new Sf());
} catch (t) {}
var Af = "/",
    Df = "tensorflowjs_models",
    Tf = "info",
    Nf = "model_topology",
    Ff = "weight_specs",
    _f = "weight_data",
    Of = "model_metadata";

function Mf(t) {
  return {
    info: [Df, t, Tf].join(Af),
    topology: [Df, t, Nf].join(Af),
    weightSpecs: [Df, t, Ff].join(Af),
    weightData: [Df, t, _f].join(Af),
    modelMetadata: [Df, t, Of].join(Af)
  };
}

function Bf(t) {
  var e = t.split(Af);
  if (e.length < 3) throw new Error("Invalid key format: " + t);
  return e.slice(1, e.length - 1).join(Af);
}

var Pf = function () {
  function t(t) {
    if (!i().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, null == t || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = t, this.keys = Mf(this.modelPath);
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o;
      return r(this, function (r) {
        if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        e = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), o = vf(t);

        try {
          return this.LS.setItem(this.keys.info, JSON.stringify(o)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, function (t) {
            if (hf) return Buffer.from(t).toString("base64");

            for (var e = new Uint8Array(t), n = "", r = 0, o = e.length; r < o; r++) n += String.fromCharCode(e[r]);

            return btoa(n);
          }(t.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
            format: t.format,
            generatedBy: t.generatedBy,
            convertedBy: t.convertedBy,
            userDefinedMetadata: t.userDefinedMetadata
          })), [2, {
            modelArtifactsInfo: o
          }];
        } catch (t) {
          throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o.modelTopologyBytes + ", weightSpecsBytes=" + o.weightSpecsBytes + ", weightDataBytes=" + o.weightDataBytes + ".");
        }

        return [2];
      });
    });
  }, t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i, s;
      return r(this, function (r) {
        if (null == (t = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
        if ("JSON" !== t.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        if (e = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
        if (e.modelTopology = n, null == (o = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
        if (e.weightSpecs = o, null != (a = this.LS.getItem(this.keys.modelMetadata)) && (i = JSON.parse(a), e.format = i.format, e.generatedBy = i.generatedBy, e.convertedBy = i.convertedBy, e.userDefinedMetadata = i.userDefinedMetadata), null == (s = this.LS.getItem(this.keys.weightData))) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
        return e.weightData = function (t) {
          if (hf) {
            var e = Buffer.from(t, "base64");
            return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
          }

          for (var n = atob(t), r = new Uint8Array(n.length), o = 0; o < n.length; ++o) r.set([n.charCodeAt(o)], o);

          return r.buffer;
        }(s), [2, e];
      });
    });
  }, t.URL_SCHEME = "localstorage://", t;
}(),
    Lf = function (t) {
  return i().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Pf.URL_SCHEME) ? (e = t.slice(Pf.URL_SCHEME.length), new Pf(e)) : null;
  var e;
};

mf.registerSaveRouter(Lf), mf.registerLoadRouter(Lf);

var Wf = function () {
  function t() {
    C(i().getBool("IS_BROWSER"), function () {
      return "Current environment is not a web browser";
    }), C("undefined" == typeof window || void 0 !== window.localStorage, function () {
      return "Current browser does not appear to support localStorage";
    }), this.LS = window.localStorage;
  }

  return t.prototype.listModels = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i;
      return r(this, function (r) {
        for (t = {}, e = Df + Af, n = Af + Tf, o = 0; o < this.LS.length; ++o) (a = this.LS.key(o)).startsWith(e) && a.endsWith(n) && (i = Bf(a), t[i] = JSON.parse(this.LS.getItem(a)));

        return [2, t];
      });
    });
  }, t.prototype.removeModel = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n;
      return r(this, function (r) {
        var o;
        if (t = (o = t).startsWith(Pf.URL_SCHEME) ? o.slice(Pf.URL_SCHEME.length) : o, e = Mf(t), null == this.LS.getItem(e.info)) throw new Error("Cannot find model at path '" + t + "'");
        return n = JSON.parse(this.LS.getItem(e.info)), this.LS.removeItem(e.info), this.LS.removeItem(e.topology), this.LS.removeItem(e.weightSpecs), this.LS.removeItem(e.weightData), [2, n];
      });
    });
  }, t;
}();

if (i().getBool("IS_BROWSER")) try {
  yf.registerManager(Pf.URL_SCHEME, new Wf());
} catch (t) {}
var Uf = "model",
    Vf = ".json",
    zf = ".weights.bin";

function Gf(t) {
  return new Promise(function (t) {
    return setTimeout(t);
  }).then(t);
}

var Hf = function () {
  function t(e) {
    if (!i().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)), null != e && 0 !== e.length || (e = Uf), this.modelTopologyFileName = e + Vf, this.weightDataFileName = e + zf;
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, i, s;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
            if (e = window.URL.createObjectURL(new Blob([t.weightData], {
              type: "application/octet-stream"
            })), !(t.modelTopology instanceof ArrayBuffer)) return [3, 1];
            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");

          case 1:
            return n = [{
              paths: ["./" + this.weightDataFileName],
              weights: t.weightSpecs
            }], o = {
              modelTopology: t.modelTopology,
              format: t.format,
              generatedBy: t.generatedBy,
              convertedBy: t.convertedBy,
              weightsManifest: n
            }, a = window.URL.createObjectURL(new Blob([JSON.stringify(o)], {
              type: "application/json"
            })), (i = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i.href = a, [4, Gf(function () {
              return i.dispatchEvent(new MouseEvent("click"));
            })];

          case 2:
            return r.sent(), null == t.weightData ? [3, 4] : ((s = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, s.href = e, [4, Gf(function () {
              return s.dispatchEvent(new MouseEvent("click"));
            })]);

          case 3:
            r.sent(), r.label = 4;

          case 4:
            return [2, {
              modelArtifactsInfo: vf(t)
            }];
        }
      });
    });
  }, t.URL_SCHEME = "downloads://", t;
}(),
    qf = function () {
  function t(t) {
    if (null == t || t.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + t);
    this.files = t;
  }

  return t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      var t,
          e,
          n = this;
      return r(this, function (r) {
        return t = this.files[0], e = this.files.slice(1), [2, new Promise(function (r, o) {
          var a = new FileReader();
          a.onload = function (a) {
            var i = JSON.parse(a.target.result),
                s = i.modelTopology;

            if (null != s) {
              0 === e.length && r({
                modelTopology: s
              });
              var u = i.weightsManifest;

              if (null != u) {
                var c;

                try {
                  c = n.checkManifestAndWeightFiles(u, e);
                } catch (t) {
                  return void o(t);
                }

                var l = [],
                    h = [],
                    f = [];
                u.forEach(function (t) {
                  t.paths.forEach(function (t) {
                    h.push(t), f.push(null);
                  }), l.push.apply(l, t.weights);
                }), u.forEach(function (t) {
                  t.paths.forEach(function (t) {
                    var e = new FileReader();
                    e.onload = function (e) {
                      var n = e.target.result,
                          o = h.indexOf(t);
                      f[o] = n, -1 === f.indexOf(null) && r({
                        modelTopology: s,
                        weightSpecs: l,
                        weightData: df(f),
                        format: i.format,
                        generatedBy: i.generatedBy,
                        convertedBy: i.convertedBy,
                        userDefinedMetadata: i.userDefinedMetadata
                      });
                    }, e.onerror = function (e) {
                      return o("Failed to weights data from file of path '" + t + "'.");
                    }, e.readAsArrayBuffer(c[t]);
                  });
                });
              } else o(new Error("weightManifest field is missing from file " + t.name));
            } else o(new Error("modelTopology field is missing from file " + t.name));
          }, a.onerror = function (e) {
            return o("Failed to read model topology and weights manifest JSON from file '" + t.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
          }, a.readAsText(t);
        })];
      });
    });
  }, t.prototype.checkManifestAndWeightFiles = function (t, e) {
    for (var n = [], r = e.map(function (t) {
      return pf(t.name);
    }), o = {}, a = 0, i = t; a < i.length; a++) {
      i[a].paths.forEach(function (t) {
        var a = pf(t);
        if (-1 !== n.indexOf(a)) throw new Error("Duplicate file basename found in weights manifest: '" + a + "'");
        if (n.push(a), -1 === r.indexOf(a)) throw new Error("Weight file with basename '" + a + "' is not provided.");
        o[t] = e[r.indexOf(a)];
      });
    }

    if (n.length !== e.length) throw new Error("Mismatch in the number of files in weights manifest (" + n.length + ") and the number of weight files provided (" + e.length + ").");
    return o;
  }, t;
}();

function Kf(t, e, n, r) {
  !function (t) {
    C(null != t && Array.isArray(t) && t.length > 0, function () {
      return "promises must be a none empty array";
    });
  }(t), function (t, e) {
    C(t >= 0 && t <= 1, function () {
      return "Progress fraction must be in range [0, 1], but got startFraction " + t;
    }), C(e >= 0 && e <= 1, function () {
      return "Progress fraction must be in range [0, 1], but got endFraction " + e;
    }), C(e >= t, function () {
      return "startFraction must be no more than endFraction, but got startFraction " + t + " and endFraction " + e;
    });
  }(n = null == n ? 0 : n, r = null == r ? 1 : r);
  var o = 0;
  return Promise.all(t.map(function (a) {
    return a.then(function (a) {
      var i = n + ++o / t.length * (r - n);
      return e(i), a;
    }), a;
  }));
}

function jf(t, e) {
  return n(this, void 0, void 0, function () {
    var n, o, a, s, u, c, l, h, f;
    return r(this, function (r) {
      switch (r.label) {
        case 0:
          return null == e && (e = {}), n = null == e.fetchFunc ? i().platform.fetch : e.fetchFunc, o = t.map(function (t) {
            return n(t, e.requestInit, {
              isBinary: !0
            });
          }), a = 0, s = .5, null != e.onProgress ? [3, 2] : [4, Promise.all(o)];

        case 1:
          return u = r.sent(), [3, 4];

        case 2:
          return [4, Kf(o, e.onProgress, a, s)];

        case 3:
          u = r.sent(), r.label = 4;

        case 4:
          return c = u.map(function (t) {
            return t.arrayBuffer();
          }), l = .5, h = 1, null != e.onProgress ? [3, 6] : [4, Promise.all(c)];

        case 5:
          return f = r.sent(), [3, 8];

        case 6:
          return [4, Kf(c, e.onProgress, l, h)];

        case 7:
          f = r.sent(), r.label = 8;

        case 8:
          return [2, f];
      }
    });
  });
}

function Xf(t) {
  var e = this;
  return function (o, a, i) {
    return void 0 === a && (a = ""), n(e, void 0, void 0, function () {
      var e, n, s, u, c, l, h, f, d, p;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (e = o.map(function () {
              return !1;
            }), n = {}, s = null != i ? i.map(function () {
              return !1;
            }) : [], u = [], o.forEach(function (t, r) {
              var o = 0;
              t.weights.forEach(function (t) {
                var a = "quantization" in t ? t.quantization.dtype : t.dtype,
                    c = sf[a] * k(t.shape),
                    l = function () {
                  e[r] = !0, null == n[r] && (n[r] = []), n[r].push({
                    manifestEntry: t,
                    groupOffset: o,
                    sizeBytes: c
                  });
                };

                null != i ? i.forEach(function (e, n) {
                  e === t.name && (l(), s[n] = !0);
                }) : l(), u.push(t.name), o += c;
              });
            }), !s.every(function (t) {
              return t;
            })) throw c = i.filter(function (t, e) {
              return !s[e];
            }), new Error("Could not find weights in manifest with names: " + c.join(", ") + ". \nManifest JSON has weights with names: " + u.join(", ") + ".");
            return l = e.reduce(function (t, e, n) {
              return e && t.push(n), t;
            }, []), h = [], l.forEach(function (t) {
              o[t].paths.forEach(function (t) {
                var e = a + (a.endsWith("/") ? "" : "/") + t;
                h.push(e);
              });
            }), [4, t(h)];

          case 1:
            return f = r.sent(), d = {}, p = 0, l.forEach(function (t) {
              for (var e = o[t].paths.length, r = 0, a = 0; a < e; a++) r += f[p + a].byteLength;

              for (var i = new ArrayBuffer(r), s = new Uint8Array(i), u = 0, c = 0; c < e; c++) {
                var l = new Uint8Array(f[p + c]);
                s.set(l, u), u += l.byteLength;
              }

              n[t].forEach(function (t) {
                var e = cf(i.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [t.manifestEntry]);

                for (var n in e) d[n] = e[n];
              }), p += e;
            }), [2, d];
        }
      });
    });
  };
}

mf.registerSaveRouter(function (t) {
  return i().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Hf.URL_SCHEME) ? function (t) {
    void 0 === t && (t = "model");
    return new Hf(t);
  }(t.slice(Hf.URL_SCHEME.length)) : null;
});

var Yf = function () {
  function t(t, e) {
    if (this.DEFAULT_METHOD = "POST", null == e && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, null != e.fetchFunc ? (C("function" == typeof e.fetchFunc, function () {
      return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
    }), this.fetch = e.fetchFunc) : this.fetch = i().platform.fetch, C(null != t && t.length > 0, function () {
      return "URL path for http must not be null, undefined or empty.";
    }), Array.isArray(t) && C(2 === t.length, function () {
      return "URL paths for http must have a length of 2, (actual length is " + t.length + ").";
    }), this.path = t, null != e.requestInit && null != e.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = e.requestInit || {};
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
            return (e = Object.assign({
              method: this.DEFAULT_METHOD
            }, this.requestInit)).body = new FormData(), n = [{
              paths: ["./model.weights.bin"],
              weights: t.weightSpecs
            }], o = {
              modelTopology: t.modelTopology,
              format: t.format,
              generatedBy: t.generatedBy,
              convertedBy: t.convertedBy,
              userDefinedMetadata: t.userDefinedMetadata,
              weightsManifest: n
            }, e.body.append("model.json", new Blob([JSON.stringify(o)], {
              type: "application/json"
            }), "model.json"), null != t.weightData && e.body.append("model.weights.bin", new Blob([t.weightData], {
              type: "application/octet-stream"
            }), "model.weights.bin"), [4, this.fetch(this.path, e)];

          case 1:
            if ((a = r.sent()).ok) return [2, {
              modelArtifactsInfo: vf(t),
              responses: [a]
            }];
            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + a.status + ".");
        }
      });
    });
  }, t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i, s, u, c, l, h, f;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, this.fetch(this.path, this.requestInit)];

          case 1:
            if (!(t = r.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + t.status + ". Please verify this URL points to the model JSON of the model to load.");
            r.label = 2;

          case 2:
            return r.trys.push([2, 4,, 5]), [4, t.json()];

          case 3:
            return e = r.sent(), [3, 5];

          case 4:
            throw r.sent(), n = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n += " Please make sure the server is serving valid JSON for this request.", new Error(n);

          case 5:
            if (o = e.modelTopology, a = e.weightsManifest, i = e.generatedBy, s = e.convertedBy, u = e.format, c = e.userDefinedMetadata, null == o && null == a) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
            return null == a ? [3, 7] : [4, this.loadWeights(a)];

          case 6:
            f = r.sent(), l = f[0], h = f[1], r.label = 7;

          case 7:
            return [2, {
              modelTopology: o,
              weightSpecs: l,
              weightData: h,
              userDefinedMetadata: c,
              generatedBy: i,
              convertedBy: s,
              format: u
            }];
        }
      });
    });
  }, t.prototype.loadWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e, n, o, a, i, s, u, c, l, h, f;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            for (e = Array.isArray(this.path) ? this.path[1] : this.path, n = function (t) {
              var e = t.lastIndexOf("/"),
                  n = t.lastIndexOf("?"),
                  r = t.substring(0, e),
                  o = n > e ? t.substring(n) : "";
              return [r + "/", o];
            }(e), o = n[0], a = n[1], i = this.weightPathPrefix || o, s = [], u = 0, c = t; u < c.length; u++) l = c[u], s.push.apply(s, l.weights);

            return h = [], t.forEach(function (t) {
              t.paths.forEach(function (t) {
                h.push(i + t + a);
              });
            }), [4, jf(h, {
              requestInit: this.requestInit,
              fetchFunc: this.fetch,
              onProgress: this.onProgress
            })];

          case 1:
            return f = r.sent(), [2, [s, df(f)]];
        }
      });
    });
  }, t.URL_SCHEME_REGEX = /^https?:\/\//, t;
}();

function $f(t) {
  return null != t.match(Yf.URL_SCHEME_REGEX);
}

var Qf = function (t, e) {
  if ("undefined" == typeof fetch) return null;
  return (Array.isArray(t) ? t.every(function (t) {
    return $f(t);
  }) : $f(t)) ? Jf(t, {
    onProgress: e
  }) : null;
};

function Jf(t, e) {
  return new Yf(t, e);
}

mf.registerSaveRouter(Qf), mf.registerLoadRouter(Qf);

var Zf = function () {
  function t(t) {
    this.modelArtifacts = t;
  }

  return t.prototype.load = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        return [2, this.modelArtifacts];
      });
    });
  }, t;
}(),
    td = function () {
  function t(t) {
    this.saveHandler = t;
  }

  return t.prototype.save = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        return [2, this.saveHandler(t)];
      });
    });
  }, t;
}();

var ed = Object.freeze({
  browserFiles: function (t) {
    return new qf(t);
  },
  browserHTTPRequest: function (t, e) {
    return Jf(t, e);
  },
  concatenateArrayBuffers: df,
  decodeWeights: cf,
  encodeWeights: function (t, e) {
    return n(this, void 0, void 0, function () {
      var o,
          a,
          i,
          s,
          u,
          c = this;
      return r(this, function (l) {
        switch (l.label) {
          case 0:
            for (o = [], a = [], i = Array.isArray(t) ? t.map(function (t) {
              return t.name;
            }) : Object.keys(t), s = function (s) {
              var u = i[s],
                  l = Array.isArray(t) ? t[s].tensor : t[u];
              if ("float32" !== l.dtype && "int32" !== l.dtype && "bool" !== l.dtype && "string" !== l.dtype) throw new Error("Unsupported dtype in weight '" + u + "': " + l.dtype);
              var h = {
                name: u,
                shape: l.shape,
                dtype: l.dtype
              };

              if ("string" === l.dtype) {
                var f = new Promise(function (t) {
                  return n(c, void 0, void 0, function () {
                    var e, n, o, a, i, s, u;
                    return r(this, function (r) {
                      switch (r.label) {
                        case 0:
                          return [4, l.bytes()];

                        case 1:
                          for (e = r.sent(), n = e.reduce(function (t, e) {
                            return t + e.length;
                          }, 0) + uf * e.length, o = new Uint8Array(n), a = 0, i = 0; i < e.length; i++) s = e[i], u = new Uint8Array(new Uint32Array([s.length]).buffer), o.set(u, a), a += uf, o.set(s, a), a += s.length;

                          return t(o), [2];
                      }
                    });
                  });
                });
                a.push(f);
              } else a.push(l.data());

              null != e && (h.group = e), o.push(h);
            }, u = 0; u < i.length; ++u) s(u);

            return [4, Promise.all(a)];

          case 1:
            return [2, {
              data: lf(l.sent()),
              specs: o
            }];
        }
      });
    });
  },
  fromMemory: function (t, e, n, r) {
    return 1 === arguments.length ? null != t.modelTopology || null != t.weightSpecs ? new Zf(t) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Zf({
      modelTopology: t
    })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Zf({
      modelTopology: t,
      weightSpecs: e,
      weightData: n,
      trainingConfig: r
    }));
  },
  getLoadHandlers: function (t, e) {
    return mf.getLoadHandlers(t, e);
  },
  getModelArtifactsInfoForJSON: vf,
  getSaveHandlers: function (t) {
    return mf.getSaveHandlers(t);
  },
  http: Jf,
  isHTTPScheme: $f,
  loadWeights: function (t, e, o, a) {
    return void 0 === e && (e = ""), n(this, void 0, void 0, function () {
      return r(this, function (n) {
        return [2, Xf(function (t) {
          return jf(t, {
            requestInit: a
          });
        })(t, e, o)];
      });
    });
  },
  registerLoadRouter: function (t) {
    return mf.registerLoadRouter(t);
  },
  registerSaveRouter: function (t) {
    return mf.registerSaveRouter(t);
  },
  weightsLoaderFactory: Xf,
  withSaveHandler: function (t) {
    return new td(t);
  },
  copyModel: function (t, e) {
    return n(this, void 0, void 0, function () {
      return r(this, function (n) {
        return !1, [2, bf(t, e, !1)];
      });
    });
  },
  listModels: function () {
    return n(this, void 0, void 0, function () {
      var t, e, n, o, a, i, s;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            t = yf.getSchemes(), e = {}, n = 0, o = t, r.label = 1;

          case 1:
            return n < o.length ? (a = o[n], [4, yf.getManager(a).listModels()]) : [3, 4];

          case 2:
            for (s in i = r.sent()) e[a + gf + s] = i[s];

            r.label = 3;

          case 3:
            return n++, [3, 1];

          case 4:
            return [2, e];
        }
      });
    });
  },
  moveModel: function (t, e) {
    return n(this, void 0, void 0, function () {
      return r(this, function (n) {
        return !0, [2, bf(t, e, !0)];
      });
    });
  },
  removeModel: function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        return e = xf(t), [2, yf.getManager(e.scheme).removeModel(e.path)];
      });
    });
  }
});
exports.io = ed;
var nd,
    rd = An({
  confusionMatrix_: function (t, e, n) {
    var r = mn(t, "labels", "confusionMatrix"),
        o = mn(e, "predictions", "confusionMatrix");
    C(null == n || n > 0 && Number.isInteger(n), function () {
      return "If provided, numClasses must be a positive integer, but got " + n;
    }), C(1 === r.rank, function () {
      return "Expected the rank of labels to be 1, but got " + r.rank;
    }), C(1 === o.rank, function () {
      return "Expected the rank of predictions to be 1, but got " + o.rank;
    }), C(r.shape[0] === o.shape[0], function () {
      return "Mismatch in the number of examples: " + r.shape[0] + " vs. " + o.shape[0] + ". Labels and predictions should have the same number of elements.";
    }), C(n > 0 && Number.isInteger(n), function () {
      return "numClasses is required to be a positive integer, but got " + n;
    });
    var a = Rr(r.asType("int32"), n),
        i = Rr(o.asType("int32"), n);
    return a.transpose().matMul(i).asType("int32");
  }
}),
    od = Object.freeze({
  confusionMatrix: rd
});
exports.math = od;

var ad = An({
  fromPixels_: function (t, e) {
    if (void 0 === e && (e = 3), e > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
    if (null == t) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    var n = !1,
        r = !1,
        o = !1,
        a = !1,
        i = !1;
    if (t.data instanceof Uint8Array) n = !0;else if ("undefined" != typeof ImageData && t instanceof ImageData) r = !0;else if ("undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement) o = !0;else if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) a = !0;else {
      if (null == t.getContext) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t.constructor.name);
      i = !0;
    }

    if (o) {
      if (o && t.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
    }

    if (null != l("FromPixels", Lt.backendName)) return Lt.runKernel("FromPixels", {
      pixels: t
    }, {
      numChannels: e
    });
    var s,
        u,
        c = o ? [t.videoWidth, t.videoHeight] : [t.width, t.height],
        h = c[0],
        f = c[1];
    if (i ? s = t.getContext("2d").getImageData(0, 0, h, f).data : r || n ? s = t.data : (a || o) && (null == nd && (nd = document.createElement("canvas").getContext("2d")), nd.canvas.width = h, nd.canvas.height = f, nd.drawImage(t, 0, 0, h, f), s = nd.getImageData(0, 0, h, f).data), 4 === e) u = new Int32Array(s);else {
      var d = h * f;
      u = new Int32Array(d * e);

      for (var p = 0; p < d; p++) for (var v = 0; v < e; ++v) u[p * e + v] = s[4 * p + v];
    }
    return Pn(u, [f, h, e], "int32");
  }
}),
    id = Object.freeze({
  toPixels: function (t, e) {
    return n(this, void 0, void 0, function () {
      var n, o, a, i, s, u, c, l, h, f, d, p, v, m, g, y, x, b, w, C, E, R, I;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            if (n = mn(t, "img", "toPixels"), t instanceof wt || (n = n.toInt()), 2 !== n.rank && 3 !== n.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n.rank + ".");
            if (o = n.shape.slice(0, 2), a = o[0], i = o[1], (s = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === s) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + s);
            return [4, n.data()];

          case 1:
            return u = r.sent(), c = n.min(), l = n.max(), [4, Promise.all([c.data(), l.data()])];

          case 2:
            if (h = r.sent(), f = h[0], d = h[1], p = f[0], v = d[0], c.dispose(), l.dispose(), "float32" === n.dtype) {
              if (p < 0 || v > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + p + " - " + v + "].");
            } else {
              if ("int32" !== n.dtype) throw new Error("Unsupported type for toPixels: " + n.dtype + ". Please use float32 or int32 tensors.");
              if (p < 0 || v > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + p + " - " + v + "].");
            }

            for (m = "float32" === n.dtype ? 255 : 1, g = new Uint8ClampedArray(i * a * 4), y = 0; y < a * i; ++y) x = void 0, b = void 0, w = void 0, C = void 0, 1 === s ? (x = u[y] * m, b = u[y] * m, w = u[y] * m, C = 255) : 3 === s ? (x = u[3 * y] * m, b = u[3 * y + 1] * m, w = u[3 * y + 2] * m, C = 255) : 4 === s && (x = u[4 * y] * m, b = u[4 * y + 1] * m, w = u[4 * y + 2] * m, C = u[4 * y + 3] * m), g[(E = 4 * y) + 0] = Math.round(x), g[E + 1] = Math.round(b), g[E + 2] = Math.round(w), g[E + 3] = Math.round(C);

            return null != e && (e.width = i, e.height = a, R = e.getContext("2d"), I = new ImageData(g, i, a), R.putImageData(I, 0, 0)), n !== t && n.dispose(), [2, g];
        }
      });
    });
  },
  fromPixels: ad
}),
    sd = function () {
  function t() {}

  return t.prototype.getClassName = function () {
    return this.constructor.className;
  }, t.fromConfig = function (t, e) {
    return new t(e);
  }, t;
}(),
    ud = function () {
  function t() {
    this.classNameMap = {};
  }

  return t.getMap = function () {
    return null == t.instance && (t.instance = new t()), t.instance;
  }, t.register = function (e) {
    t.getMap().classNameMap[e.className] = [e, e.fromConfig];
  }, t;
}();

exports.browser = id;

function cd(t) {
  C(null != t.className, function () {
    return "Class being registered does not have the static className property defined.";
  }), C("string" == typeof t.className, function () {
    return "className is required to be a string, but got type " + typeof t.className;
  }), C(t.className.length > 0, function () {
    return "Class being registered has an empty-string as its className, which is disallowed.";
  }), ud.register(t);
}

var ld = Object.freeze({
  Serializable: sd,
  SerializationMap: ud,
  registerClass: cd
}),
    hd = .001,
    fd = .1;
exports.serialization = ld;

function dd() {
  return 32 === Lt.backend.floatPrecision() ? hd : fd;
}

function pd(t, e, n) {
  var r = !0;

  if ((V(t) || V(e)) && (r = !1), V(t) && V(e) && (r = !0), r) {
    var o = t.constructor.name,
        a = e.constructor.name;
    if (o !== a) throw new Error("Arrays are of different type. Actual: " + o + ". Expected: " + a);
  }

  if (Array.isArray(t) && Array.isArray(e)) {
    var i = pn(t),
        s = pn(e);
    if (!S(i, s)) throw new Error("Arrays have different shapes. Actual: [" + i + "]. Expected: [" + s + "]");
  }

  var u = V(t) ? t : I(t),
      c = V(e) ? e : I(e);
  if (u.length !== c.length) throw new Error("Arrays have different lengths actual: " + u.length + " vs expected: " + c.length + ".\nActual:   " + u + ".\nExpected: " + c + ".");

  for (var l = 0; l < c.length; ++l) {
    var h = u[l],
        f = c[l];
    if (!n(h, f)) throw new Error("Arrays differ: actual[" + l + "] = " + h + ", expected[" + l + "] = " + f + ".\nActual:   " + u + ".\nExpected: " + c + ".");
  }
}

function vd(t, e, n) {
  return !isFinite(t) && !isFinite(e) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n);
}

var md = Object.freeze({
  TEST_EPSILON_FLOAT16: fd,
  expectArraysClose: function (t, e, n) {
    return null == n && (n = dd()), pd(t, e, function (t, e) {
      return vd(t, e, n);
    });
  },
  testEpsilon: dd,
  expectPromiseToFail: function (t, e) {
    t().then(function () {
      return e.fail();
    }, function () {
      return e();
    });
  },
  expectArraysEqual: function (t, e) {
    var n = "string" == typeof e || "number" == typeof e || "boolean" == typeof e ? [e] : e;
    return H(t) || H(t[0]) || H(e) || H(e[0]) ? pd(t, n, function (t, e) {
      return t == e;
    }) : pd(t, e, function (t, e) {
      return vd(t, e, 0);
    });
  },
  expectNumbersClose: function (t, e, n) {
    if (null == n && (n = dd()), !vd(t, e, n)) throw new Error("Numbers differ: actual === " + t + ", expected === " + e);
  },
  expectValuesInRange: function (t, e, n) {
    for (var r = 0; r < t.length; r++) if (t[r] < e || t[r] > n) throw new Error("Value out of range:" + t[r] + " low: " + e + ", high: " + n);
  },
  expectArrayBuffersEqual: function (t, e) {
    expect(new Float32Array(t)).toEqual(new Float32Array(e));
  }
}),
    gd = "1.7.0";
exports.version_core = gd;
exports.test_util = md;

var yd = Object.freeze({
  gpgpu_util: Mi,
  webgl_util: Ge,
  forceHalfFloat: function () {
    i().set("WEBGL_FORCE_F16_TEXTURES", !0);
  },
  MathBackendWebGL: Zs,
  setWebGLContext: Kt,
  GPGPUContext: Bi
}),
    xd = function (t) {
  function o() {
    return null !== t && t.apply(this, arguments) || this;
  }

  return e(o, t), o.prototype.minimize = function (t, e, n) {
    void 0 === e && (e = !1);
    var r = this.computeGradients(t, n),
        o = r.value,
        a = r.grads;

    if (null != n) {
      var i = n.map(function (t) {
        return {
          name: t.name,
          tensor: a[t.name]
        };
      });
      this.applyGradients(i);
    } else this.applyGradients(a);

    return tn(a), e ? o : (o.dispose(), null);
  }, Object.defineProperty(o.prototype, "iterations", {
    get: function () {
      return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
    },
    enumerable: !0,
    configurable: !0
  }), o.prototype.incrementIterations = function () {
    this.iterations_ = this.iterations + 1;
  }, o.prototype.computeGradients = function (t, e) {
    return po(t, e);
  }, o.prototype.dispose = function () {
    null != this.iterations_ && tn(this.iterations_);
  }, o.prototype.saveIterations = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        return null == this.iterations_ && (this.iterations_ = 0), [2, {
          name: "iter",
          tensor: On(this.iterations_, "int32")
        }];
      });
    });
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("getWeights() is not implemented for this optimizer yet.");
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
      });
    });
  }, o.prototype.extractIterations = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return e = this, [4, t[0].tensor.data()];

          case 1:
            return e.iterations_ = n.sent()[0], [2, t.slice(1)];
        }
      });
    });
  }, o;
}(sd);

exports.Optimizer = xd;
exports.webgl = yd;
Object.defineProperty(xd, Symbol.hasInstance, {
  value: function (t) {
    return null != t.minimize && null != t.computeGradients && null != t.applyGradients;
  }
});

var bd = function (t) {
  function o(e, n, r) {
    void 0 === r && (r = null);
    var o = t.call(this) || this;
    return o.learningRate = e, o.rho = n, o.epsilon = r, o.accumulatedGrads = [], o.accumulatedUpdates = [], null == r && (o.epsilon = Lt.backend.epsilon()), o;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Lt.registeredVariables[n];
      null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {
        originalName: n + "/accum_grad",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      }), null == e.accumulatedUpdates[r] && (e.accumulatedUpdates[r] = {
        originalName: n + "/accum_var",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      });
      var a = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != a) {
        var i = e.accumulatedGrads[r].variable,
            s = e.accumulatedUpdates[r].variable;
        Ze(function () {
          var t = i.mul(e.rho).add(a.square().mul(1 - e.rho)),
              n = s.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a),
              r = s.mul(e.rho).add(n.square().mul(1 - e.rho));
          i.assign(t), s.assign(r);
          var u = n.mul(-e.learningRate).add(o);
          o.assign(u);
        });
      }
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    null != this.accumulatedUpdates && (tn(this.accumulatedGrads.map(function (t) {
      return t.variable;
    })), tn(this.accumulatedUpdates.map(function (t) {
      return t.variable;
    })));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];

          case 1:
            return [2, [e.sent()].concat(t.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = n.sent(), e = t.length / 2, !1, this.accumulatedGrads = t.slice(0, e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.accumulatedUpdates = t.slice(e, 2 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      rho: this.rho,
      epsilon: this.epsilon
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.rho, e.epsilon);
  }, o.className = "Adadelta", o;
}(xd);

exports.AdadeltaOptimizer = bd;
cd(bd);

var wd = function (t) {
  function o(e, n) {
    void 0 === n && (n = .1);
    var r = t.call(this) || this;
    return r.learningRate = e, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Lt.registeredVariables[n];

      if (null == e.accumulatedGrads[r]) {
        e.accumulatedGrads[r] = {
          originalName: n + "/accumulator",
          variable: Ze(function () {
            return Hn(o.shape, e.initialAccumulatorValue).variable(!1);
          })
        };
      }

      var a = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != a) {
        var i = e.accumulatedGrads[r].variable;
        Ze(function () {
          var t = i.add(a.square());
          i.assign(t);
          var n = a.div(t.add(Lt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);
          o.assign(n);
        });
      }
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    null != this.accumulatedGrads && tn(this.accumulatedGrads.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];

          case 1:
            return [2, [t.sent()].concat(this.accumulatedGrads.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = e.sent(), !1, this.accumulatedGrads = t.map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      initialAccumulatorValue: this.initialAccumulatorValue
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.initialAccumulatorValue);
  }, o.className = "Adagrad", o;
}(xd);

exports.AdagradOptimizer = wd;
cd(wd);

var Cd = function (t) {
  function o(e, n, r, o) {
    void 0 === o && (o = null);
    var a = t.call(this) || this;
    return a.learningRate = e, a.beta1 = n, a.beta2 = r, a.epsilon = o, a.accumulatedFirstMoment = [], a.accumulatedSecondMoment = [], Ze(function () {
      a.accBeta1 = On(n).variable(), a.accBeta2 = On(r).variable();
    }), null == o && (a.epsilon = Lt.backend.epsilon()), a;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this,
        n = Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t);
    Ze(function () {
      var r = Cc(1, e.accBeta1),
          o = Cc(1, e.accBeta2);
      n.forEach(function (n, a) {
        var i = Lt.registeredVariables[n];
        null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {
          originalName: n + "/m",
          variable: Ze(function () {
            return Xn(i).variable(!1);
          })
        }), null == e.accumulatedSecondMoment[a] && (e.accumulatedSecondMoment[a] = {
          originalName: n + "/v",
          variable: Ze(function () {
            return Xn(i).variable(!1);
          })
        });
        var s = Array.isArray(t) ? t[a].tensor : t[n];

        if (null != s) {
          var u = e.accumulatedFirstMoment[a].variable,
              c = e.accumulatedSecondMoment[a].variable,
              l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
              h = c.mul(e.beta2).add(s.square().mul(1 - e.beta2)),
              f = l.div(r),
              d = h.div(o);
          u.assign(l), c.assign(h);
          var p = f.div(d.sqrt().add(e.epsilon)).mul(-e.learningRate).add(i);
          i.assign(p);
        }
      }), e.accBeta1.assign(e.accBeta1.mul(e.beta1)), e.accBeta2.assign(e.accBeta2.mul(e.beta2));
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function (t) {
      return t.variable;
    })), null != this.accumulatedSecondMoment && tn(this.accumulatedSecondMoment.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];

          case 1:
            return [2, [e.sent()].concat(t.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e,
          n = this;
      return r(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = r.sent(), Ze(function () {
              n.accBeta1.assign(xc(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(xc(n.beta2, n.iterations_ + 1));
            }), e = t.length / 2, !1, this.accumulatedFirstMoment = t.slice(0, e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.accumulatedSecondMoment = t.slice(e, 2 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.beta1, e.beta2, e.epsilon);
  }, o.className = "Adam", o;
}(xd);

exports.AdamOptimizer = Cd;
cd(Cd);

var Ed = function (t) {
  function o(e, n, r, o, a) {
    void 0 === o && (o = null), void 0 === a && (a = 0);
    var i = t.call(this) || this;
    return i.learningRate = e, i.beta1 = n, i.beta2 = r, i.epsilon = o, i.decay = a, i.accumulatedFirstMoment = [], i.accumulatedWeightedInfNorm = [], Ze(function () {
      i.iteration = On(0).variable(), i.accBeta1 = On(n).variable();
    }), null == o && (i.epsilon = Lt.backend.epsilon()), i;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this,
        n = Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t);
    Ze(function () {
      var r = Cc(1, e.accBeta1),
          o = sc(-e.learningRate, e.iteration.mul(e.decay).add(1));
      n.forEach(function (n, a) {
        var i = Lt.registeredVariables[n];
        null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {
          originalName: n + "/m",
          variable: Xn(i).variable(!1)
        }), null == e.accumulatedWeightedInfNorm[a] && (e.accumulatedWeightedInfNorm[a] = {
          originalName: n + "/v",
          variable: Xn(i).variable(!1)
        });
        var s = Array.isArray(t) ? t[a].tensor : t[n];

        if (null != s) {
          var u = e.accumulatedFirstMoment[a].variable,
              c = e.accumulatedWeightedInfNorm[a].variable,
              l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
              h = c.mul(e.beta2),
              f = s.abs(),
              d = h.maximum(f);
          u.assign(l), c.assign(d);
          var p = o.div(r).mul(l.div(d.add(e.epsilon))).add(i);
          i.assign(p);
        }
      }), e.iteration.assign(e.iteration.add(1)), e.accBeta1.assign(e.accBeta1.mul(e.beta1));
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function (t) {
      return t.variable;
    })), null != this.accumulatedWeightedInfNorm && tn(this.accumulatedWeightedInfNorm.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("getWeights() is not implemented for Adamax yet.");
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        throw new Error("setWeights() is not implemented for Adamax yet.");
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon,
      decay: this.decay
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay);
  }, o.className = "Adamax", o;
}(xd);

exports.AdamaxOptimizer = Ed;
cd(Ed);

var Rd = function (t) {
  function o(e) {
    var n = t.call(this) || this;
    return n.learningRate = e, n.setLearningRate(e), n;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != o) {
        var a = Lt.registeredVariables[n];
        Ze(function () {
          var t = e.c.mul(o).add(a);
          a.assign(t);
        });
      }
    }), this.incrementIterations();
  }, o.prototype.setLearningRate = function (t) {
    this.learningRate = t, null != this.c && this.c.dispose(), this.c = en(On(-t));
  }, o.prototype.dispose = function () {
    this.c.dispose();
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];

          case 1:
            return [2, [t.sent()]];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            if (0 !== (t = e.sent()).length) throw new Error("SGD optimizer does not have settable weights.");
            return [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate);
  }, o.className = "SGD", o;
}(xd);

exports.SGDOptimizer = Rd;
cd(Rd);

var Id = function (t) {
  function o(e, n, r) {
    void 0 === r && (r = !1);
    var o = t.call(this, e) || this;
    return o.learningRate = e, o.momentum = n, o.useNesterov = r, o.accumulations = [], o.m = On(o.momentum), o;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Lt.registeredVariables[n];

      if (null == e.accumulations[r]) {
        e.accumulations[r] = {
          originalName: n + "/momentum",
          variable: Ze(function () {
            return Xn(o).variable(!1);
          })
        };
      }

      var a = e.accumulations[r].variable,
          i = Array.isArray(t) ? t[r].tensor : t[n];
      null != i && Ze(function () {
        var t,
            n = e.m.mul(a).add(i);
        t = e.useNesterov ? e.c.mul(i.add(n.mul(e.m))).add(o) : e.c.mul(n).add(o), a.assign(n), o.assign(t);
      });
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    this.m.dispose(), null != this.accumulations && tn(this.accumulations.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.setMomentum = function (t) {
    this.momentum = t;
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      return r(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];

          case 1:
            return [2, [t.sent()].concat(this.accumulations.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = e.sent(), !1, this.accumulations = t.map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      momentum: this.momentum,
      useNesterov: this.useNesterov
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.momentum, e.useNesterov);
  }, o.className = "Momentum", o;
}(Rd);

exports.MomentumOptimizer = Id;
cd(Id);

var kd = function (t) {
  function o(e, n, r, o, a) {
    void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === o && (o = null), void 0 === a && (a = !1);
    var i = t.call(this) || this;
    if (i.learningRate = e, i.decay = n, i.momentum = r, i.epsilon = o, i.accumulatedMeanSquares = [], i.accumulatedMoments = [], i.accumulatedMeanGrads = [], i.centered = a, null == o && (i.epsilon = Lt.backend.epsilon()), null == e) throw new Error("learningRate for RMSPropOptimizer must be defined.");
    return i;
  }

  return e(o, t), o.prototype.applyGradients = function (t) {
    var e = this;
    (Array.isArray(t) ? t.map(function (t) {
      return t.name;
    }) : Object.keys(t)).forEach(function (n, r) {
      var o = Lt.registeredVariables[n];
      null == e.accumulatedMeanSquares[r] && (e.accumulatedMeanSquares[r] = {
        originalName: n + "/rms",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      }), null == e.accumulatedMoments[r] && (e.accumulatedMoments[r] = {
        originalName: n + "/momentum",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      }), null == e.accumulatedMeanGrads[r] && e.centered && (e.accumulatedMeanGrads[r] = {
        originalName: n + "/mg",
        variable: Ze(function () {
          return Xn(o).variable(!1);
        })
      });
      var a = Array.isArray(t) ? t[r].tensor : t[n];

      if (null != a) {
        var i = e.accumulatedMeanSquares[r].variable,
            s = e.accumulatedMoments[r].variable;
        Ze(function () {
          var t = i.mul(e.decay).add(a.square().mul(1 - e.decay));

          if (e.centered) {
            var n = e.accumulatedMeanGrads[r].variable,
                u = n.mul(e.decay).add(a.mul(1 - e.decay)),
                c = s.mul(e.momentum).add(a.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));
            i.assign(t), n.assign(u), s.assign(c);
            var l = o.sub(c);
            o.assign(l);
          } else {
            var h = i.mul(e.decay).add(a.square().mul(1 - e.decay));
            c = s.mul(e.momentum).add(a.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));
            i.assign(h), s.assign(c);
            l = o.sub(c);
            o.assign(l);
          }
        });
      }
    }), this.incrementIterations();
  }, o.prototype.dispose = function () {
    null != this.accumulatedMeanSquares && tn(this.accumulatedMeanSquares.map(function (t) {
      return t.variable;
    })), null != this.accumulatedMeanGrads && this.centered && tn(this.accumulatedMeanGrads.map(function (t) {
      return t.variable;
    })), null != this.accumulatedMoments && tn(this.accumulatedMoments.map(function (t) {
      return t.variable;
    }));
  }, o.prototype.getWeights = function () {
    return n(this, void 0, void 0, function () {
      var t;
      return r(this, function (e) {
        switch (e.label) {
          case 0:
            return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [4, this.saveIterations()];

          case 1:
            return [2, [e.sent()].concat(t.map(function (t) {
              return {
                name: t.originalName,
                tensor: t.variable
              };
            }))];
        }
      });
    });
  }, o.prototype.setWeights = function (t) {
    return n(this, void 0, void 0, function () {
      var e;
      return r(this, function (n) {
        switch (n.label) {
          case 0:
            return [4, this.extractIterations(t)];

          case 1:
            return t = n.sent(), e = this.centered ? t.length / 3 : t.length / 2, !1, this.accumulatedMeanSquares = t.slice(0, e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.accumulatedMoments = t.slice(e, 2 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map(function (t) {
              return {
                originalName: t.name,
                variable: t.tensor.variable(!1)
              };
            })), [2];
        }
      });
    });
  }, o.prototype.getConfig = function () {
    return {
      learningRate: this.learningRate,
      decay: this.decay,
      momentum: this.momentum,
      epsilon: this.epsilon,
      centered: this.centered
    };
  }, o.fromConfig = function (t, e) {
    return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered);
  }, o.className = "RMSProp", o;
}(xd);

exports.RMSPropOptimizer = kd;
cd(kd);

var Sd = function () {
  function t() {}

  return t.sgd = function (t) {
    return new Rd(t);
  }, t.momentum = function (t, e, n) {
    return void 0 === n && (n = !1), new Id(t, e, n);
  }, t.rmsprop = function (t, e, n, r, o) {
    return void 0 === e && (e = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1), new kd(t, e, n, r, o);
  }, t.adam = function (t, e, n, r) {
    return void 0 === t && (t = .001), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new Cd(t, e, n, r);
  }, t.adadelta = function (t, e, n) {
    return void 0 === t && (t = .001), void 0 === e && (e = .95), void 0 === n && (n = null), new bd(t, e, n);
  }, t.adamax = function (t, e, n, r, o) {
    return void 0 === t && (t = .002), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === o && (o = 0), new Ed(t, e, n, r, o);
  }, t.adagrad = function (t, e) {
    return void 0 === e && (e = .1), new wd(t, e);
  }, t;
}(),
    Ad = {
  sgd: Sd.sgd,
  momentum: Sd.momentum,
  adadelta: Sd.adadelta,
  adagrad: Sd.adagrad,
  rmsprop: Sd.rmsprop,
  adamax: Sd.adamax,
  adam: Sd.adam
},
    Dd = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function (t) {
  return t();
};

exports.train = Ad;

function Td() {
  return new Promise(function (t) {
    return Dd(function () {
      return t();
    });
  });
}

wt.prototype.squaredDifference = function (t) {
  return nu(this, t);
}, xt = Gh;
},{"crypto":"node_modules/parcel-bundler/src/builtins/_empty.js","node-fetch":"node_modules/parcel-bundler/src/builtins/_empty.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js","process":"node_modules/process/browser.js","buffer":"node_modules/buffer/index.js"}],"node_modules/face-api.js/build/es6/draw/drawContour.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawContour = drawContour;

function drawContour(ctx, points, isClosed) {
  if (isClosed === void 0) {
    isClosed = false;
  }

  ctx.beginPath();
  points.slice(1).forEach(function (_a, prevIdx) {
    var x = _a.x,
        y = _a.y;
    var from = points[prevIdx];
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(x, y);
  });

  if (isClosed) {
    var from = points[points.length - 1];
    var to = points[0];

    if (!from || !to) {
      return;
    }

    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
  }

  ctx.stroke();
}
},{}],"node_modules/tslib/tslib.es6.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__extends = __extends;
exports.__rest = __rest;
exports.__decorate = __decorate;
exports.__param = __param;
exports.__metadata = __metadata;
exports.__awaiter = __awaiter;
exports.__generator = __generator;
exports.__exportStar = __exportStar;
exports.__values = __values;
exports.__read = __read;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__await = __await;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncValues = __asyncValues;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__importStar = __importStar;
exports.__importDefault = __importDefault;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__assign = void 0;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

exports.__assign = __assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function __exportStar(m, exports) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}

function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

;

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result.default = mod;
  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
}
},{}],"node_modules/face-api.js/build/es6/classes/Dimensions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dimensions = void 0;

var _utils = require("../utils");

var Dimensions =
/** @class */
function () {
  function Dimensions(width, height) {
    if (!(0, _utils.isValidNumber)(width) || !(0, _utils.isValidNumber)(height)) {
      throw new Error("Dimensions.constructor - expected width and height to be valid numbers, instead have " + JSON.stringify({
        width: width,
        height: height
      }));
    }

    this._width = width;
    this._height = height;
  }

  Object.defineProperty(Dimensions.prototype, "width", {
    get: function () {
      return this._width;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Dimensions.prototype, "height", {
    get: function () {
      return this._height;
    },
    enumerable: true,
    configurable: true
  });

  Dimensions.prototype.reverse = function () {
    return new Dimensions(1 / this.width, 1 / this.height);
  };

  return Dimensions;
}();

exports.Dimensions = Dimensions;
},{"../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTensor = isTensor;
exports.isTensor1D = isTensor1D;
exports.isTensor2D = isTensor2D;
exports.isTensor3D = isTensor3D;
exports.isTensor4D = isTensor4D;
exports.isFloat = isFloat;
exports.isEven = isEven;
exports.round = round;
exports.isDimensions = isDimensions;
exports.computeReshapedDimensions = computeReshapedDimensions;
exports.getCenterPoint = getCenterPoint;
exports.range = range;
exports.isValidNumber = isValidNumber;
exports.isValidProbablitiy = isValidProbablitiy;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _classes = require("../classes");

var _Dimensions = require("../classes/Dimensions");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function isTensor(tensor, dim) {
  return tensor instanceof tf.Tensor && tensor.shape.length === dim;
}

function isTensor1D(tensor) {
  return isTensor(tensor, 1);
}

function isTensor2D(tensor) {
  return isTensor(tensor, 2);
}

function isTensor3D(tensor) {
  return isTensor(tensor, 3);
}

function isTensor4D(tensor) {
  return isTensor(tensor, 4);
}

function isFloat(num) {
  return num % 1 !== 0;
}

function isEven(num) {
  return num % 2 === 0;
}

function round(num, prec) {
  if (prec === void 0) {
    prec = 2;
  }

  var f = Math.pow(10, prec);
  return Math.floor(num * f) / f;
}

function isDimensions(obj) {
  return obj && obj.width && obj.height;
}

function computeReshapedDimensions(_a, inputSize) {
  var width = _a.width,
      height = _a.height;
  var scale = inputSize / Math.max(height, width);
  return new _Dimensions.Dimensions(Math.round(width * scale), Math.round(height * scale));
}

function getCenterPoint(pts) {
  return pts.reduce(function (sum, pt) {
    return sum.add(pt);
  }, new _classes.Point(0, 0)).div(new _classes.Point(pts.length, pts.length));
}

function range(num, start, step) {
  return Array(num).fill(0).map(function (_, i) {
    return start + i * step;
  });
}

function isValidNumber(num) {
  return !!num && num !== Infinity && num !== -Infinity && !isNaN(num) || num === 0;
}

function isValidProbablitiy(num) {
  return isValidNumber(num) && 0 <= num && num <= 1.0;
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../classes":"node_modules/face-api.js/build/es6/classes/index.js","../classes/Dimensions":"node_modules/face-api.js/build/es6/classes/Dimensions.js"}],"node_modules/face-api.js/build/es6/classes/Point.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Point = void 0;

var Point =
/** @class */
function () {
  function Point(x, y) {
    this._x = x;
    this._y = y;
  }

  Object.defineProperty(Point.prototype, "x", {
    get: function () {
      return this._x;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Point.prototype, "y", {
    get: function () {
      return this._y;
    },
    enumerable: true,
    configurable: true
  });

  Point.prototype.add = function (pt) {
    return new Point(this.x + pt.x, this.y + pt.y);
  };

  Point.prototype.sub = function (pt) {
    return new Point(this.x - pt.x, this.y - pt.y);
  };

  Point.prototype.mul = function (pt) {
    return new Point(this.x * pt.x, this.y * pt.y);
  };

  Point.prototype.div = function (pt) {
    return new Point(this.x / pt.x, this.y / pt.y);
  };

  Point.prototype.abs = function () {
    return new Point(Math.abs(this.x), Math.abs(this.y));
  };

  Point.prototype.magnitude = function () {
    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
  };

  Point.prototype.floor = function () {
    return new Point(Math.floor(this.x), Math.floor(this.y));
  };

  return Point;
}();

exports.Point = Point;
},{}],"node_modules/face-api.js/build/es6/classes/Box.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Box = void 0;

var _utils = require("../utils");

var _Point = require("./Point");

var Box =
/** @class */
function () {
  function Box(_box, allowNegativeDimensions) {
    if (allowNegativeDimensions === void 0) {
      allowNegativeDimensions = true;
    }

    var box = _box || {};
    var isBbox = [box.left, box.top, box.right, box.bottom].every(_utils.isValidNumber);
    var isRect = [box.x, box.y, box.width, box.height].every(_utils.isValidNumber);

    if (!isRect && !isBbox) {
      throw new Error("Box.constructor - expected box to be IBoundingBox | IRect, instead have " + JSON.stringify(box));
    }

    var _a = isRect ? [box.x, box.y, box.width, box.height] : [box.left, box.top, box.right - box.left, box.bottom - box.top],
        x = _a[0],
        y = _a[1],
        width = _a[2],
        height = _a[3];

    Box.assertIsValidBox({
      x: x,
      y: y,
      width: width,
      height: height
    }, 'Box.constructor', allowNegativeDimensions);
    this._x = x;
    this._y = y;
    this._width = width;
    this._height = height;
  }

  Box.isRect = function (rect) {
    return !!rect && [rect.x, rect.y, rect.width, rect.height].every(_utils.isValidNumber);
  };

  Box.assertIsValidBox = function (box, callee, allowNegativeDimensions) {
    if (allowNegativeDimensions === void 0) {
      allowNegativeDimensions = false;
    }

    if (!Box.isRect(box)) {
      throw new Error(callee + " - invalid box: " + JSON.stringify(box) + ", expected object with properties x, y, width, height");
    }

    if (!allowNegativeDimensions && (box.width < 0 || box.height < 0)) {
      throw new Error(callee + " - width (" + box.width + ") and height (" + box.height + ") must be positive numbers");
    }
  };

  Object.defineProperty(Box.prototype, "x", {
    get: function () {
      return this._x;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "y", {
    get: function () {
      return this._y;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "width", {
    get: function () {
      return this._width;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "height", {
    get: function () {
      return this._height;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "left", {
    get: function () {
      return this.x;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "top", {
    get: function () {
      return this.y;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "right", {
    get: function () {
      return this.x + this.width;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "bottom", {
    get: function () {
      return this.y + this.height;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "area", {
    get: function () {
      return this.width * this.height;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "topLeft", {
    get: function () {
      return new _Point.Point(this.left, this.top);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "topRight", {
    get: function () {
      return new _Point.Point(this.right, this.top);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "bottomLeft", {
    get: function () {
      return new _Point.Point(this.left, this.bottom);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Box.prototype, "bottomRight", {
    get: function () {
      return new _Point.Point(this.right, this.bottom);
    },
    enumerable: true,
    configurable: true
  });

  Box.prototype.round = function () {
    var _a = [this.x, this.y, this.width, this.height].map(function (val) {
      return Math.round(val);
    }),
        x = _a[0],
        y = _a[1],
        width = _a[2],
        height = _a[3];

    return new Box({
      x: x,
      y: y,
      width: width,
      height: height
    });
  };

  Box.prototype.floor = function () {
    var _a = [this.x, this.y, this.width, this.height].map(function (val) {
      return Math.floor(val);
    }),
        x = _a[0],
        y = _a[1],
        width = _a[2],
        height = _a[3];

    return new Box({
      x: x,
      y: y,
      width: width,
      height: height
    });
  };

  Box.prototype.toSquare = function () {
    var _a = this,
        x = _a.x,
        y = _a.y,
        width = _a.width,
        height = _a.height;

    var diff = Math.abs(width - height);

    if (width < height) {
      x -= diff / 2;
      width += diff;
    }

    if (height < width) {
      y -= diff / 2;
      height += diff;
    }

    return new Box({
      x: x,
      y: y,
      width: width,
      height: height
    });
  };

  Box.prototype.rescale = function (s) {
    var scaleX = (0, _utils.isDimensions)(s) ? s.width : s;
    var scaleY = (0, _utils.isDimensions)(s) ? s.height : s;
    return new Box({
      x: this.x * scaleX,
      y: this.y * scaleY,
      width: this.width * scaleX,
      height: this.height * scaleY
    });
  };

  Box.prototype.pad = function (padX, padY) {
    var _a = [this.x - padX / 2, this.y - padY / 2, this.width + padX, this.height + padY],
        x = _a[0],
        y = _a[1],
        width = _a[2],
        height = _a[3];
    return new Box({
      x: x,
      y: y,
      width: width,
      height: height
    });
  };

  Box.prototype.clipAtImageBorders = function (imgWidth, imgHeight) {
    var _a = this,
        x = _a.x,
        y = _a.y,
        right = _a.right,
        bottom = _a.bottom;

    var clippedX = Math.max(x, 0);
    var clippedY = Math.max(y, 0);
    var newWidth = right - clippedX;
    var newHeight = bottom - clippedY;
    var clippedWidth = Math.min(newWidth, imgWidth - clippedX);
    var clippedHeight = Math.min(newHeight, imgHeight - clippedY);
    return new Box({
      x: clippedX,
      y: clippedY,
      width: clippedWidth,
      height: clippedHeight
    }).floor();
  };

  Box.prototype.shift = function (sx, sy) {
    var _a = this,
        width = _a.width,
        height = _a.height;

    var x = this.x + sx;
    var y = this.y + sy;
    return new Box({
      x: x,
      y: y,
      width: width,
      height: height
    });
  };

  Box.prototype.padAtBorders = function (imageHeight, imageWidth) {
    var w = this.width + 1;
    var h = this.height + 1;
    var dx = 1;
    var dy = 1;
    var edx = w;
    var edy = h;
    var x = this.left;
    var y = this.top;
    var ex = this.right;
    var ey = this.bottom;

    if (ex > imageWidth) {
      edx = -ex + imageWidth + w;
      ex = imageWidth;
    }

    if (ey > imageHeight) {
      edy = -ey + imageHeight + h;
      ey = imageHeight;
    }

    if (x < 1) {
      edy = 2 - x;
      x = 1;
    }

    if (y < 1) {
      edy = 2 - y;
      y = 1;
    }

    return {
      dy: dy,
      edy: edy,
      dx: dx,
      edx: edx,
      y: y,
      ey: ey,
      x: x,
      ex: ex,
      w: w,
      h: h
    };
  };

  Box.prototype.calibrate = function (region) {
    return new Box({
      left: this.left + region.left * this.width,
      top: this.top + region.top * this.height,
      right: this.right + region.right * this.width,
      bottom: this.bottom + region.bottom * this.height
    }).toSquare().round();
  };

  return Box;
}();

exports.Box = Box;
},{"../utils":"node_modules/face-api.js/build/es6/utils/index.js","./Point":"node_modules/face-api.js/build/es6/classes/Point.js"}],"node_modules/face-api.js/build/es6/classes/BoundingBox.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoundingBox = void 0;

var _tslib = require("tslib");

var _Box = require("./Box");

var BoundingBox =
/** @class */
function (_super) {
  (0, _tslib.__extends)(BoundingBox, _super);

  function BoundingBox(left, top, right, bottom, allowNegativeDimensions) {
    if (allowNegativeDimensions === void 0) {
      allowNegativeDimensions = false;
    }

    return _super.call(this, {
      left: left,
      top: top,
      right: right,
      bottom: bottom
    }, allowNegativeDimensions) || this;
  }

  return BoundingBox;
}(_Box.Box);

exports.BoundingBox = BoundingBox;
},{"tslib":"node_modules/tslib/tslib.es6.js","./Box":"node_modules/face-api.js/build/es6/classes/Box.js"}],"node_modules/face-api.js/build/es6/classes/ObjectDetection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectDetection = void 0;

var _Box = require("./Box");

var _Dimensions = require("./Dimensions");

var ObjectDetection =
/** @class */
function () {
  function ObjectDetection(score, classScore, className, relativeBox, imageDims) {
    this._imageDims = new _Dimensions.Dimensions(imageDims.width, imageDims.height);
    this._score = score;
    this._classScore = classScore;
    this._className = className;
    this._box = new _Box.Box(relativeBox).rescale(this._imageDims);
  }

  Object.defineProperty(ObjectDetection.prototype, "score", {
    get: function () {
      return this._score;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ObjectDetection.prototype, "classScore", {
    get: function () {
      return this._classScore;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ObjectDetection.prototype, "className", {
    get: function () {
      return this._className;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ObjectDetection.prototype, "box", {
    get: function () {
      return this._box;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ObjectDetection.prototype, "imageDims", {
    get: function () {
      return this._imageDims;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ObjectDetection.prototype, "imageWidth", {
    get: function () {
      return this.imageDims.width;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ObjectDetection.prototype, "imageHeight", {
    get: function () {
      return this.imageDims.height;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ObjectDetection.prototype, "relativeBox", {
    get: function () {
      return new _Box.Box(this._box).rescale(this.imageDims.reverse());
    },
    enumerable: true,
    configurable: true
  });

  ObjectDetection.prototype.forSize = function (width, height) {
    return new ObjectDetection(this.score, this.classScore, this.className, this.relativeBox, {
      width: width,
      height: height
    });
  };

  return ObjectDetection;
}();

exports.ObjectDetection = ObjectDetection;
},{"./Box":"node_modules/face-api.js/build/es6/classes/Box.js","./Dimensions":"node_modules/face-api.js/build/es6/classes/Dimensions.js"}],"node_modules/face-api.js/build/es6/classes/FaceDetection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceDetection = void 0;

var _tslib = require("tslib");

var _ObjectDetection = require("./ObjectDetection");

var FaceDetection =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceDetection, _super);

  function FaceDetection(score, relativeBox, imageDims) {
    return _super.call(this, score, score, '', relativeBox, imageDims) || this;
  }

  FaceDetection.prototype.forSize = function (width, height) {
    var _a = _super.prototype.forSize.call(this, width, height),
        score = _a.score,
        relativeBox = _a.relativeBox,
        imageDims = _a.imageDims;

    return new FaceDetection(score, relativeBox, imageDims);
  };

  return FaceDetection;
}(_ObjectDetection.ObjectDetection);

exports.FaceDetection = FaceDetection;
},{"tslib":"node_modules/tslib/tslib.es6.js","./ObjectDetection":"node_modules/face-api.js/build/es6/classes/ObjectDetection.js"}],"node_modules/face-api.js/build/es6/ops/iou.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iou = iou;

function iou(box1, box2, isIOU) {
  if (isIOU === void 0) {
    isIOU = true;
  }

  var width = Math.max(0.0, Math.min(box1.right, box2.right) - Math.max(box1.left, box2.left));
  var height = Math.max(0.0, Math.min(box1.bottom, box2.bottom) - Math.max(box1.top, box2.top));
  var interSection = width * height;
  return isIOU ? interSection / (box1.area + box2.area - interSection) : interSection / Math.min(box1.area, box2.area);
}
},{}],"node_modules/face-api.js/build/es6/ops/minBbox.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.minBbox = minBbox;

var _classes = require("../classes");

function minBbox(pts) {
  var xs = pts.map(function (pt) {
    return pt.x;
  });
  var ys = pts.map(function (pt) {
    return pt.y;
  });
  var minX = xs.reduce(function (min, x) {
    return x < min ? x : min;
  }, Infinity);
  var minY = ys.reduce(function (min, y) {
    return y < min ? y : min;
  }, Infinity);
  var maxX = xs.reduce(function (max, x) {
    return max < x ? x : max;
  }, 0);
  var maxY = ys.reduce(function (max, y) {
    return max < y ? y : max;
  }, 0);
  return new _classes.BoundingBox(minX, minY, maxX, maxY);
}
},{"../classes":"node_modules/face-api.js/build/es6/classes/index.js"}],"node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nonMaxSuppression = nonMaxSuppression;

var _iou = require("./iou");

function nonMaxSuppression(boxes, scores, iouThreshold, isIOU) {
  if (isIOU === void 0) {
    isIOU = true;
  }

  var indicesSortedByScore = scores.map(function (score, boxIndex) {
    return {
      score: score,
      boxIndex: boxIndex
    };
  }).sort(function (c1, c2) {
    return c1.score - c2.score;
  }).map(function (c) {
    return c.boxIndex;
  });
  var pick = [];

  var _loop_1 = function () {
    var curr = indicesSortedByScore.pop();
    pick.push(curr);
    var indices = indicesSortedByScore;
    var outputs = [];

    for (var i = 0; i < indices.length; i++) {
      var idx = indices[i];
      var currBox = boxes[curr];
      var idxBox = boxes[idx];
      outputs.push((0, _iou.iou)(currBox, idxBox, isIOU));
    }

    indicesSortedByScore = indicesSortedByScore.filter(function (_, j) {
      return outputs[j] <= iouThreshold;
    });
  };

  while (indicesSortedByScore.length > 0) {
    _loop_1();
  }

  return pick;
}
},{"./iou":"node_modules/face-api.js/build/es6/ops/iou.js"}],"node_modules/face-api.js/build/es6/ops/normalize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalize = normalize;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function normalize(x, meanRgb) {
  return tf.tidy(function () {
    var r = meanRgb[0],
        g = meanRgb[1],
        b = meanRgb[2];
    var avg_r = tf.fill((0, _tslib.__spreadArrays)(x.shape.slice(0, 3), [1]), r);
    var avg_g = tf.fill((0, _tslib.__spreadArrays)(x.shape.slice(0, 3), [1]), g);
    var avg_b = tf.fill((0, _tslib.__spreadArrays)(x.shape.slice(0, 3), [1]), b);
    var avg_rgb = tf.concat([avg_r, avg_g, avg_b], 3);
    return tf.sub(x, avg_rgb);
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/ops/padToSquare.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padToSquare = padToSquare;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Pads the smaller dimension of an image tensor with zeros, such that width === height.
 *
 * @param imgTensor The image tensor.
 * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on
 * both sides of the minor dimension oof the image.
 * @returns The padded tensor with width === height.
 */
function padToSquare(imgTensor, isCenterImage) {
  if (isCenterImage === void 0) {
    isCenterImage = false;
  }

  return tf.tidy(function () {
    var _a = imgTensor.shape.slice(1),
        height = _a[0],
        width = _a[1];

    if (height === width) {
      return imgTensor;
    }

    var dimDiff = Math.abs(height - width);
    var paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));
    var paddingAxis = height > width ? 2 : 1;

    var createPaddingTensor = function (paddingAmount) {
      var paddingTensorShape = imgTensor.shape.slice();
      paddingTensorShape[paddingAxis] = paddingAmount;
      return tf.fill(paddingTensorShape, 0);
    };

    var paddingTensorAppend = createPaddingTensor(paddingAmount);
    var remainingPaddingAmount = dimDiff - paddingTensorAppend.shape[paddingAxis];
    var paddingTensorPrepend = isCenterImage && remainingPaddingAmount ? createPaddingTensor(remainingPaddingAmount) : null;
    var tensorsToStack = [paddingTensorPrepend, imgTensor, paddingTensorAppend].filter(function (t) {
      return !!t;
    }).map(function (t) {
      return t.toFloat();
    });
    return tf.concat(tensorsToStack, paddingAxis);
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/ops/shuffleArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shuffleArray = shuffleArray;

function shuffleArray(inputArray) {
  var array = inputArray.slice();

  for (var i = array.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var x = array[i];
    array[i] = array[j];
    array[j] = x;
  }

  return array;
}
},{}],"node_modules/face-api.js/build/es6/ops/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  sigmoid: true,
  inverseSigmoid: true
};
exports.sigmoid = sigmoid;
exports.inverseSigmoid = inverseSigmoid;

var _iou = require("./iou");

Object.keys(_iou).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _iou[key];
    }
  });
});

var _minBbox = require("./minBbox");

Object.keys(_minBbox).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minBbox[key];
    }
  });
});

var _nonMaxSuppression = require("./nonMaxSuppression");

Object.keys(_nonMaxSuppression).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nonMaxSuppression[key];
    }
  });
});

var _normalize = require("./normalize");

Object.keys(_normalize).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _normalize[key];
    }
  });
});

var _padToSquare = require("./padToSquare");

Object.keys(_padToSquare).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _padToSquare[key];
    }
  });
});

var _shuffleArray = require("./shuffleArray");

Object.keys(_shuffleArray).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _shuffleArray[key];
    }
  });
});

function sigmoid(x) {
  return 1 / (1 + Math.exp(-x));
}

function inverseSigmoid(x) {
  return Math.log(x / (1 - x));
}
},{"./iou":"node_modules/face-api.js/build/es6/ops/iou.js","./minBbox":"node_modules/face-api.js/build/es6/ops/minBbox.js","./nonMaxSuppression":"node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js","./normalize":"node_modules/face-api.js/build/es6/ops/normalize.js","./padToSquare":"node_modules/face-api.js/build/es6/ops/padToSquare.js","./shuffleArray":"node_modules/face-api.js/build/es6/ops/shuffleArray.js"}],"node_modules/face-api.js/build/es6/classes/Rect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rect = void 0;

var _tslib = require("tslib");

var _Box = require("./Box");

var Rect =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Rect, _super);

  function Rect(x, y, width, height, allowNegativeDimensions) {
    if (allowNegativeDimensions === void 0) {
      allowNegativeDimensions = false;
    }

    return _super.call(this, {
      x: x,
      y: y,
      width: width,
      height: height
    }, allowNegativeDimensions) || this;
  }

  return Rect;
}(_Box.Box);

exports.Rect = Rect;
},{"tslib":"node_modules/tslib/tslib.es6.js","./Box":"node_modules/face-api.js/build/es6/classes/Box.js"}],"node_modules/face-api.js/build/es6/classes/FaceLandmarks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceLandmarks = void 0;

var _ops = require("../ops");

var _utils = require("../utils");

var _Box = require("./Box");

var _Dimensions = require("./Dimensions");

var _FaceDetection = require("./FaceDetection");

var _Point = require("./Point");

var _Rect = require("./Rect");

// face alignment constants
var relX = 0.5;
var relY = 0.43;
var relScale = 0.45;

var FaceLandmarks =
/** @class */
function () {
  function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {
    if (shift === void 0) {
      shift = new _Point.Point(0, 0);
    }

    var width = imgDims.width,
        height = imgDims.height;
    this._imgDims = new _Dimensions.Dimensions(width, height);
    this._shift = shift;
    this._positions = relativeFaceLandmarkPositions.map(function (pt) {
      return pt.mul(new _Point.Point(width, height)).add(shift);
    });
  }

  Object.defineProperty(FaceLandmarks.prototype, "shift", {
    get: function () {
      return new _Point.Point(this._shift.x, this._shift.y);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FaceLandmarks.prototype, "imageWidth", {
    get: function () {
      return this._imgDims.width;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FaceLandmarks.prototype, "imageHeight", {
    get: function () {
      return this._imgDims.height;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FaceLandmarks.prototype, "positions", {
    get: function () {
      return this._positions;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FaceLandmarks.prototype, "relativePositions", {
    get: function () {
      var _this = this;

      return this._positions.map(function (pt) {
        return pt.sub(_this._shift).div(new _Point.Point(_this.imageWidth, _this.imageHeight));
      });
    },
    enumerable: true,
    configurable: true
  });

  FaceLandmarks.prototype.forSize = function (width, height) {
    return new this.constructor(this.relativePositions, {
      width: width,
      height: height
    });
  };

  FaceLandmarks.prototype.shiftBy = function (x, y) {
    return new this.constructor(this.relativePositions, this._imgDims, new _Point.Point(x, y));
  };

  FaceLandmarks.prototype.shiftByPoint = function (pt) {
    return this.shiftBy(pt.x, pt.y);
  };
  /**
   * Aligns the face landmarks after face detection from the relative positions of the faces
   * bounding box, or it's current shift. This function should be used to align the face images
   * after face detection has been performed, before they are passed to the face recognition net.
   * This will make the computed face descriptor more accurate.
   *
   * @param detection (optional) The bounding box of the face or the face detection result. If
   * no argument was passed the position of the face landmarks are assumed to be relative to
   * it's current shift.
   * @returns The bounding box of the aligned face.
   */


  FaceLandmarks.prototype.align = function (detection, options) {
    if (options === void 0) {
      options = {};
    }

    if (detection) {
      var box = detection instanceof _FaceDetection.FaceDetection ? detection.box.floor() : new _Box.Box(detection);
      return this.shiftBy(box.x, box.y).align(null, options);
    }

    var _a = Object.assign({}, {
      useDlibAlignment: false,
      minBoxPadding: 0.2
    }, options),
        useDlibAlignment = _a.useDlibAlignment,
        minBoxPadding = _a.minBoxPadding;

    if (useDlibAlignment) {
      return this.alignDlib();
    }

    return this.alignMinBbox(minBoxPadding);
  };

  FaceLandmarks.prototype.alignDlib = function () {
    var centers = this.getRefPointsForAlignment();
    var leftEyeCenter = centers[0],
        rightEyeCenter = centers[1],
        mouthCenter = centers[2];

    var distToMouth = function (pt) {
      return mouthCenter.sub(pt).magnitude();
    };

    var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;
    var size = Math.floor(eyeToMouthDist / relScale);
    var refPoint = (0, _utils.getCenterPoint)(centers); // TODO: pad in case rectangle is out of image bounds

    var x = Math.floor(Math.max(0, refPoint.x - relX * size));
    var y = Math.floor(Math.max(0, refPoint.y - relY * size));
    return new _Rect.Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));
  };

  FaceLandmarks.prototype.alignMinBbox = function (padding) {
    var box = (0, _ops.minBbox)(this.positions);
    return box.pad(box.width * padding, box.height * padding);
  };

  FaceLandmarks.prototype.getRefPointsForAlignment = function () {
    throw new Error('getRefPointsForAlignment not implemented by base class');
  };

  return FaceLandmarks;
}();

exports.FaceLandmarks = FaceLandmarks;
},{"../ops":"node_modules/face-api.js/build/es6/ops/index.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./Box":"node_modules/face-api.js/build/es6/classes/Box.js","./Dimensions":"node_modules/face-api.js/build/es6/classes/Dimensions.js","./FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js","./Point":"node_modules/face-api.js/build/es6/classes/Point.js","./Rect":"node_modules/face-api.js/build/es6/classes/Rect.js"}],"node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceLandmarks5 = void 0;

var _tslib = require("tslib");

var _utils = require("../utils");

var _FaceLandmarks = require("./FaceLandmarks");

var FaceLandmarks5 =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceLandmarks5, _super);

  function FaceLandmarks5() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  FaceLandmarks5.prototype.getRefPointsForAlignment = function () {
    var pts = this.positions;
    return [pts[0], pts[1], (0, _utils.getCenterPoint)([pts[3], pts[4]])];
  };

  return FaceLandmarks5;
}(_FaceLandmarks.FaceLandmarks);

exports.FaceLandmarks5 = FaceLandmarks5;
},{"tslib":"node_modules/tslib/tslib.es6.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./FaceLandmarks":"node_modules/face-api.js/build/es6/classes/FaceLandmarks.js"}],"node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceLandmarks68 = void 0;

var _tslib = require("tslib");

var _utils = require("../utils");

var _FaceLandmarks = require("./FaceLandmarks");

var FaceLandmarks68 =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceLandmarks68, _super);

  function FaceLandmarks68() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  FaceLandmarks68.prototype.getJawOutline = function () {
    return this.positions.slice(0, 17);
  };

  FaceLandmarks68.prototype.getLeftEyeBrow = function () {
    return this.positions.slice(17, 22);
  };

  FaceLandmarks68.prototype.getRightEyeBrow = function () {
    return this.positions.slice(22, 27);
  };

  FaceLandmarks68.prototype.getNose = function () {
    return this.positions.slice(27, 36);
  };

  FaceLandmarks68.prototype.getLeftEye = function () {
    return this.positions.slice(36, 42);
  };

  FaceLandmarks68.prototype.getRightEye = function () {
    return this.positions.slice(42, 48);
  };

  FaceLandmarks68.prototype.getMouth = function () {
    return this.positions.slice(48, 68);
  };

  FaceLandmarks68.prototype.getRefPointsForAlignment = function () {
    return [this.getLeftEye(), this.getRightEye(), this.getMouth()].map(_utils.getCenterPoint);
  };

  return FaceLandmarks68;
}(_FaceLandmarks.FaceLandmarks);

exports.FaceLandmarks68 = FaceLandmarks68;
},{"tslib":"node_modules/tslib/tslib.es6.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./FaceLandmarks":"node_modules/face-api.js/build/es6/classes/FaceLandmarks.js"}],"node_modules/face-api.js/build/es6/classes/FaceMatch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceMatch = void 0;

var _utils = require("../utils");

var FaceMatch =
/** @class */
function () {
  function FaceMatch(label, distance) {
    this._label = label;
    this._distance = distance;
  }

  Object.defineProperty(FaceMatch.prototype, "label", {
    get: function () {
      return this._label;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FaceMatch.prototype, "distance", {
    get: function () {
      return this._distance;
    },
    enumerable: true,
    configurable: true
  });

  FaceMatch.prototype.toString = function (withDistance) {
    if (withDistance === void 0) {
      withDistance = true;
    }

    return "" + this.label + (withDistance ? " (" + (0, _utils.round)(this.distance) + ")" : '');
  };

  return FaceMatch;
}();

exports.FaceMatch = FaceMatch;
},{"../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/classes/LabeledBox.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LabeledBox = void 0;

var _tslib = require("tslib");

var _utils = require("../utils");

var _Box = require("./Box");

var LabeledBox =
/** @class */
function (_super) {
  (0, _tslib.__extends)(LabeledBox, _super);

  function LabeledBox(box, label) {
    var _this = _super.call(this, box) || this;

    _this._label = label;
    return _this;
  }

  LabeledBox.assertIsValidLabeledBox = function (box, callee) {
    _Box.Box.assertIsValidBox(box, callee);

    if (!(0, _utils.isValidNumber)(box.label)) {
      throw new Error(callee + " - expected property label (" + box.label + ") to be a number");
    }
  };

  Object.defineProperty(LabeledBox.prototype, "label", {
    get: function () {
      return this._label;
    },
    enumerable: true,
    configurable: true
  });
  return LabeledBox;
}(_Box.Box);

exports.LabeledBox = LabeledBox;
},{"tslib":"node_modules/tslib/tslib.es6.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./Box":"node_modules/face-api.js/build/es6/classes/Box.js"}],"node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LabeledFaceDescriptors = void 0;

var LabeledFaceDescriptors =
/** @class */
function () {
  function LabeledFaceDescriptors(label, descriptors) {
    if (!(typeof label === 'string')) {
      throw new Error('LabeledFaceDescriptors - constructor expected label to be a string');
    }

    if (!Array.isArray(descriptors) || descriptors.some(function (desc) {
      return !(desc instanceof Float32Array);
    })) {
      throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array');
    }

    this._label = label;
    this._descriptors = descriptors;
  }

  Object.defineProperty(LabeledFaceDescriptors.prototype, "label", {
    get: function () {
      return this._label;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(LabeledFaceDescriptors.prototype, "descriptors", {
    get: function () {
      return this._descriptors;
    },
    enumerable: true,
    configurable: true
  });

  LabeledFaceDescriptors.prototype.toJSON = function () {
    return {
      label: this.label,
      descriptors: this.descriptors.map(function (d) {
        return Array.from(d);
      })
    };
  };

  LabeledFaceDescriptors.fromJSON = function (json) {
    var descriptors = json.descriptors.map(function (d) {
      return new Float32Array(d);
    });
    return new LabeledFaceDescriptors(json.label, descriptors);
  };

  return LabeledFaceDescriptors;
}();

exports.LabeledFaceDescriptors = LabeledFaceDescriptors;
},{}],"node_modules/face-api.js/build/es6/classes/PredictedBox.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictedBox = void 0;

var _tslib = require("tslib");

var _utils = require("../utils");

var _LabeledBox = require("./LabeledBox");

var PredictedBox =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictedBox, _super);

  function PredictedBox(box, label, score, classScore) {
    var _this = _super.call(this, box, label) || this;

    _this._score = score;
    _this._classScore = classScore;
    return _this;
  }

  PredictedBox.assertIsValidPredictedBox = function (box, callee) {
    _LabeledBox.LabeledBox.assertIsValidLabeledBox(box, callee);

    if (!(0, _utils.isValidProbablitiy)(box.score) || !(0, _utils.isValidProbablitiy)(box.classScore)) {
      throw new Error(callee + " - expected properties score (" + box.score + ") and (" + box.classScore + ") to be a number between [0, 1]");
    }
  };

  Object.defineProperty(PredictedBox.prototype, "score", {
    get: function () {
      return this._score;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(PredictedBox.prototype, "classScore", {
    get: function () {
      return this._classScore;
    },
    enumerable: true,
    configurable: true
  });
  return PredictedBox;
}(_LabeledBox.LabeledBox);

exports.PredictedBox = PredictedBox;
},{"tslib":"node_modules/tslib/tslib.es6.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./LabeledBox":"node_modules/face-api.js/build/es6/classes/LabeledBox.js"}],"node_modules/face-api.js/build/es6/classes/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _BoundingBox = require("./BoundingBox");

Object.keys(_BoundingBox).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _BoundingBox[key];
    }
  });
});

var _Box = require("./Box");

Object.keys(_Box).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Box[key];
    }
  });
});

var _Dimensions = require("./Dimensions");

Object.keys(_Dimensions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Dimensions[key];
    }
  });
});

var _FaceDetection = require("./FaceDetection");

Object.keys(_FaceDetection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceDetection[key];
    }
  });
});

var _FaceLandmarks = require("./FaceLandmarks");

Object.keys(_FaceLandmarks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceLandmarks[key];
    }
  });
});

var _FaceLandmarks2 = require("./FaceLandmarks5");

Object.keys(_FaceLandmarks2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceLandmarks2[key];
    }
  });
});

var _FaceLandmarks3 = require("./FaceLandmarks68");

Object.keys(_FaceLandmarks3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceLandmarks3[key];
    }
  });
});

var _FaceMatch = require("./FaceMatch");

Object.keys(_FaceMatch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceMatch[key];
    }
  });
});

var _LabeledBox = require("./LabeledBox");

Object.keys(_LabeledBox).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _LabeledBox[key];
    }
  });
});

var _LabeledFaceDescriptors = require("./LabeledFaceDescriptors");

Object.keys(_LabeledFaceDescriptors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _LabeledFaceDescriptors[key];
    }
  });
});

var _ObjectDetection = require("./ObjectDetection");

Object.keys(_ObjectDetection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ObjectDetection[key];
    }
  });
});

var _Point = require("./Point");

Object.keys(_Point).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Point[key];
    }
  });
});

var _PredictedBox = require("./PredictedBox");

Object.keys(_PredictedBox).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PredictedBox[key];
    }
  });
});

var _Rect = require("./Rect");

Object.keys(_Rect).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Rect[key];
    }
  });
});
},{"./BoundingBox":"node_modules/face-api.js/build/es6/classes/BoundingBox.js","./Box":"node_modules/face-api.js/build/es6/classes/Box.js","./Dimensions":"node_modules/face-api.js/build/es6/classes/Dimensions.js","./FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js","./FaceLandmarks":"node_modules/face-api.js/build/es6/classes/FaceLandmarks.js","./FaceLandmarks5":"node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js","./FaceLandmarks68":"node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js","./FaceMatch":"node_modules/face-api.js/build/es6/classes/FaceMatch.js","./LabeledBox":"node_modules/face-api.js/build/es6/classes/LabeledBox.js","./LabeledFaceDescriptors":"node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js","./ObjectDetection":"node_modules/face-api.js/build/es6/classes/ObjectDetection.js","./Point":"node_modules/face-api.js/build/es6/classes/Point.js","./PredictedBox":"node_modules/face-api.js/build/es6/classes/PredictedBox.js","./Rect":"node_modules/face-api.js/build/es6/classes/Rect.js"}],"node_modules/face-api.js/build/es6/factories/WithFaceDetection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWithFaceDetection = isWithFaceDetection;
exports.extendWithFaceDetection = extendWithFaceDetection;

var _FaceDetection = require("../classes/FaceDetection");

function isWithFaceDetection(obj) {
  return obj['detection'] instanceof _FaceDetection.FaceDetection;
}

function extendWithFaceDetection(sourceObj, detection) {
  var extension = {
    detection: detection
  };
  return Object.assign({}, sourceObj, extension);
}
},{"../classes/FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js"}],"node_modules/face-api.js/build/es6/env/createBrowserEnv.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBrowserEnv = createBrowserEnv;

function createBrowserEnv() {
  var fetch = window['fetch'] || function () {
    throw new Error('fetch - missing fetch implementation for browser environment');
  };

  var readFile = function () {
    throw new Error('readFile - filesystem not available for browser environment');
  };

  return {
    Canvas: HTMLCanvasElement,
    CanvasRenderingContext2D: CanvasRenderingContext2D,
    Image: HTMLImageElement,
    ImageData: ImageData,
    Video: HTMLVideoElement,
    createCanvasElement: function () {
      return document.createElement('canvas');
    },
    createImageElement: function () {
      return document.createElement('img');
    },
    fetch: fetch,
    readFile: readFile
  };
}
},{}],"node_modules/face-api.js/build/es6/env/createFileSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFileSystem = createFileSystem;

function createFileSystem(fs) {
  var requireFsError = '';

  if (!fs) {
    try {
      fs = require('fs');
    } catch (err) {
      requireFsError = err.toString();
    }
  }

  var readFile = fs ? function (filePath) {
    return new Promise(function (res, rej) {
      fs.readFile(filePath, function (err, buffer) {
        return err ? rej(err) : res(buffer);
      });
    });
  } : function () {
    throw new Error("readFile - failed to require fs in nodejs environment with error: " + requireFsError);
  };
  return {
    readFile: readFile
  };
}
},{"fs":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/face-api.js/build/es6/env/createNodejsEnv.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNodejsEnv = createNodejsEnv;

var _tslib = require("tslib");

var _createFileSystem = require("./createFileSystem");

function createNodejsEnv() {
  var Canvas = global['Canvas'] || global['HTMLCanvasElement'];
  var Image = global['Image'] || global['HTMLImageElement'];

  var createCanvasElement = function () {
    if (Canvas) {
      return new Canvas();
    }

    throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment');
  };

  var createImageElement = function () {
    if (Image) {
      return new Image();
    }

    throw new Error('createImageElement - missing Image implementation for nodejs environment');
  };

  var fetch = global['fetch'] || function () {
    throw new Error('fetch - missing fetch implementation for nodejs environment');
  };

  var fileSystem = (0, _createFileSystem.createFileSystem)();
  return (0, _tslib.__assign)({
    Canvas: Canvas ||
    /** @class */
    function () {
      function Canvas() {}

      return Canvas;
    }(),
    CanvasRenderingContext2D: global['CanvasRenderingContext2D'] ||
    /** @class */
    function () {
      function class_1() {}

      return class_1;
    }(),
    Image: Image ||
    /** @class */
    function () {
      function Image() {}

      return Image;
    }(),
    ImageData: global['ImageData'] ||
    /** @class */
    function () {
      function class_2() {}

      return class_2;
    }(),
    Video: global['HTMLVideoElement'] ||
    /** @class */
    function () {
      function class_3() {}

      return class_3;
    }(),
    createCanvasElement: createCanvasElement,
    createImageElement: createImageElement,
    fetch: fetch
  }, fileSystem);
}
},{"tslib":"node_modules/tslib/tslib.es6.js","./createFileSystem":"node_modules/face-api.js/build/es6/env/createFileSystem.js"}],"node_modules/face-api.js/build/es6/env/isBrowser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBrowser = isBrowser;

function isBrowser() {
  return typeof window === 'object' && typeof document !== 'undefined' && typeof HTMLImageElement !== 'undefined' && typeof HTMLCanvasElement !== 'undefined' && typeof HTMLVideoElement !== 'undefined' && typeof ImageData !== 'undefined' && typeof CanvasRenderingContext2D !== 'undefined';
}
},{}],"node_modules/face-api.js/build/es6/env/isNodejs.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNodejs = isNodejs;

function isNodejs() {
  return typeof global === 'object' && typeof require === 'function' && typeof module !== 'undefined' // issues with gatsby.js: module.exports is undefined
  // && !!module.exports
  && typeof process !== 'undefined' && !!process.version;
}
},{"process":"node_modules/process/browser.js"}],"node_modules/face-api.js/build/es6/env/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.env = void 0;

var _createBrowserEnv = require("./createBrowserEnv");

var _createFileSystem = require("./createFileSystem");

var _createNodejsEnv = require("./createNodejsEnv");

var _isBrowser = require("./isBrowser");

var _isNodejs = require("./isNodejs");

var environment;

function getEnv() {
  if (!environment) {
    throw new Error('getEnv - environment is not defined, check isNodejs() and isBrowser()');
  }

  return environment;
}

function setEnv(env) {
  environment = env;
}

function initialize() {
  // check for isBrowser() first to prevent electron renderer process
  // to be initialized with wrong environment due to isNodejs() returning true
  if ((0, _isBrowser.isBrowser)()) {
    setEnv((0, _createBrowserEnv.createBrowserEnv)());
  }

  if ((0, _isNodejs.isNodejs)()) {
    setEnv((0, _createNodejsEnv.createNodejsEnv)());
  }
}

function monkeyPatch(env) {
  if (!environment) {
    initialize();
  }

  if (!environment) {
    throw new Error('monkeyPatch - environment is not defined, check isNodejs() and isBrowser()');
  }

  var _a = env.Canvas,
      Canvas = _a === void 0 ? environment.Canvas : _a,
      _b = env.Image,
      Image = _b === void 0 ? environment.Image : _b;
  environment.Canvas = Canvas;
  environment.Image = Image;

  environment.createCanvasElement = env.createCanvasElement || function () {
    return new Canvas();
  };

  environment.createImageElement = env.createImageElement || function () {
    return new Image();
  };

  environment.ImageData = env.ImageData || environment.ImageData;
  environment.Video = env.Video || environment.Video;
  environment.fetch = env.fetch || environment.fetch;
  environment.readFile = env.readFile || environment.readFile;
}

var env = {
  getEnv: getEnv,
  setEnv: setEnv,
  initialize: initialize,
  createBrowserEnv: _createBrowserEnv.createBrowserEnv,
  createFileSystem: _createFileSystem.createFileSystem,
  createNodejsEnv: _createNodejsEnv.createNodejsEnv,
  monkeyPatch: monkeyPatch,
  isBrowser: _isBrowser.isBrowser,
  isNodejs: _isNodejs.isNodejs
};
exports.env = env;
initialize();
},{"./createBrowserEnv":"node_modules/face-api.js/build/es6/env/createBrowserEnv.js","./createFileSystem":"node_modules/face-api.js/build/es6/env/createFileSystem.js","./createNodejsEnv":"node_modules/face-api.js/build/es6/env/createNodejsEnv.js","./isBrowser":"node_modules/face-api.js/build/es6/env/isBrowser.js","./isNodejs":"node_modules/face-api.js/build/es6/env/isNodejs.js"}],"node_modules/face-api.js/build/es6/dom/resolveInput.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveInput = resolveInput;

var _env = require("../env");

function resolveInput(arg) {
  if (!_env.env.isNodejs() && typeof arg === 'string') {
    return document.getElementById(arg);
  }

  return arg;
}
},{"../env":"node_modules/face-api.js/build/es6/env/index.js"}],"node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContext2dOrThrow = getContext2dOrThrow;

var _env = require("../env");

var _resolveInput = require("./resolveInput");

function getContext2dOrThrow(canvasArg) {
  var _a = _env.env.getEnv(),
      Canvas = _a.Canvas,
      CanvasRenderingContext2D = _a.CanvasRenderingContext2D;

  if (canvasArg instanceof CanvasRenderingContext2D) {
    return canvasArg;
  }

  var canvas = (0, _resolveInput.resolveInput)(canvasArg);

  if (!(canvas instanceof Canvas)) {
    throw new Error('resolveContext2d - expected canvas to be of instance of Canvas');
  }

  var ctx = canvas.getContext('2d');

  if (!ctx) {
    throw new Error('resolveContext2d - canvas 2d context is null');
  }

  return ctx;
}
},{"../env":"node_modules/face-api.js/build/es6/env/index.js","./resolveInput":"node_modules/face-api.js/build/es6/dom/resolveInput.js"}],"node_modules/face-api.js/build/es6/draw/DrawTextField.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawTextField = exports.DrawTextFieldOptions = exports.AnchorPosition = void 0;

var _getContext2dOrThrow = require("../dom/getContext2dOrThrow");

var _resolveInput = require("../dom/resolveInput");

var AnchorPosition;
exports.AnchorPosition = AnchorPosition;

(function (AnchorPosition) {
  AnchorPosition["TOP_LEFT"] = "TOP_LEFT";
  AnchorPosition["TOP_RIGHT"] = "TOP_RIGHT";
  AnchorPosition["BOTTOM_LEFT"] = "BOTTOM_LEFT";
  AnchorPosition["BOTTOM_RIGHT"] = "BOTTOM_RIGHT";
})(AnchorPosition || (exports.AnchorPosition = AnchorPosition = {}));

var DrawTextFieldOptions =
/** @class */
function () {
  function DrawTextFieldOptions(options) {
    if (options === void 0) {
      options = {};
    }

    var anchorPosition = options.anchorPosition,
        backgroundColor = options.backgroundColor,
        fontColor = options.fontColor,
        fontSize = options.fontSize,
        fontStyle = options.fontStyle,
        padding = options.padding;
    this.anchorPosition = anchorPosition || AnchorPosition.TOP_LEFT;
    this.backgroundColor = backgroundColor || 'rgba(0, 0, 0, 0.5)';
    this.fontColor = fontColor || 'rgba(255, 255, 255, 1)';
    this.fontSize = fontSize || 14;
    this.fontStyle = fontStyle || 'Georgia';
    this.padding = padding || 4;
  }

  return DrawTextFieldOptions;
}();

exports.DrawTextFieldOptions = DrawTextFieldOptions;

var DrawTextField =
/** @class */
function () {
  function DrawTextField(text, anchor, options) {
    if (options === void 0) {
      options = {};
    }

    this.text = typeof text === 'string' ? [text] : text instanceof DrawTextField ? text.text : text;
    this.anchor = anchor;
    this.options = new DrawTextFieldOptions(options);
  }

  DrawTextField.prototype.measureWidth = function (ctx) {
    var padding = this.options.padding;
    return this.text.map(function (l) {
      return ctx.measureText(l).width;
    }).reduce(function (w0, w1) {
      return w0 < w1 ? w1 : w0;
    }, 0) + 2 * padding;
  };

  DrawTextField.prototype.measureHeight = function () {
    var _a = this.options,
        fontSize = _a.fontSize,
        padding = _a.padding;
    return this.text.length * fontSize + 2 * padding;
  };

  DrawTextField.prototype.getUpperLeft = function (ctx, canvasDims) {
    var anchorPosition = this.options.anchorPosition;
    var isShiftLeft = anchorPosition === AnchorPosition.BOTTOM_RIGHT || anchorPosition === AnchorPosition.TOP_RIGHT;
    var isShiftTop = anchorPosition === AnchorPosition.BOTTOM_LEFT || anchorPosition === AnchorPosition.BOTTOM_RIGHT;
    var textFieldWidth = this.measureWidth(ctx);
    var textFieldHeight = this.measureHeight();
    var x = isShiftLeft ? this.anchor.x - textFieldWidth : this.anchor.x;
    var y = isShiftTop ? this.anchor.y - textFieldHeight : this.anchor.y; // adjust anchor if text box exceeds canvas borders

    if (canvasDims) {
      var width = canvasDims.width,
          height = canvasDims.height;
      var newX = Math.max(Math.min(x, width - textFieldWidth), 0);
      var newY = Math.max(Math.min(y, height - textFieldHeight), 0);
      return {
        x: newX,
        y: newY
      };
    }

    return {
      x: x,
      y: y
    };
  };

  DrawTextField.prototype.draw = function (canvasArg) {
    var canvas = (0, _resolveInput.resolveInput)(canvasArg);
    var ctx = (0, _getContext2dOrThrow.getContext2dOrThrow)(canvas);
    var _a = this.options,
        backgroundColor = _a.backgroundColor,
        fontColor = _a.fontColor,
        fontSize = _a.fontSize,
        fontStyle = _a.fontStyle,
        padding = _a.padding;
    ctx.font = fontSize + "px " + fontStyle;
    var maxTextWidth = this.measureWidth(ctx);
    var textHeight = this.measureHeight();
    ctx.fillStyle = backgroundColor;
    var upperLeft = this.getUpperLeft(ctx, canvas);
    ctx.fillRect(upperLeft.x, upperLeft.y, maxTextWidth, textHeight);
    ctx.fillStyle = fontColor;
    this.text.forEach(function (textLine, i) {
      var x = padding + upperLeft.x;
      var y = padding + upperLeft.y + (i + 1) * fontSize;
      ctx.fillText(textLine, x, y);
    });
  };

  return DrawTextField;
}();

exports.DrawTextField = DrawTextField;
},{"../dom/getContext2dOrThrow":"node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js","../dom/resolveInput":"node_modules/face-api.js/build/es6/dom/resolveInput.js"}],"node_modules/face-api.js/build/es6/draw/DrawBox.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawBox = exports.DrawBoxOptions = void 0;

var _classes = require("../classes");

var _getContext2dOrThrow = require("../dom/getContext2dOrThrow");

var _DrawTextField = require("./DrawTextField");

var DrawBoxOptions =
/** @class */
function () {
  function DrawBoxOptions(options) {
    if (options === void 0) {
      options = {};
    }

    var boxColor = options.boxColor,
        lineWidth = options.lineWidth,
        label = options.label,
        drawLabelOptions = options.drawLabelOptions;
    this.boxColor = boxColor || 'rgba(0, 0, 255, 1)';
    this.lineWidth = lineWidth || 2;
    this.label = label;
    var defaultDrawLabelOptions = {
      anchorPosition: _DrawTextField.AnchorPosition.BOTTOM_LEFT,
      backgroundColor: this.boxColor
    };
    this.drawLabelOptions = new _DrawTextField.DrawTextFieldOptions(Object.assign({}, defaultDrawLabelOptions, drawLabelOptions));
  }

  return DrawBoxOptions;
}();

exports.DrawBoxOptions = DrawBoxOptions;

var DrawBox =
/** @class */
function () {
  function DrawBox(box, options) {
    if (options === void 0) {
      options = {};
    }

    this.box = new _classes.Box(box);
    this.options = new DrawBoxOptions(options);
  }

  DrawBox.prototype.draw = function (canvasArg) {
    var ctx = (0, _getContext2dOrThrow.getContext2dOrThrow)(canvasArg);
    var _a = this.options,
        boxColor = _a.boxColor,
        lineWidth = _a.lineWidth;
    var _b = this.box,
        x = _b.x,
        y = _b.y,
        width = _b.width,
        height = _b.height;
    ctx.strokeStyle = boxColor;
    ctx.lineWidth = lineWidth;
    ctx.strokeRect(x, y, width, height);
    var label = this.options.label;

    if (label) {
      new _DrawTextField.DrawTextField([label], {
        x: x - lineWidth / 2,
        y: y
      }, this.options.drawLabelOptions).draw(canvasArg);
    }
  };

  return DrawBox;
}();

exports.DrawBox = DrawBox;
},{"../classes":"node_modules/face-api.js/build/es6/classes/index.js","../dom/getContext2dOrThrow":"node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js","./DrawTextField":"node_modules/face-api.js/build/es6/draw/DrawTextField.js"}],"node_modules/face-api.js/build/es6/draw/drawDetections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawDetections = drawDetections;

var _classes = require("../classes");

var _FaceDetection = require("../classes/FaceDetection");

var _WithFaceDetection = require("../factories/WithFaceDetection");

var _utils = require("../utils");

var _DrawBox = require("./DrawBox");

function drawDetections(canvasArg, detections) {
  var detectionsArray = Array.isArray(detections) ? detections : [detections];
  detectionsArray.forEach(function (det) {
    var score = det instanceof _FaceDetection.FaceDetection ? det.score : (0, _WithFaceDetection.isWithFaceDetection)(det) ? det.detection.score : undefined;
    var box = det instanceof _FaceDetection.FaceDetection ? det.box : (0, _WithFaceDetection.isWithFaceDetection)(det) ? det.detection.box : new _classes.Box(det);
    var label = score ? "" + (0, _utils.round)(score) : undefined;
    new _DrawBox.DrawBox(box, {
      label: label
    }).draw(canvasArg);
  });
}
},{"../classes":"node_modules/face-api.js/build/es6/classes/index.js","../classes/FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js","../factories/WithFaceDetection":"node_modules/face-api.js/build/es6/factories/WithFaceDetection.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./DrawBox":"node_modules/face-api.js/build/es6/draw/DrawBox.js"}],"node_modules/face-api.js/build/es6/dom/isMediaLoaded.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMediaLoaded = isMediaLoaded;

var _env = require("../env");

function isMediaLoaded(media) {
  var _a = _env.env.getEnv(),
      Image = _a.Image,
      Video = _a.Video;

  return media instanceof Image && media.complete || media instanceof Video && media.readyState >= 3;
}
},{"../env":"node_modules/face-api.js/build/es6/env/index.js"}],"node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.awaitMediaLoaded = awaitMediaLoaded;

var _env = require("../env");

var _isMediaLoaded = require("./isMediaLoaded");

function awaitMediaLoaded(media) {
  return new Promise(function (resolve, reject) {
    if (media instanceof _env.env.getEnv().Canvas || (0, _isMediaLoaded.isMediaLoaded)(media)) {
      return resolve();
    }

    function onLoad(e) {
      if (!e.currentTarget) return;
      e.currentTarget.removeEventListener('load', onLoad);
      e.currentTarget.removeEventListener('error', onError);
      resolve(e);
    }

    function onError(e) {
      if (!e.currentTarget) return;
      e.currentTarget.removeEventListener('load', onLoad);
      e.currentTarget.removeEventListener('error', onError);
      reject(e);
    }

    media.addEventListener('load', onLoad);
    media.addEventListener('error', onError);
  });
}
},{"../env":"node_modules/face-api.js/build/es6/env/index.js","./isMediaLoaded":"node_modules/face-api.js/build/es6/dom/isMediaLoaded.js"}],"node_modules/face-api.js/build/es6/dom/bufferToImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bufferToImage = bufferToImage;

var _env = require("../env");

function bufferToImage(buf) {
  return new Promise(function (resolve, reject) {
    if (!(buf instanceof Blob)) {
      return reject('bufferToImage - expected buf to be of type: Blob');
    }

    var reader = new FileReader();

    reader.onload = function () {
      if (typeof reader.result !== 'string') {
        return reject('bufferToImage - expected reader.result to be a string, in onload');
      }

      var img = _env.env.getEnv().createImageElement();

      img.onload = function () {
        return resolve(img);
      };

      img.onerror = reject;
      img.src = reader.result;
    };

    reader.onerror = reject;
    reader.readAsDataURL(buf);
  });
}
},{"../env":"node_modules/face-api.js/build/es6/env/index.js"}],"node_modules/face-api.js/build/es6/dom/getMediaDimensions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMediaDimensions = getMediaDimensions;

var _Dimensions = require("../classes/Dimensions");

var _env = require("../env");

function getMediaDimensions(input) {
  var _a = _env.env.getEnv(),
      Image = _a.Image,
      Video = _a.Video;

  if (input instanceof Image) {
    return new _Dimensions.Dimensions(input.naturalWidth, input.naturalHeight);
  }

  if (input instanceof Video) {
    return new _Dimensions.Dimensions(input.videoWidth, input.videoHeight);
  }

  return new _Dimensions.Dimensions(input.width, input.height);
}
},{"../classes/Dimensions":"node_modules/face-api.js/build/es6/classes/Dimensions.js","../env":"node_modules/face-api.js/build/es6/env/index.js"}],"node_modules/face-api.js/build/es6/dom/createCanvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCanvas = createCanvas;
exports.createCanvasFromMedia = createCanvasFromMedia;

var _env = require("../env");

var _getContext2dOrThrow = require("./getContext2dOrThrow");

var _getMediaDimensions = require("./getMediaDimensions");

var _isMediaLoaded = require("./isMediaLoaded");

function createCanvas(_a) {
  var width = _a.width,
      height = _a.height;

  var createCanvasElement = _env.env.getEnv().createCanvasElement;

  var canvas = createCanvasElement();
  canvas.width = width;
  canvas.height = height;
  return canvas;
}

function createCanvasFromMedia(media, dims) {
  var ImageData = _env.env.getEnv().ImageData;

  if (!(media instanceof ImageData) && !(0, _isMediaLoaded.isMediaLoaded)(media)) {
    throw new Error('createCanvasFromMedia - media has not finished loading yet');
  }

  var _a = dims || (0, _getMediaDimensions.getMediaDimensions)(media),
      width = _a.width,
      height = _a.height;

  var canvas = createCanvas({
    width: width,
    height: height
  });

  if (media instanceof ImageData) {
    (0, _getContext2dOrThrow.getContext2dOrThrow)(canvas).putImageData(media, 0, 0);
  } else {
    (0, _getContext2dOrThrow.getContext2dOrThrow)(canvas).drawImage(media, 0, 0, width, height);
  }

  return canvas;
}
},{"../env":"node_modules/face-api.js/build/es6/env/index.js","./getContext2dOrThrow":"node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js","./getMediaDimensions":"node_modules/face-api.js/build/es6/dom/getMediaDimensions.js","./isMediaLoaded":"node_modules/face-api.js/build/es6/dom/isMediaLoaded.js"}],"node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.imageTensorToCanvas = imageTensorToCanvas;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _env = require("../env");

var _utils = require("../utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function imageTensorToCanvas(imgTensor, canvas) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var targetCanvas, _a, height, width, numChannels, imgTensor3D;

    return (0, _tslib.__generator)(this, function (_b) {
      switch (_b.label) {
        case 0:
          targetCanvas = canvas || _env.env.getEnv().createCanvasElement();
          _a = imgTensor.shape.slice((0, _utils.isTensor4D)(imgTensor) ? 1 : 0), height = _a[0], width = _a[1], numChannels = _a[2];
          imgTensor3D = tf.tidy(function () {
            return imgTensor.as3D(height, width, numChannels).toInt();
          });
          return [4
          /*yield*/
          , tf.browser.toPixels(imgTensor3D, targetCanvas)];

        case 1:
          _b.sent();

          imgTensor3D.dispose();
          return [2
          /*return*/
          , targetCanvas];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../env":"node_modules/face-api.js/build/es6/env/index.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/dom/isMediaElement.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMediaElement = isMediaElement;

var _env = require("../env");

function isMediaElement(input) {
  var _a = _env.env.getEnv(),
      Image = _a.Image,
      Canvas = _a.Canvas,
      Video = _a.Video;

  return input instanceof Image || input instanceof Canvas || input instanceof Video;
}
},{"../env":"node_modules/face-api.js/build/es6/env/index.js"}],"node_modules/face-api.js/build/es6/dom/imageToSquare.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.imageToSquare = imageToSquare;

var _env = require("../env");

var _createCanvas = require("./createCanvas");

var _getContext2dOrThrow = require("./getContext2dOrThrow");

var _getMediaDimensions = require("./getMediaDimensions");

function imageToSquare(input, inputSize, centerImage) {
  if (centerImage === void 0) {
    centerImage = false;
  }

  var _a = _env.env.getEnv(),
      Image = _a.Image,
      Canvas = _a.Canvas;

  if (!(input instanceof Image || input instanceof Canvas)) {
    throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement');
  }

  var dims = (0, _getMediaDimensions.getMediaDimensions)(input);
  var scale = inputSize / Math.max(dims.height, dims.width);
  var width = scale * dims.width;
  var height = scale * dims.height;
  var targetCanvas = (0, _createCanvas.createCanvas)({
    width: inputSize,
    height: inputSize
  });
  var inputCanvas = input instanceof Canvas ? input : (0, _createCanvas.createCanvasFromMedia)(input);
  var offset = Math.abs(width - height) / 2;
  var dx = centerImage && width < height ? offset : 0;
  var dy = centerImage && height < width ? offset : 0;
  (0, _getContext2dOrThrow.getContext2dOrThrow)(targetCanvas).drawImage(inputCanvas, dx, dy, width, height);
  return targetCanvas;
}
},{"../env":"node_modules/face-api.js/build/es6/env/index.js","./createCanvas":"node_modules/face-api.js/build/es6/dom/createCanvas.js","./getContext2dOrThrow":"node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js","./getMediaDimensions":"node_modules/face-api.js/build/es6/dom/getMediaDimensions.js"}],"node_modules/face-api.js/build/es6/dom/NetInput.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NetInput = void 0;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _env = require("../env");

var _padToSquare = require("../ops/padToSquare");

var _utils = require("../utils");

var _createCanvas = require("./createCanvas");

var _imageToSquare = require("./imageToSquare");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var NetInput =
/** @class */
function () {
  function NetInput(inputs, treatAsBatchInput) {
    var _this = this;

    if (treatAsBatchInput === void 0) {
      treatAsBatchInput = false;
    }

    this._imageTensors = [];
    this._canvases = [];
    this._treatAsBatchInput = false;
    this._inputDimensions = [];

    if (!Array.isArray(inputs)) {
      throw new Error("NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have " + inputs);
    }

    this._treatAsBatchInput = treatAsBatchInput;
    this._batchSize = inputs.length;
    inputs.forEach(function (input, idx) {
      if ((0, _utils.isTensor3D)(input)) {
        _this._imageTensors[idx] = input;
        _this._inputDimensions[idx] = input.shape;
        return;
      }

      if ((0, _utils.isTensor4D)(input)) {
        var batchSize = input.shape[0];

        if (batchSize !== 1) {
          throw new Error("NetInput - tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
        }

        _this._imageTensors[idx] = input;
        _this._inputDimensions[idx] = input.shape.slice(1);
        return;
      }

      var canvas = input instanceof _env.env.getEnv().Canvas ? input : (0, _createCanvas.createCanvasFromMedia)(input);
      _this._canvases[idx] = canvas;
      _this._inputDimensions[idx] = [canvas.height, canvas.width, 3];
    });
  }

  Object.defineProperty(NetInput.prototype, "imageTensors", {
    get: function () {
      return this._imageTensors;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(NetInput.prototype, "canvases", {
    get: function () {
      return this._canvases;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(NetInput.prototype, "isBatchInput", {
    get: function () {
      return this.batchSize > 1 || this._treatAsBatchInput;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(NetInput.prototype, "batchSize", {
    get: function () {
      return this._batchSize;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(NetInput.prototype, "inputDimensions", {
    get: function () {
      return this._inputDimensions;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(NetInput.prototype, "inputSize", {
    get: function () {
      return this._inputSize;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(NetInput.prototype, "reshapedInputDimensions", {
    get: function () {
      var _this = this;

      return (0, _utils.range)(this.batchSize, 0, 1).map(function (_, batchIdx) {
        return _this.getReshapedInputDimensions(batchIdx);
      });
    },
    enumerable: true,
    configurable: true
  });

  NetInput.prototype.getInput = function (batchIdx) {
    return this.canvases[batchIdx] || this.imageTensors[batchIdx];
  };

  NetInput.prototype.getInputDimensions = function (batchIdx) {
    return this._inputDimensions[batchIdx];
  };

  NetInput.prototype.getInputHeight = function (batchIdx) {
    return this._inputDimensions[batchIdx][0];
  };

  NetInput.prototype.getInputWidth = function (batchIdx) {
    return this._inputDimensions[batchIdx][1];
  };

  NetInput.prototype.getReshapedInputDimensions = function (batchIdx) {
    if (typeof this.inputSize !== 'number') {
      throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');
    }

    var width = this.getInputWidth(batchIdx);
    var height = this.getInputHeight(batchIdx);
    return (0, _utils.computeReshapedDimensions)({
      width: width,
      height: height
    }, this.inputSize);
  };
  /**
   * Create a batch tensor from all input canvases and tensors
   * with size [batchSize, inputSize, inputSize, 3].
   *
   * @param inputSize Height and width of the tensor.
   * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on
   * both sides of the minor dimension oof the image.
   * @returns The batch tensor.
   */


  NetInput.prototype.toBatchTensor = function (inputSize, isCenterInputs) {
    var _this = this;

    if (isCenterInputs === void 0) {
      isCenterInputs = true;
    }

    this._inputSize = inputSize;
    return tf.tidy(function () {
      var inputTensors = (0, _utils.range)(_this.batchSize, 0, 1).map(function (batchIdx) {
        var input = _this.getInput(batchIdx);

        if (input instanceof tf.Tensor) {
          var imgTensor = (0, _utils.isTensor4D)(input) ? input : input.expandDims();
          imgTensor = (0, _padToSquare.padToSquare)(imgTensor, isCenterInputs);

          if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {
            imgTensor = tf.image.resizeBilinear(imgTensor, [inputSize, inputSize]);
          }

          return imgTensor.as3D(inputSize, inputSize, 3);
        }

        if (input instanceof _env.env.getEnv().Canvas) {
          return tf.browser.fromPixels((0, _imageToSquare.imageToSquare)(input, inputSize, isCenterInputs));
        }

        throw new Error("toBatchTensor - at batchIdx " + batchIdx + ", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have " + input);
      });
      var batchTensor = tf.stack(inputTensors.map(function (t) {
        return t.toFloat();
      })).as4D(_this.batchSize, inputSize, inputSize, 3);
      return batchTensor;
    });
  };

  return NetInput;
}();

exports.NetInput = NetInput;
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../env":"node_modules/face-api.js/build/es6/env/index.js","../ops/padToSquare":"node_modules/face-api.js/build/es6/ops/padToSquare.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./createCanvas":"node_modules/face-api.js/build/es6/dom/createCanvas.js","./imageToSquare":"node_modules/face-api.js/build/es6/dom/imageToSquare.js"}],"node_modules/face-api.js/build/es6/dom/toNetInput.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toNetInput = toNetInput;

var _tslib = require("tslib");

var _utils = require("../utils");

var _awaitMediaLoaded = require("./awaitMediaLoaded");

var _isMediaElement = require("./isMediaElement");

var _NetInput = require("./NetInput");

var _resolveInput = require("./resolveInput");

/**
 * Validates the input to make sure, they are valid net inputs and awaits all media elements
 * to be finished loading.
 *
 * @param input The input, which can be a media element or an array of different media elements.
 * @returns A NetInput instance, which can be passed into one of the neural networks.
 */
function toNetInput(inputs) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var inputArgArray, getIdxHint, inputArray;
    return (0, _tslib.__generator)(this, function (_a) {
      switch (_a.label) {
        case 0:
          if (inputs instanceof _NetInput.NetInput) {
            return [2
            /*return*/
            , inputs];
          }

          inputArgArray = Array.isArray(inputs) ? inputs : [inputs];

          if (!inputArgArray.length) {
            throw new Error('toNetInput - empty array passed as input');
          }

          getIdxHint = function (idx) {
            return Array.isArray(inputs) ? " at input index " + idx + ":" : '';
          };

          inputArray = inputArgArray.map(_resolveInput.resolveInput);
          inputArray.forEach(function (input, i) {
            if (!(0, _isMediaElement.isMediaElement)(input) && !(0, _utils.isTensor3D)(input) && !(0, _utils.isTensor4D)(input)) {
              if (typeof inputArgArray[i] === 'string') {
                throw new Error("toNetInput -" + getIdxHint(i) + " string passed, but could not resolve HTMLElement for element id " + inputArgArray[i]);
              }

              throw new Error("toNetInput -" + getIdxHint(i) + " expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id");
            }

            if ((0, _utils.isTensor4D)(input)) {
              // if tf.Tensor4D is passed in the input array, the batch size has to be 1
              var batchSize = input.shape[0];

              if (batchSize !== 1) {
                throw new Error("toNetInput -" + getIdxHint(i) + " tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
              }
            }
          }); // wait for all media elements being loaded

          return [4
          /*yield*/
          , Promise.all(inputArray.map(function (input) {
            return (0, _isMediaElement.isMediaElement)(input) && (0, _awaitMediaLoaded.awaitMediaLoaded)(input);
          }))];

        case 1:
          // wait for all media elements being loaded
          _a.sent();

          return [2
          /*return*/
          , new _NetInput.NetInput(inputArray, Array.isArray(inputs))];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./awaitMediaLoaded":"node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js","./isMediaElement":"node_modules/face-api.js/build/es6/dom/isMediaElement.js","./NetInput":"node_modules/face-api.js/build/es6/dom/NetInput.js","./resolveInput":"node_modules/face-api.js/build/es6/dom/resolveInput.js"}],"node_modules/face-api.js/build/es6/dom/extractFaces.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractFaces = extractFaces;

var _tslib = require("tslib");

var _FaceDetection = require("../classes/FaceDetection");

var _env = require("../env");

var _createCanvas = require("./createCanvas");

var _getContext2dOrThrow = require("./getContext2dOrThrow");

var _imageTensorToCanvas = require("./imageTensorToCanvas");

var _toNetInput = require("./toNetInput");

/**
 * Extracts the image regions containing the detected faces.
 *
 * @param input The image that face detection has been performed on.
 * @param detections The face detection results or face bounding boxes for that image.
 * @returns The Canvases of the corresponding image region for each detected face.
 */
function extractFaces(input, detections) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var Canvas, canvas, netInput, tensorOrCanvas, _a, ctx, boxes;

    return (0, _tslib.__generator)(this, function (_b) {
      switch (_b.label) {
        case 0:
          Canvas = _env.env.getEnv().Canvas;
          canvas = input;
          if (!!(input instanceof Canvas)) return [3
          /*break*/
          , 5];
          return [4
          /*yield*/
          , (0, _toNetInput.toNetInput)(input)];

        case 1:
          netInput = _b.sent();

          if (netInput.batchSize > 1) {
            throw new Error('extractFaces - batchSize > 1 not supported');
          }

          tensorOrCanvas = netInput.getInput(0);
          if (!(tensorOrCanvas instanceof Canvas)) return [3
          /*break*/
          , 2];
          _a = tensorOrCanvas;
          return [3
          /*break*/
          , 4];

        case 2:
          return [4
          /*yield*/
          , (0, _imageTensorToCanvas.imageTensorToCanvas)(tensorOrCanvas)];

        case 3:
          _a = _b.sent();
          _b.label = 4;

        case 4:
          canvas = _a;
          _b.label = 5;

        case 5:
          ctx = (0, _getContext2dOrThrow.getContext2dOrThrow)(canvas);
          boxes = detections.map(function (det) {
            return det instanceof _FaceDetection.FaceDetection ? det.forSize(canvas.width, canvas.height).box.floor() : det;
          }).map(function (box) {
            return box.clipAtImageBorders(canvas.width, canvas.height);
          });
          return [2
          /*return*/
          , boxes.map(function (_a) {
            var x = _a.x,
                y = _a.y,
                width = _a.width,
                height = _a.height;
            var faceImg = (0, _createCanvas.createCanvas)({
              width: width,
              height: height
            });
            (0, _getContext2dOrThrow.getContext2dOrThrow)(faceImg).putImageData(ctx.getImageData(x, y, width, height), 0, 0);
            return faceImg;
          })];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","../classes/FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js","../env":"node_modules/face-api.js/build/es6/env/index.js","./createCanvas":"node_modules/face-api.js/build/es6/dom/createCanvas.js","./getContext2dOrThrow":"node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js","./imageTensorToCanvas":"node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js","./toNetInput":"node_modules/face-api.js/build/es6/dom/toNetInput.js"}],"node_modules/face-api.js/build/es6/dom/extractFaceTensors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractFaceTensors = extractFaceTensors;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _FaceDetection = require("../classes/FaceDetection");

var _utils = require("../utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Extracts the tensors of the image regions containing the detected faces.
 * Useful if you want to compute the face descriptors for the face images.
 * Using this method is faster then extracting a canvas for each face and
 * converting them to tensors individually.
 *
 * @param imageTensor The image tensor that face detection has been performed on.
 * @param detections The face detection results or face bounding boxes for that image.
 * @returns Tensors of the corresponding image region for each detected face.
 */
function extractFaceTensors(imageTensor, detections) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    return (0, _tslib.__generator)(this, function (_a) {
      if (!(0, _utils.isTensor3D)(imageTensor) && !(0, _utils.isTensor4D)(imageTensor)) {
        throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');
      }

      if ((0, _utils.isTensor4D)(imageTensor) && imageTensor.shape[0] > 1) {
        throw new Error('extractFaceTensors - batchSize > 1 not supported');
      }

      return [2
      /*return*/
      , tf.tidy(function () {
        var _a = imageTensor.shape.slice((0, _utils.isTensor4D)(imageTensor) ? 1 : 0),
            imgHeight = _a[0],
            imgWidth = _a[1],
            numChannels = _a[2];

        var boxes = detections.map(function (det) {
          return det instanceof _FaceDetection.FaceDetection ? det.forSize(imgWidth, imgHeight).box : det;
        }).map(function (box) {
          return box.clipAtImageBorders(imgWidth, imgHeight);
        });
        var faceTensors = boxes.map(function (_a) {
          var x = _a.x,
              y = _a.y,
              width = _a.width,
              height = _a.height;
          return tf.slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]);
        });
        return faceTensors;
      })];
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../classes/FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/dom/fetchOrThrow.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchOrThrow = fetchOrThrow;

var _tslib = require("tslib");

var _env = require("../env");

function fetchOrThrow(url, init) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var fetch, res;
    return (0, _tslib.__generator)(this, function (_a) {
      switch (_a.label) {
        case 0:
          fetch = _env.env.getEnv().fetch;
          return [4
          /*yield*/
          , fetch(url, init)];

        case 1:
          res = _a.sent();

          if (!(res.status < 400)) {
            throw new Error("failed to fetch: (" + res.status + ") " + res.statusText + ", from url: " + res.url);
          }

          return [2
          /*return*/
          , res];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","../env":"node_modules/face-api.js/build/es6/env/index.js"}],"node_modules/face-api.js/build/es6/dom/fetchImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchImage = fetchImage;

var _tslib = require("tslib");

var _bufferToImage = require("./bufferToImage");

var _fetchOrThrow = require("./fetchOrThrow");

function fetchImage(uri) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var res, blob;
    return (0, _tslib.__generator)(this, function (_a) {
      switch (_a.label) {
        case 0:
          return [4
          /*yield*/
          , (0, _fetchOrThrow.fetchOrThrow)(uri)];

        case 1:
          res = _a.sent();
          return [4
          /*yield*/
          , res.blob()];

        case 2:
          blob = _a.sent();

          if (!blob.type.startsWith('image/')) {
            throw new Error("fetchImage - expected blob type to be of type image/*, instead have: " + blob.type + ", for url: " + res.url);
          }

          return [2
          /*return*/
          , (0, _bufferToImage.bufferToImage)(blob)];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","./bufferToImage":"node_modules/face-api.js/build/es6/dom/bufferToImage.js","./fetchOrThrow":"node_modules/face-api.js/build/es6/dom/fetchOrThrow.js"}],"node_modules/face-api.js/build/es6/dom/fetchJson.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchJson = fetchJson;

var _tslib = require("tslib");

var _fetchOrThrow = require("./fetchOrThrow");

function fetchJson(uri) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    return (0, _tslib.__generator)(this, function (_a) {
      switch (_a.label) {
        case 0:
          return [4
          /*yield*/
          , (0, _fetchOrThrow.fetchOrThrow)(uri)];

        case 1:
          return [2
          /*return*/
          , _a.sent().json()];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","./fetchOrThrow":"node_modules/face-api.js/build/es6/dom/fetchOrThrow.js"}],"node_modules/face-api.js/build/es6/dom/fetchNetWeights.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchNetWeights = fetchNetWeights;

var _tslib = require("tslib");

var _fetchOrThrow = require("./fetchOrThrow");

function fetchNetWeights(uri) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var _a;

    return (0, _tslib.__generator)(this, function (_b) {
      switch (_b.label) {
        case 0:
          _a = Float32Array.bind;
          return [4
          /*yield*/
          , (0, _fetchOrThrow.fetchOrThrow)(uri)];

        case 1:
          return [4
          /*yield*/
          , _b.sent().arrayBuffer()];

        case 2:
          return [2
          /*return*/
          , new (_a.apply(Float32Array, [void 0, _b.sent()]))()];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","./fetchOrThrow":"node_modules/face-api.js/build/es6/dom/fetchOrThrow.js"}],"node_modules/face-api.js/build/es6/common/getModelUris.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getModelUris = getModelUris;

function getModelUris(uri, defaultModelName) {
  var defaultManifestFilename = defaultModelName + "-weights_manifest.json";

  if (!uri) {
    return {
      modelBaseUri: '',
      manifestUri: defaultManifestFilename
    };
  }

  if (uri === '/') {
    return {
      modelBaseUri: '/',
      manifestUri: "/" + defaultManifestFilename
    };
  }

  var protocol = uri.startsWith('http://') ? 'http://' : uri.startsWith('https://') ? 'https://' : '';
  uri = uri.replace(protocol, '');
  var parts = uri.split('/').filter(function (s) {
    return s;
  });
  var manifestFile = uri.endsWith('.json') ? parts[parts.length - 1] : defaultManifestFilename;
  var modelBaseUri = protocol + (uri.endsWith('.json') ? parts.slice(0, parts.length - 1) : parts).join('/');
  modelBaseUri = uri.startsWith('/') ? "/" + modelBaseUri : modelBaseUri;
  return {
    modelBaseUri: modelBaseUri,
    manifestUri: modelBaseUri === '/' ? "/" + manifestFile : modelBaseUri + "/" + manifestFile
  };
}
},{}],"node_modules/face-api.js/build/es6/dom/loadWeightMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadWeightMap = loadWeightMap;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _getModelUris = require("../common/getModelUris");

var _fetchJson = require("./fetchJson");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function loadWeightMap(uri, defaultModelName) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var _a, manifestUri, modelBaseUri, manifest;

    return (0, _tslib.__generator)(this, function (_b) {
      switch (_b.label) {
        case 0:
          _a = (0, _getModelUris.getModelUris)(uri, defaultModelName), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;
          return [4
          /*yield*/
          , (0, _fetchJson.fetchJson)(manifestUri)];

        case 1:
          manifest = _b.sent();
          return [2
          /*return*/
          , tf.io.loadWeights(manifest, modelBaseUri)];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common/getModelUris":"node_modules/face-api.js/build/es6/common/getModelUris.js","./fetchJson":"node_modules/face-api.js/build/es6/dom/fetchJson.js"}],"node_modules/face-api.js/build/es6/dom/matchDimensions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchDimensions = matchDimensions;

var _getMediaDimensions = require("./getMediaDimensions");

function matchDimensions(input, reference, useMediaDimensions) {
  if (useMediaDimensions === void 0) {
    useMediaDimensions = false;
  }

  var _a = useMediaDimensions ? (0, _getMediaDimensions.getMediaDimensions)(reference) : reference,
      width = _a.width,
      height = _a.height;

  input.width = width;
  input.height = height;
  return {
    width: width,
    height: height
  };
}
},{"./getMediaDimensions":"node_modules/face-api.js/build/es6/dom/getMediaDimensions.js"}],"node_modules/face-api.js/build/es6/dom/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _awaitMediaLoaded = require("./awaitMediaLoaded");

Object.keys(_awaitMediaLoaded).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _awaitMediaLoaded[key];
    }
  });
});

var _bufferToImage = require("./bufferToImage");

Object.keys(_bufferToImage).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _bufferToImage[key];
    }
  });
});

var _createCanvas = require("./createCanvas");

Object.keys(_createCanvas).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _createCanvas[key];
    }
  });
});

var _extractFaces = require("./extractFaces");

Object.keys(_extractFaces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _extractFaces[key];
    }
  });
});

var _extractFaceTensors = require("./extractFaceTensors");

Object.keys(_extractFaceTensors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _extractFaceTensors[key];
    }
  });
});

var _fetchImage = require("./fetchImage");

Object.keys(_fetchImage).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fetchImage[key];
    }
  });
});

var _fetchJson = require("./fetchJson");

Object.keys(_fetchJson).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fetchJson[key];
    }
  });
});

var _fetchNetWeights = require("./fetchNetWeights");

Object.keys(_fetchNetWeights).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fetchNetWeights[key];
    }
  });
});

var _fetchOrThrow = require("./fetchOrThrow");

Object.keys(_fetchOrThrow).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fetchOrThrow[key];
    }
  });
});

var _getContext2dOrThrow = require("./getContext2dOrThrow");

Object.keys(_getContext2dOrThrow).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getContext2dOrThrow[key];
    }
  });
});

var _getMediaDimensions = require("./getMediaDimensions");

Object.keys(_getMediaDimensions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getMediaDimensions[key];
    }
  });
});

var _imageTensorToCanvas = require("./imageTensorToCanvas");

Object.keys(_imageTensorToCanvas).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _imageTensorToCanvas[key];
    }
  });
});

var _imageToSquare = require("./imageToSquare");

Object.keys(_imageToSquare).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _imageToSquare[key];
    }
  });
});

var _isMediaElement = require("./isMediaElement");

Object.keys(_isMediaElement).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isMediaElement[key];
    }
  });
});

var _isMediaLoaded = require("./isMediaLoaded");

Object.keys(_isMediaLoaded).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isMediaLoaded[key];
    }
  });
});

var _loadWeightMap = require("./loadWeightMap");

Object.keys(_loadWeightMap).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _loadWeightMap[key];
    }
  });
});

var _matchDimensions = require("./matchDimensions");

Object.keys(_matchDimensions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _matchDimensions[key];
    }
  });
});

var _NetInput = require("./NetInput");

Object.keys(_NetInput).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _NetInput[key];
    }
  });
});

var _resolveInput = require("./resolveInput");

Object.keys(_resolveInput).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _resolveInput[key];
    }
  });
});

var _toNetInput = require("./toNetInput");

Object.keys(_toNetInput).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _toNetInput[key];
    }
  });
});
},{"./awaitMediaLoaded":"node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js","./bufferToImage":"node_modules/face-api.js/build/es6/dom/bufferToImage.js","./createCanvas":"node_modules/face-api.js/build/es6/dom/createCanvas.js","./extractFaces":"node_modules/face-api.js/build/es6/dom/extractFaces.js","./extractFaceTensors":"node_modules/face-api.js/build/es6/dom/extractFaceTensors.js","./fetchImage":"node_modules/face-api.js/build/es6/dom/fetchImage.js","./fetchJson":"node_modules/face-api.js/build/es6/dom/fetchJson.js","./fetchNetWeights":"node_modules/face-api.js/build/es6/dom/fetchNetWeights.js","./fetchOrThrow":"node_modules/face-api.js/build/es6/dom/fetchOrThrow.js","./getContext2dOrThrow":"node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js","./getMediaDimensions":"node_modules/face-api.js/build/es6/dom/getMediaDimensions.js","./imageTensorToCanvas":"node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js","./imageToSquare":"node_modules/face-api.js/build/es6/dom/imageToSquare.js","./isMediaElement":"node_modules/face-api.js/build/es6/dom/isMediaElement.js","./isMediaLoaded":"node_modules/face-api.js/build/es6/dom/isMediaLoaded.js","./loadWeightMap":"node_modules/face-api.js/build/es6/dom/loadWeightMap.js","./matchDimensions":"node_modules/face-api.js/build/es6/dom/matchDimensions.js","./NetInput":"node_modules/face-api.js/build/es6/dom/NetInput.js","./resolveInput":"node_modules/face-api.js/build/es6/dom/resolveInput.js","./toNetInput":"node_modules/face-api.js/build/es6/dom/toNetInput.js"}],"node_modules/face-api.js/build/es6/NeuralNetwork.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NeuralNetwork = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _getModelUris = require("./common/getModelUris");

var _dom = require("./dom");

var _env = require("./env");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var NeuralNetwork =
/** @class */
function () {
  function NeuralNetwork(_name) {
    this._name = _name;
    this._params = undefined;
    this._paramMappings = [];
  }

  Object.defineProperty(NeuralNetwork.prototype, "params", {
    get: function () {
      return this._params;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(NeuralNetwork.prototype, "paramMappings", {
    get: function () {
      return this._paramMappings;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(NeuralNetwork.prototype, "isLoaded", {
    get: function () {
      return !!this.params;
    },
    enumerable: true,
    configurable: true
  });

  NeuralNetwork.prototype.getParamFromPath = function (paramPath) {
    var _a = this.traversePropertyPath(paramPath),
        obj = _a.obj,
        objProp = _a.objProp;

    return obj[objProp];
  };

  NeuralNetwork.prototype.reassignParamFromPath = function (paramPath, tensor) {
    var _a = this.traversePropertyPath(paramPath),
        obj = _a.obj,
        objProp = _a.objProp;

    obj[objProp].dispose();
    obj[objProp] = tensor;
  };

  NeuralNetwork.prototype.getParamList = function () {
    var _this = this;

    return this._paramMappings.map(function (_a) {
      var paramPath = _a.paramPath;
      return {
        path: paramPath,
        tensor: _this.getParamFromPath(paramPath)
      };
    });
  };

  NeuralNetwork.prototype.getTrainableParams = function () {
    return this.getParamList().filter(function (param) {
      return param.tensor instanceof tf.Variable;
    });
  };

  NeuralNetwork.prototype.getFrozenParams = function () {
    return this.getParamList().filter(function (param) {
      return !(param.tensor instanceof tf.Variable);
    });
  };

  NeuralNetwork.prototype.variable = function () {
    var _this = this;

    this.getFrozenParams().forEach(function (_a) {
      var path = _a.path,
          tensor = _a.tensor;

      _this.reassignParamFromPath(path, tensor.variable());
    });
  };

  NeuralNetwork.prototype.freeze = function () {
    var _this = this;

    this.getTrainableParams().forEach(function (_a) {
      var path = _a.path,
          variable = _a.tensor;
      var tensor = tf.tensor(variable.dataSync());
      variable.dispose();

      _this.reassignParamFromPath(path, tensor);
    });
  };

  NeuralNetwork.prototype.dispose = function (throwOnRedispose) {
    if (throwOnRedispose === void 0) {
      throwOnRedispose = true;
    }

    this.getParamList().forEach(function (param) {
      if (throwOnRedispose && param.tensor.isDisposed) {
        throw new Error("param tensor has already been disposed for path " + param.path);
      }

      param.tensor.dispose();
    });
    this._params = undefined;
  };

  NeuralNetwork.prototype.serializeParams = function () {
    return new Float32Array(this.getParamList().map(function (_a) {
      var tensor = _a.tensor;
      return Array.from(tensor.dataSync());
    }).reduce(function (flat, arr) {
      return flat.concat(arr);
    }));
  };

  NeuralNetwork.prototype.load = function (weightsOrUrl) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (weightsOrUrl instanceof Float32Array) {
              this.extractWeights(weightsOrUrl);
              return [2
              /*return*/
              ];
            }

            return [4
            /*yield*/
            , this.loadFromUri(weightsOrUrl)];

          case 1:
            _a.sent();

            return [2
            /*return*/
            ];
        }
      });
    });
  };

  NeuralNetwork.prototype.loadFromUri = function (uri) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var weightMap;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (uri && typeof uri !== 'string') {
              throw new Error(this._name + ".loadFromUri - expected model uri");
            }

            return [4
            /*yield*/
            , (0, _dom.loadWeightMap)(uri, this.getDefaultModelName())];

          case 1:
            weightMap = _a.sent();
            this.loadFromWeightMap(weightMap);
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  NeuralNetwork.prototype.loadFromDisk = function (filePath) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var readFile, _a, manifestUri, modelBaseUri, fetchWeightsFromDisk, loadWeights, manifest, _b, _c, weightMap;

      return (0, _tslib.__generator)(this, function (_d) {
        switch (_d.label) {
          case 0:
            if (filePath && typeof filePath !== 'string') {
              throw new Error(this._name + ".loadFromDisk - expected model file path");
            }

            readFile = _env.env.getEnv().readFile;
            _a = (0, _getModelUris.getModelUris)(filePath, this.getDefaultModelName()), manifestUri = _a.manifestUri, modelBaseUri = _a.modelBaseUri;

            fetchWeightsFromDisk = function (filePaths) {
              return Promise.all(filePaths.map(function (filePath) {
                return readFile(filePath).then(function (buf) {
                  return buf.buffer;
                });
              }));
            };

            loadWeights = tf.io.weightsLoaderFactory(fetchWeightsFromDisk);
            _c = (_b = JSON).parse;
            return [4
            /*yield*/
            , readFile(manifestUri)];

          case 1:
            manifest = _c.apply(_b, [_d.sent().toString()]);
            return [4
            /*yield*/
            , loadWeights(manifest, modelBaseUri)];

          case 2:
            weightMap = _d.sent();
            this.loadFromWeightMap(weightMap);
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  NeuralNetwork.prototype.loadFromWeightMap = function (weightMap) {
    var _a = this.extractParamsFromWeigthMap(weightMap),
        paramMappings = _a.paramMappings,
        params = _a.params;

    this._paramMappings = paramMappings;
    this._params = params;
  };

  NeuralNetwork.prototype.extractWeights = function (weights) {
    var _a = this.extractParams(weights),
        paramMappings = _a.paramMappings,
        params = _a.params;

    this._paramMappings = paramMappings;
    this._params = params;
  };

  NeuralNetwork.prototype.traversePropertyPath = function (paramPath) {
    if (!this.params) {
      throw new Error("traversePropertyPath - model has no loaded params");
    }

    var result = paramPath.split('/').reduce(function (res, objProp) {
      if (!res.nextObj.hasOwnProperty(objProp)) {
        throw new Error("traversePropertyPath - object does not have property " + objProp + ", for path " + paramPath);
      }

      return {
        obj: res.nextObj,
        objProp: objProp,
        nextObj: res.nextObj[objProp]
      };
    }, {
      nextObj: this.params
    });
    var obj = result.obj,
        objProp = result.objProp;

    if (!obj || !objProp || !(obj[objProp] instanceof tf.Tensor)) {
      throw new Error("traversePropertyPath - parameter is not a tensor, for path " + paramPath);
    }

    return {
      obj: obj,
      objProp: objProp
    };
  };

  return NeuralNetwork;
}();

exports.NeuralNetwork = NeuralNetwork;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./common/getModelUris":"node_modules/face-api.js/build/es6/common/getModelUris.js","./dom":"node_modules/face-api.js/build/es6/dom/index.js","./env":"node_modules/face-api.js/build/es6/env/index.js"}],"node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.depthwiseSeparableConv = depthwiseSeparableConv;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function depthwiseSeparableConv(x, params, stride) {
  return tf.tidy(function () {
    var out = tf.separableConv2d(x, params.depthwise_filter, params.pointwise_filter, stride, 'same');
    out = tf.add(out, params.bias);
    return out;
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.denseBlock3 = denseBlock3;
exports.denseBlock4 = denseBlock4;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _depthwiseSeparableConv = require("../common/depthwiseSeparableConv");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function denseBlock3(x, denseBlockParams, isFirstLayer) {
  if (isFirstLayer === void 0) {
    isFirstLayer = false;
  }

  return tf.tidy(function () {
    var out1 = tf.relu(isFirstLayer ? tf.add(tf.conv2d(x, denseBlockParams.conv0.filters, [2, 2], 'same'), denseBlockParams.conv0.bias) : (0, _depthwiseSeparableConv.depthwiseSeparableConv)(x, denseBlockParams.conv0, [2, 2]));
    var out2 = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out1, denseBlockParams.conv1, [1, 1]);
    var in3 = tf.relu(tf.add(out1, out2));
    var out3 = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(in3, denseBlockParams.conv2, [1, 1]);
    return tf.relu(tf.add(out1, tf.add(out2, out3)));
  });
}

function denseBlock4(x, denseBlockParams, isFirstLayer, isScaleDown) {
  if (isFirstLayer === void 0) {
    isFirstLayer = false;
  }

  if (isScaleDown === void 0) {
    isScaleDown = true;
  }

  return tf.tidy(function () {
    var out1 = tf.relu(isFirstLayer ? tf.add(tf.conv2d(x, denseBlockParams.conv0.filters, isScaleDown ? [2, 2] : [1, 1], 'same'), denseBlockParams.conv0.bias) : (0, _depthwiseSeparableConv.depthwiseSeparableConv)(x, denseBlockParams.conv0, isScaleDown ? [2, 2] : [1, 1]));
    var out2 = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out1, denseBlockParams.conv1, [1, 1]);
    var in3 = tf.relu(tf.add(out1, out2));
    var out3 = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(in3, denseBlockParams.conv2, [1, 1]);
    var in4 = tf.relu(tf.add(out1, tf.add(out2, out3)));
    var out4 = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(in4, denseBlockParams.conv3, [1, 1]);
    return tf.relu(tf.add(out1, tf.add(out2, tf.add(out3, out4))));
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common/depthwiseSeparableConv":"node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js"}],"node_modules/face-api.js/build/es6/common/convLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convLayer = convLayer;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function convLayer(x, params, padding, withRelu) {
  if (padding === void 0) {
    padding = 'same';
  }

  if (withRelu === void 0) {
    withRelu = false;
  }

  return tf.tidy(function () {
    var out = tf.add(tf.conv2d(x, params.filters, [1, 1], padding), params.bias);
    return withRelu ? tf.relu(out) : out;
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.disposeUnusedWeightTensors = disposeUnusedWeightTensors;

function disposeUnusedWeightTensors(weightMap, paramMappings) {
  Object.keys(weightMap).forEach(function (path) {
    if (!paramMappings.some(function (pm) {
      return pm.originalPath === path;
    })) {
      weightMap[path].dispose();
    }
  });
}
},{}],"node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractConvParamsFactory = extractConvParamsFactory;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function extractConvParamsFactory(extractWeights, paramMappings) {
  return function (channelsIn, channelsOut, filterSize, mappedPrefix) {
    var filters = tf.tensor4d(extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);
    var bias = tf.tensor1d(extractWeights(channelsOut));
    paramMappings.push({
      paramPath: mappedPrefix + "/filters"
    }, {
      paramPath: mappedPrefix + "/bias"
    });
    return {
      filters: filters,
      bias: bias
    };
  };
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractFCParamsFactory = extractFCParamsFactory;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function extractFCParamsFactory(extractWeights, paramMappings) {
  return function (channelsIn, channelsOut, mappedPrefix) {
    var fc_weights = tf.tensor2d(extractWeights(channelsIn * channelsOut), [channelsIn, channelsOut]);
    var fc_bias = tf.tensor1d(extractWeights(channelsOut));
    paramMappings.push({
      paramPath: mappedPrefix + "/weights"
    }, {
      paramPath: mappedPrefix + "/bias"
    });
    return {
      weights: fc_weights,
      bias: fc_bias
    };
  };
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/common/types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SeparableConvParams = void 0;

var SeparableConvParams =
/** @class */
function () {
  function SeparableConvParams(depthwise_filter, pointwise_filter, bias) {
    this.depthwise_filter = depthwise_filter;
    this.pointwise_filter = pointwise_filter;
    this.bias = bias;
  }

  return SeparableConvParams;
}();

exports.SeparableConvParams = SeparableConvParams;
},{}],"node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractSeparableConvParamsFactory = extractSeparableConvParamsFactory;
exports.loadSeparableConvParamsFactory = loadSeparableConvParamsFactory;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _types = require("./types");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function extractSeparableConvParamsFactory(extractWeights, paramMappings) {
  return function (channelsIn, channelsOut, mappedPrefix) {
    var depthwise_filter = tf.tensor4d(extractWeights(3 * 3 * channelsIn), [3, 3, channelsIn, 1]);
    var pointwise_filter = tf.tensor4d(extractWeights(channelsIn * channelsOut), [1, 1, channelsIn, channelsOut]);
    var bias = tf.tensor1d(extractWeights(channelsOut));
    paramMappings.push({
      paramPath: mappedPrefix + "/depthwise_filter"
    }, {
      paramPath: mappedPrefix + "/pointwise_filter"
    }, {
      paramPath: mappedPrefix + "/bias"
    });
    return new _types.SeparableConvParams(depthwise_filter, pointwise_filter, bias);
  };
}

function loadSeparableConvParamsFactory(extractWeightEntry) {
  return function (prefix) {
    var depthwise_filter = extractWeightEntry(prefix + "/depthwise_filter", 4);
    var pointwise_filter = extractWeightEntry(prefix + "/pointwise_filter", 4);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return new _types.SeparableConvParams(depthwise_filter, pointwise_filter, bias);
  };
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./types":"node_modules/face-api.js/build/es6/common/types.js"}],"node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractWeightEntryFactory = extractWeightEntryFactory;

var _utils = require("../utils");

function extractWeightEntryFactory(weightMap, paramMappings) {
  return function (originalPath, paramRank, mappedPath) {
    var tensor = weightMap[originalPath];

    if (!(0, _utils.isTensor)(tensor, paramRank)) {
      throw new Error("expected weightMap[" + originalPath + "] to be a Tensor" + paramRank + "D, instead have " + tensor);
    }

    paramMappings.push({
      originalPath: originalPath,
      paramPath: mappedPath || originalPath
    });
    return tensor;
  };
}
},{"../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/common/extractWeightsFactory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractWeightsFactory = extractWeightsFactory;

function extractWeightsFactory(weights) {
  var remainingWeights = weights;

  function extractWeights(numWeights) {
    var ret = remainingWeights.slice(0, numWeights);
    remainingWeights = remainingWeights.slice(numWeights);
    return ret;
  }

  function getRemainingWeights() {
    return remainingWeights;
  }

  return {
    extractWeights: extractWeights,
    getRemainingWeights: getRemainingWeights
  };
}
},{}],"node_modules/face-api.js/build/es6/common/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _convLayer = require("./convLayer");

Object.keys(_convLayer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _convLayer[key];
    }
  });
});

var _depthwiseSeparableConv = require("./depthwiseSeparableConv");

Object.keys(_depthwiseSeparableConv).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _depthwiseSeparableConv[key];
    }
  });
});

var _disposeUnusedWeightTensors = require("./disposeUnusedWeightTensors");

Object.keys(_disposeUnusedWeightTensors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _disposeUnusedWeightTensors[key];
    }
  });
});

var _extractConvParamsFactory = require("./extractConvParamsFactory");

Object.keys(_extractConvParamsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _extractConvParamsFactory[key];
    }
  });
});

var _extractFCParamsFactory = require("./extractFCParamsFactory");

Object.keys(_extractFCParamsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _extractFCParamsFactory[key];
    }
  });
});

var _extractSeparableConvParamsFactory = require("./extractSeparableConvParamsFactory");

Object.keys(_extractSeparableConvParamsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _extractSeparableConvParamsFactory[key];
    }
  });
});

var _extractWeightEntryFactory = require("./extractWeightEntryFactory");

Object.keys(_extractWeightEntryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _extractWeightEntryFactory[key];
    }
  });
});

var _extractWeightsFactory = require("./extractWeightsFactory");

Object.keys(_extractWeightsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _extractWeightsFactory[key];
    }
  });
});

var _getModelUris = require("./getModelUris");

Object.keys(_getModelUris).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getModelUris[key];
    }
  });
});

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
},{"./convLayer":"node_modules/face-api.js/build/es6/common/convLayer.js","./depthwiseSeparableConv":"node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js","./disposeUnusedWeightTensors":"node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js","./extractConvParamsFactory":"node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js","./extractFCParamsFactory":"node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js","./extractSeparableConvParamsFactory":"node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js","./extractWeightEntryFactory":"node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js","./extractWeightsFactory":"node_modules/face-api.js/build/es6/common/extractWeightsFactory.js","./getModelUris":"node_modules/face-api.js/build/es6/common/getModelUris.js","./types":"node_modules/face-api.js/build/es6/common/types.js"}],"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractorsFactory = extractorsFactory;

var _common = require("../common");

function extractorsFactory(extractWeights, paramMappings) {
  var extractConvParams = (0, _common.extractConvParamsFactory)(extractWeights, paramMappings);
  var extractSeparableConvParams = (0, _common.extractSeparableConvParamsFactory)(extractWeights, paramMappings);

  function extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
    if (isFirstLayer === void 0) {
      isFirstLayer = false;
    }

    var conv0 = isFirstLayer ? extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv0") : extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/conv0");
    var conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv1");
    var conv2 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv2");
    return {
      conv0: conv0,
      conv1: conv1,
      conv2: conv2
    };
  }

  function extractDenseBlock4Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
    if (isFirstLayer === void 0) {
      isFirstLayer = false;
    }

    var _a = extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer),
        conv0 = _a.conv0,
        conv1 = _a.conv1,
        conv2 = _a.conv2;

    var conv3 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv3");
    return {
      conv0: conv0,
      conv1: conv1,
      conv2: conv2,
      conv3: conv3
    };
  }

  return {
    extractDenseBlock3Params: extractDenseBlock3Params,
    extractDenseBlock4Params: extractDenseBlock4Params
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js"}],"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParams = extractParams;

var _common = require("../common");

var _extractorsFactory = require("./extractorsFactory");

function extractParams(weights) {
  var paramMappings = [];

  var _a = (0, _common.extractWeightsFactory)(weights),
      extractWeights = _a.extractWeights,
      getRemainingWeights = _a.getRemainingWeights;

  var extractDenseBlock4Params = (0, _extractorsFactory.extractorsFactory)(extractWeights, paramMappings).extractDenseBlock4Params;
  var dense0 = extractDenseBlock4Params(3, 32, 'dense0', true);
  var dense1 = extractDenseBlock4Params(32, 64, 'dense1');
  var dense2 = extractDenseBlock4Params(64, 128, 'dense2');
  var dense3 = extractDenseBlock4Params(128, 256, 'dense3');

  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }

  return {
    paramMappings: paramMappings,
    params: {
      dense0: dense0,
      dense1: dense1,
      dense2: dense2,
      dense3: dense3
    }
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js","./extractorsFactory":"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js"}],"node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadConvParamsFactory = loadConvParamsFactory;

function loadConvParamsFactory(extractWeightEntry) {
  return function (prefix) {
    var filters = extractWeightEntry(prefix + "/filters", 4);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return {
      filters: filters,
      bias: bias
    };
  };
}
},{}],"node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadParamsFactory = loadParamsFactory;

var _common = require("../common");

var _loadConvParamsFactory = require("../common/loadConvParamsFactory");

function loadParamsFactory(weightMap, paramMappings) {
  var extractWeightEntry = (0, _common.extractWeightEntryFactory)(weightMap, paramMappings);
  var extractConvParams = (0, _loadConvParamsFactory.loadConvParamsFactory)(extractWeightEntry);
  var extractSeparableConvParams = (0, _common.loadSeparableConvParamsFactory)(extractWeightEntry);

  function extractDenseBlock3Params(prefix, isFirstLayer) {
    if (isFirstLayer === void 0) {
      isFirstLayer = false;
    }

    var conv0 = isFirstLayer ? extractConvParams(prefix + "/conv0") : extractSeparableConvParams(prefix + "/conv0");
    var conv1 = extractSeparableConvParams(prefix + "/conv1");
    var conv2 = extractSeparableConvParams(prefix + "/conv2");
    return {
      conv0: conv0,
      conv1: conv1,
      conv2: conv2
    };
  }

  function extractDenseBlock4Params(prefix, isFirstLayer) {
    if (isFirstLayer === void 0) {
      isFirstLayer = false;
    }

    var conv0 = isFirstLayer ? extractConvParams(prefix + "/conv0") : extractSeparableConvParams(prefix + "/conv0");
    var conv1 = extractSeparableConvParams(prefix + "/conv1");
    var conv2 = extractSeparableConvParams(prefix + "/conv2");
    var conv3 = extractSeparableConvParams(prefix + "/conv3");
    return {
      conv0: conv0,
      conv1: conv1,
      conv2: conv2,
      conv3: conv3
    };
  }

  return {
    extractDenseBlock3Params: extractDenseBlock3Params,
    extractDenseBlock4Params: extractDenseBlock4Params
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js","../common/loadConvParamsFactory":"node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js"}],"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsFromWeigthMap = extractParamsFromWeigthMap;

var _common = require("../common");

var _loadParamsFactory = require("./loadParamsFactory");

function extractParamsFromWeigthMap(weightMap) {
  var paramMappings = [];
  var extractDenseBlock4Params = (0, _loadParamsFactory.loadParamsFactory)(weightMap, paramMappings).extractDenseBlock4Params;
  var params = {
    dense0: extractDenseBlock4Params('dense0', true),
    dense1: extractDenseBlock4Params('dense1'),
    dense2: extractDenseBlock4Params('dense2'),
    dense3: extractDenseBlock4Params('dense3')
  };
  (0, _common.disposeUnusedWeightTensors)(weightMap, paramMappings);
  return {
    params: params,
    paramMappings: paramMappings
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js","./loadParamsFactory":"node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js"}],"node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceFeatureExtractor = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _dom = require("../dom");

var _NeuralNetwork = require("../NeuralNetwork");

var _ops = require("../ops");

var _denseBlock = require("./denseBlock");

var _extractParams = require("./extractParams");

var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var FaceFeatureExtractor =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceFeatureExtractor, _super);

  function FaceFeatureExtractor() {
    return _super.call(this, 'FaceFeatureExtractor') || this;
  }

  FaceFeatureExtractor.prototype.forwardInput = function (input) {
    var params = this.params;

    if (!params) {
      throw new Error('FaceFeatureExtractor - load model before inference');
    }

    return tf.tidy(function () {
      var batchTensor = input.toBatchTensor(112, true);
      var meanRgb = [122.782, 117.001, 104.298];
      var normalized = (0, _ops.normalize)(batchTensor, meanRgb).div(tf.scalar(255));
      var out = (0, _denseBlock.denseBlock4)(normalized, params.dense0, true);
      out = (0, _denseBlock.denseBlock4)(out, params.dense1);
      out = (0, _denseBlock.denseBlock4)(out, params.dense2);
      out = (0, _denseBlock.denseBlock4)(out, params.dense3);
      out = tf.avgPool(out, [7, 7], [2, 2], 'valid');
      return out;
    });
  };

  FaceFeatureExtractor.prototype.forward = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [2
            /*return*/
            , _a.apply(this, [_b.sent()])];
        }
      });
    });
  };

  FaceFeatureExtractor.prototype.getDefaultModelName = function () {
    return 'face_feature_extractor_model';
  };

  FaceFeatureExtractor.prototype.extractParamsFromWeigthMap = function (weightMap) {
    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap);
  };

  FaceFeatureExtractor.prototype.extractParams = function (weights) {
    return (0, _extractParams.extractParams)(weights);
  };

  return FaceFeatureExtractor;
}(_NeuralNetwork.NeuralNetwork);

exports.FaceFeatureExtractor = FaceFeatureExtractor;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","../ops":"node_modules/face-api.js/build/es6/ops/index.js","./denseBlock":"node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js","./extractParams":"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js","./extractParamsFromWeigthMap":"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js"}],"node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fullyConnectedLayer = fullyConnectedLayer;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function fullyConnectedLayer(x, params) {
  return tf.tidy(function () {
    return tf.add(tf.matMul(x, params.weights), params.bias);
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/faceProcessor/extractParams.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParams = extractParams;

var _common = require("../common");

function extractParams(weights, channelsIn, channelsOut) {
  var paramMappings = [];

  var _a = (0, _common.extractWeightsFactory)(weights),
      extractWeights = _a.extractWeights,
      getRemainingWeights = _a.getRemainingWeights;

  var extractFCParams = (0, _common.extractFCParamsFactory)(extractWeights, paramMappings);
  var fc = extractFCParams(channelsIn, channelsOut, 'fc');

  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }

  return {
    paramMappings: paramMappings,
    params: {
      fc: fc
    }
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js"}],"node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsFromWeigthMap = extractParamsFromWeigthMap;

var _common = require("../common");

function extractParamsFromWeigthMap(weightMap) {
  var paramMappings = [];
  var extractWeightEntry = (0, _common.extractWeightEntryFactory)(weightMap, paramMappings);

  function extractFcParams(prefix) {
    var weights = extractWeightEntry(prefix + "/weights", 2);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return {
      weights: weights,
      bias: bias
    };
  }

  var params = {
    fc: extractFcParams('fc')
  };
  (0, _common.disposeUnusedWeightTensors)(weightMap, paramMappings);
  return {
    params: params,
    paramMappings: paramMappings
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js"}],"node_modules/face-api.js/build/es6/faceProcessor/util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.seperateWeightMaps = seperateWeightMaps;

function seperateWeightMaps(weightMap) {
  var featureExtractorMap = {};
  var classifierMap = {};
  Object.keys(weightMap).forEach(function (key) {
    var map = key.startsWith('fc') ? classifierMap : featureExtractorMap;
    map[key] = weightMap[key];
  });
  return {
    featureExtractorMap: featureExtractorMap,
    classifierMap: classifierMap
  };
}
},{}],"node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceProcessor = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _fullyConnectedLayer = require("../common/fullyConnectedLayer");

var _dom = require("../dom");

var _NeuralNetwork = require("../NeuralNetwork");

var _extractParams = require("./extractParams");

var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");

var _util = require("./util");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var FaceProcessor =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceProcessor, _super);

  function FaceProcessor(_name, faceFeatureExtractor) {
    var _this = _super.call(this, _name) || this;

    _this._faceFeatureExtractor = faceFeatureExtractor;
    return _this;
  }

  Object.defineProperty(FaceProcessor.prototype, "faceFeatureExtractor", {
    get: function () {
      return this._faceFeatureExtractor;
    },
    enumerable: true,
    configurable: true
  });

  FaceProcessor.prototype.runNet = function (input) {
    var _this = this;

    var params = this.params;

    if (!params) {
      throw new Error(this._name + " - load model before inference");
    }

    return tf.tidy(function () {
      var bottleneckFeatures = input instanceof _dom.NetInput ? _this.faceFeatureExtractor.forwardInput(input) : input;
      return (0, _fullyConnectedLayer.fullyConnectedLayer)(bottleneckFeatures.as2D(bottleneckFeatures.shape[0], -1), params.fc);
    });
  };

  FaceProcessor.prototype.dispose = function (throwOnRedispose) {
    if (throwOnRedispose === void 0) {
      throwOnRedispose = true;
    }

    this.faceFeatureExtractor.dispose(throwOnRedispose);

    _super.prototype.dispose.call(this, throwOnRedispose);
  };

  FaceProcessor.prototype.loadClassifierParams = function (weights) {
    var _a = this.extractClassifierParams(weights),
        params = _a.params,
        paramMappings = _a.paramMappings;

    this._params = params;
    this._paramMappings = paramMappings;
  };

  FaceProcessor.prototype.extractClassifierParams = function (weights) {
    return (0, _extractParams.extractParams)(weights, this.getClassifierChannelsIn(), this.getClassifierChannelsOut());
  };

  FaceProcessor.prototype.extractParamsFromWeigthMap = function (weightMap) {
    var _a = (0, _util.seperateWeightMaps)(weightMap),
        featureExtractorMap = _a.featureExtractorMap,
        classifierMap = _a.classifierMap;

    this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(classifierMap);
  };

  FaceProcessor.prototype.extractParams = function (weights) {
    var cIn = this.getClassifierChannelsIn();
    var cOut = this.getClassifierChannelsOut();
    var classifierWeightSize = cOut * cIn + cOut;
    var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
    var classifierWeights = weights.slice(weights.length - classifierWeightSize);
    this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
    return this.extractClassifierParams(classifierWeights);
  };

  return FaceProcessor;
}(_NeuralNetwork.NeuralNetwork);

exports.FaceProcessor = FaceProcessor;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common/fullyConnectedLayer":"node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","./extractParams":"node_modules/face-api.js/build/es6/faceProcessor/extractParams.js","./extractParamsFromWeigthMap":"node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js","./util":"node_modules/face-api.js/build/es6/faceProcessor/util.js"}],"node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceExpressions = exports.FACE_EXPRESSION_LABELS = void 0;
var FACE_EXPRESSION_LABELS = ['neutral', 'happy', 'sad', 'angry', 'fearful', 'disgusted', 'surprised'];
exports.FACE_EXPRESSION_LABELS = FACE_EXPRESSION_LABELS;

var FaceExpressions =
/** @class */
function () {
  function FaceExpressions(probabilities) {
    var _this = this;

    if (probabilities.length !== 7) {
      throw new Error("FaceExpressions.constructor - expected probabilities.length to be 7, have: " + probabilities.length);
    }

    FACE_EXPRESSION_LABELS.forEach(function (expression, idx) {
      _this[expression] = probabilities[idx];
    });
  }

  FaceExpressions.prototype.asSortedArray = function () {
    var _this = this;

    return FACE_EXPRESSION_LABELS.map(function (expression) {
      return {
        expression: expression,
        probability: _this[expression]
      };
    }).sort(function (e0, e1) {
      return e1.probability - e0.probability;
    });
  };

  return FaceExpressions;
}();

exports.FaceExpressions = FaceExpressions;
},{}],"node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceExpressionNet = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _dom = require("../dom");

var _FaceFeatureExtractor = require("../faceFeatureExtractor/FaceFeatureExtractor");

var _FaceProcessor = require("../faceProcessor/FaceProcessor");

var _FaceExpressions = require("./FaceExpressions");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var FaceExpressionNet =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceExpressionNet, _super);

  function FaceExpressionNet(faceFeatureExtractor) {
    if (faceFeatureExtractor === void 0) {
      faceFeatureExtractor = new _FaceFeatureExtractor.FaceFeatureExtractor();
    }

    return _super.call(this, 'FaceExpressionNet', faceFeatureExtractor) || this;
  }

  FaceExpressionNet.prototype.forwardInput = function (input) {
    var _this = this;

    return tf.tidy(function () {
      return tf.softmax(_this.runNet(input));
    });
  };

  FaceExpressionNet.prototype.forward = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [2
            /*return*/
            , _a.apply(this, [_b.sent()])];
        }
      });
    });
  };

  FaceExpressionNet.prototype.predictExpressions = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var netInput, out, probabilitesByBatch, predictionsByBatch;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            netInput = _a.sent();
            return [4
            /*yield*/
            , this.forwardInput(netInput)];

          case 2:
            out = _a.sent();
            return [4
            /*yield*/
            , Promise.all(tf.unstack(out).map(function (t) {
              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
                var data;
                return (0, _tslib.__generator)(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [4
                      /*yield*/
                      , t.data()];

                    case 1:
                      data = _a.sent();
                      t.dispose();
                      return [2
                      /*return*/
                      , data];
                  }
                });
              });
            }))];

          case 3:
            probabilitesByBatch = _a.sent();
            out.dispose();
            predictionsByBatch = probabilitesByBatch.map(function (probabilites) {
              return new _FaceExpressions.FaceExpressions(probabilites);
            });
            return [2
            /*return*/
            , netInput.isBatchInput ? predictionsByBatch : predictionsByBatch[0]];
        }
      });
    });
  };

  FaceExpressionNet.prototype.getDefaultModelName = function () {
    return 'face_expression_model';
  };

  FaceExpressionNet.prototype.getClassifierChannelsIn = function () {
    return 256;
  };

  FaceExpressionNet.prototype.getClassifierChannelsOut = function () {
    return 7;
  };

  return FaceExpressionNet;
}(_FaceProcessor.FaceProcessor);

exports.FaceExpressionNet = FaceExpressionNet;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../faceFeatureExtractor/FaceFeatureExtractor":"node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js","../faceProcessor/FaceProcessor":"node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js","./FaceExpressions":"node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js"}],"node_modules/face-api.js/build/es6/faceExpressionNet/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _FaceExpressionNet = require("./FaceExpressionNet");

Object.keys(_FaceExpressionNet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceExpressionNet[key];
    }
  });
});

var _FaceExpressions = require("./FaceExpressions");

Object.keys(_FaceExpressions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceExpressions[key];
    }
  });
});
},{"./FaceExpressionNet":"node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js","./FaceExpressions":"node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js"}],"node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWithFaceExpressions = isWithFaceExpressions;
exports.extendWithFaceExpressions = extendWithFaceExpressions;

var _FaceExpressions = require("../faceExpressionNet/FaceExpressions");

function isWithFaceExpressions(obj) {
  return obj['expressions'] instanceof _FaceExpressions.FaceExpressions;
}

function extendWithFaceExpressions(sourceObj, expressions) {
  var extension = {
    expressions: expressions
  };
  return Object.assign({}, sourceObj, extension);
}
},{"../faceExpressionNet/FaceExpressions":"node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js"}],"node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawFaceExpressions = drawFaceExpressions;

var _classes = require("../classes");

var _faceExpressionNet = require("../faceExpressionNet");

var _WithFaceDetection = require("../factories/WithFaceDetection");

var _WithFaceExpressions = require("../factories/WithFaceExpressions");

var _utils = require("../utils");

var _DrawTextField = require("./DrawTextField");

function drawFaceExpressions(canvasArg, faceExpressions, minConfidence, textFieldAnchor) {
  if (minConfidence === void 0) {
    minConfidence = 0.1;
  }

  var faceExpressionsArray = Array.isArray(faceExpressions) ? faceExpressions : [faceExpressions];
  faceExpressionsArray.forEach(function (e) {
    var expr = e instanceof _faceExpressionNet.FaceExpressions ? e : (0, _WithFaceExpressions.isWithFaceExpressions)(e) ? e.expressions : undefined;

    if (!expr) {
      throw new Error('drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof');
    }

    var sorted = expr.asSortedArray();
    var resultsToDisplay = sorted.filter(function (expr) {
      return expr.probability > minConfidence;
    });
    var anchor = (0, _WithFaceDetection.isWithFaceDetection)(e) ? e.detection.box.bottomLeft : textFieldAnchor || new _classes.Point(0, 0);
    var drawTextField = new _DrawTextField.DrawTextField(resultsToDisplay.map(function (expr) {
      return expr.expression + " (" + (0, _utils.round)(expr.probability) + ")";
    }), anchor);
    drawTextField.draw(canvasArg);
  });
}
},{"../classes":"node_modules/face-api.js/build/es6/classes/index.js","../faceExpressionNet":"node_modules/face-api.js/build/es6/faceExpressionNet/index.js","../factories/WithFaceDetection":"node_modules/face-api.js/build/es6/factories/WithFaceDetection.js","../factories/WithFaceExpressions":"node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./DrawTextField":"node_modules/face-api.js/build/es6/draw/DrawTextField.js"}],"node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWithFaceLandmarks = isWithFaceLandmarks;
exports.extendWithFaceLandmarks = extendWithFaceLandmarks;

var _FaceDetection = require("../classes/FaceDetection");

var _FaceLandmarks = require("../classes/FaceLandmarks");

var _WithFaceDetection = require("./WithFaceDetection");

function isWithFaceLandmarks(obj) {
  return (0, _WithFaceDetection.isWithFaceDetection)(obj) && obj['landmarks'] instanceof _FaceLandmarks.FaceLandmarks && obj['unshiftedLandmarks'] instanceof _FaceLandmarks.FaceLandmarks && obj['alignedRect'] instanceof _FaceDetection.FaceDetection;
}

function extendWithFaceLandmarks(sourceObj, unshiftedLandmarks) {
  var shift = sourceObj.detection.box;
  var landmarks = unshiftedLandmarks.shiftBy(shift.x, shift.y);
  var rect = landmarks.align();
  var imageDims = sourceObj.detection.imageDims;
  var alignedRect = new _FaceDetection.FaceDetection(sourceObj.detection.score, rect.rescale(imageDims.reverse()), imageDims);
  var extension = {
    landmarks: landmarks,
    unshiftedLandmarks: unshiftedLandmarks,
    alignedRect: alignedRect
  };
  return Object.assign({}, sourceObj, extension);
}
},{"../classes/FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js","../classes/FaceLandmarks":"node_modules/face-api.js/build/es6/classes/FaceLandmarks.js","./WithFaceDetection":"node_modules/face-api.js/build/es6/factories/WithFaceDetection.js"}],"node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawFaceLandmarks = drawFaceLandmarks;
exports.DrawFaceLandmarks = exports.DrawFaceLandmarksOptions = void 0;

var _FaceLandmarks = require("../classes/FaceLandmarks");

var _FaceLandmarks2 = require("../classes/FaceLandmarks68");

var _getContext2dOrThrow = require("../dom/getContext2dOrThrow");

var _WithFaceLandmarks = require("../factories/WithFaceLandmarks");

var _drawContour = require("./drawContour");

var DrawFaceLandmarksOptions =
/** @class */
function () {
  function DrawFaceLandmarksOptions(options) {
    if (options === void 0) {
      options = {};
    }

    var _a = options.drawLines,
        drawLines = _a === void 0 ? true : _a,
        _b = options.drawPoints,
        drawPoints = _b === void 0 ? true : _b,
        lineWidth = options.lineWidth,
        lineColor = options.lineColor,
        pointSize = options.pointSize,
        pointColor = options.pointColor;
    this.drawLines = drawLines;
    this.drawPoints = drawPoints;
    this.lineWidth = lineWidth || 1;
    this.pointSize = pointSize || 2;
    this.lineColor = lineColor || 'rgba(0, 255, 255, 1)';
    this.pointColor = pointColor || 'rgba(255, 0, 255, 1)';
  }

  return DrawFaceLandmarksOptions;
}();

exports.DrawFaceLandmarksOptions = DrawFaceLandmarksOptions;

var DrawFaceLandmarks =
/** @class */
function () {
  function DrawFaceLandmarks(faceLandmarks, options) {
    if (options === void 0) {
      options = {};
    }

    this.faceLandmarks = faceLandmarks;
    this.options = new DrawFaceLandmarksOptions(options);
  }

  DrawFaceLandmarks.prototype.draw = function (canvasArg) {
    var ctx = (0, _getContext2dOrThrow.getContext2dOrThrow)(canvasArg);
    var _a = this.options,
        drawLines = _a.drawLines,
        drawPoints = _a.drawPoints,
        lineWidth = _a.lineWidth,
        lineColor = _a.lineColor,
        pointSize = _a.pointSize,
        pointColor = _a.pointColor;

    if (drawLines && this.faceLandmarks instanceof _FaceLandmarks2.FaceLandmarks68) {
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = lineWidth;
      (0, _drawContour.drawContour)(ctx, this.faceLandmarks.getJawOutline());
      (0, _drawContour.drawContour)(ctx, this.faceLandmarks.getLeftEyeBrow());
      (0, _drawContour.drawContour)(ctx, this.faceLandmarks.getRightEyeBrow());
      (0, _drawContour.drawContour)(ctx, this.faceLandmarks.getNose());
      (0, _drawContour.drawContour)(ctx, this.faceLandmarks.getLeftEye(), true);
      (0, _drawContour.drawContour)(ctx, this.faceLandmarks.getRightEye(), true);
      (0, _drawContour.drawContour)(ctx, this.faceLandmarks.getMouth(), true);
    }

    if (drawPoints) {
      ctx.strokeStyle = pointColor;
      ctx.fillStyle = pointColor;

      var drawPoint = function (pt) {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, pointSize, 0, 2 * Math.PI);
        ctx.fill();
      };

      this.faceLandmarks.positions.forEach(drawPoint);
    }
  };

  return DrawFaceLandmarks;
}();

exports.DrawFaceLandmarks = DrawFaceLandmarks;

function drawFaceLandmarks(canvasArg, faceLandmarks) {
  var faceLandmarksArray = Array.isArray(faceLandmarks) ? faceLandmarks : [faceLandmarks];
  faceLandmarksArray.forEach(function (f) {
    var landmarks = f instanceof _FaceLandmarks.FaceLandmarks ? f : (0, _WithFaceLandmarks.isWithFaceLandmarks)(f) ? f.landmarks : undefined;

    if (!landmarks) {
      throw new Error('drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof');
    }

    new DrawFaceLandmarks(landmarks).draw(canvasArg);
  });
}
},{"../classes/FaceLandmarks":"node_modules/face-api.js/build/es6/classes/FaceLandmarks.js","../classes/FaceLandmarks68":"node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js","../dom/getContext2dOrThrow":"node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js","../factories/WithFaceLandmarks":"node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js","./drawContour":"node_modules/face-api.js/build/es6/draw/drawContour.js"}],"node_modules/face-api.js/build/es6/draw/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _drawContour = require("./drawContour");

Object.keys(_drawContour).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _drawContour[key];
    }
  });
});

var _drawDetections = require("./drawDetections");

Object.keys(_drawDetections).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _drawDetections[key];
    }
  });
});

var _drawFaceExpressions = require("./drawFaceExpressions");

Object.keys(_drawFaceExpressions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _drawFaceExpressions[key];
    }
  });
});

var _DrawBox = require("./DrawBox");

Object.keys(_DrawBox).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _DrawBox[key];
    }
  });
});

var _DrawFaceLandmarks = require("./DrawFaceLandmarks");

Object.keys(_DrawFaceLandmarks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _DrawFaceLandmarks[key];
    }
  });
});

var _DrawTextField = require("./DrawTextField");

Object.keys(_DrawTextField).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _DrawTextField[key];
    }
  });
});
},{"./drawContour":"node_modules/face-api.js/build/es6/draw/drawContour.js","./drawDetections":"node_modules/face-api.js/build/es6/draw/drawDetections.js","./drawFaceExpressions":"node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js","./DrawBox":"node_modules/face-api.js/build/es6/draw/DrawBox.js","./DrawFaceLandmarks":"node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js","./DrawTextField":"node_modules/face-api.js/build/es6/draw/DrawTextField.js"}],"node_modules/face-api.js/build/es6/xception/extractParams.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParams = extractParams;

var _common = require("../common");

var _utils = require("../utils");

function extractorsFactory(extractWeights, paramMappings) {
  var extractConvParams = (0, _common.extractConvParamsFactory)(extractWeights, paramMappings);
  var extractSeparableConvParams = (0, _common.extractSeparableConvParamsFactory)(extractWeights, paramMappings);

  function extractReductionBlockParams(channelsIn, channelsOut, mappedPrefix) {
    var separable_conv0 = extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/separable_conv0");
    var separable_conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/separable_conv1");
    var expansion_conv = extractConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/expansion_conv");
    return {
      separable_conv0: separable_conv0,
      separable_conv1: separable_conv1,
      expansion_conv: expansion_conv
    };
  }

  function extractMainBlockParams(channels, mappedPrefix) {
    var separable_conv0 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv0");
    var separable_conv1 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv1");
    var separable_conv2 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv2");
    return {
      separable_conv0: separable_conv0,
      separable_conv1: separable_conv1,
      separable_conv2: separable_conv2
    };
  }

  return {
    extractConvParams: extractConvParams,
    extractSeparableConvParams: extractSeparableConvParams,
    extractReductionBlockParams: extractReductionBlockParams,
    extractMainBlockParams: extractMainBlockParams
  };
}

function extractParams(weights, numMainBlocks) {
  var paramMappings = [];

  var _a = (0, _common.extractWeightsFactory)(weights),
      extractWeights = _a.extractWeights,
      getRemainingWeights = _a.getRemainingWeights;

  var _b = extractorsFactory(extractWeights, paramMappings),
      extractConvParams = _b.extractConvParams,
      extractSeparableConvParams = _b.extractSeparableConvParams,
      extractReductionBlockParams = _b.extractReductionBlockParams,
      extractMainBlockParams = _b.extractMainBlockParams;

  var entry_flow_conv_in = extractConvParams(3, 32, 3, 'entry_flow/conv_in');
  var entry_flow_reduction_block_0 = extractReductionBlockParams(32, 64, 'entry_flow/reduction_block_0');
  var entry_flow_reduction_block_1 = extractReductionBlockParams(64, 128, 'entry_flow/reduction_block_1');
  var entry_flow = {
    conv_in: entry_flow_conv_in,
    reduction_block_0: entry_flow_reduction_block_0,
    reduction_block_1: entry_flow_reduction_block_1
  };
  var middle_flow = {};
  (0, _utils.range)(numMainBlocks, 0, 1).forEach(function (idx) {
    middle_flow["main_block_" + idx] = extractMainBlockParams(128, "middle_flow/main_block_" + idx);
  });
  var exit_flow_reduction_block = extractReductionBlockParams(128, 256, 'exit_flow/reduction_block');
  var exit_flow_separable_conv = extractSeparableConvParams(256, 512, 'exit_flow/separable_conv');
  var exit_flow = {
    reduction_block: exit_flow_reduction_block,
    separable_conv: exit_flow_separable_conv
  };

  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }

  return {
    paramMappings: paramMappings,
    params: {
      entry_flow: entry_flow,
      middle_flow: middle_flow,
      exit_flow: exit_flow
    }
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsFromWeigthMap = extractParamsFromWeigthMap;

var _common = require("../common");

var _loadConvParamsFactory = require("../common/loadConvParamsFactory");

var _utils = require("../utils");

function loadParamsFactory(weightMap, paramMappings) {
  var extractWeightEntry = (0, _common.extractWeightEntryFactory)(weightMap, paramMappings);
  var extractConvParams = (0, _loadConvParamsFactory.loadConvParamsFactory)(extractWeightEntry);
  var extractSeparableConvParams = (0, _common.loadSeparableConvParamsFactory)(extractWeightEntry);

  function extractReductionBlockParams(mappedPrefix) {
    var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
    var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
    var expansion_conv = extractConvParams(mappedPrefix + "/expansion_conv");
    return {
      separable_conv0: separable_conv0,
      separable_conv1: separable_conv1,
      expansion_conv: expansion_conv
    };
  }

  function extractMainBlockParams(mappedPrefix) {
    var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
    var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
    var separable_conv2 = extractSeparableConvParams(mappedPrefix + "/separable_conv2");
    return {
      separable_conv0: separable_conv0,
      separable_conv1: separable_conv1,
      separable_conv2: separable_conv2
    };
  }

  return {
    extractConvParams: extractConvParams,
    extractSeparableConvParams: extractSeparableConvParams,
    extractReductionBlockParams: extractReductionBlockParams,
    extractMainBlockParams: extractMainBlockParams
  };
}

function extractParamsFromWeigthMap(weightMap, numMainBlocks) {
  var paramMappings = [];

  var _a = loadParamsFactory(weightMap, paramMappings),
      extractConvParams = _a.extractConvParams,
      extractSeparableConvParams = _a.extractSeparableConvParams,
      extractReductionBlockParams = _a.extractReductionBlockParams,
      extractMainBlockParams = _a.extractMainBlockParams;

  var entry_flow_conv_in = extractConvParams('entry_flow/conv_in');
  var entry_flow_reduction_block_0 = extractReductionBlockParams('entry_flow/reduction_block_0');
  var entry_flow_reduction_block_1 = extractReductionBlockParams('entry_flow/reduction_block_1');
  var entry_flow = {
    conv_in: entry_flow_conv_in,
    reduction_block_0: entry_flow_reduction_block_0,
    reduction_block_1: entry_flow_reduction_block_1
  };
  var middle_flow = {};
  (0, _utils.range)(numMainBlocks, 0, 1).forEach(function (idx) {
    middle_flow["main_block_" + idx] = extractMainBlockParams("middle_flow/main_block_" + idx);
  });
  var exit_flow_reduction_block = extractReductionBlockParams('exit_flow/reduction_block');
  var exit_flow_separable_conv = extractSeparableConvParams('exit_flow/separable_conv');
  var exit_flow = {
    reduction_block: exit_flow_reduction_block,
    separable_conv: exit_flow_separable_conv
  };
  (0, _common.disposeUnusedWeightTensors)(weightMap, paramMappings);
  return {
    params: {
      entry_flow: entry_flow,
      middle_flow: middle_flow,
      exit_flow: exit_flow
    },
    paramMappings: paramMappings
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js","../common/loadConvParamsFactory":"node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/xception/TinyXception.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyXception = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _common = require("../common");

var _dom = require("../dom");

var _NeuralNetwork = require("../NeuralNetwork");

var _ops = require("../ops");

var _utils = require("../utils");

var _extractParams = require("./extractParams");

var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function conv(x, params, stride) {
  return tf.add(tf.conv2d(x, params.filters, stride, 'same'), params.bias);
}

function reductionBlock(x, params, isActivateInput) {
  if (isActivateInput === void 0) {
    isActivateInput = true;
  }

  var out = isActivateInput ? tf.relu(x) : x;
  out = (0, _common.depthwiseSeparableConv)(out, params.separable_conv0, [1, 1]);
  out = (0, _common.depthwiseSeparableConv)(tf.relu(out), params.separable_conv1, [1, 1]);
  out = tf.maxPool(out, [3, 3], [2, 2], 'same');
  out = tf.add(out, conv(x, params.expansion_conv, [2, 2]));
  return out;
}

function mainBlock(x, params) {
  var out = (0, _common.depthwiseSeparableConv)(tf.relu(x), params.separable_conv0, [1, 1]);
  out = (0, _common.depthwiseSeparableConv)(tf.relu(out), params.separable_conv1, [1, 1]);
  out = (0, _common.depthwiseSeparableConv)(tf.relu(out), params.separable_conv2, [1, 1]);
  out = tf.add(out, x);
  return out;
}

var TinyXception =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TinyXception, _super);

  function TinyXception(numMainBlocks) {
    var _this = _super.call(this, 'TinyXception') || this;

    _this._numMainBlocks = numMainBlocks;
    return _this;
  }

  TinyXception.prototype.forwardInput = function (input) {
    var _this = this;

    var params = this.params;

    if (!params) {
      throw new Error('TinyXception - load model before inference');
    }

    return tf.tidy(function () {
      var batchTensor = input.toBatchTensor(112, true);
      var meanRgb = [122.782, 117.001, 104.298];
      var normalized = (0, _ops.normalize)(batchTensor, meanRgb).div(tf.scalar(256));
      var out = tf.relu(conv(normalized, params.entry_flow.conv_in, [2, 2]));
      out = reductionBlock(out, params.entry_flow.reduction_block_0, false);
      out = reductionBlock(out, params.entry_flow.reduction_block_1);
      (0, _utils.range)(_this._numMainBlocks, 0, 1).forEach(function (idx) {
        out = mainBlock(out, params.middle_flow["main_block_" + idx]);
      });
      out = reductionBlock(out, params.exit_flow.reduction_block);
      out = tf.relu((0, _common.depthwiseSeparableConv)(out, params.exit_flow.separable_conv, [1, 1]));
      return out;
    });
  };

  TinyXception.prototype.forward = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [2
            /*return*/
            , _a.apply(this, [_b.sent()])];
        }
      });
    });
  };

  TinyXception.prototype.getDefaultModelName = function () {
    return 'tiny_xception_model';
  };

  TinyXception.prototype.extractParamsFromWeigthMap = function (weightMap) {
    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap, this._numMainBlocks);
  };

  TinyXception.prototype.extractParams = function (weights) {
    return (0, _extractParams.extractParams)(weights, this._numMainBlocks);
  };

  return TinyXception;
}(_NeuralNetwork.NeuralNetwork);

exports.TinyXception = TinyXception;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common":"node_modules/face-api.js/build/es6/common/index.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","../ops":"node_modules/face-api.js/build/es6/ops/index.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js","./extractParams":"node_modules/face-api.js/build/es6/xception/extractParams.js","./extractParamsFromWeigthMap":"node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js"}],"node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParams = extractParams;

var _common = require("../common");

function extractParams(weights) {
  var paramMappings = [];

  var _a = (0, _common.extractWeightsFactory)(weights),
      extractWeights = _a.extractWeights,
      getRemainingWeights = _a.getRemainingWeights;

  var extractFCParams = (0, _common.extractFCParamsFactory)(extractWeights, paramMappings);
  var age = extractFCParams(512, 1, 'fc/age');
  var gender = extractFCParams(512, 2, 'fc/gender');

  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }

  return {
    paramMappings: paramMappings,
    params: {
      fc: {
        age: age,
        gender: gender
      }
    }
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js"}],"node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsFromWeigthMap = extractParamsFromWeigthMap;

var _common = require("../common");

function extractParamsFromWeigthMap(weightMap) {
  var paramMappings = [];
  var extractWeightEntry = (0, _common.extractWeightEntryFactory)(weightMap, paramMappings);

  function extractFcParams(prefix) {
    var weights = extractWeightEntry(prefix + "/weights", 2);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return {
      weights: weights,
      bias: bias
    };
  }

  var params = {
    fc: {
      age: extractFcParams('fc/age'),
      gender: extractFcParams('fc/gender')
    }
  };
  (0, _common.disposeUnusedWeightTensors)(weightMap, paramMappings);
  return {
    params: params,
    paramMappings: paramMappings
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js"}],"node_modules/face-api.js/build/es6/ageGenderNet/types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Gender = void 0;
var Gender;
exports.Gender = Gender;

(function (Gender) {
  Gender["FEMALE"] = "female";
  Gender["MALE"] = "male";
})(Gender || (exports.Gender = Gender = {}));
},{}],"node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AgeGenderNet = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _fullyConnectedLayer = require("../common/fullyConnectedLayer");

var _util = require("../faceProcessor/util");

var _TinyXception = require("../xception/TinyXception");

var _extractParams = require("./extractParams");

var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");

var _types = require("./types");

var _NeuralNetwork = require("../NeuralNetwork");

var _dom = require("../dom");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var AgeGenderNet =
/** @class */
function (_super) {
  (0, _tslib.__extends)(AgeGenderNet, _super);

  function AgeGenderNet(faceFeatureExtractor) {
    if (faceFeatureExtractor === void 0) {
      faceFeatureExtractor = new _TinyXception.TinyXception(2);
    }

    var _this = _super.call(this, 'AgeGenderNet') || this;

    _this._faceFeatureExtractor = faceFeatureExtractor;
    return _this;
  }

  Object.defineProperty(AgeGenderNet.prototype, "faceFeatureExtractor", {
    get: function () {
      return this._faceFeatureExtractor;
    },
    enumerable: true,
    configurable: true
  });

  AgeGenderNet.prototype.runNet = function (input) {
    var _this = this;

    var params = this.params;

    if (!params) {
      throw new Error(this._name + " - load model before inference");
    }

    return tf.tidy(function () {
      var bottleneckFeatures = input instanceof _dom.NetInput ? _this.faceFeatureExtractor.forwardInput(input) : input;
      var pooled = tf.avgPool(bottleneckFeatures, [7, 7], [2, 2], 'valid').as2D(bottleneckFeatures.shape[0], -1);
      var age = (0, _fullyConnectedLayer.fullyConnectedLayer)(pooled, params.fc.age).as1D();
      var gender = (0, _fullyConnectedLayer.fullyConnectedLayer)(pooled, params.fc.gender);
      return {
        age: age,
        gender: gender
      };
    });
  };

  AgeGenderNet.prototype.forwardInput = function (input) {
    var _this = this;

    return tf.tidy(function () {
      var _a = _this.runNet(input),
          age = _a.age,
          gender = _a.gender;

      return {
        age: age,
        gender: tf.softmax(gender)
      };
    });
  };

  AgeGenderNet.prototype.forward = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [2
            /*return*/
            , _a.apply(this, [_b.sent()])];
        }
      });
    });
  };

  AgeGenderNet.prototype.predictAgeAndGender = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var netInput, out, ages, genders, ageAndGenderTensors, predictionsByBatch;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            netInput = _a.sent();
            return [4
            /*yield*/
            , this.forwardInput(netInput)];

          case 2:
            out = _a.sent();
            ages = tf.unstack(out.age);
            genders = tf.unstack(out.gender);
            ageAndGenderTensors = ages.map(function (ageTensor, i) {
              return {
                ageTensor: ageTensor,
                genderTensor: genders[i]
              };
            });
            return [4
            /*yield*/
            , Promise.all(ageAndGenderTensors.map(function (_a) {
              var ageTensor = _a.ageTensor,
                  genderTensor = _a.genderTensor;
              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
                var age, probMale, isMale, gender, genderProbability;
                return (0, _tslib.__generator)(this, function (_b) {
                  switch (_b.label) {
                    case 0:
                      return [4
                      /*yield*/
                      , ageTensor.data()];

                    case 1:
                      age = _b.sent()[0];
                      return [4
                      /*yield*/
                      , genderTensor.data()];

                    case 2:
                      probMale = _b.sent()[0];
                      isMale = probMale > 0.5;
                      gender = isMale ? _types.Gender.MALE : _types.Gender.FEMALE;
                      genderProbability = isMale ? probMale : 1 - probMale;
                      ageTensor.dispose();
                      genderTensor.dispose();
                      return [2
                      /*return*/
                      , {
                        age: age,
                        gender: gender,
                        genderProbability: genderProbability
                      }];
                  }
                });
              });
            }))];

          case 3:
            predictionsByBatch = _a.sent();
            out.age.dispose();
            out.gender.dispose();
            return [2
            /*return*/
            , netInput.isBatchInput ? predictionsByBatch : predictionsByBatch[0]];
        }
      });
    });
  };

  AgeGenderNet.prototype.getDefaultModelName = function () {
    return 'age_gender_model';
  };

  AgeGenderNet.prototype.dispose = function (throwOnRedispose) {
    if (throwOnRedispose === void 0) {
      throwOnRedispose = true;
    }

    this.faceFeatureExtractor.dispose(throwOnRedispose);

    _super.prototype.dispose.call(this, throwOnRedispose);
  };

  AgeGenderNet.prototype.loadClassifierParams = function (weights) {
    var _a = this.extractClassifierParams(weights),
        params = _a.params,
        paramMappings = _a.paramMappings;

    this._params = params;
    this._paramMappings = paramMappings;
  };

  AgeGenderNet.prototype.extractClassifierParams = function (weights) {
    return (0, _extractParams.extractParams)(weights);
  };

  AgeGenderNet.prototype.extractParamsFromWeigthMap = function (weightMap) {
    var _a = (0, _util.seperateWeightMaps)(weightMap),
        featureExtractorMap = _a.featureExtractorMap,
        classifierMap = _a.classifierMap;

    this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(classifierMap);
  };

  AgeGenderNet.prototype.extractParams = function (weights) {
    var classifierWeightSize = 512 * 1 + 1 + (512 * 2 + 2);
    var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
    var classifierWeights = weights.slice(weights.length - classifierWeightSize);
    this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
    return this.extractClassifierParams(classifierWeights);
  };

  return AgeGenderNet;
}(_NeuralNetwork.NeuralNetwork);

exports.AgeGenderNet = AgeGenderNet;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common/fullyConnectedLayer":"node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js","../faceProcessor/util":"node_modules/face-api.js/build/es6/faceProcessor/util.js","../xception/TinyXception":"node_modules/face-api.js/build/es6/xception/TinyXception.js","./extractParams":"node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js","./extractParamsFromWeigthMap":"node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js","./types":"node_modules/face-api.js/build/es6/ageGenderNet/types.js","../NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js"}],"node_modules/face-api.js/build/es6/ageGenderNet/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AgeGenderNet = require("./AgeGenderNet");

Object.keys(_AgeGenderNet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _AgeGenderNet[key];
    }
  });
});

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
},{"./AgeGenderNet":"node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js","./types":"node_modules/face-api.js/build/es6/ageGenderNet/types.js"}],"node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceLandmark68NetBase = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _classes = require("../classes");

var _FaceLandmarks = require("../classes/FaceLandmarks68");

var _dom = require("../dom");

var _FaceProcessor = require("../faceProcessor/FaceProcessor");

var _utils = require("../utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var FaceLandmark68NetBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceLandmark68NetBase, _super);

  function FaceLandmark68NetBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  FaceLandmark68NetBase.prototype.postProcess = function (output, inputSize, originalDimensions) {
    var inputDimensions = originalDimensions.map(function (_a) {
      var width = _a.width,
          height = _a.height;
      var scale = inputSize / Math.max(height, width);
      return {
        width: width * scale,
        height: height * scale
      };
    });
    var batchSize = inputDimensions.length;
    return tf.tidy(function () {
      var createInterleavedTensor = function (fillX, fillY) {
        return tf.stack([tf.fill([68], fillX), tf.fill([68], fillY)], 1).as2D(1, 136).as1D();
      };

      var getPadding = function (batchIdx, cond) {
        var _a = inputDimensions[batchIdx],
            width = _a.width,
            height = _a.height;
        return cond(width, height) ? Math.abs(width - height) / 2 : 0;
      };

      var getPaddingX = function (batchIdx) {
        return getPadding(batchIdx, function (w, h) {
          return w < h;
        });
      };

      var getPaddingY = function (batchIdx) {
        return getPadding(batchIdx, function (w, h) {
          return h < w;
        });
      };

      var landmarkTensors = output.mul(tf.fill([batchSize, 136], inputSize)).sub(tf.stack(Array.from(Array(batchSize), function (_, batchIdx) {
        return createInterleavedTensor(getPaddingX(batchIdx), getPaddingY(batchIdx));
      }))).div(tf.stack(Array.from(Array(batchSize), function (_, batchIdx) {
        return createInterleavedTensor(inputDimensions[batchIdx].width, inputDimensions[batchIdx].height);
      })));
      return landmarkTensors;
    });
  };

  FaceLandmark68NetBase.prototype.forwardInput = function (input) {
    var _this = this;

    return tf.tidy(function () {
      var out = _this.runNet(input);

      return _this.postProcess(out, input.inputSize, input.inputDimensions.map(function (_a) {
        var height = _a[0],
            width = _a[1];
        return {
          height: height,
          width: width
        };
      }));
    });
  };

  FaceLandmark68NetBase.prototype.forward = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [2
            /*return*/
            , _a.apply(this, [_b.sent()])];
        }
      });
    });
  };

  FaceLandmark68NetBase.prototype.detectLandmarks = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var netInput, landmarkTensors, landmarksForBatch;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            netInput = _a.sent();
            landmarkTensors = tf.tidy(function () {
              return tf.unstack(_this.forwardInput(netInput));
            });
            return [4
            /*yield*/
            , Promise.all(landmarkTensors.map(function (landmarkTensor, batchIdx) {
              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
                var landmarksArray, _a, _b, xCoords, yCoords;

                return (0, _tslib.__generator)(this, function (_c) {
                  switch (_c.label) {
                    case 0:
                      _b = (_a = Array).from;
                      return [4
                      /*yield*/
                      , landmarkTensor.data()];

                    case 1:
                      landmarksArray = _b.apply(_a, [_c.sent()]);
                      xCoords = landmarksArray.filter(function (_, i) {
                        return (0, _utils.isEven)(i);
                      });
                      yCoords = landmarksArray.filter(function (_, i) {
                        return !(0, _utils.isEven)(i);
                      });
                      return [2
                      /*return*/
                      , new _FaceLandmarks.FaceLandmarks68(Array(68).fill(0).map(function (_, i) {
                        return new _classes.Point(xCoords[i], yCoords[i]);
                      }), {
                        height: netInput.getInputHeight(batchIdx),
                        width: netInput.getInputWidth(batchIdx)
                      })];
                  }
                });
              });
            }))];

          case 2:
            landmarksForBatch = _a.sent();
            landmarkTensors.forEach(function (t) {
              return t.dispose();
            });
            return [2
            /*return*/
            , netInput.isBatchInput ? landmarksForBatch : landmarksForBatch[0]];
        }
      });
    });
  };

  FaceLandmark68NetBase.prototype.getClassifierChannelsOut = function () {
    return 136;
  };

  return FaceLandmark68NetBase;
}(_FaceProcessor.FaceProcessor);

exports.FaceLandmark68NetBase = FaceLandmark68NetBase;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../classes":"node_modules/face-api.js/build/es6/classes/index.js","../classes/FaceLandmarks68":"node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../faceProcessor/FaceProcessor":"node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceLandmark68Net = void 0;

var _tslib = require("tslib");

var _FaceFeatureExtractor = require("../faceFeatureExtractor/FaceFeatureExtractor");

var _FaceLandmark68NetBase = require("./FaceLandmark68NetBase");

var FaceLandmark68Net =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceLandmark68Net, _super);

  function FaceLandmark68Net(faceFeatureExtractor) {
    if (faceFeatureExtractor === void 0) {
      faceFeatureExtractor = new _FaceFeatureExtractor.FaceFeatureExtractor();
    }

    return _super.call(this, 'FaceLandmark68Net', faceFeatureExtractor) || this;
  }

  FaceLandmark68Net.prototype.getDefaultModelName = function () {
    return 'face_landmark_68_model';
  };

  FaceLandmark68Net.prototype.getClassifierChannelsIn = function () {
    return 256;
  };

  return FaceLandmark68Net;
}(_FaceLandmark68NetBase.FaceLandmark68NetBase);

exports.FaceLandmark68Net = FaceLandmark68Net;
},{"tslib":"node_modules/tslib/tslib.es6.js","../faceFeatureExtractor/FaceFeatureExtractor":"node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js","./FaceLandmark68NetBase":"node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js"}],"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsFromWeigthMapTiny = extractParamsFromWeigthMapTiny;

var _common = require("../common");

var _loadParamsFactory = require("./loadParamsFactory");

function extractParamsFromWeigthMapTiny(weightMap) {
  var paramMappings = [];
  var extractDenseBlock3Params = (0, _loadParamsFactory.loadParamsFactory)(weightMap, paramMappings).extractDenseBlock3Params;
  var params = {
    dense0: extractDenseBlock3Params('dense0', true),
    dense1: extractDenseBlock3Params('dense1'),
    dense2: extractDenseBlock3Params('dense2')
  };
  (0, _common.disposeUnusedWeightTensors)(weightMap, paramMappings);
  return {
    params: params,
    paramMappings: paramMappings
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js","./loadParamsFactory":"node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js"}],"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsTiny = extractParamsTiny;

var _common = require("../common");

var _extractorsFactory = require("./extractorsFactory");

function extractParamsTiny(weights) {
  var paramMappings = [];

  var _a = (0, _common.extractWeightsFactory)(weights),
      extractWeights = _a.extractWeights,
      getRemainingWeights = _a.getRemainingWeights;

  var extractDenseBlock3Params = (0, _extractorsFactory.extractorsFactory)(extractWeights, paramMappings).extractDenseBlock3Params;
  var dense0 = extractDenseBlock3Params(3, 32, 'dense0', true);
  var dense1 = extractDenseBlock3Params(32, 64, 'dense1');
  var dense2 = extractDenseBlock3Params(64, 128, 'dense2');

  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }

  return {
    paramMappings: paramMappings,
    params: {
      dense0: dense0,
      dense1: dense1,
      dense2: dense2
    }
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js","./extractorsFactory":"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js"}],"node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyFaceFeatureExtractor = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _dom = require("../dom");

var _NeuralNetwork = require("../NeuralNetwork");

var _ops = require("../ops");

var _denseBlock = require("./denseBlock");

var _extractParamsFromWeigthMapTiny = require("./extractParamsFromWeigthMapTiny");

var _extractParamsTiny = require("./extractParamsTiny");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var TinyFaceFeatureExtractor =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TinyFaceFeatureExtractor, _super);

  function TinyFaceFeatureExtractor() {
    return _super.call(this, 'TinyFaceFeatureExtractor') || this;
  }

  TinyFaceFeatureExtractor.prototype.forwardInput = function (input) {
    var params = this.params;

    if (!params) {
      throw new Error('TinyFaceFeatureExtractor - load model before inference');
    }

    return tf.tidy(function () {
      var batchTensor = input.toBatchTensor(112, true);
      var meanRgb = [122.782, 117.001, 104.298];
      var normalized = (0, _ops.normalize)(batchTensor, meanRgb).div(tf.scalar(255));
      var out = (0, _denseBlock.denseBlock3)(normalized, params.dense0, true);
      out = (0, _denseBlock.denseBlock3)(out, params.dense1);
      out = (0, _denseBlock.denseBlock3)(out, params.dense2);
      out = tf.avgPool(out, [14, 14], [2, 2], 'valid');
      return out;
    });
  };

  TinyFaceFeatureExtractor.prototype.forward = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [2
            /*return*/
            , _a.apply(this, [_b.sent()])];
        }
      });
    });
  };

  TinyFaceFeatureExtractor.prototype.getDefaultModelName = function () {
    return 'face_feature_extractor_tiny_model';
  };

  TinyFaceFeatureExtractor.prototype.extractParamsFromWeigthMap = function (weightMap) {
    return (0, _extractParamsFromWeigthMapTiny.extractParamsFromWeigthMapTiny)(weightMap);
  };

  TinyFaceFeatureExtractor.prototype.extractParams = function (weights) {
    return (0, _extractParamsTiny.extractParamsTiny)(weights);
  };

  return TinyFaceFeatureExtractor;
}(_NeuralNetwork.NeuralNetwork);

exports.TinyFaceFeatureExtractor = TinyFaceFeatureExtractor;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","../ops":"node_modules/face-api.js/build/es6/ops/index.js","./denseBlock":"node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js","./extractParamsFromWeigthMapTiny":"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js","./extractParamsTiny":"node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js"}],"node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceLandmark68TinyNet = void 0;

var _tslib = require("tslib");

var _TinyFaceFeatureExtractor = require("../faceFeatureExtractor/TinyFaceFeatureExtractor");

var _FaceLandmark68NetBase = require("./FaceLandmark68NetBase");

var FaceLandmark68TinyNet =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceLandmark68TinyNet, _super);

  function FaceLandmark68TinyNet(faceFeatureExtractor) {
    if (faceFeatureExtractor === void 0) {
      faceFeatureExtractor = new _TinyFaceFeatureExtractor.TinyFaceFeatureExtractor();
    }

    return _super.call(this, 'FaceLandmark68TinyNet', faceFeatureExtractor) || this;
  }

  FaceLandmark68TinyNet.prototype.getDefaultModelName = function () {
    return 'face_landmark_68_tiny_model';
  };

  FaceLandmark68TinyNet.prototype.getClassifierChannelsIn = function () {
    return 128;
  };

  return FaceLandmark68TinyNet;
}(_FaceLandmark68NetBase.FaceLandmark68NetBase);

exports.FaceLandmark68TinyNet = FaceLandmark68TinyNet;
},{"tslib":"node_modules/tslib/tslib.es6.js","../faceFeatureExtractor/TinyFaceFeatureExtractor":"node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js","./FaceLandmark68NetBase":"node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js"}],"node_modules/face-api.js/build/es6/faceLandmarkNet/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  FaceLandmarkNet: true
};
exports.FaceLandmarkNet = void 0;

var _tslib = require("tslib");

var _FaceLandmark68Net = require("./FaceLandmark68Net");

Object.keys(_FaceLandmark68Net).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceLandmark68Net[key];
    }
  });
});

var _FaceLandmark68TinyNet = require("./FaceLandmark68TinyNet");

Object.keys(_FaceLandmark68TinyNet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceLandmark68TinyNet[key];
    }
  });
});

var FaceLandmarkNet =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceLandmarkNet, _super);

  function FaceLandmarkNet() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return FaceLandmarkNet;
}(_FaceLandmark68Net.FaceLandmark68Net);

exports.FaceLandmarkNet = FaceLandmarkNet;
},{"tslib":"node_modules/tslib/tslib.es6.js","./FaceLandmark68Net":"node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js","./FaceLandmark68TinyNet":"node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js"}],"node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scale = scale;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function scale(x, params) {
  return tf.add(tf.mul(x, params.weights), params.biases);
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conv = conv;
exports.convNoRelu = convNoRelu;
exports.convDown = convDown;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _scaleLayer = require("./scaleLayer");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function convLayer(x, params, strides, withRelu, padding) {
  if (padding === void 0) {
    padding = 'same';
  }

  var _a = params.conv,
      filters = _a.filters,
      bias = _a.bias;
  var out = tf.conv2d(x, filters, strides, padding);
  out = tf.add(out, bias);
  out = (0, _scaleLayer.scale)(out, params.scale);
  return withRelu ? tf.relu(out) : out;
}

function conv(x, params) {
  return convLayer(x, params, [1, 1], true);
}

function convNoRelu(x, params) {
  return convLayer(x, params, [1, 1], false);
}

function convDown(x, params) {
  return convLayer(x, params, [2, 2], true, 'valid');
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./scaleLayer":"node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js"}],"node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParams = extractParams;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _common = require("../common");

var _utils = require("../utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function extractorsFactory(extractWeights, paramMappings) {
  function extractFilterValues(numFilterValues, numFilters, filterSize) {
    var weights = extractWeights(numFilterValues);
    var depth = weights.length / (numFilters * filterSize * filterSize);

    if ((0, _utils.isFloat)(depth)) {
      throw new Error("depth has to be an integer: " + depth + ", weights.length: " + weights.length + ", numFilters: " + numFilters + ", filterSize: " + filterSize);
    }

    return tf.tidy(function () {
      return tf.transpose(tf.tensor4d(weights, [numFilters, depth, filterSize, filterSize]), [2, 3, 1, 0]);
    });
  }

  function extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
    var filters = extractFilterValues(numFilterValues, numFilters, filterSize);
    var bias = tf.tensor1d(extractWeights(numFilters));
    paramMappings.push({
      paramPath: mappedPrefix + "/filters"
    }, {
      paramPath: mappedPrefix + "/bias"
    });
    return {
      filters: filters,
      bias: bias
    };
  }

  function extractScaleLayerParams(numWeights, mappedPrefix) {
    var weights = tf.tensor1d(extractWeights(numWeights));
    var biases = tf.tensor1d(extractWeights(numWeights));
    paramMappings.push({
      paramPath: mappedPrefix + "/weights"
    }, {
      paramPath: mappedPrefix + "/biases"
    });
    return {
      weights: weights,
      biases: biases
    };
  }

  function extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
    var conv = extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv");
    var scale = extractScaleLayerParams(numFilters, mappedPrefix + "/scale");
    return {
      conv: conv,
      scale: scale
    };
  }

  function extractResidualLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix, isDown) {
    if (isDown === void 0) {
      isDown = false;
    }

    var conv1 = extractConvLayerParams((isDown ? 0.5 : 1) * numFilterValues, numFilters, filterSize, mappedPrefix + "/conv1");
    var conv2 = extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv2");
    return {
      conv1: conv1,
      conv2: conv2
    };
  }

  return {
    extractConvLayerParams: extractConvLayerParams,
    extractResidualLayerParams: extractResidualLayerParams
  };
}

function extractParams(weights) {
  var _a = (0, _common.extractWeightsFactory)(weights),
      extractWeights = _a.extractWeights,
      getRemainingWeights = _a.getRemainingWeights;

  var paramMappings = [];

  var _b = extractorsFactory(extractWeights, paramMappings),
      extractConvLayerParams = _b.extractConvLayerParams,
      extractResidualLayerParams = _b.extractResidualLayerParams;

  var conv32_down = extractConvLayerParams(4704, 32, 7, 'conv32_down');
  var conv32_1 = extractResidualLayerParams(9216, 32, 3, 'conv32_1');
  var conv32_2 = extractResidualLayerParams(9216, 32, 3, 'conv32_2');
  var conv32_3 = extractResidualLayerParams(9216, 32, 3, 'conv32_3');
  var conv64_down = extractResidualLayerParams(36864, 64, 3, 'conv64_down', true);
  var conv64_1 = extractResidualLayerParams(36864, 64, 3, 'conv64_1');
  var conv64_2 = extractResidualLayerParams(36864, 64, 3, 'conv64_2');
  var conv64_3 = extractResidualLayerParams(36864, 64, 3, 'conv64_3');
  var conv128_down = extractResidualLayerParams(147456, 128, 3, 'conv128_down', true);
  var conv128_1 = extractResidualLayerParams(147456, 128, 3, 'conv128_1');
  var conv128_2 = extractResidualLayerParams(147456, 128, 3, 'conv128_2');
  var conv256_down = extractResidualLayerParams(589824, 256, 3, 'conv256_down', true);
  var conv256_1 = extractResidualLayerParams(589824, 256, 3, 'conv256_1');
  var conv256_2 = extractResidualLayerParams(589824, 256, 3, 'conv256_2');
  var conv256_down_out = extractResidualLayerParams(589824, 256, 3, 'conv256_down_out');
  var fc = tf.tidy(function () {
    return tf.transpose(tf.tensor2d(extractWeights(256 * 128), [128, 256]), [1, 0]);
  });
  paramMappings.push({
    paramPath: "fc"
  });

  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }

  var params = {
    conv32_down: conv32_down,
    conv32_1: conv32_1,
    conv32_2: conv32_2,
    conv32_3: conv32_3,
    conv64_down: conv64_down,
    conv64_1: conv64_1,
    conv64_2: conv64_2,
    conv64_3: conv64_3,
    conv128_down: conv128_down,
    conv128_1: conv128_1,
    conv128_2: conv128_2,
    conv256_down: conv256_down,
    conv256_1: conv256_1,
    conv256_2: conv256_2,
    conv256_down_out: conv256_down_out,
    fc: fc
  };
  return {
    params: params,
    paramMappings: paramMappings
  };
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common":"node_modules/face-api.js/build/es6/common/index.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsFromWeigthMap = extractParamsFromWeigthMap;

var _common = require("../common");

var _utils = require("../utils");

function extractorsFactory(weightMap, paramMappings) {
  var extractWeightEntry = (0, _common.extractWeightEntryFactory)(weightMap, paramMappings);

  function extractScaleLayerParams(prefix) {
    var weights = extractWeightEntry(prefix + "/scale/weights", 1);
    var biases = extractWeightEntry(prefix + "/scale/biases", 1);
    return {
      weights: weights,
      biases: biases
    };
  }

  function extractConvLayerParams(prefix) {
    var filters = extractWeightEntry(prefix + "/conv/filters", 4);
    var bias = extractWeightEntry(prefix + "/conv/bias", 1);
    var scale = extractScaleLayerParams(prefix);
    return {
      conv: {
        filters: filters,
        bias: bias
      },
      scale: scale
    };
  }

  function extractResidualLayerParams(prefix) {
    return {
      conv1: extractConvLayerParams(prefix + "/conv1"),
      conv2: extractConvLayerParams(prefix + "/conv2")
    };
  }

  return {
    extractConvLayerParams: extractConvLayerParams,
    extractResidualLayerParams: extractResidualLayerParams
  };
}

function extractParamsFromWeigthMap(weightMap) {
  var paramMappings = [];

  var _a = extractorsFactory(weightMap, paramMappings),
      extractConvLayerParams = _a.extractConvLayerParams,
      extractResidualLayerParams = _a.extractResidualLayerParams;

  var conv32_down = extractConvLayerParams('conv32_down');
  var conv32_1 = extractResidualLayerParams('conv32_1');
  var conv32_2 = extractResidualLayerParams('conv32_2');
  var conv32_3 = extractResidualLayerParams('conv32_3');
  var conv64_down = extractResidualLayerParams('conv64_down');
  var conv64_1 = extractResidualLayerParams('conv64_1');
  var conv64_2 = extractResidualLayerParams('conv64_2');
  var conv64_3 = extractResidualLayerParams('conv64_3');
  var conv128_down = extractResidualLayerParams('conv128_down');
  var conv128_1 = extractResidualLayerParams('conv128_1');
  var conv128_2 = extractResidualLayerParams('conv128_2');
  var conv256_down = extractResidualLayerParams('conv256_down');
  var conv256_1 = extractResidualLayerParams('conv256_1');
  var conv256_2 = extractResidualLayerParams('conv256_2');
  var conv256_down_out = extractResidualLayerParams('conv256_down_out');
  var fc = weightMap['fc'];
  paramMappings.push({
    originalPath: 'fc',
    paramPath: 'fc'
  });

  if (!(0, _utils.isTensor2D)(fc)) {
    throw new Error("expected weightMap[fc] to be a Tensor2D, instead have " + fc);
  }

  var params = {
    conv32_down: conv32_down,
    conv32_1: conv32_1,
    conv32_2: conv32_2,
    conv32_3: conv32_3,
    conv64_down: conv64_down,
    conv64_1: conv64_1,
    conv64_2: conv64_2,
    conv64_3: conv64_3,
    conv128_down: conv128_down,
    conv128_1: conv128_1,
    conv128_2: conv128_2,
    conv256_down: conv256_down,
    conv256_1: conv256_1,
    conv256_2: conv256_2,
    conv256_down_out: conv256_down_out,
    fc: fc
  };
  (0, _common.disposeUnusedWeightTensors)(weightMap, paramMappings);
  return {
    params: params,
    paramMappings: paramMappings
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.residual = residual;
exports.residualDown = residualDown;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _convLayer = require("./convLayer");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function residual(x, params) {
  var out = (0, _convLayer.conv)(x, params.conv1);
  out = (0, _convLayer.convNoRelu)(out, params.conv2);
  out = tf.add(out, x);
  out = tf.relu(out);
  return out;
}

function residualDown(x, params) {
  var out = (0, _convLayer.convDown)(x, params.conv1);
  out = (0, _convLayer.convNoRelu)(out, params.conv2);
  var pooled = tf.avgPool(x, 2, 2, 'valid');
  var zeros = tf.zeros(pooled.shape);
  var isPad = pooled.shape[3] !== out.shape[3];
  var isAdjustShape = pooled.shape[1] !== out.shape[1] || pooled.shape[2] !== out.shape[2];

  if (isAdjustShape) {
    var padShapeX = (0, _tslib.__spreadArrays)(out.shape);
    padShapeX[1] = 1;
    var zerosW = tf.zeros(padShapeX);
    out = tf.concat([out, zerosW], 1);
    var padShapeY = (0, _tslib.__spreadArrays)(out.shape);
    padShapeY[2] = 1;
    var zerosH = tf.zeros(padShapeY);
    out = tf.concat([out, zerosH], 2);
  }

  pooled = isPad ? tf.concat([pooled, zeros], 3) : pooled;
  out = tf.add(pooled, out);
  out = tf.relu(out);
  return out;
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./convLayer":"node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js"}],"node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceRecognitionNet = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _dom = require("../dom");

var _NeuralNetwork = require("../NeuralNetwork");

var _ops = require("../ops");

var _convLayer = require("./convLayer");

var _extractParams = require("./extractParams");

var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");

var _residualLayer = require("./residualLayer");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var FaceRecognitionNet =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceRecognitionNet, _super);

  function FaceRecognitionNet() {
    return _super.call(this, 'FaceRecognitionNet') || this;
  }

  FaceRecognitionNet.prototype.forwardInput = function (input) {
    var params = this.params;

    if (!params) {
      throw new Error('FaceRecognitionNet - load model before inference');
    }

    return tf.tidy(function () {
      var batchTensor = input.toBatchTensor(150, true).toFloat();
      var meanRgb = [122.782, 117.001, 104.298];
      var normalized = (0, _ops.normalize)(batchTensor, meanRgb).div(tf.scalar(256));
      var out = (0, _convLayer.convDown)(normalized, params.conv32_down);
      out = tf.maxPool(out, 3, 2, 'valid');
      out = (0, _residualLayer.residual)(out, params.conv32_1);
      out = (0, _residualLayer.residual)(out, params.conv32_2);
      out = (0, _residualLayer.residual)(out, params.conv32_3);
      out = (0, _residualLayer.residualDown)(out, params.conv64_down);
      out = (0, _residualLayer.residual)(out, params.conv64_1);
      out = (0, _residualLayer.residual)(out, params.conv64_2);
      out = (0, _residualLayer.residual)(out, params.conv64_3);
      out = (0, _residualLayer.residualDown)(out, params.conv128_down);
      out = (0, _residualLayer.residual)(out, params.conv128_1);
      out = (0, _residualLayer.residual)(out, params.conv128_2);
      out = (0, _residualLayer.residualDown)(out, params.conv256_down);
      out = (0, _residualLayer.residual)(out, params.conv256_1);
      out = (0, _residualLayer.residual)(out, params.conv256_2);
      out = (0, _residualLayer.residualDown)(out, params.conv256_down_out);
      var globalAvg = out.mean([1, 2]);
      var fullyConnected = tf.matMul(globalAvg, params.fc);
      return fullyConnected;
    });
  };

  FaceRecognitionNet.prototype.forward = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [2
            /*return*/
            , _a.apply(this, [_b.sent()])];
        }
      });
    });
  };

  FaceRecognitionNet.prototype.computeFaceDescriptor = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var netInput, faceDescriptorTensors, faceDescriptorsForBatch;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            netInput = _a.sent();
            faceDescriptorTensors = tf.tidy(function () {
              return tf.unstack(_this.forwardInput(netInput));
            });
            return [4
            /*yield*/
            , Promise.all(faceDescriptorTensors.map(function (t) {
              return t.data();
            }))];

          case 2:
            faceDescriptorsForBatch = _a.sent();
            faceDescriptorTensors.forEach(function (t) {
              return t.dispose();
            });
            return [2
            /*return*/
            , netInput.isBatchInput ? faceDescriptorsForBatch : faceDescriptorsForBatch[0]];
        }
      });
    });
  };

  FaceRecognitionNet.prototype.getDefaultModelName = function () {
    return 'face_recognition_model';
  };

  FaceRecognitionNet.prototype.extractParamsFromWeigthMap = function (weightMap) {
    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap);
  };

  FaceRecognitionNet.prototype.extractParams = function (weights) {
    return (0, _extractParams.extractParams)(weights);
  };

  return FaceRecognitionNet;
}(_NeuralNetwork.NeuralNetwork);

exports.FaceRecognitionNet = FaceRecognitionNet;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","../ops":"node_modules/face-api.js/build/es6/ops/index.js","./convLayer":"node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js","./extractParams":"node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js","./extractParamsFromWeigthMap":"node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js","./residualLayer":"node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js"}],"node_modules/face-api.js/build/es6/faceRecognitionNet/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createFaceRecognitionNet: true
};
exports.createFaceRecognitionNet = createFaceRecognitionNet;

var _FaceRecognitionNet = require("./FaceRecognitionNet");

Object.keys(_FaceRecognitionNet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceRecognitionNet[key];
    }
  });
});

function createFaceRecognitionNet(weights) {
  var net = new _FaceRecognitionNet.FaceRecognitionNet();
  net.extractWeights(weights);
  return net;
}
},{"./FaceRecognitionNet":"node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js"}],"node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extendWithFaceDescriptor = extendWithFaceDescriptor;

function extendWithFaceDescriptor(sourceObj, descriptor) {
  var extension = {
    descriptor: descriptor
  };
  return Object.assign({}, sourceObj, extension);
}
},{}],"node_modules/face-api.js/build/es6/factories/WithAge.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWithAge = isWithAge;
exports.extendWithAge = extendWithAge;

function isWithAge(obj) {
  return typeof obj['age'] === 'number';
}

function extendWithAge(sourceObj, age) {
  var extension = {
    age: age
  };
  return Object.assign({}, sourceObj, extension);
}
},{}],"node_modules/face-api.js/build/es6/factories/WithGender.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWithGender = isWithGender;
exports.extendWithGender = extendWithGender;

var _types = require("../ageGenderNet/types");

var _utils = require("../utils");

function isWithGender(obj) {
  return (obj['gender'] === _types.Gender.MALE || obj['gender'] === _types.Gender.FEMALE) && (0, _utils.isValidProbablitiy)(obj['genderProbability']);
}

function extendWithGender(sourceObj, gender, genderProbability) {
  var extension = {
    gender: gender,
    genderProbability: genderProbability
  };
  return Object.assign({}, sourceObj, extension);
}
},{"../ageGenderNet/types":"node_modules/face-api.js/build/es6/ageGenderNet/types.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/factories/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _WithFaceDescriptor = require("./WithFaceDescriptor");

Object.keys(_WithFaceDescriptor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _WithFaceDescriptor[key];
    }
  });
});

var _WithFaceDetection = require("./WithFaceDetection");

Object.keys(_WithFaceDetection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _WithFaceDetection[key];
    }
  });
});

var _WithFaceExpressions = require("./WithFaceExpressions");

Object.keys(_WithFaceExpressions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _WithFaceExpressions[key];
    }
  });
});

var _WithFaceLandmarks = require("./WithFaceLandmarks");

Object.keys(_WithFaceLandmarks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _WithFaceLandmarks[key];
    }
  });
});

var _WithAge = require("./WithAge");

Object.keys(_WithAge).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _WithAge[key];
    }
  });
});

var _WithGender = require("./WithGender");

Object.keys(_WithGender).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _WithGender[key];
    }
  });
});
},{"./WithFaceDescriptor":"node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js","./WithFaceDetection":"node_modules/face-api.js/build/es6/factories/WithFaceDetection.js","./WithFaceExpressions":"node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js","./WithFaceLandmarks":"node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js","./WithAge":"node_modules/face-api.js/build/es6/factories/WithAge.js","./WithGender":"node_modules/face-api.js/build/es6/factories/WithGender.js"}],"node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MtcnnOptions = void 0;

var MtcnnOptions =
/** @class */
function () {
  function MtcnnOptions(_a) {
    var _b = _a === void 0 ? {} : _a,
        minFaceSize = _b.minFaceSize,
        scaleFactor = _b.scaleFactor,
        maxNumScales = _b.maxNumScales,
        scoreThresholds = _b.scoreThresholds,
        scaleSteps = _b.scaleSteps;

    this._name = 'MtcnnOptions';
    this._minFaceSize = minFaceSize || 20;
    this._scaleFactor = scaleFactor || 0.709;
    this._maxNumScales = maxNumScales || 10;
    this._scoreThresholds = scoreThresholds || [0.6, 0.7, 0.7];
    this._scaleSteps = scaleSteps;

    if (typeof this._minFaceSize !== 'number' || this._minFaceSize < 0) {
      throw new Error(this._name + " - expected minFaceSize to be a number > 0");
    }

    if (typeof this._scaleFactor !== 'number' || this._scaleFactor <= 0 || this._scaleFactor >= 1) {
      throw new Error(this._name + " - expected scaleFactor to be a number between 0 and 1");
    }

    if (typeof this._maxNumScales !== 'number' || this._maxNumScales < 0) {
      throw new Error(this._name + " - expected maxNumScales to be a number > 0");
    }

    if (!Array.isArray(this._scoreThresholds) || this._scoreThresholds.length !== 3 || this._scoreThresholds.some(function (th) {
      return typeof th !== 'number';
    })) {
      throw new Error(this._name + " - expected scoreThresholds to be an array of numbers of length 3");
    }

    if (this._scaleSteps && (!Array.isArray(this._scaleSteps) || this._scaleSteps.some(function (th) {
      return typeof th !== 'number';
    }))) {
      throw new Error(this._name + " - expected scaleSteps to be an array of numbers");
    }
  }

  Object.defineProperty(MtcnnOptions.prototype, "minFaceSize", {
    get: function () {
      return this._minFaceSize;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MtcnnOptions.prototype, "scaleFactor", {
    get: function () {
      return this._scaleFactor;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MtcnnOptions.prototype, "maxNumScales", {
    get: function () {
      return this._maxNumScales;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MtcnnOptions.prototype, "scoreThresholds", {
    get: function () {
      return this._scoreThresholds;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MtcnnOptions.prototype, "scaleSteps", {
    get: function () {
      return this._scaleSteps;
    },
    enumerable: true,
    configurable: true
  });
  return MtcnnOptions;
}();

exports.MtcnnOptions = MtcnnOptions;
},{}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParams = extractParams;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _common = require("../common");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function extractorsFactory(extractWeights, paramMappings) {
  function extractDepthwiseConvParams(numChannels, mappedPrefix) {
    var filters = tf.tensor4d(extractWeights(3 * 3 * numChannels), [3, 3, numChannels, 1]);
    var batch_norm_scale = tf.tensor1d(extractWeights(numChannels));
    var batch_norm_offset = tf.tensor1d(extractWeights(numChannels));
    var batch_norm_mean = tf.tensor1d(extractWeights(numChannels));
    var batch_norm_variance = tf.tensor1d(extractWeights(numChannels));
    paramMappings.push({
      paramPath: mappedPrefix + "/filters"
    }, {
      paramPath: mappedPrefix + "/batch_norm_scale"
    }, {
      paramPath: mappedPrefix + "/batch_norm_offset"
    }, {
      paramPath: mappedPrefix + "/batch_norm_mean"
    }, {
      paramPath: mappedPrefix + "/batch_norm_variance"
    });
    return {
      filters: filters,
      batch_norm_scale: batch_norm_scale,
      batch_norm_offset: batch_norm_offset,
      batch_norm_mean: batch_norm_mean,
      batch_norm_variance: batch_norm_variance
    };
  }

  function extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, isPointwiseConv) {
    var filters = tf.tensor4d(extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);
    var bias = tf.tensor1d(extractWeights(channelsOut));
    paramMappings.push({
      paramPath: mappedPrefix + "/filters"
    }, {
      paramPath: mappedPrefix + "/" + (isPointwiseConv ? 'batch_norm_offset' : 'bias')
    });
    return {
      filters: filters,
      bias: bias
    };
  }

  function extractPointwiseConvParams(channelsIn, channelsOut, filterSize, mappedPrefix) {
    var _a = extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, true),
        filters = _a.filters,
        bias = _a.bias;

    return {
      filters: filters,
      batch_norm_offset: bias
    };
  }

  function extractConvPairParams(channelsIn, channelsOut, mappedPrefix) {
    var depthwise_conv = extractDepthwiseConvParams(channelsIn, mappedPrefix + "/depthwise_conv");
    var pointwise_conv = extractPointwiseConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/pointwise_conv");
    return {
      depthwise_conv: depthwise_conv,
      pointwise_conv: pointwise_conv
    };
  }

  function extractMobilenetV1Params() {
    var conv_0 = extractPointwiseConvParams(3, 32, 3, 'mobilenetv1/conv_0');
    var conv_1 = extractConvPairParams(32, 64, 'mobilenetv1/conv_1');
    var conv_2 = extractConvPairParams(64, 128, 'mobilenetv1/conv_2');
    var conv_3 = extractConvPairParams(128, 128, 'mobilenetv1/conv_3');
    var conv_4 = extractConvPairParams(128, 256, 'mobilenetv1/conv_4');
    var conv_5 = extractConvPairParams(256, 256, 'mobilenetv1/conv_5');
    var conv_6 = extractConvPairParams(256, 512, 'mobilenetv1/conv_6');
    var conv_7 = extractConvPairParams(512, 512, 'mobilenetv1/conv_7');
    var conv_8 = extractConvPairParams(512, 512, 'mobilenetv1/conv_8');
    var conv_9 = extractConvPairParams(512, 512, 'mobilenetv1/conv_9');
    var conv_10 = extractConvPairParams(512, 512, 'mobilenetv1/conv_10');
    var conv_11 = extractConvPairParams(512, 512, 'mobilenetv1/conv_11');
    var conv_12 = extractConvPairParams(512, 1024, 'mobilenetv1/conv_12');
    var conv_13 = extractConvPairParams(1024, 1024, 'mobilenetv1/conv_13');
    return {
      conv_0: conv_0,
      conv_1: conv_1,
      conv_2: conv_2,
      conv_3: conv_3,
      conv_4: conv_4,
      conv_5: conv_5,
      conv_6: conv_6,
      conv_7: conv_7,
      conv_8: conv_8,
      conv_9: conv_9,
      conv_10: conv_10,
      conv_11: conv_11,
      conv_12: conv_12,
      conv_13: conv_13
    };
  }

  function extractPredictionLayerParams() {
    var conv_0 = extractPointwiseConvParams(1024, 256, 1, 'prediction_layer/conv_0');
    var conv_1 = extractPointwiseConvParams(256, 512, 3, 'prediction_layer/conv_1');
    var conv_2 = extractPointwiseConvParams(512, 128, 1, 'prediction_layer/conv_2');
    var conv_3 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_3');
    var conv_4 = extractPointwiseConvParams(256, 128, 1, 'prediction_layer/conv_4');
    var conv_5 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_5');
    var conv_6 = extractPointwiseConvParams(256, 64, 1, 'prediction_layer/conv_6');
    var conv_7 = extractPointwiseConvParams(64, 128, 3, 'prediction_layer/conv_7');
    var box_encoding_0_predictor = extractConvParams(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor');
    var class_predictor_0 = extractConvParams(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor');
    var box_encoding_1_predictor = extractConvParams(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor');
    var class_predictor_1 = extractConvParams(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor');
    var box_encoding_2_predictor = extractConvParams(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor');
    var class_predictor_2 = extractConvParams(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor');
    var box_encoding_3_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor');
    var class_predictor_3 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor');
    var box_encoding_4_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor');
    var class_predictor_4 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor');
    var box_encoding_5_predictor = extractConvParams(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor');
    var class_predictor_5 = extractConvParams(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor');
    var box_predictor_0 = {
      box_encoding_predictor: box_encoding_0_predictor,
      class_predictor: class_predictor_0
    };
    var box_predictor_1 = {
      box_encoding_predictor: box_encoding_1_predictor,
      class_predictor: class_predictor_1
    };
    var box_predictor_2 = {
      box_encoding_predictor: box_encoding_2_predictor,
      class_predictor: class_predictor_2
    };
    var box_predictor_3 = {
      box_encoding_predictor: box_encoding_3_predictor,
      class_predictor: class_predictor_3
    };
    var box_predictor_4 = {
      box_encoding_predictor: box_encoding_4_predictor,
      class_predictor: class_predictor_4
    };
    var box_predictor_5 = {
      box_encoding_predictor: box_encoding_5_predictor,
      class_predictor: class_predictor_5
    };
    return {
      conv_0: conv_0,
      conv_1: conv_1,
      conv_2: conv_2,
      conv_3: conv_3,
      conv_4: conv_4,
      conv_5: conv_5,
      conv_6: conv_6,
      conv_7: conv_7,
      box_predictor_0: box_predictor_0,
      box_predictor_1: box_predictor_1,
      box_predictor_2: box_predictor_2,
      box_predictor_3: box_predictor_3,
      box_predictor_4: box_predictor_4,
      box_predictor_5: box_predictor_5
    };
  }

  return {
    extractMobilenetV1Params: extractMobilenetV1Params,
    extractPredictionLayerParams: extractPredictionLayerParams
  };
}

function extractParams(weights) {
  var paramMappings = [];

  var _a = (0, _common.extractWeightsFactory)(weights),
      extractWeights = _a.extractWeights,
      getRemainingWeights = _a.getRemainingWeights;

  var _b = extractorsFactory(extractWeights, paramMappings),
      extractMobilenetV1Params = _b.extractMobilenetV1Params,
      extractPredictionLayerParams = _b.extractPredictionLayerParams;

  var mobilenetv1 = extractMobilenetV1Params();
  var prediction_layer = extractPredictionLayerParams();
  var extra_dim = tf.tensor3d(extractWeights(5118 * 4), [1, 5118, 4]);
  var output_layer = {
    extra_dim: extra_dim
  };
  paramMappings.push({
    paramPath: 'output_layer/extra_dim'
  });

  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }

  return {
    params: {
      mobilenetv1: mobilenetv1,
      prediction_layer: prediction_layer,
      output_layer: output_layer
    },
    paramMappings: paramMappings
  };
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common":"node_modules/face-api.js/build/es6/common/index.js"}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsFromWeigthMap = extractParamsFromWeigthMap;

var _common = require("../common");

var _utils = require("../utils");

function extractorsFactory(weightMap, paramMappings) {
  var extractWeightEntry = (0, _common.extractWeightEntryFactory)(weightMap, paramMappings);

  function extractPointwiseConvParams(prefix, idx, mappedPrefix) {
    var filters = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/weights", 4, mappedPrefix + "/filters");
    var batch_norm_offset = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/convolution_bn_offset", 1, mappedPrefix + "/batch_norm_offset");
    return {
      filters: filters,
      batch_norm_offset: batch_norm_offset
    };
  }

  function extractConvPairParams(idx) {
    var mappedPrefix = "mobilenetv1/conv_" + idx;
    var prefixDepthwiseConv = "MobilenetV1/Conv2d_" + idx + "_depthwise";
    var mappedPrefixDepthwiseConv = mappedPrefix + "/depthwise_conv";
    var mappedPrefixPointwiseConv = mappedPrefix + "/pointwise_conv";
    var filters = extractWeightEntry(prefixDepthwiseConv + "/depthwise_weights", 4, mappedPrefixDepthwiseConv + "/filters");
    var batch_norm_scale = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/gamma", 1, mappedPrefixDepthwiseConv + "/batch_norm_scale");
    var batch_norm_offset = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/beta", 1, mappedPrefixDepthwiseConv + "/batch_norm_offset");
    var batch_norm_mean = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_mean", 1, mappedPrefixDepthwiseConv + "/batch_norm_mean");
    var batch_norm_variance = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_variance", 1, mappedPrefixDepthwiseConv + "/batch_norm_variance");
    return {
      depthwise_conv: {
        filters: filters,
        batch_norm_scale: batch_norm_scale,
        batch_norm_offset: batch_norm_offset,
        batch_norm_mean: batch_norm_mean,
        batch_norm_variance: batch_norm_variance
      },
      pointwise_conv: extractPointwiseConvParams('MobilenetV1', idx, mappedPrefixPointwiseConv)
    };
  }

  function extractMobilenetV1Params() {
    return {
      conv_0: extractPointwiseConvParams('MobilenetV1', 0, 'mobilenetv1/conv_0'),
      conv_1: extractConvPairParams(1),
      conv_2: extractConvPairParams(2),
      conv_3: extractConvPairParams(3),
      conv_4: extractConvPairParams(4),
      conv_5: extractConvPairParams(5),
      conv_6: extractConvPairParams(6),
      conv_7: extractConvPairParams(7),
      conv_8: extractConvPairParams(8),
      conv_9: extractConvPairParams(9),
      conv_10: extractConvPairParams(10),
      conv_11: extractConvPairParams(11),
      conv_12: extractConvPairParams(12),
      conv_13: extractConvPairParams(13)
    };
  }

  function extractConvParams(prefix, mappedPrefix) {
    var filters = extractWeightEntry(prefix + "/weights", 4, mappedPrefix + "/filters");
    var bias = extractWeightEntry(prefix + "/biases", 1, mappedPrefix + "/bias");
    return {
      filters: filters,
      bias: bias
    };
  }

  function extractBoxPredictorParams(idx) {
    var box_encoding_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/BoxEncodingPredictor", "prediction_layer/box_predictor_" + idx + "/box_encoding_predictor");
    var class_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/ClassPredictor", "prediction_layer/box_predictor_" + idx + "/class_predictor");
    return {
      box_encoding_predictor: box_encoding_predictor,
      class_predictor: class_predictor
    };
  }

  function extractPredictionLayerParams() {
    return {
      conv_0: extractPointwiseConvParams('Prediction', 0, 'prediction_layer/conv_0'),
      conv_1: extractPointwiseConvParams('Prediction', 1, 'prediction_layer/conv_1'),
      conv_2: extractPointwiseConvParams('Prediction', 2, 'prediction_layer/conv_2'),
      conv_3: extractPointwiseConvParams('Prediction', 3, 'prediction_layer/conv_3'),
      conv_4: extractPointwiseConvParams('Prediction', 4, 'prediction_layer/conv_4'),
      conv_5: extractPointwiseConvParams('Prediction', 5, 'prediction_layer/conv_5'),
      conv_6: extractPointwiseConvParams('Prediction', 6, 'prediction_layer/conv_6'),
      conv_7: extractPointwiseConvParams('Prediction', 7, 'prediction_layer/conv_7'),
      box_predictor_0: extractBoxPredictorParams(0),
      box_predictor_1: extractBoxPredictorParams(1),
      box_predictor_2: extractBoxPredictorParams(2),
      box_predictor_3: extractBoxPredictorParams(3),
      box_predictor_4: extractBoxPredictorParams(4),
      box_predictor_5: extractBoxPredictorParams(5)
    };
  }

  return {
    extractMobilenetV1Params: extractMobilenetV1Params,
    extractPredictionLayerParams: extractPredictionLayerParams
  };
}

function extractParamsFromWeigthMap(weightMap) {
  var paramMappings = [];

  var _a = extractorsFactory(weightMap, paramMappings),
      extractMobilenetV1Params = _a.extractMobilenetV1Params,
      extractPredictionLayerParams = _a.extractPredictionLayerParams;

  var extra_dim = weightMap['Output/extra_dim'];
  paramMappings.push({
    originalPath: 'Output/extra_dim',
    paramPath: 'output_layer/extra_dim'
  });

  if (!(0, _utils.isTensor3D)(extra_dim)) {
    throw new Error("expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have " + extra_dim);
  }

  var params = {
    mobilenetv1: extractMobilenetV1Params(),
    prediction_layer: extractPredictionLayerParams(),
    output_layer: {
      extra_dim: extra_dim
    }
  };
  (0, _common.disposeUnusedWeightTensors)(weightMap, paramMappings);
  return {
    params: params,
    paramMappings: paramMappings
  };
}
},{"../common":"node_modules/face-api.js/build/es6/common/index.js","../utils":"node_modules/face-api.js/build/es6/utils/index.js"}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointwiseConvLayer = pointwiseConvLayer;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function pointwiseConvLayer(x, params, strides) {
  return tf.tidy(function () {
    var out = tf.conv2d(x, params.filters, strides, 'same');
    out = tf.add(out, params.batch_norm_offset);
    return tf.clipByValue(out, 0, 6);
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mobileNetV1 = mobileNetV1;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _pointwiseConvLayer = require("./pointwiseConvLayer");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var epsilon = 0.0010000000474974513;

function depthwiseConvLayer(x, params, strides) {
  return tf.tidy(function () {
    var out = tf.depthwiseConv2d(x, params.filters, strides, 'same');
    out = tf.batchNorm(out, params.batch_norm_mean, params.batch_norm_variance, params.batch_norm_offset, params.batch_norm_scale, epsilon);
    return tf.clipByValue(out, 0, 6);
  });
}

function getStridesForLayerIdx(layerIdx) {
  return [2, 4, 6, 12].some(function (idx) {
    return idx === layerIdx;
  }) ? [2, 2] : [1, 1];
}

function mobileNetV1(x, params) {
  return tf.tidy(function () {
    var conv11 = null;
    var out = (0, _pointwiseConvLayer.pointwiseConvLayer)(x, params.conv_0, [2, 2]);
    var convPairParams = [params.conv_1, params.conv_2, params.conv_3, params.conv_4, params.conv_5, params.conv_6, params.conv_7, params.conv_8, params.conv_9, params.conv_10, params.conv_11, params.conv_12, params.conv_13];
    convPairParams.forEach(function (param, i) {
      var layerIdx = i + 1;
      var depthwiseConvStrides = getStridesForLayerIdx(layerIdx);
      out = depthwiseConvLayer(out, param.depthwise_conv, depthwiseConvStrides);
      out = (0, _pointwiseConvLayer.pointwiseConvLayer)(out, param.pointwise_conv, [1, 1]);

      if (layerIdx === 11) {
        conv11 = out;
      }
    });

    if (conv11 === null) {
      throw new Error('mobileNetV1 - output of conv layer 11 is null');
    }

    return {
      out: out,
      conv11: conv11
    };
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./pointwiseConvLayer":"node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js"}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nonMaxSuppression = nonMaxSuppression;

function nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
  var numBoxes = boxes.shape[0];
  var outputSize = Math.min(maxOutputSize, numBoxes);
  var candidates = scores.map(function (score, boxIndex) {
    return {
      score: score,
      boxIndex: boxIndex
    };
  }).filter(function (c) {
    return c.score > scoreThreshold;
  }).sort(function (c1, c2) {
    return c2.score - c1.score;
  });

  var suppressFunc = function (x) {
    return x <= iouThreshold ? 1 : 0;
  };

  var selected = [];
  candidates.forEach(function (c) {
    if (selected.length >= outputSize) {
      return;
    }

    var originalScore = c.score;

    for (var j = selected.length - 1; j >= 0; --j) {
      var iou = IOU(boxes, c.boxIndex, selected[j]);

      if (iou === 0.0) {
        continue;
      }

      c.score *= suppressFunc(iou);

      if (c.score <= scoreThreshold) {
        break;
      }
    }

    if (originalScore === c.score) {
      selected.push(c.boxIndex);
    }
  });
  return selected;
}

function IOU(boxes, i, j) {
  var boxesData = boxes.arraySync();
  var yminI = Math.min(boxesData[i][0], boxesData[i][2]);
  var xminI = Math.min(boxesData[i][1], boxesData[i][3]);
  var ymaxI = Math.max(boxesData[i][0], boxesData[i][2]);
  var xmaxI = Math.max(boxesData[i][1], boxesData[i][3]);
  var yminJ = Math.min(boxesData[j][0], boxesData[j][2]);
  var xminJ = Math.min(boxesData[j][1], boxesData[j][3]);
  var ymaxJ = Math.max(boxesData[j][0], boxesData[j][2]);
  var xmaxJ = Math.max(boxesData[j][1], boxesData[j][3]);
  var areaI = (ymaxI - yminI) * (xmaxI - xminI);
  var areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);

  if (areaI <= 0 || areaJ <= 0) {
    return 0.0;
  }

  var intersectionYmin = Math.max(yminI, yminJ);
  var intersectionXmin = Math.max(xminI, xminJ);
  var intersectionYmax = Math.min(ymaxI, ymaxJ);
  var intersectionXmax = Math.min(xmaxI, xmaxJ);
  var intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) * Math.max(intersectionXmax - intersectionXmin, 0.0);
  return intersectionArea / (areaI + areaJ - intersectionArea);
}
},{}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.outputLayer = outputLayer;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function getCenterCoordinatesAndSizesLayer(x) {
  var vec = tf.unstack(tf.transpose(x, [1, 0]));
  var sizes = [tf.sub(vec[2], vec[0]), tf.sub(vec[3], vec[1])];
  var centers = [tf.add(vec[0], tf.div(sizes[0], tf.scalar(2))), tf.add(vec[1], tf.div(sizes[1], tf.scalar(2)))];
  return {
    sizes: sizes,
    centers: centers
  };
}

function decodeBoxesLayer(x0, x1) {
  var _a = getCenterCoordinatesAndSizesLayer(x0),
      sizes = _a.sizes,
      centers = _a.centers;

  var vec = tf.unstack(tf.transpose(x1, [1, 0]));
  var div0_out = tf.div(tf.mul(tf.exp(tf.div(vec[2], tf.scalar(5))), sizes[0]), tf.scalar(2));
  var add0_out = tf.add(tf.mul(tf.div(vec[0], tf.scalar(10)), sizes[0]), centers[0]);
  var div1_out = tf.div(tf.mul(tf.exp(tf.div(vec[3], tf.scalar(5))), sizes[1]), tf.scalar(2));
  var add1_out = tf.add(tf.mul(tf.div(vec[1], tf.scalar(10)), sizes[1]), centers[1]);
  return tf.transpose(tf.stack([tf.sub(add0_out, div0_out), tf.sub(add1_out, div1_out), tf.add(add0_out, div0_out), tf.add(add1_out, div1_out)]), [1, 0]);
}

function outputLayer(boxPredictions, classPredictions, params) {
  return tf.tidy(function () {
    var batchSize = boxPredictions.shape[0];
    var boxes = decodeBoxesLayer(tf.reshape(tf.tile(params.extra_dim, [batchSize, 1, 1]), [-1, 4]), tf.reshape(boxPredictions, [-1, 4]));
    boxes = tf.reshape(boxes, [batchSize, boxes.shape[0] / batchSize, 4]);
    var scoresAndClasses = tf.sigmoid(tf.slice(classPredictions, [0, 0, 1], [-1, -1, -1]));
    var scores = tf.slice(scoresAndClasses, [0, 0, 0], [-1, -1, 1]);
    scores = tf.reshape(scores, [batchSize, scores.shape[1]]);
    var boxesByBatch = tf.unstack(boxes);
    var scoresByBatch = tf.unstack(scores);
    return {
      boxes: boxesByBatch,
      scores: scoresByBatch
    };
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.boxPredictionLayer = boxPredictionLayer;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _common = require("../common");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function boxPredictionLayer(x, params) {
  return tf.tidy(function () {
    var batchSize = x.shape[0];
    var boxPredictionEncoding = tf.reshape((0, _common.convLayer)(x, params.box_encoding_predictor), [batchSize, -1, 1, 4]);
    var classPrediction = tf.reshape((0, _common.convLayer)(x, params.class_predictor), [batchSize, -1, 3]);
    return {
      boxPredictionEncoding: boxPredictionEncoding,
      classPrediction: classPrediction
    };
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common":"node_modules/face-api.js/build/es6/common/index.js"}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.predictionLayer = predictionLayer;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _boxPredictionLayer = require("./boxPredictionLayer");

var _pointwiseConvLayer = require("./pointwiseConvLayer");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function predictionLayer(x, conv11, params) {
  return tf.tidy(function () {
    var conv0 = (0, _pointwiseConvLayer.pointwiseConvLayer)(x, params.conv_0, [1, 1]);
    var conv1 = (0, _pointwiseConvLayer.pointwiseConvLayer)(conv0, params.conv_1, [2, 2]);
    var conv2 = (0, _pointwiseConvLayer.pointwiseConvLayer)(conv1, params.conv_2, [1, 1]);
    var conv3 = (0, _pointwiseConvLayer.pointwiseConvLayer)(conv2, params.conv_3, [2, 2]);
    var conv4 = (0, _pointwiseConvLayer.pointwiseConvLayer)(conv3, params.conv_4, [1, 1]);
    var conv5 = (0, _pointwiseConvLayer.pointwiseConvLayer)(conv4, params.conv_5, [2, 2]);
    var conv6 = (0, _pointwiseConvLayer.pointwiseConvLayer)(conv5, params.conv_6, [1, 1]);
    var conv7 = (0, _pointwiseConvLayer.pointwiseConvLayer)(conv6, params.conv_7, [2, 2]);
    var boxPrediction0 = (0, _boxPredictionLayer.boxPredictionLayer)(conv11, params.box_predictor_0);
    var boxPrediction1 = (0, _boxPredictionLayer.boxPredictionLayer)(x, params.box_predictor_1);
    var boxPrediction2 = (0, _boxPredictionLayer.boxPredictionLayer)(conv1, params.box_predictor_2);
    var boxPrediction3 = (0, _boxPredictionLayer.boxPredictionLayer)(conv3, params.box_predictor_3);
    var boxPrediction4 = (0, _boxPredictionLayer.boxPredictionLayer)(conv5, params.box_predictor_4);
    var boxPrediction5 = (0, _boxPredictionLayer.boxPredictionLayer)(conv7, params.box_predictor_5);
    var boxPredictions = tf.concat([boxPrediction0.boxPredictionEncoding, boxPrediction1.boxPredictionEncoding, boxPrediction2.boxPredictionEncoding, boxPrediction3.boxPredictionEncoding, boxPrediction4.boxPredictionEncoding, boxPrediction5.boxPredictionEncoding], 1);
    var classPredictions = tf.concat([boxPrediction0.classPrediction, boxPrediction1.classPrediction, boxPrediction2.classPrediction, boxPrediction3.classPrediction, boxPrediction4.classPrediction, boxPrediction5.classPrediction], 1);
    return {
      boxPredictions: boxPredictions,
      classPredictions: classPredictions
    };
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./boxPredictionLayer":"node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js","./pointwiseConvLayer":"node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js"}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SsdMobilenetv1Options = void 0;

var SsdMobilenetv1Options =
/** @class */
function () {
  function SsdMobilenetv1Options(_a) {
    var _b = _a === void 0 ? {} : _a,
        minConfidence = _b.minConfidence,
        maxResults = _b.maxResults;

    this._name = 'SsdMobilenetv1Options';
    this._minConfidence = minConfidence || 0.5;
    this._maxResults = maxResults || 100;

    if (typeof this._minConfidence !== 'number' || this._minConfidence <= 0 || this._minConfidence >= 1) {
      throw new Error(this._name + " - expected minConfidence to be a number between 0 and 1");
    }

    if (typeof this._maxResults !== 'number') {
      throw new Error(this._name + " - expected maxResults to be a number");
    }
  }

  Object.defineProperty(SsdMobilenetv1Options.prototype, "minConfidence", {
    get: function () {
      return this._minConfidence;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(SsdMobilenetv1Options.prototype, "maxResults", {
    get: function () {
      return this._maxResults;
    },
    enumerable: true,
    configurable: true
  });
  return SsdMobilenetv1Options;
}();

exports.SsdMobilenetv1Options = SsdMobilenetv1Options;
},{}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SsdMobilenetv1 = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _classes = require("../classes");

var _FaceDetection = require("../classes/FaceDetection");

var _dom = require("../dom");

var _NeuralNetwork = require("../NeuralNetwork");

var _extractParams = require("./extractParams");

var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");

var _mobileNetV = require("./mobileNetV1");

var _nonMaxSuppression = require("./nonMaxSuppression");

var _outputLayer = require("./outputLayer");

var _predictionLayer = require("./predictionLayer");

var _SsdMobilenetv1Options = require("./SsdMobilenetv1Options");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var SsdMobilenetv1 =
/** @class */
function (_super) {
  (0, _tslib.__extends)(SsdMobilenetv1, _super);

  function SsdMobilenetv1() {
    return _super.call(this, 'SsdMobilenetv1') || this;
  }

  SsdMobilenetv1.prototype.forwardInput = function (input) {
    var params = this.params;

    if (!params) {
      throw new Error('SsdMobilenetv1 - load model before inference');
    }

    return tf.tidy(function () {
      var batchTensor = input.toBatchTensor(512, false).toFloat();
      var x = tf.sub(tf.mul(batchTensor, tf.scalar(0.007843137718737125)), tf.scalar(1));
      var features = (0, _mobileNetV.mobileNetV1)(x, params.mobilenetv1);

      var _a = (0, _predictionLayer.predictionLayer)(features.out, features.conv11, params.prediction_layer),
          boxPredictions = _a.boxPredictions,
          classPredictions = _a.classPredictions;

      return (0, _outputLayer.outputLayer)(boxPredictions, classPredictions, params.output_layer);
    });
  };

  SsdMobilenetv1.prototype.forward = function (input) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [2
            /*return*/
            , _a.apply(this, [_b.sent()])];
        }
      });
    });
  };

  SsdMobilenetv1.prototype.locateFaces = function (input, options) {
    if (options === void 0) {
      options = {};
    }

    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a, maxResults, minConfidence, netInput, _b, _boxes, _scores, boxes, scores, i, scoresData, _c, _d, iouThreshold, indices, reshapedDims, inputSize, padX, padY, boxesData, results;

      return (0, _tslib.__generator)(this, function (_e) {
        switch (_e.label) {
          case 0:
            _a = new _SsdMobilenetv1Options.SsdMobilenetv1Options(options), maxResults = _a.maxResults, minConfidence = _a.minConfidence;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            netInput = _e.sent();
            _b = this.forwardInput(netInput), _boxes = _b.boxes, _scores = _b.scores;
            boxes = _boxes[0];
            scores = _scores[0];

            for (i = 1; i < _boxes.length; i++) {
              _boxes[i].dispose();

              _scores[i].dispose();
            }

            _d = (_c = Array).from;
            return [4
            /*yield*/
            , scores.data()];

          case 2:
            scoresData = _d.apply(_c, [_e.sent()]);
            iouThreshold = 0.5;
            indices = (0, _nonMaxSuppression.nonMaxSuppression)(boxes, scoresData, maxResults, iouThreshold, minConfidence);
            reshapedDims = netInput.getReshapedInputDimensions(0);
            inputSize = netInput.inputSize;
            padX = inputSize / reshapedDims.width;
            padY = inputSize / reshapedDims.height;
            boxesData = boxes.arraySync();
            results = indices.map(function (idx) {
              var _a = [Math.max(0, boxesData[idx][0]), Math.min(1.0, boxesData[idx][2])].map(function (val) {
                return val * padY;
              }),
                  top = _a[0],
                  bottom = _a[1];

              var _b = [Math.max(0, boxesData[idx][1]), Math.min(1.0, boxesData[idx][3])].map(function (val) {
                return val * padX;
              }),
                  left = _b[0],
                  right = _b[1];

              return new _FaceDetection.FaceDetection(scoresData[idx], new _classes.Rect(left, top, right - left, bottom - top), {
                height: netInput.getInputHeight(0),
                width: netInput.getInputWidth(0)
              });
            });
            boxes.dispose();
            scores.dispose();
            return [2
            /*return*/
            , results];
        }
      });
    });
  };

  SsdMobilenetv1.prototype.getDefaultModelName = function () {
    return 'ssd_mobilenetv1_model';
  };

  SsdMobilenetv1.prototype.extractParamsFromWeigthMap = function (weightMap) {
    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap);
  };

  SsdMobilenetv1.prototype.extractParams = function (weights) {
    return (0, _extractParams.extractParams)(weights);
  };

  return SsdMobilenetv1;
}(_NeuralNetwork.NeuralNetwork);

exports.SsdMobilenetv1 = SsdMobilenetv1;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../classes":"node_modules/face-api.js/build/es6/classes/index.js","../classes/FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","./extractParams":"node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js","./extractParamsFromWeigthMap":"node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js","./mobileNetV1":"node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js","./nonMaxSuppression":"node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js","./outputLayer":"node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js","./predictionLayer":"node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js","./SsdMobilenetv1Options":"node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js"}],"node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createSsdMobilenetv1: true,
  createFaceDetectionNet: true,
  FaceDetectionNet: true
};
exports.createSsdMobilenetv1 = createSsdMobilenetv1;
exports.createFaceDetectionNet = createFaceDetectionNet;
exports.FaceDetectionNet = void 0;

var _tslib = require("tslib");

var _SsdMobilenetv = require("./SsdMobilenetv1");

Object.keys(_SsdMobilenetv).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _SsdMobilenetv[key];
    }
  });
});

var _SsdMobilenetv1Options = require("./SsdMobilenetv1Options");

Object.keys(_SsdMobilenetv1Options).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _SsdMobilenetv1Options[key];
    }
  });
});

function createSsdMobilenetv1(weights) {
  var net = new _SsdMobilenetv.SsdMobilenetv1();
  net.extractWeights(weights);
  return net;
}

function createFaceDetectionNet(weights) {
  return createSsdMobilenetv1(weights);
} // alias for backward compatibily


var FaceDetectionNet =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FaceDetectionNet, _super);

  function FaceDetectionNet() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return FaceDetectionNet;
}(_SsdMobilenetv.SsdMobilenetv1);

exports.FaceDetectionNet = FaceDetectionNet;
},{"tslib":"node_modules/tslib/tslib.es6.js","./SsdMobilenetv1":"node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js","./SsdMobilenetv1Options":"node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js"}],"node_modules/face-api.js/build/es6/tinyYolov2/const.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_MODEL_NAME_SEPARABLE_CONV = exports.DEFAULT_MODEL_NAME = exports.MEAN_RGB_SEPARABLE = exports.BOX_ANCHORS_SEPARABLE = exports.BOX_ANCHORS = exports.IOU_THRESHOLD = void 0;

var _classes = require("../classes");

var IOU_THRESHOLD = 0.4;
exports.IOU_THRESHOLD = IOU_THRESHOLD;
var BOX_ANCHORS = [new _classes.Point(0.738768, 0.874946), new _classes.Point(2.42204, 2.65704), new _classes.Point(4.30971, 7.04493), new _classes.Point(10.246, 4.59428), new _classes.Point(12.6868, 11.8741)];
exports.BOX_ANCHORS = BOX_ANCHORS;
var BOX_ANCHORS_SEPARABLE = [new _classes.Point(1.603231, 2.094468), new _classes.Point(6.041143, 7.080126), new _classes.Point(2.882459, 3.518061), new _classes.Point(4.266906, 5.178857), new _classes.Point(9.041765, 10.66308)];
exports.BOX_ANCHORS_SEPARABLE = BOX_ANCHORS_SEPARABLE;
var MEAN_RGB_SEPARABLE = [117.001, 114.697, 97.404];
exports.MEAN_RGB_SEPARABLE = MEAN_RGB_SEPARABLE;
var DEFAULT_MODEL_NAME = 'tiny_yolov2_model';
exports.DEFAULT_MODEL_NAME = DEFAULT_MODEL_NAME;
var DEFAULT_MODEL_NAME_SEPARABLE_CONV = 'tiny_yolov2_separable_conv_model';
exports.DEFAULT_MODEL_NAME_SEPARABLE_CONV = DEFAULT_MODEL_NAME_SEPARABLE_CONV;
},{"../classes":"node_modules/face-api.js/build/es6/classes/index.js"}],"node_modules/face-api.js/build/es6/tinyYolov2/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateConfig = validateConfig;

var isNumber = function (arg) {
  return typeof arg === 'number';
};

function validateConfig(config) {
  if (!config) {
    throw new Error("invalid config: " + config);
  }

  if (typeof config.withSeparableConvs !== 'boolean') {
    throw new Error("config.withSeparableConvs has to be a boolean, have: " + config.withSeparableConvs);
  }

  if (!isNumber(config.iouThreshold) || config.iouThreshold < 0 || config.iouThreshold > 1.0) {
    throw new Error("config.iouThreshold has to be a number between [0, 1], have: " + config.iouThreshold);
  }

  if (!Array.isArray(config.classes) || !config.classes.length || !config.classes.every(function (c) {
    return typeof c === 'string';
  })) {
    throw new Error("config.classes has to be an array class names: string[], have: " + JSON.stringify(config.classes));
  }

  if (!Array.isArray(config.anchors) || !config.anchors.length || !config.anchors.map(function (a) {
    return a || {};
  }).every(function (a) {
    return isNumber(a.x) && isNumber(a.y);
  })) {
    throw new Error("config.anchors has to be an array of { x: number, y: number }, have: " + JSON.stringify(config.anchors));
  }

  if (config.meanRgb && (!Array.isArray(config.meanRgb) || config.meanRgb.length !== 3 || !config.meanRgb.every(isNumber))) {
    throw new Error("config.meanRgb has to be an array of shape [number, number, number], have: " + JSON.stringify(config.meanRgb));
  }
}
},{}],"node_modules/face-api.js/build/es6/tinyYolov2/leaky.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.leaky = leaky;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function leaky(x) {
  return tf.tidy(function () {
    var min = tf.mul(x, tf.scalar(0.10000000149011612));
    return tf.add(tf.relu(tf.sub(x, min)), min); //return tf.maximum(x, min)
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convWithBatchNorm = convWithBatchNorm;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _leaky = require("./leaky");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function convWithBatchNorm(x, params) {
  return tf.tidy(function () {
    var out = tf.pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]);
    out = tf.conv2d(out, params.conv.filters, [1, 1], 'valid');
    out = tf.sub(out, params.bn.sub);
    out = tf.mul(out, params.bn.truediv);
    out = tf.add(out, params.conv.bias);
    return (0, _leaky.leaky)(out);
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./leaky":"node_modules/face-api.js/build/es6/tinyYolov2/leaky.js"}],"node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.depthwiseSeparableConv = depthwiseSeparableConv;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _leaky = require("./leaky");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function depthwiseSeparableConv(x, params) {
  return tf.tidy(function () {
    var out = tf.pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]);
    out = tf.separableConv2d(out, params.depthwise_filter, params.pointwise_filter, [1, 1], 'valid');
    out = tf.add(out, params.bias);
    return (0, _leaky.leaky)(out);
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./leaky":"node_modules/face-api.js/build/es6/tinyYolov2/leaky.js"}],"node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParams = extractParams;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _common = require("../common");

var _extractSeparableConvParamsFactory = require("../common/extractSeparableConvParamsFactory");

var _extractWeightsFactory = require("../common/extractWeightsFactory");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function extractorsFactory(extractWeights, paramMappings) {
  var extractConvParams = (0, _common.extractConvParamsFactory)(extractWeights, paramMappings);

  function extractBatchNormParams(size, mappedPrefix) {
    var sub = tf.tensor1d(extractWeights(size));
    var truediv = tf.tensor1d(extractWeights(size));
    paramMappings.push({
      paramPath: mappedPrefix + "/sub"
    }, {
      paramPath: mappedPrefix + "/truediv"
    });
    return {
      sub: sub,
      truediv: truediv
    };
  }

  function extractConvWithBatchNormParams(channelsIn, channelsOut, mappedPrefix) {
    var conv = extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv");
    var bn = extractBatchNormParams(channelsOut, mappedPrefix + "/bn");
    return {
      conv: conv,
      bn: bn
    };
  }

  var extractSeparableConvParams = (0, _extractSeparableConvParamsFactory.extractSeparableConvParamsFactory)(extractWeights, paramMappings);
  return {
    extractConvParams: extractConvParams,
    extractConvWithBatchNormParams: extractConvWithBatchNormParams,
    extractSeparableConvParams: extractSeparableConvParams
  };
}

function extractParams(weights, config, boxEncodingSize, filterSizes) {
  var _a = (0, _extractWeightsFactory.extractWeightsFactory)(weights),
      extractWeights = _a.extractWeights,
      getRemainingWeights = _a.getRemainingWeights;

  var paramMappings = [];

  var _b = extractorsFactory(extractWeights, paramMappings),
      extractConvParams = _b.extractConvParams,
      extractConvWithBatchNormParams = _b.extractConvWithBatchNormParams,
      extractSeparableConvParams = _b.extractSeparableConvParams;

  var params;

  if (config.withSeparableConvs) {
    var s0 = filterSizes[0],
        s1 = filterSizes[1],
        s2 = filterSizes[2],
        s3 = filterSizes[3],
        s4 = filterSizes[4],
        s5 = filterSizes[5],
        s6 = filterSizes[6],
        s7 = filterSizes[7],
        s8 = filterSizes[8];
    var conv0 = config.isFirstLayerConv2d ? extractConvParams(s0, s1, 3, 'conv0') : extractSeparableConvParams(s0, s1, 'conv0');
    var conv1 = extractSeparableConvParams(s1, s2, 'conv1');
    var conv2 = extractSeparableConvParams(s2, s3, 'conv2');
    var conv3 = extractSeparableConvParams(s3, s4, 'conv3');
    var conv4 = extractSeparableConvParams(s4, s5, 'conv4');
    var conv5 = extractSeparableConvParams(s5, s6, 'conv5');
    var conv6 = s7 ? extractSeparableConvParams(s6, s7, 'conv6') : undefined;
    var conv7 = s8 ? extractSeparableConvParams(s7, s8, 'conv7') : undefined;
    var conv8 = extractConvParams(s8 || s7 || s6, 5 * boxEncodingSize, 1, 'conv8');
    params = {
      conv0: conv0,
      conv1: conv1,
      conv2: conv2,
      conv3: conv3,
      conv4: conv4,
      conv5: conv5,
      conv6: conv6,
      conv7: conv7,
      conv8: conv8
    };
  } else {
    var s0 = filterSizes[0],
        s1 = filterSizes[1],
        s2 = filterSizes[2],
        s3 = filterSizes[3],
        s4 = filterSizes[4],
        s5 = filterSizes[5],
        s6 = filterSizes[6],
        s7 = filterSizes[7],
        s8 = filterSizes[8];
    var conv0 = extractConvWithBatchNormParams(s0, s1, 'conv0');
    var conv1 = extractConvWithBatchNormParams(s1, s2, 'conv1');
    var conv2 = extractConvWithBatchNormParams(s2, s3, 'conv2');
    var conv3 = extractConvWithBatchNormParams(s3, s4, 'conv3');
    var conv4 = extractConvWithBatchNormParams(s4, s5, 'conv4');
    var conv5 = extractConvWithBatchNormParams(s5, s6, 'conv5');
    var conv6 = extractConvWithBatchNormParams(s6, s7, 'conv6');
    var conv7 = extractConvWithBatchNormParams(s7, s8, 'conv7');
    var conv8 = extractConvParams(s8, 5 * boxEncodingSize, 1, 'conv8');
    params = {
      conv0: conv0,
      conv1: conv1,
      conv2: conv2,
      conv3: conv3,
      conv4: conv4,
      conv5: conv5,
      conv6: conv6,
      conv7: conv7,
      conv8: conv8
    };
  }

  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }

  return {
    params: params,
    paramMappings: paramMappings
  };
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common":"node_modules/face-api.js/build/es6/common/index.js","../common/extractSeparableConvParamsFactory":"node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js","../common/extractWeightsFactory":"node_modules/face-api.js/build/es6/common/extractWeightsFactory.js"}],"node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsFromWeigthMap = extractParamsFromWeigthMap;

var _disposeUnusedWeightTensors = require("../common/disposeUnusedWeightTensors");

var _extractSeparableConvParamsFactory = require("../common/extractSeparableConvParamsFactory");

var _extractWeightEntryFactory = require("../common/extractWeightEntryFactory");

function extractorsFactory(weightMap, paramMappings) {
  var extractWeightEntry = (0, _extractWeightEntryFactory.extractWeightEntryFactory)(weightMap, paramMappings);

  function extractBatchNormParams(prefix) {
    var sub = extractWeightEntry(prefix + "/sub", 1);
    var truediv = extractWeightEntry(prefix + "/truediv", 1);
    return {
      sub: sub,
      truediv: truediv
    };
  }

  function extractConvParams(prefix) {
    var filters = extractWeightEntry(prefix + "/filters", 4);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return {
      filters: filters,
      bias: bias
    };
  }

  function extractConvWithBatchNormParams(prefix) {
    var conv = extractConvParams(prefix + "/conv");
    var bn = extractBatchNormParams(prefix + "/bn");
    return {
      conv: conv,
      bn: bn
    };
  }

  var extractSeparableConvParams = (0, _extractSeparableConvParamsFactory.loadSeparableConvParamsFactory)(extractWeightEntry);
  return {
    extractConvParams: extractConvParams,
    extractConvWithBatchNormParams: extractConvWithBatchNormParams,
    extractSeparableConvParams: extractSeparableConvParams
  };
}

function extractParamsFromWeigthMap(weightMap, config) {
  var paramMappings = [];

  var _a = extractorsFactory(weightMap, paramMappings),
      extractConvParams = _a.extractConvParams,
      extractConvWithBatchNormParams = _a.extractConvWithBatchNormParams,
      extractSeparableConvParams = _a.extractSeparableConvParams;

  var params;

  if (config.withSeparableConvs) {
    var numFilters = config.filterSizes && config.filterSizes.length || 9;
    params = {
      conv0: config.isFirstLayerConv2d ? extractConvParams('conv0') : extractSeparableConvParams('conv0'),
      conv1: extractSeparableConvParams('conv1'),
      conv2: extractSeparableConvParams('conv2'),
      conv3: extractSeparableConvParams('conv3'),
      conv4: extractSeparableConvParams('conv4'),
      conv5: extractSeparableConvParams('conv5'),
      conv6: numFilters > 7 ? extractSeparableConvParams('conv6') : undefined,
      conv7: numFilters > 8 ? extractSeparableConvParams('conv7') : undefined,
      conv8: extractConvParams('conv8')
    };
  } else {
    params = {
      conv0: extractConvWithBatchNormParams('conv0'),
      conv1: extractConvWithBatchNormParams('conv1'),
      conv2: extractConvWithBatchNormParams('conv2'),
      conv3: extractConvWithBatchNormParams('conv3'),
      conv4: extractConvWithBatchNormParams('conv4'),
      conv5: extractConvWithBatchNormParams('conv5'),
      conv6: extractConvWithBatchNormParams('conv6'),
      conv7: extractConvWithBatchNormParams('conv7'),
      conv8: extractConvParams('conv8')
    };
  }

  (0, _disposeUnusedWeightTensors.disposeUnusedWeightTensors)(weightMap, paramMappings);
  return {
    params: params,
    paramMappings: paramMappings
  };
}
},{"../common/disposeUnusedWeightTensors":"node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js","../common/extractSeparableConvParamsFactory":"node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js","../common/extractWeightEntryFactory":"node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js"}],"node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyYolov2Options = exports.TinyYolov2SizeType = void 0;
var TinyYolov2SizeType;
exports.TinyYolov2SizeType = TinyYolov2SizeType;

(function (TinyYolov2SizeType) {
  TinyYolov2SizeType[TinyYolov2SizeType["XS"] = 224] = "XS";
  TinyYolov2SizeType[TinyYolov2SizeType["SM"] = 320] = "SM";
  TinyYolov2SizeType[TinyYolov2SizeType["MD"] = 416] = "MD";
  TinyYolov2SizeType[TinyYolov2SizeType["LG"] = 608] = "LG";
})(TinyYolov2SizeType || (exports.TinyYolov2SizeType = TinyYolov2SizeType = {}));

var TinyYolov2Options =
/** @class */
function () {
  function TinyYolov2Options(_a) {
    var _b = _a === void 0 ? {} : _a,
        inputSize = _b.inputSize,
        scoreThreshold = _b.scoreThreshold;

    this._name = 'TinyYolov2Options';
    this._inputSize = inputSize || 416;
    this._scoreThreshold = scoreThreshold || 0.5;

    if (typeof this._inputSize !== 'number' || this._inputSize % 32 !== 0) {
      throw new Error(this._name + " - expected inputSize to be a number divisible by 32");
    }

    if (typeof this._scoreThreshold !== 'number' || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) {
      throw new Error(this._name + " - expected scoreThreshold to be a number between 0 and 1");
    }
  }

  Object.defineProperty(TinyYolov2Options.prototype, "inputSize", {
    get: function () {
      return this._inputSize;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TinyYolov2Options.prototype, "scoreThreshold", {
    get: function () {
      return this._scoreThreshold;
    },
    enumerable: true,
    configurable: true
  });
  return TinyYolov2Options;
}();

exports.TinyYolov2Options = TinyYolov2Options;
},{}],"node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyYolov2Base = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _BoundingBox = require("../classes/BoundingBox");

var _ObjectDetection = require("../classes/ObjectDetection");

var _common = require("../common");

var _dom = require("../dom");

var _NeuralNetwork = require("../NeuralNetwork");

var _ops = require("../ops");

var _nonMaxSuppression = require("../ops/nonMaxSuppression");

var _normalize = require("../ops/normalize");

var _config = require("./config");

var _convWithBatchNorm = require("./convWithBatchNorm");

var _depthwiseSeparableConv = require("./depthwiseSeparableConv");

var _extractParams = require("./extractParams");

var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");

var _leaky = require("./leaky");

var _TinyYolov2Options = require("./TinyYolov2Options");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var TinyYolov2Base =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TinyYolov2Base, _super);

  function TinyYolov2Base(config) {
    var _this = _super.call(this, 'TinyYolov2') || this;

    (0, _config.validateConfig)(config);
    _this._config = config;
    return _this;
  }

  Object.defineProperty(TinyYolov2Base.prototype, "config", {
    get: function () {
      return this._config;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TinyYolov2Base.prototype, "withClassScores", {
    get: function () {
      return this.config.withClassScores || this.config.classes.length > 1;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TinyYolov2Base.prototype, "boxEncodingSize", {
    get: function () {
      return 5 + (this.withClassScores ? this.config.classes.length : 0);
    },
    enumerable: true,
    configurable: true
  });

  TinyYolov2Base.prototype.runTinyYolov2 = function (x, params) {
    var out = (0, _convWithBatchNorm.convWithBatchNorm)(x, params.conv0);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv1);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv2);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv3);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv4);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv5);
    out = tf.maxPool(out, [2, 2], [1, 1], 'same');
    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv6);
    out = (0, _convWithBatchNorm.convWithBatchNorm)(out, params.conv7);
    return (0, _common.convLayer)(out, params.conv8, 'valid', false);
  };

  TinyYolov2Base.prototype.runMobilenet = function (x, params) {
    var out = this.config.isFirstLayerConv2d ? (0, _leaky.leaky)((0, _common.convLayer)(x, params.conv0, 'valid', false)) : (0, _depthwiseSeparableConv.depthwiseSeparableConv)(x, params.conv0);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv1);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv2);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv3);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv4);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv5);
    out = tf.maxPool(out, [2, 2], [1, 1], 'same');
    out = params.conv6 ? (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv6) : out;
    out = params.conv7 ? (0, _depthwiseSeparableConv.depthwiseSeparableConv)(out, params.conv7) : out;
    return (0, _common.convLayer)(out, params.conv8, 'valid', false);
  };

  TinyYolov2Base.prototype.forwardInput = function (input, inputSize) {
    var _this = this;

    var params = this.params;

    if (!params) {
      throw new Error('TinyYolov2 - load model before inference');
    }

    return tf.tidy(function () {
      var batchTensor = input.toBatchTensor(inputSize, false).toFloat();
      batchTensor = _this.config.meanRgb ? (0, _normalize.normalize)(batchTensor, _this.config.meanRgb) : batchTensor;
      batchTensor = batchTensor.div(tf.scalar(256));
      return _this.config.withSeparableConvs ? _this.runMobilenet(batchTensor, params) : _this.runTinyYolov2(batchTensor, params);
    });
  };

  TinyYolov2Base.prototype.forward = function (input, inputSize) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [4
            /*yield*/
            , _a.apply(this, [_b.sent(), inputSize])];

          case 2:
            return [2
            /*return*/
            , _b.sent()];
        }
      });
    });
  };

  TinyYolov2Base.prototype.detect = function (input, forwardParams) {
    if (forwardParams === void 0) {
      forwardParams = {};
    }

    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = new _TinyYolov2Options.TinyYolov2Options(forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            netInput = _b.sent();
            return [4
            /*yield*/
            , this.forwardInput(netInput, inputSize)];

          case 2:
            out = _b.sent();
            out0 = tf.tidy(function () {
              return tf.unstack(out)[0].expandDims();
            });
            inputDimensions = {
              width: netInput.getInputWidth(0),
              height: netInput.getInputHeight(0)
            };
            return [4
            /*yield*/
            , this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold)];

          case 3:
            results = _b.sent();
            out.dispose();
            out0.dispose();
            boxes = results.map(function (res) {
              return res.box;
            });
            scores = results.map(function (res) {
              return res.score;
            });
            classScores = results.map(function (res) {
              return res.classScore;
            });
            classNames = results.map(function (res) {
              return _this.config.classes[res.label];
            });
            indices = (0, _nonMaxSuppression.nonMaxSuppression)(boxes.map(function (box) {
              return box.rescale(inputSize);
            }), scores, this.config.iouThreshold, true);
            detections = indices.map(function (idx) {
              return new _ObjectDetection.ObjectDetection(scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);
            });
            return [2
            /*return*/
            , detections];
        }
      });
    });
  };

  TinyYolov2Base.prototype.getDefaultModelName = function () {
    return '';
  };

  TinyYolov2Base.prototype.extractParamsFromWeigthMap = function (weightMap) {
    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap, this.config);
  };

  TinyYolov2Base.prototype.extractParams = function (weights) {
    var filterSizes = this.config.filterSizes || TinyYolov2Base.DEFAULT_FILTER_SIZES;
    var numFilters = filterSizes ? filterSizes.length : undefined;

    if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {
      throw new Error("TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found " + numFilters + " filterSizes in config");
    }

    return (0, _extractParams.extractParams)(weights, this.config, this.boxEncodingSize, filterSizes);
  };

  TinyYolov2Base.prototype.extractBoxes = function (outputTensor, inputBlobDimensions, scoreThreshold) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var width, height, inputSize, correctionFactorX, correctionFactorY, numCells, numBoxes, _a, boxesTensor, scoresTensor, classScoresTensor, results, scoresData, boxesData, row, col, anchor, score, ctX, ctY, width_1, height_1, x, y, pos, _b, classScore, label, _c;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_d) {
        switch (_d.label) {
          case 0:
            width = inputBlobDimensions.width, height = inputBlobDimensions.height;
            inputSize = Math.max(width, height);
            correctionFactorX = inputSize / width;
            correctionFactorY = inputSize / height;
            numCells = outputTensor.shape[1];
            numBoxes = this.config.anchors.length;
            _a = tf.tidy(function () {
              var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);
              var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);
              var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);
              var classScores = _this.withClassScores ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3) : tf.scalar(0);
              return [boxes, scores, classScores];
            }), boxesTensor = _a[0], scoresTensor = _a[1], classScoresTensor = _a[2];
            results = [];
            return [4
            /*yield*/
            , scoresTensor.array()];

          case 1:
            scoresData = _d.sent();
            return [4
            /*yield*/
            , boxesTensor.array()];

          case 2:
            boxesData = _d.sent();
            row = 0;
            _d.label = 3;

          case 3:
            if (!(row < numCells)) return [3
            /*break*/
            , 12];
            col = 0;
            _d.label = 4;

          case 4:
            if (!(col < numCells)) return [3
            /*break*/
            , 11];
            anchor = 0;
            _d.label = 5;

          case 5:
            if (!(anchor < numBoxes)) return [3
            /*break*/
            , 10];
            score = (0, _ops.sigmoid)(scoresData[row][col][anchor][0]);
            if (!(!scoreThreshold || score > scoreThreshold)) return [3
            /*break*/
            , 9];
            ctX = (col + (0, _ops.sigmoid)(boxesData[row][col][anchor][0])) / numCells * correctionFactorX;
            ctY = (row + (0, _ops.sigmoid)(boxesData[row][col][anchor][1])) / numCells * correctionFactorY;
            width_1 = Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x / numCells * correctionFactorX;
            height_1 = Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y / numCells * correctionFactorY;
            x = ctX - width_1 / 2;
            y = ctY - height_1 / 2;
            pos = {
              row: row,
              col: col,
              anchor: anchor
            };
            if (!this.withClassScores) return [3
            /*break*/
            , 7];
            return [4
            /*yield*/
            , this.extractPredictedClass(classScoresTensor, pos)];

          case 6:
            _c = _d.sent();
            return [3
            /*break*/
            , 8];

          case 7:
            _c = {
              classScore: 1,
              label: 0
            };
            _d.label = 8;

          case 8:
            _b = _c, classScore = _b.classScore, label = _b.label;
            results.push((0, _tslib.__assign)({
              box: new _BoundingBox.BoundingBox(x, y, x + width_1, y + height_1),
              score: score,
              classScore: score * classScore,
              label: label
            }, pos));
            _d.label = 9;

          case 9:
            anchor++;
            return [3
            /*break*/
            , 5];

          case 10:
            col++;
            return [3
            /*break*/
            , 4];

          case 11:
            row++;
            return [3
            /*break*/
            , 3];

          case 12:
            boxesTensor.dispose();
            scoresTensor.dispose();
            classScoresTensor.dispose();
            return [2
            /*return*/
            , results];
        }
      });
    });
  };

  TinyYolov2Base.prototype.extractPredictedClass = function (classesTensor, pos) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var row, col, anchor, classesData;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            row = pos.row, col = pos.col, anchor = pos.anchor;
            return [4
            /*yield*/
            , classesTensor.array()];

          case 1:
            classesData = _a.sent();
            return [2
            /*return*/
            , Array(this.config.classes.length).fill(0).map(function (_, i) {
              return classesData[row][col][anchor][i];
            }).map(function (classScore, label) {
              return {
                classScore: classScore,
                label: label
              };
            }).reduce(function (max, curr) {
              return max.classScore > curr.classScore ? max : curr;
            })];
        }
      });
    });
  };

  TinyYolov2Base.DEFAULT_FILTER_SIZES = [3, 16, 32, 64, 128, 256, 512, 1024, 1024];
  return TinyYolov2Base;
}(_NeuralNetwork.NeuralNetwork);

exports.TinyYolov2Base = TinyYolov2Base;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../classes/BoundingBox":"node_modules/face-api.js/build/es6/classes/BoundingBox.js","../classes/ObjectDetection":"node_modules/face-api.js/build/es6/classes/ObjectDetection.js","../common":"node_modules/face-api.js/build/es6/common/index.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","../ops":"node_modules/face-api.js/build/es6/ops/index.js","../ops/nonMaxSuppression":"node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js","../ops/normalize":"node_modules/face-api.js/build/es6/ops/normalize.js","./config":"node_modules/face-api.js/build/es6/tinyYolov2/config.js","./convWithBatchNorm":"node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js","./depthwiseSeparableConv":"node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js","./extractParams":"node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js","./extractParamsFromWeigthMap":"node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js","./leaky":"node_modules/face-api.js/build/es6/tinyYolov2/leaky.js","./TinyYolov2Options":"node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js"}],"node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyYolov2 = void 0;

var _tslib = require("tslib");

var _classes = require("../classes");

var _const = require("./const");

var _TinyYolov2Base = require("./TinyYolov2Base");

var TinyYolov2 =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TinyYolov2, _super);

  function TinyYolov2(withSeparableConvs) {
    if (withSeparableConvs === void 0) {
      withSeparableConvs = true;
    }

    var _this = this;

    var config = Object.assign({}, {
      withSeparableConvs: withSeparableConvs,
      iouThreshold: _const.IOU_THRESHOLD,
      classes: ['face']
    }, withSeparableConvs ? {
      anchors: _const.BOX_ANCHORS_SEPARABLE,
      meanRgb: _const.MEAN_RGB_SEPARABLE
    } : {
      anchors: _const.BOX_ANCHORS,
      withClassScores: true
    });
    _this = _super.call(this, config) || this;
    return _this;
  }

  Object.defineProperty(TinyYolov2.prototype, "withSeparableConvs", {
    get: function () {
      return this.config.withSeparableConvs;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TinyYolov2.prototype, "anchors", {
    get: function () {
      return this.config.anchors;
    },
    enumerable: true,
    configurable: true
  });

  TinyYolov2.prototype.locateFaces = function (input, forwardParams) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var objectDetections;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , this.detect(input, forwardParams)];

          case 1:
            objectDetections = _a.sent();
            return [2
            /*return*/
            , objectDetections.map(function (det) {
              return new _classes.FaceDetection(det.score, det.relativeBox, {
                width: det.imageWidth,
                height: det.imageHeight
              });
            })];
        }
      });
    });
  };

  TinyYolov2.prototype.getDefaultModelName = function () {
    return this.withSeparableConvs ? _const.DEFAULT_MODEL_NAME_SEPARABLE_CONV : _const.DEFAULT_MODEL_NAME;
  };

  TinyYolov2.prototype.extractParamsFromWeigthMap = function (weightMap) {
    return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
  };

  return TinyYolov2;
}(_TinyYolov2Base.TinyYolov2Base);

exports.TinyYolov2 = TinyYolov2;
},{"tslib":"node_modules/tslib/tslib.es6.js","../classes":"node_modules/face-api.js/build/es6/classes/index.js","./const":"node_modules/face-api.js/build/es6/tinyYolov2/const.js","./TinyYolov2Base":"node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js"}],"node_modules/face-api.js/build/es6/tinyYolov2/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createTinyYolov2: true,
  TinyYolov2: true
};
exports.createTinyYolov2 = createTinyYolov2;
Object.defineProperty(exports, "TinyYolov2", {
  enumerable: true,
  get: function () {
    return _TinyYolov.TinyYolov2;
  }
});

var _TinyYolov = require("./TinyYolov2");

var _TinyYolov2Options = require("./TinyYolov2Options");

Object.keys(_TinyYolov2Options).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TinyYolov2Options[key];
    }
  });
});

var _config = require("./config");

Object.keys(_config).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _config[key];
    }
  });
});

function createTinyYolov2(weights, withSeparableConvs) {
  if (withSeparableConvs === void 0) {
    withSeparableConvs = true;
  }

  var net = new _TinyYolov.TinyYolov2(withSeparableConvs);
  net.extractWeights(weights);
  return net;
}
},{"./TinyYolov2":"node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js","./TinyYolov2Options":"node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js","./config":"node_modules/face-api.js/build/es6/tinyYolov2/config.js"}],"node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyFaceDetectorOptions = void 0;

var _tslib = require("tslib");

var _tinyYolov = require("../tinyYolov2");

var TinyFaceDetectorOptions =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TinyFaceDetectorOptions, _super);

  function TinyFaceDetectorOptions() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this._name = 'TinyFaceDetectorOptions';
    return _this;
  }

  return TinyFaceDetectorOptions;
}(_tinyYolov.TinyYolov2Options);

exports.TinyFaceDetectorOptions = TinyFaceDetectorOptions;
},{"tslib":"node_modules/tslib/tslib.es6.js","../tinyYolov2":"node_modules/face-api.js/build/es6/tinyYolov2/index.js"}],"node_modules/face-api.js/build/es6/globalApi/ComposableTask.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComposableTask = void 0;

var _tslib = require("tslib");

var ComposableTask =
/** @class */
function () {
  function ComposableTask() {}

  ComposableTask.prototype.then = function (onfulfilled) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = onfulfilled;
            return [4
            /*yield*/
            , this.run()];

          case 1:
            return [2
            /*return*/
            , _a.apply(void 0, [_b.sent()])];
        }
      });
    });
  };

  ComposableTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      return (0, _tslib.__generator)(this, function (_a) {
        throw new Error('ComposableTask - run is not implemented');
      });
    });
  };

  return ComposableTask;
}();

exports.ComposableTask = ComposableTask;
},{"tslib":"node_modules/tslib/tslib.es6.js"}],"node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAllFacesAndComputeResults = extractAllFacesAndComputeResults;
exports.extractSingleFaceAndComputeResult = extractSingleFaceAndComputeResult;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _dom = require("../dom");

var _WithFaceLandmarks = require("../factories/WithFaceLandmarks");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function extractAllFacesAndComputeResults(parentResults, input, computeResults, extractedFaces, getRectForAlignment) {
  if (getRectForAlignment === void 0) {
    getRectForAlignment = function (_a) {
      var alignedRect = _a.alignedRect;
      return alignedRect;
    };
  }

  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var faceBoxes, faces, _a, _b, results;

    return (0, _tslib.__generator)(this, function (_c) {
      switch (_c.label) {
        case 0:
          faceBoxes = parentResults.map(function (parentResult) {
            return (0, _WithFaceLandmarks.isWithFaceLandmarks)(parentResult) ? getRectForAlignment(parentResult) : parentResult.detection;
          });
          _a = extractedFaces;
          if (_a) return [3
          /*break*/
          , 5];
          if (!(input instanceof tf.Tensor)) return [3
          /*break*/
          , 2];
          return [4
          /*yield*/
          , (0, _dom.extractFaceTensors)(input, faceBoxes)];

        case 1:
          _b = _c.sent();
          return [3
          /*break*/
          , 4];

        case 2:
          return [4
          /*yield*/
          , (0, _dom.extractFaces)(input, faceBoxes)];

        case 3:
          _b = _c.sent();
          _c.label = 4;

        case 4:
          _a = _b;
          _c.label = 5;

        case 5:
          faces = _a;
          return [4
          /*yield*/
          , computeResults(faces)];

        case 6:
          results = _c.sent();
          faces.forEach(function (f) {
            return f instanceof tf.Tensor && f.dispose();
          });
          return [2
          /*return*/
          , results];
      }
    });
  });
}

function extractSingleFaceAndComputeResult(parentResult, input, computeResult, extractedFaces, getRectForAlignment) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var _this = this;

    return (0, _tslib.__generator)(this, function (_a) {
      return [2
      /*return*/
      , extractAllFacesAndComputeResults([parentResult], input, function (faces) {
        return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
          return (0, _tslib.__generator)(this, function (_a) {
            return [2
            /*return*/
            , computeResult(faces[0])];
          });
        });
      }, extractedFaces, getRectForAlignment)];
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../factories/WithFaceLandmarks":"node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js"}],"node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bgrToRgbTensor = bgrToRgbTensor;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function bgrToRgbTensor(tensor) {
  return tf.tidy(function () {
    return tf.stack(tf.unstack(tensor, 3).reverse(), 3);
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/mtcnn/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CELL_SIZE = exports.CELL_STRIDE = void 0;
var CELL_STRIDE = 2;
exports.CELL_STRIDE = CELL_STRIDE;
var CELL_SIZE = 12;
exports.CELL_SIZE = CELL_SIZE;
},{}],"node_modules/face-api.js/build/es6/mtcnn/extractParams.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParams = extractParams;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _common = require("../common");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function extractorsFactory(extractWeights, paramMappings) {
  var extractConvParams = (0, _common.extractConvParamsFactory)(extractWeights, paramMappings);
  var extractFCParams = (0, _common.extractFCParamsFactory)(extractWeights, paramMappings);

  function extractPReluParams(size, paramPath) {
    var alpha = tf.tensor1d(extractWeights(size));
    paramMappings.push({
      paramPath: paramPath
    });
    return alpha;
  }

  function extractSharedParams(numFilters, mappedPrefix, isRnet) {
    if (isRnet === void 0) {
      isRnet = false;
    }

    var conv1 = extractConvParams(numFilters[0], numFilters[1], 3, mappedPrefix + "/conv1");
    var prelu1_alpha = extractPReluParams(numFilters[1], mappedPrefix + "/prelu1_alpha");
    var conv2 = extractConvParams(numFilters[1], numFilters[2], 3, mappedPrefix + "/conv2");
    var prelu2_alpha = extractPReluParams(numFilters[2], mappedPrefix + "/prelu2_alpha");
    var conv3 = extractConvParams(numFilters[2], numFilters[3], isRnet ? 2 : 3, mappedPrefix + "/conv3");
    var prelu3_alpha = extractPReluParams(numFilters[3], mappedPrefix + "/prelu3_alpha");
    return {
      conv1: conv1,
      prelu1_alpha: prelu1_alpha,
      conv2: conv2,
      prelu2_alpha: prelu2_alpha,
      conv3: conv3,
      prelu3_alpha: prelu3_alpha
    };
  }

  function extractPNetParams() {
    var sharedParams = extractSharedParams([3, 10, 16, 32], 'pnet');
    var conv4_1 = extractConvParams(32, 2, 1, 'pnet/conv4_1');
    var conv4_2 = extractConvParams(32, 4, 1, 'pnet/conv4_2');
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, sharedParams), {
      conv4_1: conv4_1,
      conv4_2: conv4_2
    });
  }

  function extractRNetParams() {
    var sharedParams = extractSharedParams([3, 28, 48, 64], 'rnet', true);
    var fc1 = extractFCParams(576, 128, 'rnet/fc1');
    var prelu4_alpha = extractPReluParams(128, 'rnet/prelu4_alpha');
    var fc2_1 = extractFCParams(128, 2, 'rnet/fc2_1');
    var fc2_2 = extractFCParams(128, 4, 'rnet/fc2_2');
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, sharedParams), {
      fc1: fc1,
      prelu4_alpha: prelu4_alpha,
      fc2_1: fc2_1,
      fc2_2: fc2_2
    });
  }

  function extractONetParams() {
    var sharedParams = extractSharedParams([3, 32, 64, 64], 'onet');
    var conv4 = extractConvParams(64, 128, 2, 'onet/conv4');
    var prelu4_alpha = extractPReluParams(128, 'onet/prelu4_alpha');
    var fc1 = extractFCParams(1152, 256, 'onet/fc1');
    var prelu5_alpha = extractPReluParams(256, 'onet/prelu5_alpha');
    var fc2_1 = extractFCParams(256, 2, 'onet/fc2_1');
    var fc2_2 = extractFCParams(256, 4, 'onet/fc2_2');
    var fc2_3 = extractFCParams(256, 10, 'onet/fc2_3');
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, sharedParams), {
      conv4: conv4,
      prelu4_alpha: prelu4_alpha,
      fc1: fc1,
      prelu5_alpha: prelu5_alpha,
      fc2_1: fc2_1,
      fc2_2: fc2_2,
      fc2_3: fc2_3
    });
  }

  return {
    extractPNetParams: extractPNetParams,
    extractRNetParams: extractRNetParams,
    extractONetParams: extractONetParams
  };
}

function extractParams(weights) {
  var _a = (0, _common.extractWeightsFactory)(weights),
      extractWeights = _a.extractWeights,
      getRemainingWeights = _a.getRemainingWeights;

  var paramMappings = [];

  var _b = extractorsFactory(extractWeights, paramMappings),
      extractPNetParams = _b.extractPNetParams,
      extractRNetParams = _b.extractRNetParams,
      extractONetParams = _b.extractONetParams;

  var pnet = extractPNetParams();
  var rnet = extractRNetParams();
  var onet = extractONetParams();

  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }

  return {
    params: {
      pnet: pnet,
      rnet: rnet,
      onet: onet
    },
    paramMappings: paramMappings
  };
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common":"node_modules/face-api.js/build/es6/common/index.js"}],"node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractParamsFromWeigthMap = extractParamsFromWeigthMap;

var _tslib = require("tslib");

var _common = require("../common");

function extractorsFactory(weightMap, paramMappings) {
  var extractWeightEntry = (0, _common.extractWeightEntryFactory)(weightMap, paramMappings);

  function extractConvParams(prefix) {
    var filters = extractWeightEntry(prefix + "/weights", 4, prefix + "/filters");
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return {
      filters: filters,
      bias: bias
    };
  }

  function extractFCParams(prefix) {
    var weights = extractWeightEntry(prefix + "/weights", 2);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return {
      weights: weights,
      bias: bias
    };
  }

  function extractPReluParams(paramPath) {
    return extractWeightEntry(paramPath, 1);
  }

  function extractSharedParams(prefix) {
    var conv1 = extractConvParams(prefix + "/conv1");
    var prelu1_alpha = extractPReluParams(prefix + "/prelu1_alpha");
    var conv2 = extractConvParams(prefix + "/conv2");
    var prelu2_alpha = extractPReluParams(prefix + "/prelu2_alpha");
    var conv3 = extractConvParams(prefix + "/conv3");
    var prelu3_alpha = extractPReluParams(prefix + "/prelu3_alpha");
    return {
      conv1: conv1,
      prelu1_alpha: prelu1_alpha,
      conv2: conv2,
      prelu2_alpha: prelu2_alpha,
      conv3: conv3,
      prelu3_alpha: prelu3_alpha
    };
  }

  function extractPNetParams() {
    var sharedParams = extractSharedParams('pnet');
    var conv4_1 = extractConvParams('pnet/conv4_1');
    var conv4_2 = extractConvParams('pnet/conv4_2');
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, sharedParams), {
      conv4_1: conv4_1,
      conv4_2: conv4_2
    });
  }

  function extractRNetParams() {
    var sharedParams = extractSharedParams('rnet');
    var fc1 = extractFCParams('rnet/fc1');
    var prelu4_alpha = extractPReluParams('rnet/prelu4_alpha');
    var fc2_1 = extractFCParams('rnet/fc2_1');
    var fc2_2 = extractFCParams('rnet/fc2_2');
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, sharedParams), {
      fc1: fc1,
      prelu4_alpha: prelu4_alpha,
      fc2_1: fc2_1,
      fc2_2: fc2_2
    });
  }

  function extractONetParams() {
    var sharedParams = extractSharedParams('onet');
    var conv4 = extractConvParams('onet/conv4');
    var prelu4_alpha = extractPReluParams('onet/prelu4_alpha');
    var fc1 = extractFCParams('onet/fc1');
    var prelu5_alpha = extractPReluParams('onet/prelu5_alpha');
    var fc2_1 = extractFCParams('onet/fc2_1');
    var fc2_2 = extractFCParams('onet/fc2_2');
    var fc2_3 = extractFCParams('onet/fc2_3');
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, sharedParams), {
      conv4: conv4,
      prelu4_alpha: prelu4_alpha,
      fc1: fc1,
      prelu5_alpha: prelu5_alpha,
      fc2_1: fc2_1,
      fc2_2: fc2_2,
      fc2_3: fc2_3
    });
  }

  return {
    extractPNetParams: extractPNetParams,
    extractRNetParams: extractRNetParams,
    extractONetParams: extractONetParams
  };
}

function extractParamsFromWeigthMap(weightMap) {
  var paramMappings = [];

  var _a = extractorsFactory(weightMap, paramMappings),
      extractPNetParams = _a.extractPNetParams,
      extractRNetParams = _a.extractRNetParams,
      extractONetParams = _a.extractONetParams;

  var pnet = extractPNetParams();
  var rnet = extractRNetParams();
  var onet = extractONetParams();
  (0, _common.disposeUnusedWeightTensors)(weightMap, paramMappings);
  return {
    params: {
      pnet: pnet,
      rnet: rnet,
      onet: onet
    },
    paramMappings: paramMappings
  };
}
},{"tslib":"node_modules/tslib/tslib.es6.js","../common":"node_modules/face-api.js/build/es6/common/index.js"}],"node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSizesForScale = getSizesForScale;

function getSizesForScale(scale, _a) {
  var height = _a[0],
      width = _a[1];
  return {
    height: Math.floor(height * scale),
    width: Math.floor(width * scale)
  };
}
},{}],"node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pyramidDown = pyramidDown;

var _config = require("./config");

function pyramidDown(minFaceSize, scaleFactor, dims) {
  var height = dims[0],
      width = dims[1];
  var m = _config.CELL_SIZE / minFaceSize;
  var scales = [];
  var minLayer = Math.min(height, width) * m;
  var exp = 0;

  while (minLayer >= 12) {
    scales.push(m * Math.pow(scaleFactor, exp));
    minLayer = minLayer * scaleFactor;
    exp += 1;
  }

  return scales;
}
},{"./config":"node_modules/face-api.js/build/es6/mtcnn/config.js"}],"node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MtcnnBox = void 0;

var _tslib = require("tslib");

var _classes = require("../classes");

var MtcnnBox =
/** @class */
function (_super) {
  (0, _tslib.__extends)(MtcnnBox, _super);

  function MtcnnBox(left, top, right, bottom) {
    return _super.call(this, {
      left: left,
      top: top,
      right: right,
      bottom: bottom
    }, true) || this;
  }

  return MtcnnBox;
}(_classes.Box);

exports.MtcnnBox = MtcnnBox;
},{"tslib":"node_modules/tslib/tslib.es6.js","../classes":"node_modules/face-api.js/build/es6/classes/index.js"}],"node_modules/face-api.js/build/es6/mtcnn/normalize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalize = normalize;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function normalize(x) {
  return tf.tidy(function () {
    return tf.mul(tf.sub(x, tf.scalar(127.5)), tf.scalar(0.0078125));
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/mtcnn/prelu.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prelu = prelu;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function prelu(x, alpha) {
  return tf.tidy(function () {
    return tf.add(tf.relu(x), tf.mul(alpha, tf.neg(tf.relu(tf.neg(x)))));
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"}],"node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sharedLayer = sharedLayer;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _common = require("../common");

var _prelu = require("./prelu");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function sharedLayer(x, params, isPnet) {
  if (isPnet === void 0) {
    isPnet = false;
  }

  return tf.tidy(function () {
    var out = (0, _common.convLayer)(x, params.conv1, 'valid');
    out = (0, _prelu.prelu)(out, params.prelu1_alpha);
    out = tf.maxPool(out, isPnet ? [2, 2] : [3, 3], [2, 2], 'same');
    out = (0, _common.convLayer)(out, params.conv2, 'valid');
    out = (0, _prelu.prelu)(out, params.prelu2_alpha);
    out = isPnet ? out : tf.maxPool(out, [3, 3], [2, 2], 'valid');
    out = (0, _common.convLayer)(out, params.conv3, 'valid');
    out = (0, _prelu.prelu)(out, params.prelu3_alpha);
    return out;
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common":"node_modules/face-api.js/build/es6/common/index.js","./prelu":"node_modules/face-api.js/build/es6/mtcnn/prelu.js"}],"node_modules/face-api.js/build/es6/mtcnn/PNet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PNet = PNet;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _common = require("../common");

var _sharedLayers = require("./sharedLayers");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function PNet(x, params) {
  return tf.tidy(function () {
    var out = (0, _sharedLayers.sharedLayer)(x, params, true);
    var conv = (0, _common.convLayer)(out, params.conv4_1, 'valid');
    var max = tf.expandDims(tf.max(conv, 3), 3);
    var prob = tf.softmax(tf.sub(conv, max), 3);
    var regions = (0, _common.convLayer)(out, params.conv4_2, 'valid');
    return {
      prob: prob,
      regions: regions
    };
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common":"node_modules/face-api.js/build/es6/common/index.js","./sharedLayers":"node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js"}],"node_modules/face-api.js/build/es6/mtcnn/stage1.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stage1 = stage1;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _classes = require("../classes");

var _ops = require("../ops");

var _config = require("./config");

var _getSizesForScale = require("./getSizesForScale");

var _MtcnnBox = require("./MtcnnBox");

var _normalize = require("./normalize");

var _PNet = require("./PNet");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function rescaleAndNormalize(x, scale) {
  return tf.tidy(function () {
    var _a = (0, _getSizesForScale.getSizesForScale)(scale, x.shape.slice(1)),
        height = _a.height,
        width = _a.width;

    var resized = tf.image.resizeBilinear(x, [height, width]);
    var normalized = (0, _normalize.normalize)(resized);
    return tf.transpose(normalized, [0, 2, 1, 3]);
  });
}

function extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold) {
  // TODO: fix this!, maybe better to use tf.gather here
  var indices = [];
  var scoresData = scoresTensor.arraySync();

  for (var y = 0; y < scoresTensor.shape[0]; y++) {
    for (var x = 0; x < scoresTensor.shape[1]; x++) {
      if (scoresData[y][x] >= scoreThreshold) {
        indices.push(new _classes.Point(x, y));
      }
    }
  }

  var boundingBoxes = indices.map(function (idx) {
    var cell = new _classes.BoundingBox(Math.round((idx.y * _config.CELL_STRIDE + 1) / scale), Math.round((idx.x * _config.CELL_STRIDE + 1) / scale), Math.round((idx.y * _config.CELL_STRIDE + _config.CELL_SIZE) / scale), Math.round((idx.x * _config.CELL_STRIDE + _config.CELL_SIZE) / scale));
    var score = scoresData[idx.y][idx.x];
    var regionsData = regionsTensor.arraySync();
    var region = new _MtcnnBox.MtcnnBox(regionsData[idx.y][idx.x][0], regionsData[idx.y][idx.x][1], regionsData[idx.y][idx.x][2], regionsData[idx.y][idx.x][3]);
    return {
      cell: cell,
      score: score,
      region: region
    };
  });
  return boundingBoxes;
}

function stage1(imgTensor, scales, scoreThreshold, params, stats) {
  stats.stage1 = [];
  var pnetOutputs = scales.map(function (scale) {
    return tf.tidy(function () {
      var statsForScale = {
        scale: scale
      };
      var resized = rescaleAndNormalize(imgTensor, scale);
      var ts = Date.now();

      var _a = (0, _PNet.PNet)(resized, params),
          prob = _a.prob,
          regions = _a.regions;

      statsForScale.pnet = Date.now() - ts;
      var scoresTensor = tf.unstack(tf.unstack(prob, 3)[1])[0];
      var regionsTensor = tf.unstack(regions)[0];
      return {
        scoresTensor: scoresTensor,
        regionsTensor: regionsTensor,
        scale: scale,
        statsForScale: statsForScale
      };
    });
  });
  var boxesForScale = pnetOutputs.map(function (_a) {
    var scoresTensor = _a.scoresTensor,
        regionsTensor = _a.regionsTensor,
        scale = _a.scale,
        statsForScale = _a.statsForScale;
    var boundingBoxes = extractBoundingBoxes(scoresTensor, regionsTensor, scale, scoreThreshold);
    scoresTensor.dispose();
    regionsTensor.dispose();

    if (!boundingBoxes.length) {
      stats.stage1.push(statsForScale);
      return [];
    }

    var ts = Date.now();
    var indices = (0, _ops.nonMaxSuppression)(boundingBoxes.map(function (bbox) {
      return bbox.cell;
    }), boundingBoxes.map(function (bbox) {
      return bbox.score;
    }), 0.5);
    statsForScale.nms = Date.now() - ts;
    statsForScale.numBoxes = indices.length;
    stats.stage1.push(statsForScale);
    return indices.map(function (boxIdx) {
      return boundingBoxes[boxIdx];
    });
  });
  var allBoxes = boxesForScale.reduce(function (all, boxes) {
    return all.concat(boxes);
  }, []);
  var finalBoxes = [];
  var finalScores = [];

  if (allBoxes.length > 0) {
    var ts = Date.now();
    var indices = (0, _ops.nonMaxSuppression)(allBoxes.map(function (bbox) {
      return bbox.cell;
    }), allBoxes.map(function (bbox) {
      return bbox.score;
    }), 0.7);
    stats.stage1_nms = Date.now() - ts;
    finalScores = indices.map(function (idx) {
      return allBoxes[idx].score;
    });
    finalBoxes = indices.map(function (idx) {
      return allBoxes[idx];
    }).map(function (_a) {
      var cell = _a.cell,
          region = _a.region;
      return new _classes.BoundingBox(cell.left + region.left * cell.width, cell.top + region.top * cell.height, cell.right + region.right * cell.width, cell.bottom + region.bottom * cell.height).toSquare().round();
    });
  }

  return {
    boxes: finalBoxes,
    scores: finalScores
  };
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../classes":"node_modules/face-api.js/build/es6/classes/index.js","../ops":"node_modules/face-api.js/build/es6/ops/index.js","./config":"node_modules/face-api.js/build/es6/mtcnn/config.js","./getSizesForScale":"node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js","./MtcnnBox":"node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js","./normalize":"node_modules/face-api.js/build/es6/mtcnn/normalize.js","./PNet":"node_modules/face-api.js/build/es6/mtcnn/PNet.js"}],"node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractImagePatches = extractImagePatches;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _dom = require("../dom");

var _env = require("../env");

var _normalize = require("./normalize");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function extractImagePatches(img, boxes, _a) {
  var width = _a.width,
      height = _a.height;
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var imgCtx, bitmaps, imagePatchesDatas;

    var _this = this;

    return (0, _tslib.__generator)(this, function (_b) {
      switch (_b.label) {
        case 0:
          imgCtx = (0, _dom.getContext2dOrThrow)(img);
          return [4
          /*yield*/
          , Promise.all(boxes.map(function (box) {
            return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
              var _a, y, ey, x, ex, fromX, fromY, imgData;

              return (0, _tslib.__generator)(this, function (_b) {
                _a = box.padAtBorders(img.height, img.width), y = _a.y, ey = _a.ey, x = _a.x, ex = _a.ex;
                fromX = x - 1;
                fromY = y - 1;
                imgData = imgCtx.getImageData(fromX, fromY, ex - fromX, ey - fromY);
                return [2
                /*return*/
                , _env.env.isNodejs() ? (0, _dom.createCanvasFromMedia)(imgData) : createImageBitmap(imgData)];
              });
            });
          }))];

        case 1:
          bitmaps = _b.sent();
          imagePatchesDatas = [];
          bitmaps.forEach(function (bmp) {
            var patch = (0, _dom.createCanvas)({
              width: width,
              height: height
            });
            var patchCtx = (0, _dom.getContext2dOrThrow)(patch);
            patchCtx.drawImage(bmp, 0, 0, width, height);
            var data = patchCtx.getImageData(0, 0, width, height).data;
            var currData = []; // RGBA -> BGR

            for (var i = 0; i < data.length; i += 4) {
              currData.push(data[i + 2]);
              currData.push(data[i + 1]);
              currData.push(data[i]);
            }

            imagePatchesDatas.push(currData);
          });
          return [2
          /*return*/
          , imagePatchesDatas.map(function (data) {
            var t = tf.tidy(function () {
              var imagePatchTensor = tf.transpose(tf.tensor4d(data, [1, width, height, 3]), [0, 2, 1, 3]).toFloat();
              return (0, _normalize.normalize)(imagePatchTensor);
            });
            return t;
          })];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../env":"node_modules/face-api.js/build/es6/env/index.js","./normalize":"node_modules/face-api.js/build/es6/mtcnn/normalize.js"}],"node_modules/face-api.js/build/es6/mtcnn/RNet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RNet = RNet;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _fullyConnectedLayer = require("../common/fullyConnectedLayer");

var _prelu = require("./prelu");

var _sharedLayers = require("./sharedLayers");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function RNet(x, params) {
  return tf.tidy(function () {
    var convOut = (0, _sharedLayers.sharedLayer)(x, params);
    var vectorized = tf.reshape(convOut, [convOut.shape[0], params.fc1.weights.shape[0]]);
    var fc1 = (0, _fullyConnectedLayer.fullyConnectedLayer)(vectorized, params.fc1);
    var prelu4 = (0, _prelu.prelu)(fc1, params.prelu4_alpha);
    var fc2_1 = (0, _fullyConnectedLayer.fullyConnectedLayer)(prelu4, params.fc2_1);
    var max = tf.expandDims(tf.max(fc2_1, 1), 1);
    var prob = tf.softmax(tf.sub(fc2_1, max), 1);
    var regions = (0, _fullyConnectedLayer.fullyConnectedLayer)(prelu4, params.fc2_2);
    var scores = tf.unstack(prob, 1)[1];
    return {
      scores: scores,
      regions: regions
    };
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common/fullyConnectedLayer":"node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js","./prelu":"node_modules/face-api.js/build/es6/mtcnn/prelu.js","./sharedLayers":"node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js"}],"node_modules/face-api.js/build/es6/mtcnn/stage2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stage2 = stage2;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _ops = require("../ops");

var _extractImagePatches = require("./extractImagePatches");

var _MtcnnBox = require("./MtcnnBox");

var _RNet = require("./RNet");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function stage2(img, inputBoxes, scoreThreshold, params, stats) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var ts, rnetInputs, rnetOuts, scoresTensor, scores, _a, _b, indices, filteredBoxes, filteredScores, finalBoxes, finalScores, indicesNms, regions_1;

    return (0, _tslib.__generator)(this, function (_c) {
      switch (_c.label) {
        case 0:
          ts = Date.now();
          return [4
          /*yield*/
          , (0, _extractImagePatches.extractImagePatches)(img, inputBoxes, {
            width: 24,
            height: 24
          })];

        case 1:
          rnetInputs = _c.sent();
          stats.stage2_extractImagePatches = Date.now() - ts;
          ts = Date.now();
          rnetOuts = rnetInputs.map(function (rnetInput) {
            var out = (0, _RNet.RNet)(rnetInput, params);
            rnetInput.dispose();
            return out;
          });
          stats.stage2_rnet = Date.now() - ts;
          scoresTensor = rnetOuts.length > 1 ? tf.concat(rnetOuts.map(function (out) {
            return out.scores;
          })) : rnetOuts[0].scores;
          _b = (_a = Array).from;
          return [4
          /*yield*/
          , scoresTensor.data()];

        case 2:
          scores = _b.apply(_a, [_c.sent()]);
          scoresTensor.dispose();
          indices = scores.map(function (score, idx) {
            return {
              score: score,
              idx: idx
            };
          }).filter(function (c) {
            return c.score > scoreThreshold;
          }).map(function (_a) {
            var idx = _a.idx;
            return idx;
          });
          filteredBoxes = indices.map(function (idx) {
            return inputBoxes[idx];
          });
          filteredScores = indices.map(function (idx) {
            return scores[idx];
          });
          finalBoxes = [];
          finalScores = [];

          if (filteredBoxes.length > 0) {
            ts = Date.now();
            indicesNms = (0, _ops.nonMaxSuppression)(filteredBoxes, filteredScores, 0.7);
            stats.stage2_nms = Date.now() - ts;
            regions_1 = indicesNms.map(function (idx) {
              var regionsData = rnetOuts[indices[idx]].regions.arraySync();
              return new _MtcnnBox.MtcnnBox(regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
            });
            finalScores = indicesNms.map(function (idx) {
              return filteredScores[idx];
            });
            finalBoxes = indicesNms.map(function (idx, i) {
              return filteredBoxes[idx].calibrate(regions_1[i]);
            });
          }

          rnetOuts.forEach(function (t) {
            t.regions.dispose();
            t.scores.dispose();
          });
          return [2
          /*return*/
          , {
            boxes: finalBoxes,
            scores: finalScores
          }];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../ops":"node_modules/face-api.js/build/es6/ops/index.js","./extractImagePatches":"node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js","./MtcnnBox":"node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js","./RNet":"node_modules/face-api.js/build/es6/mtcnn/RNet.js"}],"node_modules/face-api.js/build/es6/mtcnn/ONet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ONet = ONet;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _common = require("../common");

var _fullyConnectedLayer = require("../common/fullyConnectedLayer");

var _prelu = require("./prelu");

var _sharedLayers = require("./sharedLayers");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ONet(x, params) {
  return tf.tidy(function () {
    var out = (0, _sharedLayers.sharedLayer)(x, params);
    out = tf.maxPool(out, [2, 2], [2, 2], 'same');
    out = (0, _common.convLayer)(out, params.conv4, 'valid');
    out = (0, _prelu.prelu)(out, params.prelu4_alpha);
    var vectorized = tf.reshape(out, [out.shape[0], params.fc1.weights.shape[0]]);
    var fc1 = (0, _fullyConnectedLayer.fullyConnectedLayer)(vectorized, params.fc1);
    var prelu5 = (0, _prelu.prelu)(fc1, params.prelu5_alpha);
    var fc2_1 = (0, _fullyConnectedLayer.fullyConnectedLayer)(prelu5, params.fc2_1);
    var max = tf.expandDims(tf.max(fc2_1, 1), 1);
    var prob = tf.softmax(tf.sub(fc2_1, max), 1);
    var regions = (0, _fullyConnectedLayer.fullyConnectedLayer)(prelu5, params.fc2_2);
    var points = (0, _fullyConnectedLayer.fullyConnectedLayer)(prelu5, params.fc2_3);
    var scores = tf.unstack(prob, 1)[1];
    return {
      scores: scores,
      regions: regions,
      points: points
    };
  });
}
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../common":"node_modules/face-api.js/build/es6/common/index.js","../common/fullyConnectedLayer":"node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js","./prelu":"node_modules/face-api.js/build/es6/mtcnn/prelu.js","./sharedLayers":"node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js"}],"node_modules/face-api.js/build/es6/mtcnn/stage3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stage3 = stage3;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _classes = require("../classes");

var _ops = require("../ops");

var _extractImagePatches = require("./extractImagePatches");

var _MtcnnBox = require("./MtcnnBox");

var _ONet = require("./ONet");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function stage3(img, inputBoxes, scoreThreshold, params, stats) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    var ts, onetInputs, onetOuts, scoresTensor, scores, _a, _b, indices, filteredRegions, filteredBoxes, filteredScores, finalBoxes, finalScores, points, indicesNms;

    return (0, _tslib.__generator)(this, function (_c) {
      switch (_c.label) {
        case 0:
          ts = Date.now();
          return [4
          /*yield*/
          , (0, _extractImagePatches.extractImagePatches)(img, inputBoxes, {
            width: 48,
            height: 48
          })];

        case 1:
          onetInputs = _c.sent();
          stats.stage3_extractImagePatches = Date.now() - ts;
          ts = Date.now();
          onetOuts = onetInputs.map(function (onetInput) {
            var out = (0, _ONet.ONet)(onetInput, params);
            onetInput.dispose();
            return out;
          });
          stats.stage3_onet = Date.now() - ts;
          scoresTensor = onetOuts.length > 1 ? tf.concat(onetOuts.map(function (out) {
            return out.scores;
          })) : onetOuts[0].scores;
          _b = (_a = Array).from;
          return [4
          /*yield*/
          , scoresTensor.data()];

        case 2:
          scores = _b.apply(_a, [_c.sent()]);
          scoresTensor.dispose();
          indices = scores.map(function (score, idx) {
            return {
              score: score,
              idx: idx
            };
          }).filter(function (c) {
            return c.score > scoreThreshold;
          }).map(function (_a) {
            var idx = _a.idx;
            return idx;
          });
          filteredRegions = indices.map(function (idx) {
            var regionsData = onetOuts[idx].regions.arraySync();
            return new _MtcnnBox.MtcnnBox(regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
          });
          filteredBoxes = indices.map(function (idx, i) {
            return inputBoxes[idx].calibrate(filteredRegions[i]);
          });
          filteredScores = indices.map(function (idx) {
            return scores[idx];
          });
          finalBoxes = [];
          finalScores = [];
          points = [];

          if (filteredBoxes.length > 0) {
            ts = Date.now();
            indicesNms = (0, _ops.nonMaxSuppression)(filteredBoxes, filteredScores, 0.7, false);
            stats.stage3_nms = Date.now() - ts;
            finalBoxes = indicesNms.map(function (idx) {
              return filteredBoxes[idx];
            });
            finalScores = indicesNms.map(function (idx) {
              return filteredScores[idx];
            });
            points = indicesNms.map(function (idx, i) {
              return Array(5).fill(0).map(function (_, ptIdx) {
                var pointsData = onetOuts[idx].points.arraySync();
                return new _classes.Point(pointsData[0][ptIdx] * (finalBoxes[i].width + 1) + finalBoxes[i].left, pointsData[0][ptIdx + 5] * (finalBoxes[i].height + 1) + finalBoxes[i].top);
              });
            });
          }

          onetOuts.forEach(function (t) {
            t.regions.dispose();
            t.scores.dispose();
            t.points.dispose();
          });
          return [2
          /*return*/
          , {
            boxes: finalBoxes,
            scores: finalScores,
            points: points
          }];
      }
    });
  });
}
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../classes":"node_modules/face-api.js/build/es6/classes/index.js","../ops":"node_modules/face-api.js/build/es6/ops/index.js","./extractImagePatches":"node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js","./MtcnnBox":"node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js","./ONet":"node_modules/face-api.js/build/es6/mtcnn/ONet.js"}],"node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mtcnn = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _classes = require("../classes");

var _FaceDetection = require("../classes/FaceDetection");

var _FaceLandmarks = require("../classes/FaceLandmarks5");

var _dom = require("../dom");

var _factories = require("../factories");

var _NeuralNetwork = require("../NeuralNetwork");

var _bgrToRgbTensor = require("./bgrToRgbTensor");

var _config = require("./config");

var _extractParams = require("./extractParams");

var _extractParamsFromWeigthMap = require("./extractParamsFromWeigthMap");

var _getSizesForScale = require("./getSizesForScale");

var _MtcnnOptions = require("./MtcnnOptions");

var _pyramidDown = require("./pyramidDown");

var _stage = require("./stage1");

var _stage2 = require("./stage2");

var _stage3 = require("./stage3");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Mtcnn =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Mtcnn, _super);

  function Mtcnn() {
    return _super.call(this, 'Mtcnn') || this;
  }

  Mtcnn.prototype.load = function (weightsOrUrl) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      return (0, _tslib.__generator)(this, function (_a) {
        console.warn('mtcnn is deprecated and will be removed soon');
        return [2
        /*return*/
        , _super.prototype.load.call(this, weightsOrUrl)];
      });
    });
  };

  Mtcnn.prototype.loadFromDisk = function (filePath) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      return (0, _tslib.__generator)(this, function (_a) {
        console.warn('mtcnn is deprecated and will be removed soon');
        return [2
        /*return*/
        , _super.prototype.loadFromDisk.call(this, filePath)];
      });
    });
  };

  Mtcnn.prototype.forwardInput = function (input, forwardParams) {
    if (forwardParams === void 0) {
      forwardParams = {};
    }

    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts, out1, out2, out3, results;

      return (0, _tslib.__generator)(this, function (_c) {
        switch (_c.label) {
          case 0:
            params = this.params;

            if (!params) {
              throw new Error('Mtcnn - load model before inference');
            }

            inputCanvas = input.canvases[0];

            if (!inputCanvas) {
              throw new Error('Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.');
            }

            stats = {};
            tsTotal = Date.now();
            imgTensor = tf.tidy(function () {
              return (0, _bgrToRgbTensor.bgrToRgbTensor)(tf.expandDims(tf.browser.fromPixels(inputCanvas)).toFloat());
            });

            onReturn = function (results) {
              // dispose tensors on return
              imgTensor.dispose();
              stats.total = Date.now() - tsTotal;
              return results;
            };

            _a = imgTensor.shape.slice(1), height = _a[0], width = _a[1];
            _b = new _MtcnnOptions.MtcnnOptions(forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;
            scales = (scaleSteps || (0, _pyramidDown.pyramidDown)(minFaceSize, scaleFactor, [height, width])).filter(function (scale) {
              var sizes = (0, _getSizesForScale.getSizesForScale)(scale, [height, width]);
              return Math.min(sizes.width, sizes.height) > _config.CELL_SIZE;
            }).slice(0, maxNumScales);
            stats.scales = scales;
            stats.pyramid = scales.map(function (scale) {
              return (0, _getSizesForScale.getSizesForScale)(scale, [height, width]);
            });
            ts = Date.now();
            return [4
            /*yield*/
            , (0, _stage.stage1)(imgTensor, scales, scoreThresholds[0], params.pnet, stats)];

          case 1:
            out1 = _c.sent();
            stats.total_stage1 = Date.now() - ts;

            if (!out1.boxes.length) {
              return [2
              /*return*/
              , onReturn({
                results: [],
                stats: stats
              })];
            }

            stats.stage2_numInputBoxes = out1.boxes.length; // using the inputCanvas to extract and resize the image patches, since it is faster
            // than doing this on the gpu

            ts = Date.now();
            return [4
            /*yield*/
            , (0, _stage2.stage2)(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)];

          case 2:
            out2 = _c.sent();
            stats.total_stage2 = Date.now() - ts;

            if (!out2.boxes.length) {
              return [2
              /*return*/
              , onReturn({
                results: [],
                stats: stats
              })];
            }

            stats.stage3_numInputBoxes = out2.boxes.length;
            ts = Date.now();
            return [4
            /*yield*/
            , (0, _stage3.stage3)(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)];

          case 3:
            out3 = _c.sent();
            stats.total_stage3 = Date.now() - ts;
            results = out3.boxes.map(function (box, idx) {
              return (0, _factories.extendWithFaceLandmarks)((0, _factories.extendWithFaceDetection)({}, new _FaceDetection.FaceDetection(out3.scores[idx], new _classes.Rect(box.left / width, box.top / height, box.width / width, box.height / height), {
                height: height,
                width: width
              })), new _FaceLandmarks.FaceLandmarks5(out3.points[idx].map(function (pt) {
                return pt.sub(new _classes.Point(box.left, box.top)).div(new _classes.Point(box.width, box.height));
              }), {
                width: box.width,
                height: box.height
              }));
            });
            return [2
            /*return*/
            , onReturn({
              results: results,
              stats: stats
            })];
        }
      });
    });
  };

  Mtcnn.prototype.forward = function (input, forwardParams) {
    if (forwardParams === void 0) {
      forwardParams = {};
    }

    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [4
            /*yield*/
            , _a.apply(this, [_b.sent(), forwardParams])];

          case 2:
            return [2
            /*return*/
            , _b.sent().results];
        }
      });
    });
  };

  Mtcnn.prototype.forwardWithStats = function (input, forwardParams) {
    if (forwardParams === void 0) {
      forwardParams = {};
    }

    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this.forwardInput;
            return [4
            /*yield*/
            , (0, _dom.toNetInput)(input)];

          case 1:
            return [2
            /*return*/
            , _a.apply(this, [_b.sent(), forwardParams])];
        }
      });
    });
  };

  Mtcnn.prototype.getDefaultModelName = function () {
    return 'mtcnn_model';
  };

  Mtcnn.prototype.extractParamsFromWeigthMap = function (weightMap) {
    return (0, _extractParamsFromWeigthMap.extractParamsFromWeigthMap)(weightMap);
  };

  Mtcnn.prototype.extractParams = function (weights) {
    return (0, _extractParams.extractParams)(weights);
  };

  return Mtcnn;
}(_NeuralNetwork.NeuralNetwork);

exports.Mtcnn = Mtcnn;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../classes":"node_modules/face-api.js/build/es6/classes/index.js","../classes/FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js","../classes/FaceLandmarks5":"node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../factories":"node_modules/face-api.js/build/es6/factories/index.js","../NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","./bgrToRgbTensor":"node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js","./config":"node_modules/face-api.js/build/es6/mtcnn/config.js","./extractParams":"node_modules/face-api.js/build/es6/mtcnn/extractParams.js","./extractParamsFromWeigthMap":"node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js","./getSizesForScale":"node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js","./MtcnnOptions":"node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js","./pyramidDown":"node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js","./stage1":"node_modules/face-api.js/build/es6/mtcnn/stage1.js","./stage2":"node_modules/face-api.js/build/es6/mtcnn/stage2.js","./stage3":"node_modules/face-api.js/build/es6/mtcnn/stage3.js"}],"node_modules/face-api.js/build/es6/tinyFaceDetector/const.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MEAN_RGB = exports.BOX_ANCHORS = exports.IOU_THRESHOLD = void 0;

var _classes = require("../classes");

var IOU_THRESHOLD = 0.4;
exports.IOU_THRESHOLD = IOU_THRESHOLD;
var BOX_ANCHORS = [new _classes.Point(1.603231, 2.094468), new _classes.Point(6.041143, 7.080126), new _classes.Point(2.882459, 3.518061), new _classes.Point(4.266906, 5.178857), new _classes.Point(9.041765, 10.66308)];
exports.BOX_ANCHORS = BOX_ANCHORS;
var MEAN_RGB = [117.001, 114.697, 97.404];
exports.MEAN_RGB = MEAN_RGB;
},{"../classes":"node_modules/face-api.js/build/es6/classes/index.js"}],"node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyFaceDetector = void 0;

var _tslib = require("tslib");

var _classes = require("../classes");

var _TinyYolov2Base = require("../tinyYolov2/TinyYolov2Base");

var _const = require("./const");

var TinyFaceDetector =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TinyFaceDetector, _super);

  function TinyFaceDetector() {
    var _this = this;

    var config = {
      withSeparableConvs: true,
      iouThreshold: _const.IOU_THRESHOLD,
      classes: ['face'],
      anchors: _const.BOX_ANCHORS,
      meanRgb: _const.MEAN_RGB,
      isFirstLayerConv2d: true,
      filterSizes: [3, 16, 32, 64, 128, 256, 512]
    };
    _this = _super.call(this, config) || this;
    return _this;
  }

  Object.defineProperty(TinyFaceDetector.prototype, "anchors", {
    get: function () {
      return this.config.anchors;
    },
    enumerable: true,
    configurable: true
  });

  TinyFaceDetector.prototype.locateFaces = function (input, forwardParams) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var objectDetections;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , this.detect(input, forwardParams)];

          case 1:
            objectDetections = _a.sent();
            return [2
            /*return*/
            , objectDetections.map(function (det) {
              return new _classes.FaceDetection(det.score, det.relativeBox, {
                width: det.imageWidth,
                height: det.imageHeight
              });
            })];
        }
      });
    });
  };

  TinyFaceDetector.prototype.getDefaultModelName = function () {
    return 'tiny_face_detector_model';
  };

  TinyFaceDetector.prototype.extractParamsFromWeigthMap = function (weightMap) {
    return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
  };

  return TinyFaceDetector;
}(_TinyYolov2Base.TinyYolov2Base);

exports.TinyFaceDetector = TinyFaceDetector;
},{"tslib":"node_modules/tslib/tslib.es6.js","../classes":"node_modules/face-api.js/build/es6/classes/index.js","../tinyYolov2/TinyYolov2Base":"node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js","./const":"node_modules/face-api.js/build/es6/tinyFaceDetector/const.js"}],"node_modules/face-api.js/build/es6/globalApi/nets.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detectLandmarks = exports.locateFaces = exports.loadFaceDetectionModel = exports.loadAgeGenderModel = exports.loadFaceExpressionModel = exports.loadFaceRecognitionModel = exports.loadFaceLandmarkTinyModel = exports.loadFaceLandmarkModel = exports.loadTinyYolov2Model = exports.loadMtcnnModel = exports.loadTinyFaceDetectorModel = exports.loadSsdMobilenetv1Model = exports.predictAgeAndGender = exports.recognizeFaceExpressions = exports.computeFaceDescriptor = exports.detectFaceLandmarksTiny = exports.detectFaceLandmarks = exports.mtcnn = exports.tinyYolov2 = exports.tinyFaceDetector = exports.ssdMobilenetv1 = exports.nets = void 0;

var _AgeGenderNet = require("../ageGenderNet/AgeGenderNet");

var _FaceExpressionNet = require("../faceExpressionNet/FaceExpressionNet");

var _FaceLandmark68Net = require("../faceLandmarkNet/FaceLandmark68Net");

var _FaceLandmark68TinyNet = require("../faceLandmarkNet/FaceLandmark68TinyNet");

var _FaceRecognitionNet = require("../faceRecognitionNet/FaceRecognitionNet");

var _Mtcnn = require("../mtcnn/Mtcnn");

var _SsdMobilenetv = require("../ssdMobilenetv1/SsdMobilenetv1");

var _TinyFaceDetector = require("../tinyFaceDetector/TinyFaceDetector");

var _tinyYolov = require("../tinyYolov2");

var nets = {
  ssdMobilenetv1: new _SsdMobilenetv.SsdMobilenetv1(),
  tinyFaceDetector: new _TinyFaceDetector.TinyFaceDetector(),
  tinyYolov2: new _tinyYolov.TinyYolov2(),
  mtcnn: new _Mtcnn.Mtcnn(),
  faceLandmark68Net: new _FaceLandmark68Net.FaceLandmark68Net(),
  faceLandmark68TinyNet: new _FaceLandmark68TinyNet.FaceLandmark68TinyNet(),
  faceRecognitionNet: new _FaceRecognitionNet.FaceRecognitionNet(),
  faceExpressionNet: new _FaceExpressionNet.FaceExpressionNet(),
  ageGenderNet: new _AgeGenderNet.AgeGenderNet()
};
/**
 * Attempts to detect all faces in an image using SSD Mobilenetv1 Network.
 *
 * @param input The input image.
 * @param options (optional, default: see SsdMobilenetv1Options constructor for default parameters).
 * @returns Bounding box of each face with score.
 */

exports.nets = nets;

var ssdMobilenetv1 = function (input, options) {
  return nets.ssdMobilenetv1.locateFaces(input, options);
};
/**
 * Attempts to detect all faces in an image using the Tiny Face Detector.
 *
 * @param input The input image.
 * @param options (optional, default: see TinyFaceDetectorOptions constructor for default parameters).
 * @returns Bounding box of each face with score.
 */


exports.ssdMobilenetv1 = ssdMobilenetv1;

var tinyFaceDetector = function (input, options) {
  return nets.tinyFaceDetector.locateFaces(input, options);
};
/**
 * Attempts to detect all faces in an image using the Tiny Yolov2 Network.
 *
 * @param input The input image.
 * @param options (optional, default: see TinyYolov2Options constructor for default parameters).
 * @returns Bounding box of each face with score.
 */


exports.tinyFaceDetector = tinyFaceDetector;

var tinyYolov2 = function (input, options) {
  return nets.tinyYolov2.locateFaces(input, options);
};
/**
 * Attempts to detect all faces in an image and the 5 point face landmarks
 * of each detected face using the MTCNN Network.
 *
 * @param input The input image.
 * @param options (optional, default: see MtcnnOptions constructor for default parameters).
 * @returns Bounding box of each face with score and 5 point face landmarks.
 */


exports.tinyYolov2 = tinyYolov2;

var mtcnn = function (input, options) {
  return nets.mtcnn.forward(input, options);
};
/**
 * Detects the 68 point face landmark positions of the face shown in an image.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns 68 point face landmarks or array thereof in case of batch input.
 */


exports.mtcnn = mtcnn;

var detectFaceLandmarks = function (input) {
  return nets.faceLandmark68Net.detectLandmarks(input);
};
/**
 * Detects the 68 point face landmark positions of the face shown in an image
 * using a tinier version of the 68 point face landmark model, which is slightly
 * faster at inference, but also slightly less accurate.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns 68 point face landmarks or array thereof in case of batch input.
 */


exports.detectFaceLandmarks = detectFaceLandmarks;

var detectFaceLandmarksTiny = function (input) {
  return nets.faceLandmark68TinyNet.detectLandmarks(input);
};
/**
 * Computes a 128 entry vector (face descriptor / face embeddings) from the face shown in an image,
 * which uniquely represents the features of that persons face. The computed face descriptor can
 * be used to measure the similarity between faces, by computing the euclidean distance of two
 * face descriptors.
 *
 * @param inputs The face image extracted from the aligned bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns Face descriptor with 128 entries or array thereof in case of batch input.
 */


exports.detectFaceLandmarksTiny = detectFaceLandmarksTiny;

var computeFaceDescriptor = function (input) {
  return nets.faceRecognitionNet.computeFaceDescriptor(input);
};
/**
 * Recognizes the facial expressions from a face image.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns Facial expressions with corresponding probabilities or array thereof in case of batch input.
 */


exports.computeFaceDescriptor = computeFaceDescriptor;

var recognizeFaceExpressions = function (input) {
  return nets.faceExpressionNet.predictExpressions(input);
};
/**
 * Predicts age and gender from a face image.
 *
 * @param inputs The face image extracted from the bounding box of a face. Can
 * also be an array of input images, which will be batch processed.
 * @returns Predictions with age, gender and gender probability or array thereof in case of batch input.
 */


exports.recognizeFaceExpressions = recognizeFaceExpressions;

var predictAgeAndGender = function (input) {
  return nets.ageGenderNet.predictAgeAndGender(input);
};

exports.predictAgeAndGender = predictAgeAndGender;

var loadSsdMobilenetv1Model = function (url) {
  return nets.ssdMobilenetv1.load(url);
};

exports.loadSsdMobilenetv1Model = loadSsdMobilenetv1Model;

var loadTinyFaceDetectorModel = function (url) {
  return nets.tinyFaceDetector.load(url);
};

exports.loadTinyFaceDetectorModel = loadTinyFaceDetectorModel;

var loadMtcnnModel = function (url) {
  return nets.mtcnn.load(url);
};

exports.loadMtcnnModel = loadMtcnnModel;

var loadTinyYolov2Model = function (url) {
  return nets.tinyYolov2.load(url);
};

exports.loadTinyYolov2Model = loadTinyYolov2Model;

var loadFaceLandmarkModel = function (url) {
  return nets.faceLandmark68Net.load(url);
};

exports.loadFaceLandmarkModel = loadFaceLandmarkModel;

var loadFaceLandmarkTinyModel = function (url) {
  return nets.faceLandmark68TinyNet.load(url);
};

exports.loadFaceLandmarkTinyModel = loadFaceLandmarkTinyModel;

var loadFaceRecognitionModel = function (url) {
  return nets.faceRecognitionNet.load(url);
};

exports.loadFaceRecognitionModel = loadFaceRecognitionModel;

var loadFaceExpressionModel = function (url) {
  return nets.faceExpressionNet.load(url);
};

exports.loadFaceExpressionModel = loadFaceExpressionModel;

var loadAgeGenderModel = function (url) {
  return nets.ageGenderNet.load(url);
}; // backward compatibility


exports.loadAgeGenderModel = loadAgeGenderModel;
var loadFaceDetectionModel = loadSsdMobilenetv1Model;
exports.loadFaceDetectionModel = loadFaceDetectionModel;
var locateFaces = ssdMobilenetv1;
exports.locateFaces = locateFaces;
var detectLandmarks = detectFaceLandmarks;
exports.detectLandmarks = detectLandmarks;
},{"../ageGenderNet/AgeGenderNet":"node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js","../faceExpressionNet/FaceExpressionNet":"node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js","../faceLandmarkNet/FaceLandmark68Net":"node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js","../faceLandmarkNet/FaceLandmark68TinyNet":"node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js","../faceRecognitionNet/FaceRecognitionNet":"node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js","../mtcnn/Mtcnn":"node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js","../ssdMobilenetv1/SsdMobilenetv1":"node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js","../tinyFaceDetector/TinyFaceDetector":"node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js","../tinyYolov2":"node_modules/face-api.js/build/es6/tinyYolov2/index.js"}],"node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictSingleFaceExpressionsWithFaceAlignmentTask = exports.PredictAllFaceExpressionsWithFaceAlignmentTask = exports.PredictSingleFaceExpressionsTask = exports.PredictAllFaceExpressionsTask = exports.PredictFaceExpressionsTaskBase = void 0;

var _tslib = require("tslib");

var _WithFaceExpressions = require("../factories/WithFaceExpressions");

var _ComposableTask = require("./ComposableTask");

var _ComputeFaceDescriptorsTasks = require("./ComputeFaceDescriptorsTasks");

var _extractFacesAndComputeResults = require("./extractFacesAndComputeResults");

var _nets = require("./nets");

var _PredictAgeAndGenderTask = require("./PredictAgeAndGenderTask");

var PredictFaceExpressionsTaskBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictFaceExpressionsTaskBase, _super);

  function PredictFaceExpressionsTaskBase(parentTask, input, extractedFaces) {
    var _this = _super.call(this) || this;

    _this.parentTask = parentTask;
    _this.input = input;
    _this.extractedFaces = extractedFaces;
    return _this;
  }

  return PredictFaceExpressionsTaskBase;
}(_ComposableTask.ComposableTask);

exports.PredictFaceExpressionsTaskBase = PredictFaceExpressionsTaskBase;

var PredictAllFaceExpressionsTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictAllFaceExpressionsTask, _super);

  function PredictAllFaceExpressionsTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PredictAllFaceExpressionsTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var parentResults, faceExpressionsByFace;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , this.parentTask];

          case 1:
            parentResults = _a.sent();
            return [4
            /*yield*/
            , (0, _extractFacesAndComputeResults.extractAllFacesAndComputeResults)(parentResults, this.input, function (faces) {
              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
                return (0, _tslib.__generator)(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [4
                      /*yield*/
                      , Promise.all(faces.map(function (face) {
                        return _nets.nets.faceExpressionNet.predictExpressions(face);
                      }))];

                    case 1:
                      return [2
                      /*return*/
                      , _a.sent()];
                  }
                });
              });
            }, this.extractedFaces)];

          case 2:
            faceExpressionsByFace = _a.sent();
            return [2
            /*return*/
            , parentResults.map(function (parentResult, i) {
              return (0, _WithFaceExpressions.extendWithFaceExpressions)(parentResult, faceExpressionsByFace[i]);
            })];
        }
      });
    });
  };

  PredictAllFaceExpressionsTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictAllAgeAndGenderTask(this, this.input);
  };

  return PredictAllFaceExpressionsTask;
}(PredictFaceExpressionsTaskBase);

exports.PredictAllFaceExpressionsTask = PredictAllFaceExpressionsTask;

var PredictSingleFaceExpressionsTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictSingleFaceExpressionsTask, _super);

  function PredictSingleFaceExpressionsTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PredictSingleFaceExpressionsTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var parentResult, faceExpressions;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , this.parentTask];

          case 1:
            parentResult = _a.sent();

            if (!parentResult) {
              return [2
              /*return*/
              ];
            }

            return [4
            /*yield*/
            , (0, _extractFacesAndComputeResults.extractSingleFaceAndComputeResult)(parentResult, this.input, function (face) {
              return _nets.nets.faceExpressionNet.predictExpressions(face);
            }, this.extractedFaces)];

          case 2:
            faceExpressions = _a.sent();
            return [2
            /*return*/
            , (0, _WithFaceExpressions.extendWithFaceExpressions)(parentResult, faceExpressions)];
        }
      });
    });
  };

  PredictSingleFaceExpressionsTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictSingleAgeAndGenderTask(this, this.input);
  };

  return PredictSingleFaceExpressionsTask;
}(PredictFaceExpressionsTaskBase);

exports.PredictSingleFaceExpressionsTask = PredictSingleFaceExpressionsTask;

var PredictAllFaceExpressionsWithFaceAlignmentTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictAllFaceExpressionsWithFaceAlignmentTask, _super);

  function PredictAllFaceExpressionsWithFaceAlignmentTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PredictAllFaceExpressionsWithFaceAlignmentTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);
  };

  PredictAllFaceExpressionsWithFaceAlignmentTask.prototype.withFaceDescriptors = function () {
    return new _ComputeFaceDescriptorsTasks.ComputeAllFaceDescriptorsTask(this, this.input);
  };

  return PredictAllFaceExpressionsWithFaceAlignmentTask;
}(PredictAllFaceExpressionsTask);

exports.PredictAllFaceExpressionsWithFaceAlignmentTask = PredictAllFaceExpressionsWithFaceAlignmentTask;

var PredictSingleFaceExpressionsWithFaceAlignmentTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictSingleFaceExpressionsWithFaceAlignmentTask, _super);

  function PredictSingleFaceExpressionsWithFaceAlignmentTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PredictSingleFaceExpressionsWithFaceAlignmentTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);
  };

  PredictSingleFaceExpressionsWithFaceAlignmentTask.prototype.withFaceDescriptor = function () {
    return new _ComputeFaceDescriptorsTasks.ComputeSingleFaceDescriptorTask(this, this.input);
  };

  return PredictSingleFaceExpressionsWithFaceAlignmentTask;
}(PredictSingleFaceExpressionsTask);

exports.PredictSingleFaceExpressionsWithFaceAlignmentTask = PredictSingleFaceExpressionsWithFaceAlignmentTask;
},{"tslib":"node_modules/tslib/tslib.es6.js","../factories/WithFaceExpressions":"node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js","./ComposableTask":"node_modules/face-api.js/build/es6/globalApi/ComposableTask.js","./ComputeFaceDescriptorsTasks":"node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js","./extractFacesAndComputeResults":"node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js","./nets":"node_modules/face-api.js/build/es6/globalApi/nets.js","./PredictAgeAndGenderTask":"node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js"}],"node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictSingleAgeAndGenderWithFaceAlignmentTask = exports.PredictAllAgeAndGenderWithFaceAlignmentTask = exports.PredictSingleAgeAndGenderTask = exports.PredictAllAgeAndGenderTask = exports.PredictAgeAndGenderTaskBase = void 0;

var _tslib = require("tslib");

var _WithAge = require("../factories/WithAge");

var _WithGender = require("../factories/WithGender");

var _ComposableTask = require("./ComposableTask");

var _ComputeFaceDescriptorsTasks = require("./ComputeFaceDescriptorsTasks");

var _extractFacesAndComputeResults = require("./extractFacesAndComputeResults");

var _nets = require("./nets");

var _PredictFaceExpressionsTask = require("./PredictFaceExpressionsTask");

var PredictAgeAndGenderTaskBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictAgeAndGenderTaskBase, _super);

  function PredictAgeAndGenderTaskBase(parentTask, input, extractedFaces) {
    var _this = _super.call(this) || this;

    _this.parentTask = parentTask;
    _this.input = input;
    _this.extractedFaces = extractedFaces;
    return _this;
  }

  return PredictAgeAndGenderTaskBase;
}(_ComposableTask.ComposableTask);

exports.PredictAgeAndGenderTaskBase = PredictAgeAndGenderTaskBase;

var PredictAllAgeAndGenderTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictAllAgeAndGenderTask, _super);

  function PredictAllAgeAndGenderTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PredictAllAgeAndGenderTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var parentResults, ageAndGenderByFace;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , this.parentTask];

          case 1:
            parentResults = _a.sent();
            return [4
            /*yield*/
            , (0, _extractFacesAndComputeResults.extractAllFacesAndComputeResults)(parentResults, this.input, function (faces) {
              return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
                return (0, _tslib.__generator)(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [4
                      /*yield*/
                      , Promise.all(faces.map(function (face) {
                        return _nets.nets.ageGenderNet.predictAgeAndGender(face);
                      }))];

                    case 1:
                      return [2
                      /*return*/
                      , _a.sent()];
                  }
                });
              });
            }, this.extractedFaces)];

          case 2:
            ageAndGenderByFace = _a.sent();
            return [2
            /*return*/
            , parentResults.map(function (parentResult, i) {
              var _a = ageAndGenderByFace[i],
                  age = _a.age,
                  gender = _a.gender,
                  genderProbability = _a.genderProbability;
              return (0, _WithAge.extendWithAge)((0, _WithGender.extendWithGender)(parentResult, gender, genderProbability), age);
            })];
        }
      });
    });
  };

  PredictAllAgeAndGenderTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictAllFaceExpressionsTask(this, this.input);
  };

  return PredictAllAgeAndGenderTask;
}(PredictAgeAndGenderTaskBase);

exports.PredictAllAgeAndGenderTask = PredictAllAgeAndGenderTask;

var PredictSingleAgeAndGenderTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictSingleAgeAndGenderTask, _super);

  function PredictSingleAgeAndGenderTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PredictSingleAgeAndGenderTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var parentResult, _a, age, gender, genderProbability;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            return [4
            /*yield*/
            , this.parentTask];

          case 1:
            parentResult = _b.sent();

            if (!parentResult) {
              return [2
              /*return*/
              ];
            }

            return [4
            /*yield*/
            , (0, _extractFacesAndComputeResults.extractSingleFaceAndComputeResult)(parentResult, this.input, function (face) {
              return _nets.nets.ageGenderNet.predictAgeAndGender(face);
            }, this.extractedFaces)];

          case 2:
            _a = _b.sent(), age = _a.age, gender = _a.gender, genderProbability = _a.genderProbability;
            return [2
            /*return*/
            , (0, _WithAge.extendWithAge)((0, _WithGender.extendWithGender)(parentResult, gender, genderProbability), age)];
        }
      });
    });
  };

  PredictSingleAgeAndGenderTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictSingleFaceExpressionsTask(this, this.input);
  };

  return PredictSingleAgeAndGenderTask;
}(PredictAgeAndGenderTaskBase);

exports.PredictSingleAgeAndGenderTask = PredictSingleAgeAndGenderTask;

var PredictAllAgeAndGenderWithFaceAlignmentTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictAllAgeAndGenderWithFaceAlignmentTask, _super);

  function PredictAllAgeAndGenderWithFaceAlignmentTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PredictAllAgeAndGenderWithFaceAlignmentTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);
  };

  PredictAllAgeAndGenderWithFaceAlignmentTask.prototype.withFaceDescriptors = function () {
    return new _ComputeFaceDescriptorsTasks.ComputeAllFaceDescriptorsTask(this, this.input);
  };

  return PredictAllAgeAndGenderWithFaceAlignmentTask;
}(PredictAllAgeAndGenderTask);

exports.PredictAllAgeAndGenderWithFaceAlignmentTask = PredictAllAgeAndGenderWithFaceAlignmentTask;

var PredictSingleAgeAndGenderWithFaceAlignmentTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PredictSingleAgeAndGenderWithFaceAlignmentTask, _super);

  function PredictSingleAgeAndGenderWithFaceAlignmentTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PredictSingleAgeAndGenderWithFaceAlignmentTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);
  };

  PredictSingleAgeAndGenderWithFaceAlignmentTask.prototype.withFaceDescriptor = function () {
    return new _ComputeFaceDescriptorsTasks.ComputeSingleFaceDescriptorTask(this, this.input);
  };

  return PredictSingleAgeAndGenderWithFaceAlignmentTask;
}(PredictSingleAgeAndGenderTask);

exports.PredictSingleAgeAndGenderWithFaceAlignmentTask = PredictSingleAgeAndGenderWithFaceAlignmentTask;
},{"tslib":"node_modules/tslib/tslib.es6.js","../factories/WithAge":"node_modules/face-api.js/build/es6/factories/WithAge.js","../factories/WithGender":"node_modules/face-api.js/build/es6/factories/WithGender.js","./ComposableTask":"node_modules/face-api.js/build/es6/globalApi/ComposableTask.js","./ComputeFaceDescriptorsTasks":"node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js","./extractFacesAndComputeResults":"node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js","./nets":"node_modules/face-api.js/build/es6/globalApi/nets.js","./PredictFaceExpressionsTask":"node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js"}],"node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComputeSingleFaceDescriptorTask = exports.ComputeAllFaceDescriptorsTask = exports.ComputeFaceDescriptorsTaskBase = void 0;

var _tslib = require("tslib");

var _WithFaceDescriptor = require("../factories/WithFaceDescriptor");

var _ComposableTask = require("./ComposableTask");

var _extractFacesAndComputeResults = require("./extractFacesAndComputeResults");

var _nets = require("./nets");

var _PredictAgeAndGenderTask = require("./PredictAgeAndGenderTask");

var _PredictFaceExpressionsTask = require("./PredictFaceExpressionsTask");

var ComputeFaceDescriptorsTaskBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ComputeFaceDescriptorsTaskBase, _super);

  function ComputeFaceDescriptorsTaskBase(parentTask, input) {
    var _this = _super.call(this) || this;

    _this.parentTask = parentTask;
    _this.input = input;
    return _this;
  }

  return ComputeFaceDescriptorsTaskBase;
}(_ComposableTask.ComposableTask);

exports.ComputeFaceDescriptorsTaskBase = ComputeFaceDescriptorsTaskBase;

var ComputeAllFaceDescriptorsTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ComputeAllFaceDescriptorsTask, _super);

  function ComputeAllFaceDescriptorsTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ComputeAllFaceDescriptorsTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var parentResults, descriptors;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , this.parentTask];

          case 1:
            parentResults = _a.sent();
            return [4
            /*yield*/
            , (0, _extractFacesAndComputeResults.extractAllFacesAndComputeResults)(parentResults, this.input, function (faces) {
              return Promise.all(faces.map(function (face) {
                return _nets.nets.faceRecognitionNet.computeFaceDescriptor(face);
              }));
            }, null, function (parentResult) {
              return parentResult.landmarks.align(null, {
                useDlibAlignment: true
              });
            })];

          case 2:
            descriptors = _a.sent();
            return [2
            /*return*/
            , descriptors.map(function (descriptor, i) {
              return (0, _WithFaceDescriptor.extendWithFaceDescriptor)(parentResults[i], descriptor);
            })];
        }
      });
    });
  };

  ComputeAllFaceDescriptorsTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);
  };

  ComputeAllFaceDescriptorsTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);
  };

  return ComputeAllFaceDescriptorsTask;
}(ComputeFaceDescriptorsTaskBase);

exports.ComputeAllFaceDescriptorsTask = ComputeAllFaceDescriptorsTask;

var ComputeSingleFaceDescriptorTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ComputeSingleFaceDescriptorTask, _super);

  function ComputeSingleFaceDescriptorTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ComputeSingleFaceDescriptorTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var parentResult, descriptor;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , this.parentTask];

          case 1:
            parentResult = _a.sent();

            if (!parentResult) {
              return [2
              /*return*/
              ];
            }

            return [4
            /*yield*/
            , (0, _extractFacesAndComputeResults.extractSingleFaceAndComputeResult)(parentResult, this.input, function (face) {
              return _nets.nets.faceRecognitionNet.computeFaceDescriptor(face);
            }, null, function (parentResult) {
              return parentResult.landmarks.align(null, {
                useDlibAlignment: true
              });
            })];

          case 2:
            descriptor = _a.sent();
            return [2
            /*return*/
            , (0, _WithFaceDescriptor.extendWithFaceDescriptor)(parentResult, descriptor)];
        }
      });
    });
  };

  ComputeSingleFaceDescriptorTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);
  };

  ComputeSingleFaceDescriptorTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);
  };

  return ComputeSingleFaceDescriptorTask;
}(ComputeFaceDescriptorsTaskBase);

exports.ComputeSingleFaceDescriptorTask = ComputeSingleFaceDescriptorTask;
},{"tslib":"node_modules/tslib/tslib.es6.js","../factories/WithFaceDescriptor":"node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js","./ComposableTask":"node_modules/face-api.js/build/es6/globalApi/ComposableTask.js","./extractFacesAndComputeResults":"node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js","./nets":"node_modules/face-api.js/build/es6/globalApi/nets.js","./PredictAgeAndGenderTask":"node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js","./PredictFaceExpressionsTask":"node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js"}],"node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DetectSingleFaceLandmarksTask = exports.DetectAllFaceLandmarksTask = exports.DetectFaceLandmarksTaskBase = void 0;

var _tslib = require("tslib");

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

var _dom = require("../dom");

var _WithFaceLandmarks = require("../factories/WithFaceLandmarks");

var _ComposableTask = require("./ComposableTask");

var _ComputeFaceDescriptorsTasks = require("./ComputeFaceDescriptorsTasks");

var _nets = require("./nets");

var _PredictAgeAndGenderTask = require("./PredictAgeAndGenderTask");

var _PredictFaceExpressionsTask = require("./PredictFaceExpressionsTask");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var DetectFaceLandmarksTaskBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DetectFaceLandmarksTaskBase, _super);

  function DetectFaceLandmarksTaskBase(parentTask, input, useTinyLandmarkNet) {
    var _this = _super.call(this) || this;

    _this.parentTask = parentTask;
    _this.input = input;
    _this.useTinyLandmarkNet = useTinyLandmarkNet;
    return _this;
  }

  Object.defineProperty(DetectFaceLandmarksTaskBase.prototype, "landmarkNet", {
    get: function () {
      return this.useTinyLandmarkNet ? _nets.nets.faceLandmark68TinyNet : _nets.nets.faceLandmark68Net;
    },
    enumerable: true,
    configurable: true
  });
  return DetectFaceLandmarksTaskBase;
}(_ComposableTask.ComposableTask);

exports.DetectFaceLandmarksTaskBase = DetectFaceLandmarksTaskBase;

var DetectAllFaceLandmarksTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DetectAllFaceLandmarksTask, _super);

  function DetectAllFaceLandmarksTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DetectAllFaceLandmarksTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var parentResults, detections, faces, _a, faceLandmarksByFace;

      var _this = this;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            return [4
            /*yield*/
            , this.parentTask];

          case 1:
            parentResults = _b.sent();
            detections = parentResults.map(function (res) {
              return res.detection;
            });
            if (!(this.input instanceof tf.Tensor)) return [3
            /*break*/
            , 3];
            return [4
            /*yield*/
            , (0, _dom.extractFaceTensors)(this.input, detections)];

          case 2:
            _a = _b.sent();
            return [3
            /*break*/
            , 5];

          case 3:
            return [4
            /*yield*/
            , (0, _dom.extractFaces)(this.input, detections)];

          case 4:
            _a = _b.sent();
            _b.label = 5;

          case 5:
            faces = _a;
            return [4
            /*yield*/
            , Promise.all(faces.map(function (face) {
              return _this.landmarkNet.detectLandmarks(face);
            }))];

          case 6:
            faceLandmarksByFace = _b.sent();
            faces.forEach(function (f) {
              return f instanceof tf.Tensor && f.dispose();
            });
            return [2
            /*return*/
            , parentResults.map(function (parentResult, i) {
              return (0, _WithFaceLandmarks.extendWithFaceLandmarks)(parentResult, faceLandmarksByFace[i]);
            })];
        }
      });
    });
  };

  DetectAllFaceLandmarksTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);
  };

  DetectAllFaceLandmarksTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);
  };

  DetectAllFaceLandmarksTask.prototype.withFaceDescriptors = function () {
    return new _ComputeFaceDescriptorsTasks.ComputeAllFaceDescriptorsTask(this, this.input);
  };

  return DetectAllFaceLandmarksTask;
}(DetectFaceLandmarksTaskBase);

exports.DetectAllFaceLandmarksTask = DetectAllFaceLandmarksTask;

var DetectSingleFaceLandmarksTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DetectSingleFaceLandmarksTask, _super);

  function DetectSingleFaceLandmarksTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DetectSingleFaceLandmarksTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var parentResult, detection, faces, _a, landmarks;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            return [4
            /*yield*/
            , this.parentTask];

          case 1:
            parentResult = _b.sent();

            if (!parentResult) {
              return [2
              /*return*/
              ];
            }

            detection = parentResult.detection;
            if (!(this.input instanceof tf.Tensor)) return [3
            /*break*/
            , 3];
            return [4
            /*yield*/
            , (0, _dom.extractFaceTensors)(this.input, [detection])];

          case 2:
            _a = _b.sent();
            return [3
            /*break*/
            , 5];

          case 3:
            return [4
            /*yield*/
            , (0, _dom.extractFaces)(this.input, [detection])];

          case 4:
            _a = _b.sent();
            _b.label = 5;

          case 5:
            faces = _a;
            return [4
            /*yield*/
            , this.landmarkNet.detectLandmarks(faces[0])];

          case 6:
            landmarks = _b.sent();
            faces.forEach(function (f) {
              return f instanceof tf.Tensor && f.dispose();
            });
            return [2
            /*return*/
            , (0, _WithFaceLandmarks.extendWithFaceLandmarks)(parentResult, landmarks)];
        }
      });
    });
  };

  DetectSingleFaceLandmarksTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);
  };

  DetectSingleFaceLandmarksTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);
  };

  DetectSingleFaceLandmarksTask.prototype.withFaceDescriptor = function () {
    return new _ComputeFaceDescriptorsTasks.ComputeSingleFaceDescriptorTask(this, this.input);
  };

  return DetectSingleFaceLandmarksTask;
}(DetectFaceLandmarksTaskBase);

exports.DetectSingleFaceLandmarksTask = DetectSingleFaceLandmarksTask;
},{"tslib":"node_modules/tslib/tslib.es6.js","@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","../dom":"node_modules/face-api.js/build/es6/dom/index.js","../factories/WithFaceLandmarks":"node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js","./ComposableTask":"node_modules/face-api.js/build/es6/globalApi/ComposableTask.js","./ComputeFaceDescriptorsTasks":"node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js","./nets":"node_modules/face-api.js/build/es6/globalApi/nets.js","./PredictAgeAndGenderTask":"node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js","./PredictFaceExpressionsTask":"node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js"}],"node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DetectSingleFaceTask = exports.DetectAllFacesTask = exports.DetectFacesTaskBase = void 0;

var _tslib = require("tslib");

var _WithFaceDetection = require("../factories/WithFaceDetection");

var _MtcnnOptions = require("../mtcnn/MtcnnOptions");

var _SsdMobilenetv1Options = require("../ssdMobilenetv1/SsdMobilenetv1Options");

var _TinyFaceDetectorOptions = require("../tinyFaceDetector/TinyFaceDetectorOptions");

var _tinyYolov = require("../tinyYolov2");

var _ComposableTask = require("./ComposableTask");

var _DetectFaceLandmarksTasks = require("./DetectFaceLandmarksTasks");

var _nets = require("./nets");

var _PredictAgeAndGenderTask = require("./PredictAgeAndGenderTask");

var _PredictFaceExpressionsTask = require("./PredictFaceExpressionsTask");

var DetectFacesTaskBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DetectFacesTaskBase, _super);

  function DetectFacesTaskBase(input, options) {
    if (options === void 0) {
      options = new _SsdMobilenetv1Options.SsdMobilenetv1Options();
    }

    var _this = _super.call(this) || this;

    _this.input = input;
    _this.options = options;
    return _this;
  }

  return DetectFacesTaskBase;
}(_ComposableTask.ComposableTask);

exports.DetectFacesTaskBase = DetectFacesTaskBase;

var DetectAllFacesTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DetectAllFacesTask, _super);

  function DetectAllFacesTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DetectAllFacesTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var _a, input, options, faceDetectionFunction;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = this, input = _a.input, options = _a.options;
            if (!(options instanceof _MtcnnOptions.MtcnnOptions)) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , _nets.nets.mtcnn.forward(input, options)];

          case 1:
            return [2
            /*return*/
            , _b.sent().map(function (result) {
              return result.detection;
            })];

          case 2:
            faceDetectionFunction = options instanceof _TinyFaceDetectorOptions.TinyFaceDetectorOptions ? function (input) {
              return _nets.nets.tinyFaceDetector.locateFaces(input, options);
            } : options instanceof _SsdMobilenetv1Options.SsdMobilenetv1Options ? function (input) {
              return _nets.nets.ssdMobilenetv1.locateFaces(input, options);
            } : options instanceof _tinyYolov.TinyYolov2Options ? function (input) {
              return _nets.nets.tinyYolov2.locateFaces(input, options);
            } : null;

            if (!faceDetectionFunction) {
              throw new Error('detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options');
            }

            return [2
            /*return*/
            , faceDetectionFunction(input)];
        }
      });
    });
  };

  DetectAllFacesTask.prototype.runAndExtendWithFaceDetections = function () {
    var _this = this;

    return new Promise(function (res) {
      return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
        var detections;
        return (0, _tslib.__generator)(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.run()];

            case 1:
              detections = _a.sent();
              return [2
              /*return*/
              , res(detections.map(function (detection) {
                return (0, _WithFaceDetection.extendWithFaceDetection)({}, detection);
              }))];
          }
        });
      });
    });
  };

  DetectAllFacesTask.prototype.withFaceLandmarks = function (useTinyLandmarkNet) {
    if (useTinyLandmarkNet === void 0) {
      useTinyLandmarkNet = false;
    }

    return new _DetectFaceLandmarksTasks.DetectAllFaceLandmarksTask(this.runAndExtendWithFaceDetections(), this.input, useTinyLandmarkNet);
  };

  DetectAllFacesTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictAllFaceExpressionsTask(this.runAndExtendWithFaceDetections(), this.input);
  };

  DetectAllFacesTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictAllAgeAndGenderTask(this.runAndExtendWithFaceDetections(), this.input);
  };

  return DetectAllFacesTask;
}(DetectFacesTaskBase);

exports.DetectAllFacesTask = DetectAllFacesTask;

var DetectSingleFaceTask =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DetectSingleFaceTask, _super);

  function DetectSingleFaceTask() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DetectSingleFaceTask.prototype.run = function () {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
      var faceDetections, faceDetectionWithHighestScore;
      return (0, _tslib.__generator)(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , new DetectAllFacesTask(this.input, this.options)];

          case 1:
            faceDetections = _a.sent();
            faceDetectionWithHighestScore = faceDetections[0];
            faceDetections.forEach(function (faceDetection) {
              if (faceDetection.score > faceDetectionWithHighestScore.score) {
                faceDetectionWithHighestScore = faceDetection;
              }
            });
            return [2
            /*return*/
            , faceDetectionWithHighestScore];
        }
      });
    });
  };

  DetectSingleFaceTask.prototype.runAndExtendWithFaceDetection = function () {
    var _this = this;

    return new Promise(function (res) {
      return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
        var detection;
        return (0, _tslib.__generator)(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4
              /*yield*/
              , this.run()];

            case 1:
              detection = _a.sent();
              return [2
              /*return*/
              , res(detection ? (0, _WithFaceDetection.extendWithFaceDetection)({}, detection) : undefined)];
          }
        });
      });
    });
  };

  DetectSingleFaceTask.prototype.withFaceLandmarks = function (useTinyLandmarkNet) {
    if (useTinyLandmarkNet === void 0) {
      useTinyLandmarkNet = false;
    }

    return new _DetectFaceLandmarksTasks.DetectSingleFaceLandmarksTask(this.runAndExtendWithFaceDetection(), this.input, useTinyLandmarkNet);
  };

  DetectSingleFaceTask.prototype.withFaceExpressions = function () {
    return new _PredictFaceExpressionsTask.PredictSingleFaceExpressionsTask(this.runAndExtendWithFaceDetection(), this.input);
  };

  DetectSingleFaceTask.prototype.withAgeAndGender = function () {
    return new _PredictAgeAndGenderTask.PredictSingleAgeAndGenderTask(this.runAndExtendWithFaceDetection(), this.input);
  };

  return DetectSingleFaceTask;
}(DetectFacesTaskBase);

exports.DetectSingleFaceTask = DetectSingleFaceTask;
},{"tslib":"node_modules/tslib/tslib.es6.js","../factories/WithFaceDetection":"node_modules/face-api.js/build/es6/factories/WithFaceDetection.js","../mtcnn/MtcnnOptions":"node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js","../ssdMobilenetv1/SsdMobilenetv1Options":"node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js","../tinyFaceDetector/TinyFaceDetectorOptions":"node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js","../tinyYolov2":"node_modules/face-api.js/build/es6/tinyYolov2/index.js","./ComposableTask":"node_modules/face-api.js/build/es6/globalApi/ComposableTask.js","./DetectFaceLandmarksTasks":"node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js","./nets":"node_modules/face-api.js/build/es6/globalApi/nets.js","./PredictAgeAndGenderTask":"node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js","./PredictFaceExpressionsTask":"node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js"}],"node_modules/face-api.js/build/es6/globalApi/detectFaces.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detectSingleFace = detectSingleFace;
exports.detectAllFaces = detectAllFaces;

var _SsdMobilenetv1Options = require("../ssdMobilenetv1/SsdMobilenetv1Options");

var _DetectFacesTasks = require("./DetectFacesTasks");

function detectSingleFace(input, options) {
  if (options === void 0) {
    options = new _SsdMobilenetv1Options.SsdMobilenetv1Options();
  }

  return new _DetectFacesTasks.DetectSingleFaceTask(input, options);
}

function detectAllFaces(input, options) {
  if (options === void 0) {
    options = new _SsdMobilenetv1Options.SsdMobilenetv1Options();
  }

  return new _DetectFacesTasks.DetectAllFacesTask(input, options);
}
},{"../ssdMobilenetv1/SsdMobilenetv1Options":"node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js","./DetectFacesTasks":"node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js"}],"node_modules/face-api.js/build/es6/globalApi/allFaces.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.allFacesSsdMobilenetv1 = allFacesSsdMobilenetv1;
exports.allFacesTinyYolov2 = allFacesTinyYolov2;
exports.allFacesMtcnn = allFacesMtcnn;
exports.allFaces = void 0;

var _tslib = require("tslib");

var _MtcnnOptions = require("../mtcnn/MtcnnOptions");

var _ssdMobilenetv = require("../ssdMobilenetv1");

var _tinyYolov = require("../tinyYolov2");

var _detectFaces = require("./detectFaces");

// export allFaces API for backward compatibility
function allFacesSsdMobilenetv1(input, minConfidence) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    return (0, _tslib.__generator)(this, function (_a) {
      switch (_a.label) {
        case 0:
          console.warn('allFacesSsdMobilenetv1 is deprecated and will be removed soon, use the high level api instead');
          return [4
          /*yield*/
          , (0, _detectFaces.detectAllFaces)(input, new _ssdMobilenetv.SsdMobilenetv1Options(minConfidence ? {
            minConfidence: minConfidence
          } : {})).withFaceLandmarks().withFaceDescriptors()];

        case 1:
          return [2
          /*return*/
          , _a.sent()];
      }
    });
  });
}

function allFacesTinyYolov2(input, forwardParams) {
  if (forwardParams === void 0) {
    forwardParams = {};
  }

  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    return (0, _tslib.__generator)(this, function (_a) {
      switch (_a.label) {
        case 0:
          console.warn('allFacesTinyYolov2 is deprecated and will be removed soon, use the high level api instead');
          return [4
          /*yield*/
          , (0, _detectFaces.detectAllFaces)(input, new _tinyYolov.TinyYolov2Options(forwardParams)).withFaceLandmarks().withFaceDescriptors()];

        case 1:
          return [2
          /*return*/
          , _a.sent()];
      }
    });
  });
}

function allFacesMtcnn(input, forwardParams) {
  if (forwardParams === void 0) {
    forwardParams = {};
  }

  return (0, _tslib.__awaiter)(this, void 0, void 0, function () {
    return (0, _tslib.__generator)(this, function (_a) {
      switch (_a.label) {
        case 0:
          console.warn('allFacesMtcnn is deprecated and will be removed soon, use the high level api instead');
          return [4
          /*yield*/
          , (0, _detectFaces.detectAllFaces)(input, new _MtcnnOptions.MtcnnOptions(forwardParams)).withFaceLandmarks().withFaceDescriptors()];

        case 1:
          return [2
          /*return*/
          , _a.sent()];
      }
    });
  });
}

var allFaces = allFacesSsdMobilenetv1;
exports.allFaces = allFaces;
},{"tslib":"node_modules/tslib/tslib.es6.js","../mtcnn/MtcnnOptions":"node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js","../ssdMobilenetv1":"node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js","../tinyYolov2":"node_modules/face-api.js/build/es6/tinyYolov2/index.js","./detectFaces":"node_modules/face-api.js/build/es6/globalApi/detectFaces.js"}],"node_modules/face-api.js/build/es6/euclideanDistance.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.euclideanDistance = euclideanDistance;

function euclideanDistance(arr1, arr2) {
  if (arr1.length !== arr2.length) throw new Error('euclideanDistance: arr1.length !== arr2.length');
  var desc1 = Array.from(arr1);
  var desc2 = Array.from(arr2);
  return Math.sqrt(desc1.map(function (val, i) {
    return val - desc2[i];
  }).reduce(function (res, diff) {
    return res + Math.pow(diff, 2);
  }, 0));
}
},{}],"node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FaceMatcher = void 0;

var _FaceMatch = require("../classes/FaceMatch");

var _LabeledFaceDescriptors = require("../classes/LabeledFaceDescriptors");

var _euclideanDistance = require("../euclideanDistance");

var FaceMatcher =
/** @class */
function () {
  function FaceMatcher(inputs, distanceThreshold) {
    if (distanceThreshold === void 0) {
      distanceThreshold = 0.6;
    }

    this._distanceThreshold = distanceThreshold;
    var inputArray = Array.isArray(inputs) ? inputs : [inputs];

    if (!inputArray.length) {
      throw new Error("FaceRecognizer.constructor - expected atleast one input");
    }

    var count = 1;

    var createUniqueLabel = function () {
      return "person " + count++;
    };

    this._labeledDescriptors = inputArray.map(function (desc) {
      if (desc instanceof _LabeledFaceDescriptors.LabeledFaceDescriptors) {
        return desc;
      }

      if (desc instanceof Float32Array) {
        return new _LabeledFaceDescriptors.LabeledFaceDescriptors(createUniqueLabel(), [desc]);
      }

      if (desc.descriptor && desc.descriptor instanceof Float32Array) {
        return new _LabeledFaceDescriptors.LabeledFaceDescriptors(createUniqueLabel(), [desc.descriptor]);
      }

      throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>");
    });
  }

  Object.defineProperty(FaceMatcher.prototype, "labeledDescriptors", {
    get: function () {
      return this._labeledDescriptors;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FaceMatcher.prototype, "distanceThreshold", {
    get: function () {
      return this._distanceThreshold;
    },
    enumerable: true,
    configurable: true
  });

  FaceMatcher.prototype.computeMeanDistance = function (queryDescriptor, descriptors) {
    return descriptors.map(function (d) {
      return (0, _euclideanDistance.euclideanDistance)(d, queryDescriptor);
    }).reduce(function (d1, d2) {
      return d1 + d2;
    }, 0) / (descriptors.length || 1);
  };

  FaceMatcher.prototype.matchDescriptor = function (queryDescriptor) {
    var _this = this;

    return this.labeledDescriptors.map(function (_a) {
      var descriptors = _a.descriptors,
          label = _a.label;
      return new _FaceMatch.FaceMatch(label, _this.computeMeanDistance(queryDescriptor, descriptors));
    }).reduce(function (best, curr) {
      return best.distance < curr.distance ? best : curr;
    });
  };

  FaceMatcher.prototype.findBestMatch = function (queryDescriptor) {
    var bestMatch = this.matchDescriptor(queryDescriptor);
    return bestMatch.distance < this.distanceThreshold ? bestMatch : new _FaceMatch.FaceMatch('unknown', bestMatch.distance);
  };

  FaceMatcher.prototype.toJSON = function () {
    return {
      distanceThreshold: this.distanceThreshold,
      labeledDescriptors: this.labeledDescriptors.map(function (ld) {
        return ld.toJSON();
      })
    };
  };

  FaceMatcher.fromJSON = function (json) {
    var labeledDescriptors = json.labeledDescriptors.map(function (ld) {
      return _LabeledFaceDescriptors.LabeledFaceDescriptors.fromJSON(ld);
    });
    return new FaceMatcher(labeledDescriptors, json.distanceThreshold);
  };

  return FaceMatcher;
}();

exports.FaceMatcher = FaceMatcher;
},{"../classes/FaceMatch":"node_modules/face-api.js/build/es6/classes/FaceMatch.js","../classes/LabeledFaceDescriptors":"node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js","../euclideanDistance":"node_modules/face-api.js/build/es6/euclideanDistance.js"}],"node_modules/face-api.js/build/es6/globalApi/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _allFaces = require("./allFaces");

Object.keys(_allFaces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _allFaces[key];
    }
  });
});

var _ComposableTask = require("./ComposableTask");

Object.keys(_ComposableTask).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ComposableTask[key];
    }
  });
});

var _ComputeFaceDescriptorsTasks = require("./ComputeFaceDescriptorsTasks");

Object.keys(_ComputeFaceDescriptorsTasks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ComputeFaceDescriptorsTasks[key];
    }
  });
});

var _detectFaces = require("./detectFaces");

Object.keys(_detectFaces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _detectFaces[key];
    }
  });
});

var _DetectFacesTasks = require("./DetectFacesTasks");

Object.keys(_DetectFacesTasks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _DetectFacesTasks[key];
    }
  });
});

var _DetectFaceLandmarksTasks = require("./DetectFaceLandmarksTasks");

Object.keys(_DetectFaceLandmarksTasks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _DetectFaceLandmarksTasks[key];
    }
  });
});

var _FaceMatcher = require("./FaceMatcher");

Object.keys(_FaceMatcher).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FaceMatcher[key];
    }
  });
});

var _nets = require("./nets");

Object.keys(_nets).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nets[key];
    }
  });
});
},{"./allFaces":"node_modules/face-api.js/build/es6/globalApi/allFaces.js","./ComposableTask":"node_modules/face-api.js/build/es6/globalApi/ComposableTask.js","./ComputeFaceDescriptorsTasks":"node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js","./detectFaces":"node_modules/face-api.js/build/es6/globalApi/detectFaces.js","./DetectFacesTasks":"node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js","./DetectFaceLandmarksTasks":"node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js","./FaceMatcher":"node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js","./nets":"node_modules/face-api.js/build/es6/globalApi/nets.js"}],"node_modules/face-api.js/build/es6/mtcnn/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createMtcnn: true
};
exports.createMtcnn = createMtcnn;

var _Mtcnn = require("./Mtcnn");

Object.keys(_Mtcnn).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Mtcnn[key];
    }
  });
});

var _MtcnnOptions = require("./MtcnnOptions");

Object.keys(_MtcnnOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _MtcnnOptions[key];
    }
  });
});

function createMtcnn(weights) {
  var net = new _Mtcnn.Mtcnn();
  net.extractWeights(weights);
  return net;
}
},{"./Mtcnn":"node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js","./MtcnnOptions":"node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js"}],"node_modules/face-api.js/build/es6/tinyFaceDetector/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createTinyFaceDetector: true
};
exports.createTinyFaceDetector = createTinyFaceDetector;

var _TinyFaceDetector = require("./TinyFaceDetector");

Object.keys(_TinyFaceDetector).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TinyFaceDetector[key];
    }
  });
});

var _TinyFaceDetectorOptions = require("./TinyFaceDetectorOptions");

Object.keys(_TinyFaceDetectorOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TinyFaceDetectorOptions[key];
    }
  });
});

function createTinyFaceDetector(weights) {
  var net = new _TinyFaceDetector.TinyFaceDetector();
  net.extractWeights(weights);
  return net;
}
},{"./TinyFaceDetector":"node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js","./TinyFaceDetectorOptions":"node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js"}],"node_modules/face-api.js/build/es6/resizeResults.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resizeResults = resizeResults;

var _classes = require("./classes");

var _FaceDetection = require("./classes/FaceDetection");

var _FaceLandmarks = require("./classes/FaceLandmarks");

var _WithFaceDetection = require("./factories/WithFaceDetection");

var _WithFaceLandmarks = require("./factories/WithFaceLandmarks");

function resizeResults(results, dimensions) {
  var _a = new _classes.Dimensions(dimensions.width, dimensions.height),
      width = _a.width,
      height = _a.height;

  if (width <= 0 || height <= 0) {
    throw new Error("resizeResults - invalid dimensions: " + JSON.stringify({
      width: width,
      height: height
    }));
  }

  if (Array.isArray(results)) {
    return results.map(function (obj) {
      return resizeResults(obj, {
        width: width,
        height: height
      });
    });
  }

  if ((0, _WithFaceLandmarks.isWithFaceLandmarks)(results)) {
    var resizedDetection = results.detection.forSize(width, height);
    var resizedLandmarks = results.unshiftedLandmarks.forSize(resizedDetection.box.width, resizedDetection.box.height);
    return (0, _WithFaceLandmarks.extendWithFaceLandmarks)((0, _WithFaceDetection.extendWithFaceDetection)(results, resizedDetection), resizedLandmarks);
  }

  if ((0, _WithFaceDetection.isWithFaceDetection)(results)) {
    return (0, _WithFaceDetection.extendWithFaceDetection)(results, results.detection.forSize(width, height));
  }

  if (results instanceof _FaceLandmarks.FaceLandmarks || results instanceof _FaceDetection.FaceDetection) {
    return results.forSize(width, height);
  }

  return results;
}
},{"./classes":"node_modules/face-api.js/build/es6/classes/index.js","./classes/FaceDetection":"node_modules/face-api.js/build/es6/classes/FaceDetection.js","./classes/FaceLandmarks":"node_modules/face-api.js/build/es6/classes/FaceLandmarks.js","./factories/WithFaceDetection":"node_modules/face-api.js/build/es6/factories/WithFaceDetection.js","./factories/WithFaceLandmarks":"node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js"}],"node_modules/face-api.js/build/es6/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  tf: true,
  draw: true,
  utils: true
};
exports.utils = exports.draw = exports.tf = void 0;

var tf = _interopRequireWildcard(require("@tensorflow/tfjs-core"));

exports.tf = tf;

var draw = _interopRequireWildcard(require("./draw"));

exports.draw = draw;

var utils = _interopRequireWildcard(require("./utils"));

exports.utils = utils;

var _index = require("./ageGenderNet/index");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});

var _index2 = require("./classes/index");

Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index2[key];
    }
  });
});

var _index3 = require("./dom/index");

Object.keys(_index3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index3[key];
    }
  });
});

var _index4 = require("./env/index");

Object.keys(_index4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index4[key];
    }
  });
});

var _index5 = require("./faceExpressionNet/index");

Object.keys(_index5).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index5[key];
    }
  });
});

var _index6 = require("./faceLandmarkNet/index");

Object.keys(_index6).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index6[key];
    }
  });
});

var _index7 = require("./faceRecognitionNet/index");

Object.keys(_index7).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index7[key];
    }
  });
});

var _index8 = require("./factories/index");

Object.keys(_index8).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index8[key];
    }
  });
});

var _index9 = require("./globalApi/index");

Object.keys(_index9).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index9[key];
    }
  });
});

var _index10 = require("./mtcnn/index");

Object.keys(_index10).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index10[key];
    }
  });
});

var _index11 = require("./ops/index");

Object.keys(_index11).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index11[key];
    }
  });
});

var _index12 = require("./ssdMobilenetv1/index");

Object.keys(_index12).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index12[key];
    }
  });
});

var _index13 = require("./tinyFaceDetector/index");

Object.keys(_index13).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index13[key];
    }
  });
});

var _index14 = require("./tinyYolov2/index");

Object.keys(_index14).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index14[key];
    }
  });
});

var _euclideanDistance = require("./euclideanDistance");

Object.keys(_euclideanDistance).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _euclideanDistance[key];
    }
  });
});

var _NeuralNetwork = require("./NeuralNetwork");

Object.keys(_NeuralNetwork).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _NeuralNetwork[key];
    }
  });
});

var _resizeResults = require("./resizeResults");

Object.keys(_resizeResults).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _resizeResults[key];
    }
  });
});

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"@tensorflow/tfjs-core":"node_modules/face-api.js/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js","./draw":"node_modules/face-api.js/build/es6/draw/index.js","./utils":"node_modules/face-api.js/build/es6/utils/index.js","./ageGenderNet/index":"node_modules/face-api.js/build/es6/ageGenderNet/index.js","./classes/index":"node_modules/face-api.js/build/es6/classes/index.js","./dom/index":"node_modules/face-api.js/build/es6/dom/index.js","./env/index":"node_modules/face-api.js/build/es6/env/index.js","./faceExpressionNet/index":"node_modules/face-api.js/build/es6/faceExpressionNet/index.js","./faceLandmarkNet/index":"node_modules/face-api.js/build/es6/faceLandmarkNet/index.js","./faceRecognitionNet/index":"node_modules/face-api.js/build/es6/faceRecognitionNet/index.js","./factories/index":"node_modules/face-api.js/build/es6/factories/index.js","./globalApi/index":"node_modules/face-api.js/build/es6/globalApi/index.js","./mtcnn/index":"node_modules/face-api.js/build/es6/mtcnn/index.js","./ops/index":"node_modules/face-api.js/build/es6/ops/index.js","./ssdMobilenetv1/index":"node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js","./tinyFaceDetector/index":"node_modules/face-api.js/build/es6/tinyFaceDetector/index.js","./tinyYolov2/index":"node_modules/face-api.js/build/es6/tinyYolov2/index.js","./euclideanDistance":"node_modules/face-api.js/build/es6/euclideanDistance.js","./NeuralNetwork":"node_modules/face-api.js/build/es6/NeuralNetwork.js","./resizeResults":"node_modules/face-api.js/build/es6/resizeResults.js"}],"utils/gameUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.insertInputText = insertInputText;
exports.nextImage = nextImage;
exports.readSetGo = exports.makeLetters = exports.clearLetters = exports.readJson = exports.imageVisitied = exports.getImage = exports.loaded = exports.userAnswer = exports.answer = exports.levelData = exports.lst = void 0;

var _camera = require("../camera.js");

// import {Machine, interpret, assign} from "xstate";
// import {stateMachine} from '../stateMachine.js';
// contains all used images
var lst = []; // stores levelJson data

exports.lst = lst;
var levelData; // export let service;

exports.levelData = levelData;
var answer;
exports.answer = answer;
var userAnswer;
exports.userAnswer = userAnswer;
var counter = 0;
var loaded = false;
exports.loaded = loaded;

function compareStrings(letter, id) {
  console.log('Comparing');

  if (answer.charAt(id) == letter) {
    document.getElementById("text_box" + id).style.backgroundColor = "green";
    ++counter;
  } else {
    document.getElementById("text_box" + id).style.backgroundColor = "red";
  }

  if (counter == 3) {
    clearLetters();
    nextImage();
  }
}

function insertInputText(label) {
  console.log("text_box" + counter);
  console.log(label);
  document.getElementById("text_box" + counter).value = label;
  compareStrings(document.getElementById("text_box" + counter).value, counter); //Comment this to input text by hand and not through model
} // getRandom image without repetition


var getImage = function getImage() {
  do {
    var x = Math.floor(Math.random() * 11);
  } while (lst.indexOf(String(x)) != -1);

  return x;
}; // pushes used images to list


exports.getImage = getImage;

var imageVisitied = function imageVisitied(data) {
  lst.push(String(data));
};

exports.imageVisitied = imageVisitied;

function nextImage() {
  console.log("came to next image function");
  counter = 0;
  var index = getImage();
  imageVisitied(index);
  var image = levelData[index];
  var url = './images/' + image; //Grabs name of file as answer:    

  console.log(image.slice(0, image.indexOf(".")));
  exports.answer = answer = image.slice(0, image.indexOf(".")).toUpperCase(); // service = interpret(stateMachine).start();
  // service.send("INPUT_CHANGE", {
  //   name: "answer",
  //   value: image.slice(0,image.indexOf("."))      
  // });
  // service = interpret(stateMachine).onTransition(current => {
  //   state=current
  //   console.log(current);
  // });    

  console.log(url);
  document.getElementById("guess_image").src = url;
  makeLetters(3);
  exports.loaded = loaded = true;
} // helper inner function


function passJson(data) {
  exports.levelData = levelData = data;
} // Promise based Json read had to use async-await for async


var readJson = function readJson(url) {
  return new Promise(function (resolve, reject) {
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open("GET", url, true);
    xmlhttp.send();

    xmlhttp.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        var myArr = JSON.parse(this.responseText);
        passJson(myArr);
        resolve();
      }
    };
  });
}; // This two function will generate the text boxes put number in to @data to make that many 
// text boxes 
// Onchange = Updates the new letter from the input


exports.readJson = readJson;

var helperMakeLetter = function helperMakeLetter(id, placeholder) {
  var element = document.createElement("input");
  element.className = "form-control";
  element.placeholder = placeholder;
  element.id = "text_box" + id; //id in letter in put

  element.onchange = function () {
    console.log("New Letter");
    compareStrings(element.value, id); //Text input by hand change if not commented
    // service = interpret(stateMachine).start();
    // service.send("INPUT_CHANGE", {
    //   value: element.target.value,
    //   name: element.target.name
    // });
  };

  return element;
};

var clearLetters = function clearLetters() {
  var list = document.getElementById("word_list");

  while (list.firstChild) {
    list.removeChild(list.lastChild);
  }
};

exports.clearLetters = clearLetters;

var makeLetters = function makeLetters(data) {
  var domElement = "";

  for (var i = 0; i < data; i++) {
    domElement = helperMakeLetter(i, "_");
    document.getElementById("word_list").appendChild(domElement);
  }
};

exports.makeLetters = makeLetters;

var readSetGo = function readSetGo() {
  document.getElementById("start_btn").style.display = "none";
  var ml4 = {};
  ml4.opacityIn = [0, 1];
  ml4.scaleIn = [0.2, 1];
  ml4.scaleOut = 3;
  ml4.durationIn = 800;
  ml4.durationOut = 600;
  ml4.delay = 500;
  anime.timeline({
    loop: false
  }).add({
    targets: '.ml4 .letters-1',
    opacity: ml4.opacityIn,
    scale: ml4.scaleIn,
    duration: ml4.durationIn
  }).add({
    targets: '.ml4 .letters-1',
    opacity: 0,
    scale: ml4.scaleOut,
    duration: ml4.durationOut,
    easing: "easeInExpo",
    delay: ml4.delay
  }).add({
    targets: '.ml4 .letters-2',
    opacity: ml4.opacityIn,
    scale: ml4.scaleIn,
    duration: ml4.durationIn
  }).add({
    targets: '.ml4 .letters-2',
    opacity: 0,
    scale: ml4.scaleOut,
    duration: ml4.durationOut,
    easing: "easeInExpo",
    delay: ml4.delay
  }).add({
    targets: '.ml4 .letters-3',
    opacity: ml4.opacityIn,
    scale: ml4.scaleIn,
    duration: ml4.durationIn
  }).add({
    targets: '.ml4 .letters-3',
    opacity: 0,
    scale: ml4.scaleOut,
    duration: ml4.durationOut,
    easing: "easeInExpo",
    delay: ml4.delay
  }).add({
    targets: '.ml4',
    opacity: 0,
    duration: 500,
    delay: 500
  });
  document.getElementById("right_game_window_h1").innerHTML = "Guess The Word!";
  document.getElementById("right_game_window_p").innerHTML = "Make letters with your arms and legs and guess the word";
  setTimeout(function () {
    nextImage();
    document.getElementById("guess_image").style.visibility = "visible";
    document.getElementById("word1").style.visibility = "visible";
    console.log("starting game"); // loadModel();
  }, 6000);
};

exports.readSetGo = readSetGo;
},{"../camera.js":"camera.js"}],"node_modules/xstate/es/types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpecialTargets = exports.ActionTypes = void 0;
var ActionTypes;
exports.ActionTypes = ActionTypes;

(function (ActionTypes) {
  ActionTypes["Start"] = "xstate.start";
  ActionTypes["Stop"] = "xstate.stop";
  ActionTypes["Raise"] = "xstate.raise";
  ActionTypes["Send"] = "xstate.send";
  ActionTypes["Cancel"] = "xstate.cancel";
  ActionTypes["NullEvent"] = "";
  ActionTypes["Assign"] = "xstate.assign";
  ActionTypes["After"] = "xstate.after";
  ActionTypes["DoneState"] = "done.state";
  ActionTypes["DoneInvoke"] = "done.invoke";
  ActionTypes["Log"] = "xstate.log";
  ActionTypes["Init"] = "xstate.init";
  ActionTypes["Invoke"] = "xstate.invoke";
  ActionTypes["ErrorExecution"] = "error.execution";
  ActionTypes["ErrorCommunication"] = "error.communication";
  ActionTypes["ErrorPlatform"] = "error.platform";
  ActionTypes["Update"] = "xstate.update";
  ActionTypes["Pure"] = "xstate.pure";
})(ActionTypes || (exports.ActionTypes = ActionTypes = {}));

var SpecialTargets;
exports.SpecialTargets = SpecialTargets;

(function (SpecialTargets) {
  SpecialTargets["Parent"] = "#_parent";
  SpecialTargets["Internal"] = "#_internal";
})(SpecialTargets || (exports.SpecialTargets = SpecialTargets = {}));
},{}],"node_modules/xstate/es/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_GUARD_TYPE = exports.EMPTY_ACTIVITY_MAP = exports.STATE_DELIMITER = void 0;
var STATE_DELIMITER = '.';
exports.STATE_DELIMITER = STATE_DELIMITER;
var EMPTY_ACTIVITY_MAP = {};
exports.EMPTY_ACTIVITY_MAP = EMPTY_ACTIVITY_MAP;
var DEFAULT_GUARD_TYPE = 'xstate.guard';
exports.DEFAULT_GUARD_TYPE = DEFAULT_GUARD_TYPE;
},{}],"node_modules/xstate/es/environment.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IS_PRODUCTION = void 0;
var IS_PRODUCTION = "development" === 'production';
exports.IS_PRODUCTION = IS_PRODUCTION;
},{}],"node_modules/xstate/es/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keys = keys;
exports.matchesState = matchesState;
exports.getEventType = getEventType;
exports.getActionType = getActionType;
exports.toStatePath = toStatePath;
exports.toStateValue = toStateValue;
exports.pathToStateValue = pathToStateValue;
exports.mapValues = mapValues;
exports.mapFilterValues = mapFilterValues;
exports.nestedPath = nestedPath;
exports.toStatePaths = toStatePaths;
exports.flatten = flatten;
exports.toArray = toArray;
exports.mapContext = mapContext;
exports.isBuiltInEvent = isBuiltInEvent;
exports.isPromiseLike = isPromiseLike;
exports.partition = partition;
exports.updateHistoryStates = updateHistoryStates;
exports.updateHistoryValue = updateHistoryValue;
exports.updateContext = updateContext;
exports.bindActionToState = bindActionToState;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isString = isString;
exports.toGuard = toGuard;
exports.isObservable = isObservable;
exports.isMachine = isMachine;
exports.uniqueId = exports.warn = exports.pathsToStateValue = exports.path = void 0;

var _types = require("./types");

var _constants = require("./constants");

var _environment = require("./environment");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __values = void 0 && (void 0).__values || function (o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
};

function isState(state) {
  if (isString(state)) {
    return false;
  }

  return 'value' in state && 'tree' in state && 'history' in state;
}

function keys(value) {
  return Object.keys(value);
}

function matchesState(parentStateId, childStateId, delimiter) {
  if (delimiter === void 0) {
    delimiter = _constants.STATE_DELIMITER;
  }

  var parentStateValue = toStateValue(parentStateId, delimiter);
  var childStateValue = toStateValue(childStateId, delimiter);

  if (isString(childStateValue)) {
    if (isString(parentStateValue)) {
      return childStateValue === parentStateValue;
    } // Parent more specific than child


    return false;
  }

  if (isString(parentStateValue)) {
    return parentStateValue in childStateValue;
  }

  return keys(parentStateValue).every(function (key) {
    if (!(key in childStateValue)) {
      return false;
    }

    return matchesState(parentStateValue[key], childStateValue[key]);
  });
}

function getEventType(event) {
  try {
    return isString(event) || typeof event === 'number' ? "" + event : event.type;
  } catch (e) {
    throw new Error('Events must be strings or objects with a string event.type property.');
  }
}

function getActionType(action) {
  try {
    return isString(action) || typeof action === 'number' ? "" + action : isFunction(action) ? action.name : action.type;
  } catch (e) {
    throw new Error('Actions must be strings or objects with a string action.type property.');
  }
}

function toStatePath(stateId, delimiter) {
  try {
    if (isArray(stateId)) {
      return stateId;
    }

    return stateId.toString().split(delimiter);
  } catch (e) {
    throw new Error("'" + stateId + "' is not a valid state path.");
  }
}

function toStateValue(stateValue, delimiter) {
  if (isState(stateValue)) {
    return stateValue.value;
  }

  if (isArray(stateValue)) {
    return pathToStateValue(stateValue);
  }

  if (typeof stateValue !== 'string' && !isState(stateValue)) {
    return stateValue;
  }

  var statePath = toStatePath(stateValue, delimiter);
  return pathToStateValue(statePath);
}

function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0];
  }

  var value = {};
  var marker = value;

  for (var i = 0; i < statePath.length - 1; i++) {
    if (i === statePath.length - 2) {
      marker[statePath[i]] = statePath[i + 1];
    } else {
      marker[statePath[i]] = {};
      marker = marker[statePath[i]];
    }
  }

  return value;
}

function mapValues(collection, iteratee) {
  var result = {};
  var collectionKeys = keys(collection);

  for (var i = 0; i < collectionKeys.length; i++) {
    var key = collectionKeys[i];
    result[key] = iteratee(collection[key], key, collection, i);
  }

  return result;
}

function mapFilterValues(collection, iteratee, predicate) {
  var e_1, _a;

  var result = {};

  try {
    for (var _b = __values(keys(collection)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var item = collection[key];

      if (!predicate(item)) {
        continue;
      }

      result[key] = iteratee(item, key, collection);
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return result;
}
/**
 * Retrieves a value at the given path.
 * @param props The deep path to the prop of the desired value
 */


var path = function (props) {
  return function (object) {
    var e_2, _a;

    var result = object;

    try {
      for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
        var prop = props_1_1.value;
        result = result[prop];
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    return result;
  };
};
/**
 * Retrieves a value at the given path via the nested accessor prop.
 * @param props The deep path to the prop of the desired value
 */


exports.path = path;

function nestedPath(props, accessorProp) {
  return function (object) {
    var e_3, _a;

    var result = object;

    try {
      for (var props_2 = __values(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {
        var prop = props_2_1.value;
        result = result[accessorProp][prop];
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (props_2_1 && !props_2_1.done && (_a = props_2.return)) _a.call(props_2);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    return result;
  };
}

function toStatePaths(stateValue) {
  if (!stateValue) {
    return [[]];
  }

  if (isString(stateValue)) {
    return [[stateValue]];
  }

  var result = flatten(keys(stateValue).map(function (key) {
    var subStateValue = stateValue[key];

    if (typeof subStateValue !== 'string' && (!subStateValue || !Object.keys(subStateValue).length)) {
      return [[key]];
    }

    return toStatePaths(stateValue[key]).map(function (subPath) {
      return [key].concat(subPath);
    });
  }));
  return result;
}

var pathsToStateValue = function (paths) {
  var e_4, _a;

  var result = {};

  if (paths && paths.length === 1 && paths[0].length === 1) {
    return paths[0][0];
  }

  try {
    for (var paths_1 = __values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
      var currentPath = paths_1_1.value;
      var marker = result; // tslint:disable-next-line:prefer-for-of

      for (var i = 0; i < currentPath.length; i++) {
        var subPath = currentPath[i];

        if (i === currentPath.length - 2) {
          marker[subPath] = currentPath[i + 1];
          break;
        }

        marker[subPath] = marker[subPath] || {};
        marker = marker[subPath];
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);
    } finally {
      if (e_4) throw e_4.error;
    }
  }

  return result;
};

exports.pathsToStateValue = pathsToStateValue;

function flatten(array) {
  var _a;

  return (_a = []).concat.apply(_a, __spread(array));
}

function toArray(value) {
  if (isArray(value)) {
    return value;
  }

  if (value === undefined) {
    return [];
  }

  return [value];
}

function mapContext(mapper, context, event) {
  var e_5, _a;

  if (isFunction(mapper)) {
    return mapper(context, event);
  }

  var result = {};

  try {
    for (var _b = __values(keys(mapper)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var subMapper = mapper[key];

      if (isFunction(subMapper)) {
        result[key] = subMapper(context, event);
      } else {
        result[key] = subMapper;
      }
    }
  } catch (e_5_1) {
    e_5 = {
      error: e_5_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_5) throw e_5.error;
    }
  }

  return result;
}

function isBuiltInEvent(eventType) {
  // check if event is a "done" event
  if (eventType.indexOf(_types.ActionTypes.DoneState) === 0 || eventType.indexOf(_types.ActionTypes.DoneInvoke) === 0) {
    return true;
  } // check if event is an "error" event


  if (eventType === _types.ActionTypes.ErrorCommunication || eventType === _types.ActionTypes.ErrorExecution || eventType.indexOf(_types.ActionTypes.ErrorPlatform) === 0) {
    return true;
  }

  return false;
}

function isPromiseLike(value) {
  if (value instanceof Promise) {
    return true;
  } // Check if shape matches the Promise/A+ specification for a "thenable".


  if (value !== null && (isFunction(value) || typeof value === 'object') && isFunction(value.then)) {
    return true;
  }

  return false;
}

function partition(items, predicate) {
  var e_6, _a;

  var _b = __read([[], []], 2),
      truthy = _b[0],
      falsy = _b[1];

  try {
    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var item = items_1_1.value;

      if (predicate(item)) {
        truthy.push(item);
      } else {
        falsy.push(item);
      }
    }
  } catch (e_6_1) {
    e_6 = {
      error: e_6_1
    };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
    } finally {
      if (e_6) throw e_6.error;
    }
  }

  return [truthy, falsy];
}

function updateHistoryStates(hist, stateValue) {
  return mapValues(hist.states, function (subHist, key) {
    if (!subHist) {
      return undefined;
    }

    var subStateValue = (isString(stateValue) ? undefined : stateValue[key]) || (subHist ? subHist.current : undefined);

    if (!subStateValue) {
      return undefined;
    }

    return {
      current: subStateValue,
      states: updateHistoryStates(subHist, subStateValue)
    };
  });
}

function updateHistoryValue(hist, stateValue) {
  return {
    current: stateValue,
    states: updateHistoryStates(hist, stateValue)
  };
}

function updateContext(context, event, assignActions) {
  var updatedContext = context ? assignActions.reduce(function (acc, assignAction) {
    var e_7, _a;

    var assignment = assignAction.assignment;
    var partialUpdate = {};

    if (isFunction(assignment)) {
      partialUpdate = assignment(acc, event || {
        type: _types.ActionTypes.Init
      });
    } else {
      try {
        for (var _b = __values(keys(assignment)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          var propAssignment = assignment[key];
          partialUpdate[key] = isFunction(propAssignment) ? propAssignment(acc, event) : propAssignment;
        }
      } catch (e_7_1) {
        e_7 = {
          error: e_7_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_7) throw e_7.error;
        }
      }
    }

    return Object.assign({}, acc, partialUpdate);
  }, context) : context;
  return updatedContext;
}

function bindActionToState(action, state) {
  var exec = action.exec;

  var boundAction = __assign({}, action, {
    exec: exec !== undefined ? function () {
      return exec(state.context, state.event, {
        action: action,
        state: state
      });
    } : undefined
  });

  return boundAction;
} // tslint:disable-next-line:no-empty


var warn = function () {};

exports.warn = warn;

if (!_environment.IS_PRODUCTION) {
  exports.warn = warn = function (condition, message) {
    var error = condition instanceof Error ? condition : undefined;

    if (!error && condition) {
      return;
    }

    if (console !== undefined) {
      var args = ["Warning: " + message];

      if (error) {
        args.push(error);
      } // tslint:disable-next-line:no-console


      console.warn.apply(console, args);
    }
  };
}

function isArray(value) {
  return Array.isArray(value);
} // tslint:disable-next-line:ban-types


function isFunction(value) {
  return typeof value === 'function';
}

function isString(value) {
  return typeof value === 'string';
} // export function memoizedGetter<T, TP extends { prototype: object }>(
//   o: TP,
//   property: string,
//   getter: () => T
// ): void {
//   Object.defineProperty(o.prototype, property, {
//     get: getter,
//     enumerable: false,
//     configurable: false
//   });
// }


function toGuard(condition, guardMap) {
  if (!condition) {
    return undefined;
  }

  if (isString(condition)) {
    return {
      type: _constants.DEFAULT_GUARD_TYPE,
      name: condition,
      predicate: guardMap ? guardMap[condition] : undefined
    };
  }

  if (isFunction(condition)) {
    return {
      type: _constants.DEFAULT_GUARD_TYPE,
      name: condition.name,
      predicate: condition
    };
  }

  return condition;
}

function isObservable(value) {
  try {
    return 'subscribe' in value && isFunction(value.subscribe);
  } catch (e) {
    return false;
  }
}

function isMachine(value) {
  try {
    return '__xstatenode' in value;
  } catch (e) {
    return false;
  }
}

var uniqueId = /*#__PURE__*/function () {
  var currentId = 0;
  return function () {
    currentId++;
    return currentId.toString(16);
  };
}();

exports.uniqueId = uniqueId;
},{"./types":"node_modules/xstate/es/types.js","./constants":"node_modules/xstate/es/constants.js","./environment":"node_modules/xstate/es/environment.js"}],"node_modules/xstate/es/mapState.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapState = mapState;

var _utils = require("./utils");

var __values = void 0 && (void 0).__values || function (o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
};

function mapState(stateMap, stateId) {
  var e_1, _a;

  var foundStateId;

  try {
    for (var _b = __values((0, _utils.keys)(stateMap)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var mappedStateId = _c.value;

      if ((0, _utils.matchesState)(mappedStateId, stateId) && (!foundStateId || stateId.length > foundStateId.length)) {
        foundStateId = mappedStateId;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return stateMap[foundStateId];
}
},{"./utils":"node_modules/xstate/es/utils.js"}],"node_modules/xstate/es/State.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stateValuesEqual = stateValuesEqual;
exports.State = void 0;

var _types = require("./types");

var _constants = require("./constants");

var _utils = require("./utils");

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
};

function stateValuesEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a === undefined || b === undefined) {
    return false;
  }

  if ((0, _utils.isString)(a) || (0, _utils.isString)(b)) {
    return a === b;
  }

  var aKeys = (0, _utils.keys)(a);
  var bKeys = (0, _utils.keys)(b);
  return aKeys.length === bKeys.length && aKeys.every(function (key) {
    return stateValuesEqual(a[key], b[key]);
  });
}

var State =
/** @class */

/*#__PURE__*/
function () {
  /**
   * Creates a new State instance.
   * @param value The state value
   * @param context The extended state
   * @param historyValue The tree representing historical values of the state nodes
   * @param history The previous state
   * @param actions An array of action objects to execute as side-effects
   * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).
   * @param meta
   * @param events Internal event queue. Should be empty with run-to-completion semantics.
   * @param tree
   */
  function State(config) {
    this.actions = [];
    this.activities = _constants.EMPTY_ACTIVITY_MAP;
    this.meta = {};
    this.events = [];
    this.value = config.value;
    this.context = config.context;
    this.event = config.event;
    this.historyValue = config.historyValue;
    this.history = config.history;
    this.actions = config.actions || [];
    this.activities = config.activities || _constants.EMPTY_ACTIVITY_MAP;
    this.meta = config.meta || {};
    this.events = config.events || [];
    Object.defineProperty(this, 'tree', {
      value: config.tree,
      enumerable: false
    });
    this.matches = this.matches.bind(this);
    this.toStrings = this.toStrings.bind(this);
  }
  /**
   * Creates a new State instance for the given `stateValue` and `context`.
   * @param stateValue
   * @param context
   */


  State.from = function (stateValue, context) {
    if (stateValue instanceof State) {
      if (stateValue.context !== context) {
        return new State({
          value: stateValue.value,
          context: context,
          event: stateValue.event,
          historyValue: stateValue.historyValue,
          history: stateValue.history,
          actions: [],
          activities: stateValue.activities,
          meta: {},
          events: [],
          tree: stateValue.tree
        });
      }

      return stateValue;
    }

    var event = {
      type: _types.ActionTypes.Init
    };
    return new State({
      value: stateValue,
      context: context,
      event: event,
      historyValue: undefined,
      history: undefined,
      actions: [],
      activities: undefined,
      meta: undefined,
      events: []
    });
  };
  /**
   * Creates a new State instance for the given `config`.
   * @param config The state config
   */


  State.create = function (config) {
    return new State(config);
  };
  /**
   * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).
   * @param stateValue
   * @param context
   */


  State.inert = function (stateValue, context) {
    if (stateValue instanceof State) {
      if (!stateValue.actions.length) {
        return stateValue;
      }

      var event_1 = {
        type: _types.ActionTypes.Init
      };
      return new State({
        value: stateValue.value,
        context: context,
        event: event_1,
        historyValue: stateValue.historyValue,
        history: stateValue.history,
        activities: stateValue.activities,
        tree: stateValue.tree
      });
    }

    return State.from(stateValue, context);
  };

  Object.defineProperty(State.prototype, "inert", {
    /**
     * Returns a new `State` instance that is equal to this state no actions (side-effects).
     */
    get: function () {
      return State.inert(this, this.context);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(State.prototype, "nextEvents", {
    /**
     * The next events that will cause a transition from the current state.
     */
    get: function () {
      if (!this.tree) {
        return [];
      }

      return this.tree.nextEvents;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns an array of all the string leaf state node paths.
   * @param stateValue
   * @param delimiter The character(s) that separate each subpath in the string state node path.
   */

  State.prototype.toStrings = function (stateValue, delimiter) {
    var _this = this;

    if (stateValue === void 0) {
      stateValue = this.value;
    }

    if (delimiter === void 0) {
      delimiter = '.';
    }

    if ((0, _utils.isString)(stateValue)) {
      return [stateValue];
    }

    var valueKeys = (0, _utils.keys)(stateValue);
    return valueKeys.concat.apply(valueKeys, __spread(valueKeys.map(function (key) {
      return _this.toStrings(stateValue[key]).map(function (s) {
        return key + delimiter + s;
      });
    })));
  };
  /**
   * Whether the current state value is a subset of the given parent state value.
   * @param parentStateValue
   */


  State.prototype.matches = function (parentStateValue) {
    return (0, _utils.matchesState)(parentStateValue, this.value);
  };

  return State;
}();

exports.State = State;
},{"./types":"node_modules/xstate/es/types.js","./constants":"node_modules/xstate/es/constants.js","./utils":"node_modules/xstate/es/utils.js"}],"node_modules/xstate/es/actionTypes.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.update = exports.errorPlatform = exports.errorExecution = exports.invoke = exports.init = exports.log = exports.doneState = exports.after = exports.assign = exports.nullEvent = exports.cancel = exports.send = exports.raise = exports.stop = exports.start = void 0;

var _types = require("./types");

// xstate-specific action types
var start = _types.ActionTypes.Start;
exports.start = start;
var stop = _types.ActionTypes.Stop;
exports.stop = stop;
var raise = _types.ActionTypes.Raise;
exports.raise = raise;
var send = _types.ActionTypes.Send;
exports.send = send;
var cancel = _types.ActionTypes.Cancel;
exports.cancel = cancel;
var nullEvent = _types.ActionTypes.NullEvent;
exports.nullEvent = nullEvent;
var assign = _types.ActionTypes.Assign;
exports.assign = assign;
var after = _types.ActionTypes.After;
exports.after = after;
var doneState = _types.ActionTypes.DoneState;
exports.doneState = doneState;
var log = _types.ActionTypes.Log;
exports.log = log;
var init = _types.ActionTypes.Init;
exports.init = init;
var invoke = _types.ActionTypes.Invoke;
exports.invoke = invoke;
var errorExecution = _types.ActionTypes.ErrorExecution;
exports.errorExecution = errorExecution;
var errorPlatform = _types.ActionTypes.ErrorPlatform;
exports.errorPlatform = errorPlatform;
var update = _types.ActionTypes.Update;
exports.update = update;
},{"./types":"node_modules/xstate/es/types.js"}],"node_modules/xstate/es/actions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toEventObject = toEventObject;
exports.getActionFunction = getActionFunction;
exports.toActionObject = toActionObject;
exports.toActivityDefinition = toActivityDefinition;
exports.raise = raise;
exports.send = send;
exports.resolveSend = resolveSend;
exports.sendParent = sendParent;
exports.log = log;
exports.start = start;
exports.stop = stop;
exports.isActionObject = isActionObject;
exports.after = after;
exports.done = done;
exports.doneInvoke = doneInvoke;
exports.error = error;
exports.pure = pure;
exports.actionTypes = exports.assign = exports.cancel = exports.toActionObjects = exports.initEvent = void 0;

var _types = require("./types");

var actionTypes = _interopRequireWildcard(require("./actionTypes"));

exports.actionTypes = actionTypes;

var _utils = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  return t;
};

var initEvent = {
  type: actionTypes.init
};
exports.initEvent = initEvent;

function toEventObject(event, payload // id?: TEvent['type']
) {
  if ((0, _utils.isString)(event) || typeof event === 'number') {
    var eventObject = {
      type: event
    };

    if (payload) {
      Object.assign(eventObject, payload);
    }

    return eventObject;
  }

  return event;
}

function getActionFunction(actionType, actionFunctionMap) {
  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;
}

function toActionObject(action, actionFunctionMap) {
  var actionObject;

  if ((0, _utils.isString)(action) || typeof action === 'number') {
    var exec = getActionFunction(action, actionFunctionMap);

    if ((0, _utils.isFunction)(exec)) {
      actionObject = {
        type: action,
        exec: exec
      };
    } else if (exec) {
      actionObject = exec;
    } else {
      actionObject = {
        type: action,
        exec: undefined
      };
    }
  } else if ((0, _utils.isFunction)(action)) {
    actionObject = {
      // Convert action to string if unnamed
      type: action.name || action.toString(),
      exec: action
    };
  } else {
    var exec = getActionFunction(action.type, actionFunctionMap);

    if ((0, _utils.isFunction)(exec)) {
      actionObject = __assign({}, action, {
        exec: exec
      });
    } else if (exec) {
      var type = action.type,
          other = __rest(action, ["type"]);

      actionObject = __assign({
        type: type
      }, exec, other);
    } else {
      actionObject = action;
    }
  }

  Object.defineProperty(actionObject, 'toString', {
    value: function () {
      return actionObject.type;
    },
    enumerable: false,
    configurable: true
  });
  return actionObject;
}

var toActionObjects = function (action, actionFunctionMap) {
  if (!action) {
    return [];
  }

  var actions = (0, _utils.isArray)(action) ? action : [action];
  return actions.map(function (subAction) {
    return toActionObject(subAction, actionFunctionMap);
  });
};

exports.toActionObjects = toActionObjects;

function toActivityDefinition(action) {
  var actionObject = toActionObject(action);
  return __assign({
    id: (0, _utils.isString)(action) ? action : actionObject.id
  }, actionObject, {
    type: actionObject.type
  });
}
/**
 * Raises an event. This places the event in the internal event queue, so that
 * the event is immediately consumed by the machine in the current step.
 *
 * @param eventType The event to raise.
 */


function raise(event) {
  return {
    type: actionTypes.raise,
    event: event
  };
}
/**
 * Sends an event. This returns an action that will be read by an interpreter to
 * send the event in the next step, after the current step is finished executing.
 *
 * @param event The event to send.
 * @param options Options to pass into the send event:
 *  - `id` - The unique send event identifier (used with `cancel()`).
 *  - `delay` - The number of milliseconds to delay the sending of the event.
 *  - `target` - The target of this event (by default, the machine the event was sent from).
 */


function send(event, options) {
  return {
    to: options ? options.to : undefined,
    type: actionTypes.send,
    event: (0, _utils.isFunction)(event) ? event : toEventObject(event),
    delay: options ? options.delay : undefined,
    id: options && options.id !== undefined ? options.id : (0, _utils.isFunction)(event) ? event.name : (0, _utils.getEventType)(event)
  };
}

function resolveSend(action, ctx, event) {
  // TODO: helper function for resolving Expr
  var resolvedEvent = (0, _utils.isFunction)(action.event) ? toEventObject(action.event(ctx, event)) : toEventObject(action.event);
  var resolvedDelay = (0, _utils.isFunction)(action.delay) ? action.delay(ctx, event) : action.delay;
  var resolvedTarget = (0, _utils.isFunction)(action.to) ? action.to(ctx, event) : action.to;
  return __assign({}, action, {
    to: resolvedTarget,
    event: resolvedEvent,
    delay: resolvedDelay
  });
}
/**
 * Sends an event to this machine's parent machine.
 *
 * @param event The event to send to the parent machine.
 * @param options Options to pass into the send event.
 */


function sendParent(event, options) {
  return send(event, __assign({}, options, {
    to: _types.SpecialTargets.Parent
  }));
}
/**
 *
 * @param expr The expression function to evaluate which will be logged.
 *  Takes in 2 arguments:
 *  - `ctx` - the current state context
 *  - `event` - the event that caused this action to be executed.
 * @param label The label to give to the logged expression.
 */


function log(expr, label) {
  if (expr === void 0) {
    expr = function (context, event) {
      return {
        context: context,
        event: event
      };
    };
  }

  return {
    type: actionTypes.log,
    label: label,
    expr: expr
  };
}
/**
 * Cancels an in-flight `send(...)` action. A canceled sent action will not
 * be executed, nor will its event be sent, unless it has already been sent
 * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
 *
 * @param sendId The `id` of the `send(...)` action to cancel.
 */


var cancel = function (sendId) {
  return {
    type: actionTypes.cancel,
    sendId: sendId
  };
};
/**
 * Starts an activity.
 *
 * @param activity The activity to start.
 */


exports.cancel = cancel;

function start(activity) {
  var activityDef = toActivityDefinition(activity);
  return {
    type: _types.ActionTypes.Start,
    activity: activityDef,
    exec: undefined
  };
}
/**
 * Stops an activity.
 *
 * @param activity The activity to stop.
 */


function stop(activity) {
  var activityDef = toActivityDefinition(activity);
  return {
    type: _types.ActionTypes.Stop,
    activity: activityDef,
    exec: undefined
  };
}
/**
 * Updates the current context of the machine.
 *
 * @param assignment An object that represents the partial context to update.
 */


var assign = function (assignment) {
  return {
    type: actionTypes.assign,
    assignment: assignment
  };
};

exports.assign = assign;

function isActionObject(action) {
  return typeof action === 'object' && 'type' in action;
}
/**
 * Returns an event type that represents an implicit event that
 * is sent after the specified `delay`.
 *
 * @param delayRef The delay in milliseconds
 * @param id The state node ID where this event is handled
 */


function after(delayRef, id) {
  var idSuffix = id ? "#" + id : '';
  return _types.ActionTypes.After + "(" + delayRef + ")" + idSuffix;
}
/**
 * Returns an event that represents that a final state node
 * has been reached in the parent state node.
 *
 * @param id The final state node's parent state node `id`
 * @param data The data to pass into the event
 */


function done(id, data) {
  var type = _types.ActionTypes.DoneState + "." + id;
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}
/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state node,
 * but not when it is canceled.
 *
 * @param id The final state node ID
 * @param data The data to pass into the event
 */


function doneInvoke(id, data) {
  var type = _types.ActionTypes.DoneInvoke + "." + id;
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}

function error(id, data) {
  var type = _types.ActionTypes.ErrorPlatform + "." + id;
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}

function pure(getActions) {
  return {
    type: _types.ActionTypes.Pure,
    get: getActions
  };
}
},{"./types":"node_modules/xstate/es/types.js","./actionTypes":"node_modules/xstate/es/actionTypes.js","./utils":"node_modules/xstate/es/utils.js"}],"node_modules/xstate/es/StateTree.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StateTree = void 0;

var _utils = require("./utils");

var _actions = require("./actions");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
};

var __values = void 0 && (void 0).__values || function (o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
};

var defaultStateTreeOptions = {
  resolved: false
};

var StateTree =
/** @class */

/*#__PURE__*/
function () {
  function StateTree(stateNode, stateValue, options, parent) {
    var _this = this;

    var _a;

    if (options === void 0) {
      options = defaultStateTreeOptions;
    }

    this.stateNode = stateNode;
    this.stateValue = stateValue;
    this.parent = parent;
    this.reentryNodes = new Set();
    this.root = this.parent ? this.parent.root : this;
    this.nodes = stateValue ? (0, _utils.isString)(stateValue) ? (_a = {}, _a[stateValue] = new StateTree(stateNode.getStateNode(stateValue), undefined, undefined, this), _a) : (0, _utils.mapValues)(stateValue, function (subValue, key) {
      return new StateTree(stateNode.getStateNode(key), subValue, undefined, _this);
    }) : {};

    var resolvedOptions = __assign({}, defaultStateTreeOptions, options);

    this.isResolved = resolvedOptions.resolved;
  }

  Object.defineProperty(StateTree.prototype, "done", {
    get: function () {
      var _this = this;

      switch (this.stateNode.type) {
        case 'final':
          return true;

        case 'compound':
          var childTree = this.nodes[(0, _utils.keys)(this.nodes)[0]];
          return childTree.stateNode.type === 'final';

        case 'parallel':
          return (0, _utils.keys)(this.nodes).every(function (key) {
            return _this.nodes[key].done;
          });

        default:
          return false;
      }
    },
    enumerable: true,
    configurable: true
  });

  StateTree.prototype.getDoneData = function (context, event) {
    if (!this.done) {
      return undefined;
    }

    if (this.stateNode.type === 'compound') {
      var childTree = this.nodes[(0, _utils.keys)(this.nodes)[0]];

      if (!childTree.stateNode.data) {
        return undefined;
      }

      return (0, _utils.mapContext)(childTree.stateNode.data, context, event);
    }

    return undefined;
  };

  Object.defineProperty(StateTree.prototype, "atomicNodes", {
    get: function () {
      var _this = this;

      if (this.stateNode.type === 'atomic' || this.stateNode.type === 'final') {
        return [this.stateNode];
      }

      return (0, _utils.flatten)((0, _utils.keys)(this.value).map(function (key) {
        return _this.value[key].atomicNodes;
      }));
    },
    enumerable: true,
    configurable: true
  });

  StateTree.prototype.getDoneEvents = function (entryStateNodes) {
    var _this = this; // If no state nodes are being entered, no done events will be fired


    if (!entryStateNodes || !entryStateNodes.size) {
      return [];
    }

    if (entryStateNodes.has(this.stateNode) && this.stateNode.type === 'final') {
      return [(0, _actions.done)(this.stateNode.id, this.stateNode.data)];
    }

    var childDoneEvents = (0, _utils.flatten)((0, _utils.keys)(this.nodes).map(function (key) {
      return _this.nodes[key].getDoneEvents(entryStateNodes);
    }));

    if (this.stateNode.type === 'parallel') {
      var allChildrenDone = (0, _utils.keys)(this.nodes).every(function (key) {
        return _this.nodes[key].done;
      });

      if (childDoneEvents && allChildrenDone) {
        return childDoneEvents.concat((0, _actions.done)(this.stateNode.id));
      } else {
        return childDoneEvents;
      }
    }

    if (!this.done || !childDoneEvents.length) {
      return childDoneEvents;
    } // TODO: handle merging strategy
    // For compound state nodes with final child state, there should be only
    // one done.state event (potentially with data).


    var doneData = childDoneEvents.length === 1 ? childDoneEvents[0].data : undefined;
    return childDoneEvents.concat((0, _actions.done)(this.stateNode.id, doneData));
  };

  Object.defineProperty(StateTree.prototype, "resolved", {
    get: function () {
      var newStateTree = new StateTree(this.stateNode, this.stateNode.resolve(this.value), {
        resolved: true
      });
      newStateTree.reentryNodes = this.reentryNodes;
      return newStateTree;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateTree.prototype, "paths", {
    get: function () {
      return (0, _utils.toStatePaths)(this.value);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateTree.prototype, "absolute", {
    get: function () {
      var _stateValue = this.stateValue;
      var absoluteStateValue = {};
      var marker = absoluteStateValue;

      for (var i = 0; i < this.stateNode.path.length; i++) {
        var key = this.stateNode.path[i];

        if (i === this.stateNode.path.length - 1) {
          marker[key] = _stateValue;
        } else {
          marker[key] = {};
          marker = marker[key];
        }
      }

      var newStateTree = new StateTree(this.stateNode.machine, absoluteStateValue);
      newStateTree.reentryNodes = this.reentryNodes;
      return newStateTree;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateTree.prototype, "nextEvents", {
    get: function () {
      var _this = this;

      var ownEvents = this.stateNode.ownEvents;
      var childEvents = (0, _utils.flatten)((0, _utils.keys)(this.nodes).map(function (key) {
        var subTree = _this.nodes[key];
        return subTree.nextEvents;
      }));
      return __spread(new Set(childEvents.concat(ownEvents)));
    },
    enumerable: true,
    configurable: true
  });

  StateTree.prototype.clone = function () {
    var newStateTree = new StateTree(this.stateNode, this.value, undefined, this.parent);
    return newStateTree;
  };

  StateTree.prototype.combine = function (tree) {
    var _a, e_1, _b;

    if (tree.stateNode !== this.stateNode) {
      throw new Error('Cannot combine distinct trees');
    }

    var newTree = this.clone();
    tree.root.reentryNodes.forEach(function (reentryNode) {
      newTree.root.addReentryNode(reentryNode);
    });

    if (this.stateNode.type === 'compound') {
      // Only combine if no child state is defined
      var newValue = void 0;

      if (!(0, _utils.keys)(this.nodes).length || !(0, _utils.keys)(tree.nodes).length) {
        newValue = Object.assign({}, this.nodes, tree.nodes);
        newTree.nodes = newValue;
        return newTree;
      } else {
        var childKey = (0, _utils.keys)(this.nodes)[0];
        newValue = (_a = {}, _a[childKey] = this.nodes[childKey].combine(tree.nodes[childKey]), _a);
        newTree.nodes = newValue;
        return newTree;
      }
    }

    if (this.stateNode.type === 'parallel') {
      var valueKeys = new Set(__spread((0, _utils.keys)(this.nodes), (0, _utils.keys)(tree.nodes)));
      var newValue = {};

      try {
        for (var valueKeys_1 = __values(valueKeys), valueKeys_1_1 = valueKeys_1.next(); !valueKeys_1_1.done; valueKeys_1_1 = valueKeys_1.next()) {
          var key = valueKeys_1_1.value;

          if (!this.nodes[key] || !tree.nodes[key]) {
            newValue[key] = this.nodes[key] || tree.nodes[key];
          } else {
            newValue[key] = this.nodes[key].combine(tree.nodes[key]);
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (valueKeys_1_1 && !valueKeys_1_1.done && (_b = valueKeys_1.return)) _b.call(valueKeys_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      newTree.nodes = newValue;
      return newTree;
    } // nothing to do


    return this;
  };

  Object.defineProperty(StateTree.prototype, "value", {
    get: function () {
      if (this.stateNode.type === 'atomic' || this.stateNode.type === 'final') {
        return {};
      }

      if (this.stateNode.type === 'parallel') {
        return (0, _utils.mapValues)(this.nodes, function (st) {
          return st.value;
        });
      }

      if (this.stateNode.type === 'compound') {
        if ((0, _utils.keys)(this.nodes).length === 0) {
          return {};
        }

        var childStateNode = this.nodes[(0, _utils.keys)(this.nodes)[0]].stateNode;

        if (childStateNode.type === 'atomic' || childStateNode.type === 'final') {
          return childStateNode.key;
        }

        return (0, _utils.mapValues)(this.nodes, function (st) {
          return st.value;
        });
      }

      return {};
    },
    enumerable: true,
    configurable: true
  });

  StateTree.prototype.matches = function (parentValue) {
    return (0, _utils.matchesState)(parentValue, this.value);
  };

  StateTree.prototype.getEntryExitStates = function (prevTree) {
    var _this = this;

    var e_2, _a;

    var externalNodes = this.root.reentryNodes;

    if (!prevTree) {
      // Initial state
      return {
        exit: [],
        entry: __spread(externalNodes)
      };
    }

    if (prevTree.stateNode !== this.stateNode) {
      throw new Error('Cannot compare distinct trees');
    }

    switch (this.stateNode.type) {
      case 'compound':
        var compoundResult = {
          exit: [],
          entry: []
        };
        var currentChildKey = (0, _utils.keys)(this.nodes)[0];
        var prevChildKey = (0, _utils.keys)(prevTree.nodes)[0];

        if (currentChildKey !== prevChildKey) {
          compoundResult.exit = prevTree.nodes[prevChildKey].getExitStates();
          compoundResult.entry = this.nodes[currentChildKey].getEntryStates();
        } else {
          compoundResult = this.nodes[currentChildKey].getEntryExitStates(prevTree.nodes[prevChildKey]);
        }

        if (externalNodes && externalNodes.has(this.stateNode)) {
          compoundResult.exit.push(this.stateNode);
          compoundResult.entry.unshift(this.stateNode);
        }

        return compoundResult;

      case 'parallel':
        var all = (0, _utils.keys)(this.nodes).map(function (key) {
          return _this.nodes[key].getEntryExitStates(prevTree.nodes[key]);
        });
        var parallelResult = {
          exit: [],
          entry: []
        };

        try {
          for (var all_1 = __values(all), all_1_1 = all_1.next(); !all_1_1.done; all_1_1 = all_1.next()) {
            var ees = all_1_1.value;
            parallelResult.exit = __spread(parallelResult.exit, ees.exit);
            parallelResult.entry = __spread(parallelResult.entry, ees.entry);
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (all_1_1 && !all_1_1.done && (_a = all_1.return)) _a.call(all_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }

        if (externalNodes && externalNodes.has(this.stateNode)) {
          parallelResult.exit.push(this.stateNode);
          parallelResult.entry.unshift(this.stateNode);
        }

        return parallelResult;

      case 'atomic':
      default:
        if (externalNodes && externalNodes.has(this.stateNode)) {
          return {
            exit: [this.stateNode],
            entry: [this.stateNode]
          };
        }

        return {
          exit: [],
          entry: []
        };
    }
  };

  StateTree.prototype.getEntryStates = function () {
    var _this = this;

    if (!this.nodes) {
      return [this.stateNode];
    }

    return [this.stateNode].concat((0, _utils.flatten)((0, _utils.keys)(this.nodes).map(function (key) {
      return _this.nodes[key].getEntryStates();
    })));
  };

  StateTree.prototype.getExitStates = function () {
    var _this = this;

    if (!this.nodes) {
      return [this.stateNode];
    }

    return (0, _utils.flatten)((0, _utils.keys)(this.nodes).map(function (key) {
      return _this.nodes[key].getExitStates();
    })).concat(this.stateNode);
  };

  StateTree.prototype.addReentryNode = function (reentryNode) {
    this.root.reentryNodes.add(reentryNode);
  };

  return StateTree;
}();

exports.StateTree = StateTree;
},{"./utils":"node_modules/xstate/es/utils.js","./actions":"node_modules/xstate/es/actions.js"}],"node_modules/xstate/es/stateUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getConfiguration = getConfiguration;
exports.getAdjList = getAdjList;
exports.getValue = getValue;

var _utils = require("./utils");

var __values = void 0 && (void 0).__values || function (o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
};

function getChildren(stateNode) {
  return (0, _utils.keys)(stateNode.states).map(function (key) {
    return stateNode.states[key];
  });
}

function getConfiguration(prevStateNodes, stateNodes) {
  var e_1, _a, e_2, _b, e_3, _c;

  var prevConfiguration = new Set(prevStateNodes);
  var prevAdjList = getAdjList(prevConfiguration);
  var configuration = new Set(stateNodes);

  try {
    // add all ancestors
    for (var configuration_1 = __values(configuration), configuration_1_1 = configuration_1.next(); !configuration_1_1.done; configuration_1_1 = configuration_1.next()) {
      var s = configuration_1_1.value;
      var m = s.parent;

      while (m && !configuration.has(m)) {
        configuration.add(m);
        m = m.parent;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (configuration_1_1 && !configuration_1_1.done && (_a = configuration_1.return)) _a.call(configuration_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  var adjList = getAdjList(configuration);

  try {
    // console.log('KEYS:', [...adjList.keys()].map(k => k.id));
    // add descendants
    for (var configuration_2 = __values(configuration), configuration_2_1 = configuration_2.next(); !configuration_2_1.done; configuration_2_1 = configuration_2.next()) {
      var s = configuration_2_1.value;

      if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {
        if (prevAdjList.get(s)) {
          prevAdjList.get(s).forEach(function (sn) {
            return configuration.add(sn);
          });
        } else {
          s.initialStateNodes.forEach(function (sn) {
            return configuration.add(sn);
          });
        }
      } else {
        if (s.type === 'parallel') {
          try {
            for (var _d = __values(getChildren(s)), _e = _d.next(); !_e.done; _e = _d.next()) {
              var child = _e.value;

              if (!configuration.has(child)) {
                configuration.add(child);

                if (prevAdjList.get(child)) {
                  prevAdjList.get(child).forEach(function (sn) {
                    return configuration.add(sn);
                  });
                } else {
                  child.initialStateNodes.forEach(function (sn) {
                    return configuration.add(sn);
                  });
                }
              }
            }
          } catch (e_3_1) {
            e_3 = {
              error: e_3_1
            };
          } finally {
            try {
              if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
        }
      }
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (configuration_2_1 && !configuration_2_1.done && (_b = configuration_2.return)) _b.call(configuration_2);
    } finally {
      if (e_2) throw e_2.error;
    }
  }

  return configuration;
}

function getValueFromAdj(baseNode, adjList) {
  var stateValue = {};
  var childStateNodes = adjList.get(baseNode);

  if (!childStateNodes) {
    return {}; // todo: fix?
  }

  if (baseNode.type === 'compound') {
    if (childStateNodes[0]) {
      if (childStateNodes[0].type === 'atomic') {
        return childStateNodes[0].key;
      }
    } else {
      return {};
    }
  }

  childStateNodes.forEach(function (csn) {
    stateValue[csn.key] = getValueFromAdj(csn, adjList);
  });
  return stateValue;
}

function getAdjList(configuration) {
  var e_4, _a;

  var adjList = new Map();

  try {
    for (var configuration_3 = __values(configuration), configuration_3_1 = configuration_3.next(); !configuration_3_1.done; configuration_3_1 = configuration_3.next()) {
      var s = configuration_3_1.value;

      if (!adjList.has(s)) {
        adjList.set(s, []);
      }

      if (s.parent) {
        if (!adjList.has(s.parent)) {
          adjList.set(s.parent, []);
        }

        adjList.get(s.parent).push(s);
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (configuration_3_1 && !configuration_3_1.done && (_a = configuration_3.return)) _a.call(configuration_3);
    } finally {
      if (e_4) throw e_4.error;
    }
  } // console.log(
  //   [...adjList.keys()].map(key => [key.id, adjList.get(key)!.map(sn => sn.id)])
  // );


  return adjList;
}

function getValue(rootNode, configuration) {
  var config = getConfiguration([rootNode], configuration);
  return getValueFromAdj(rootNode, getAdjList(config));
}
},{"./utils":"node_modules/xstate/es/utils.js"}],"node_modules/xstate/es/StateNode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StateNode = void 0;

var _utils = require("./utils");

var _types = require("./types");

var _State = require("./State");

var actionTypes = _interopRequireWildcard(require("./actionTypes"));

var _actions = require("./actions");

var _StateTree = require("./StateTree");

var _environment = require("./environment");

var _constants = require("./constants");

var _stateUtils = require("./stateUtils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  return t;
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
};

var __values = void 0 && (void 0).__values || function (o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
};

var STATE_DELIMITER = '.';
var NULL_EVENT = '';
var STATE_IDENTIFIER = '#';
var TARGETLESS_KEY = '';
var EMPTY_OBJECT = {};

var isStateId = function (str) {
  return str[0] === STATE_IDENTIFIER;
};

var createDefaultOptions = function () {
  return {
    actions: {},
    guards: {},
    services: {},
    activities: {},
    delays: {},
    updater: _utils.updateContext
  };
};

var StateNode =
/** @class */

/*#__PURE__*/
function () {
  function StateNode(_config, options,
  /**
   * The initial extended state
   */
  context) {
    var _this = this;

    this.context = context;
    this.__xstatenode = true;
    this.__cache = {
      events: undefined,
      relativeValue: new Map(),
      initialStateValue: undefined,
      initialState: undefined,
      transitions: undefined
    };
    this.idMap = {};

    var parent = _config.parent,
        config = __rest(_config, ["parent"]);

    this.config = config;
    this.parent = parent;
    this.options = __assign({}, createDefaultOptions(), options);
    this.key = _config.key || _config.id || '(machine)';
    this.machine = this.parent ? this.parent.machine : this;
    this.path = this.parent ? this.parent.path.concat(this.key) : [];
    this.delimiter = _config.delimiter || (this.parent ? this.parent.delimiter : STATE_DELIMITER);
    this.id = _config.id || (this.machine ? __spread([this.machine.key], this.path).join(this.delimiter) : this.key);
    this.version = this.parent ? this.parent.version : _config.version;
    this.type = _config.type || (_config.parallel ? 'parallel' : _config.states && (0, _utils.keys)(_config.states).length ? 'compound' : _config.history ? 'history' : 'atomic');

    if (!_environment.IS_PRODUCTION) {
      (0, _utils.warn)(!('parallel' in _config), "The \"parallel\" property is deprecated and will be removed in version 4.1. " + (_config.parallel ? "Replace with `type: 'parallel'`" : "Use `type: '" + this.type + "'`") + " in the config for state node '" + this.id + "' instead.");
    }

    this.initial = _config.initial;
    this.order = _config.order || -1;
    this.states = _config.states ? (0, _utils.mapValues)(_config.states, function (stateConfig, key, _, i) {
      var _a;

      var stateNode = new StateNode(__assign({}, stateConfig, {
        key: key,
        order: stateConfig.order === undefined ? i : stateConfig.order,
        parent: _this
      }));
      Object.assign(_this.idMap, __assign((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));
      return stateNode;
    }) : EMPTY_OBJECT; // History config

    this.history = _config.history === true ? 'shallow' : _config.history || false;
    this._transient = !!(_config.on && _config.on[NULL_EVENT]);
    this.strict = !!_config.strict; // TODO: deprecate (entry)

    this.onEntry = (0, _utils.toArray)(_config.entry || _config.onEntry).map(function (action) {
      return (0, _actions.toActionObject)(action);
    }); // TODO: deprecate (exit)

    this.onExit = (0, _utils.toArray)(_config.exit || _config.onExit).map(function (action) {
      return (0, _actions.toActionObject)(action);
    });
    this.meta = _config.meta;
    this.data = this.type === 'final' ? _config.data : undefined;
    this.invoke = (0, _utils.toArray)(_config.invoke).map(function (invokeConfig, i) {
      var _a, _b;

      if ((0, _utils.isMachine)(invokeConfig)) {
        (_this.parent || _this).options.services = __assign((_a = {}, _a[invokeConfig.id] = invokeConfig, _a), (_this.parent || _this).options.services);
        return {
          type: actionTypes.invoke,
          src: invokeConfig.id,
          id: invokeConfig.id
        };
      } else if (typeof invokeConfig.src !== 'string') {
        var invokeSrc = _this.id + ":invocation[" + i + "]"; // TODO: util function

        _this.machine.options.services = __assign((_b = {}, _b[invokeSrc] = invokeConfig.src, _b), _this.machine.options.services);
        return __assign({
          type: actionTypes.invoke,
          id: invokeSrc
        }, invokeConfig, {
          src: invokeSrc
        });
      } else {
        return __assign({}, invokeConfig, {
          type: actionTypes.invoke,
          id: invokeConfig.id || invokeConfig.src,
          src: invokeConfig.src
        });
      }
    });
    this.activities = (0, _utils.toArray)(_config.activities).concat(this.invoke).map(function (activity) {
      return (0, _actions.toActivityDefinition)(activity);
    });
    this.after = this.getDelayedTransitions();
  }
  /**
   * Clones this state machine with custom options and context.
   *
   * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.
   * @param context Custom context (will override predefined context)
   */


  StateNode.prototype.withConfig = function (options, context) {
    if (context === void 0) {
      context = this.context;
    }

    var _a = this.options,
        actions = _a.actions,
        activities = _a.activities,
        guards = _a.guards,
        services = _a.services,
        delays = _a.delays;
    return new StateNode(this.config, {
      actions: __assign({}, actions, options.actions),
      activities: __assign({}, activities, options.activities),
      guards: __assign({}, guards, options.guards),
      services: __assign({}, services, options.services),
      delays: __assign({}, delays, options.delays)
    }, context);
  };
  /**
   * Clones this state machine with custom context.
   *
   * @param context Custom context (will override predefined context, not recursive)
   */


  StateNode.prototype.withContext = function (context) {
    return new StateNode(this.config, this.options, context);
  };

  Object.defineProperty(StateNode.prototype, "definition", {
    /**
     * The well-structured state node definition.
     */
    get: function () {
      return {
        id: this.id,
        key: this.key,
        version: this.version,
        type: this.type,
        initial: this.initial,
        history: this.history,
        states: (0, _utils.mapValues)(this.states, function (state) {
          return state.definition;
        }),
        on: this.on,
        onEntry: this.onEntry,
        onExit: this.onExit,
        activities: this.activities || [],
        meta: this.meta,
        order: this.order || -1,
        data: this.data,
        invoke: this.invoke
      };
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.toJSON = function () {
    return this.definition;
  };

  Object.defineProperty(StateNode.prototype, "on", {
    /**
     * The mapping of events to transitions.
     */
    get: function () {
      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "transitions", {
    /**
     * All the transitions that can be taken from this state node.
     */
    get: function () {
      var _this = this;

      return (0, _utils.flatten)((0, _utils.keys)(this.on).map(function (event) {
        return _this.on[event];
      }));
    },
    enumerable: true,
    configurable: true
  });
  /**
   * All delayed transitions from the config.
   */

  StateNode.prototype.getDelayedTransitions = function () {
    var _this = this;

    if (this.after) {
      return this.after;
    }

    var afterConfig = this.config.after;
    var guards = this.machine.options.guards;

    if (!afterConfig) {
      return [];
    }

    if ((0, _utils.isArray)(afterConfig)) {
      return afterConfig.map(function (delayedTransition, i) {
        var delay = delayedTransition.delay,
            target = delayedTransition.target;
        var delayRef;

        if ((0, _utils.isFunction)(delay)) {
          delayRef = _this.id + ":delay[" + i + "]";
          _this.options.delays[delayRef] = delay; // TODO: util function
        } else {
          delayRef = delay;
        }

        var event = (0, _actions.after)(delayRef, _this.id);

        _this.onEntry.push((0, _actions.send)(event, {
          delay: delay
        }));

        _this.onExit.push((0, _actions.cancel)(event));

        return __assign({
          event: event
        }, delayedTransition, {
          source: _this,
          target: target === undefined ? undefined : (0, _utils.toArray)(target),
          cond: (0, _utils.toGuard)(delayedTransition.cond, guards),
          actions: (0, _utils.toArray)(delayedTransition.actions).map(function (action) {
            return (0, _actions.toActionObject)(action);
          })
        });
      });
    }

    var allDelayedTransitions = (0, _utils.flatten)((0, _utils.keys)(afterConfig).map(function (delayKey) {
      var delayedTransition = afterConfig[delayKey];
      var delay = isNaN(+delayKey) ? delayKey : +delayKey;
      var event = (0, _actions.after)(delay, _this.id);

      _this.onEntry.push((0, _actions.send)(event, {
        delay: delay
      }));

      _this.onExit.push((0, _actions.cancel)(event));

      if ((0, _utils.isString)(delayedTransition)) {
        return [{
          source: _this,
          target: [delayedTransition],
          delay: delay,
          event: event,
          actions: []
        }];
      }

      var delayedTransitions = (0, _utils.toArray)(delayedTransition);
      return delayedTransitions.map(function (transition) {
        return __assign({
          event: event,
          delay: delay
        }, transition, {
          source: _this,
          target: transition.target === undefined ? transition.target : (0, _utils.toArray)(transition.target),
          cond: (0, _utils.toGuard)(transition.cond, guards),
          actions: (0, _utils.toArray)(transition.actions).map(function (action) {
            return (0, _actions.toActionObject)(action);
          })
        });
      });
    }));
    allDelayedTransitions.sort(function (a, b) {
      return (0, _utils.isString)(a) || (0, _utils.isString)(b) ? 0 : +a.delay - +b.delay;
    });
    return allDelayedTransitions;
  };
  /**
   * Returns the state nodes represented by the current state value.
   *
   * @param state The state value or State instance
   */


  StateNode.prototype.getStateNodes = function (state) {
    var _this = this;

    var _a;

    if (!state) {
      return [];
    }

    var stateValue = state instanceof _State.State ? state.value : (0, _utils.toStateValue)(state, this.delimiter);

    if ((0, _utils.isString)(stateValue)) {
      var initialStateValue = this.getStateNode(stateValue).initial;
      return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this.states[stateValue]];
    }

    var subStateKeys = (0, _utils.keys)(stateValue);
    var subStateNodes = subStateKeys.map(function (subStateKey) {
      return _this.getStateNode(subStateKey);
    });
    return subStateNodes.concat(subStateKeys.reduce(function (allSubStateNodes, subStateKey) {
      var subStateNode = _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);

      return allSubStateNodes.concat(subStateNode);
    }, []));
  };
  /**
   * Returns `true` if this state node explicitly handles the given event.
   *
   * @param event The event in question
   */


  StateNode.prototype.handles = function (event) {
    var eventType = (0, _utils.getEventType)(event);
    return this.events.indexOf(eventType) !== -1;
  };
  /**
   * Resolves the given `state` to a new `State` instance relative to this machine.
   *
   * This ensures that `.events` and `.nextEvents` represent the correct values.
   *
   * @param state The state to resolve
   */


  StateNode.prototype.resolveState = function (state) {
    return new _State.State(__assign({}, state, {
      value: this.resolve(state.value),
      tree: this.getStateTree(state.value)
    }));
  };

  StateNode.prototype.transitionLeafNode = function (stateValue, state, eventObject) {
    var stateNode = this.getStateNode(stateValue);
    var next = stateNode.next(state, eventObject);

    if (!next.tree) {
      var _a = this.next(state, eventObject),
          actions = _a.actions,
          tree = _a.tree,
          transitions = _a.transitions,
          configuration = _a.configuration;

      return {
        tree: tree,
        transitions: transitions,
        configuration: configuration,
        source: state,
        actions: actions
      };
    }

    return next;
  };

  StateNode.prototype.transitionCompoundNode = function (stateValue, state, eventObject) {
    var subStateKeys = (0, _utils.keys)(stateValue);
    var stateNode = this.getStateNode(subStateKeys[0]);

    var next = stateNode._transition(stateValue[subStateKeys[0]], state, eventObject);

    if (!next.tree) {
      var _a = this.next(state, eventObject),
          actions = _a.actions,
          tree = _a.tree,
          transitions = _a.transitions,
          configuration = _a.configuration;

      return {
        tree: tree,
        transitions: transitions,
        configuration: configuration,
        source: state,
        actions: actions
      };
    }

    return next;
  };

  StateNode.prototype.transitionParallelNode = function (stateValue, state, eventObject) {
    var e_1, _a;

    var noTransitionKeys = [];
    var transitionMap = {};

    try {
      for (var _b = __values((0, _utils.keys)(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var subStateKey = _c.value;
        var subStateValue = stateValue[subStateKey];

        if (!subStateValue) {
          continue;
        }

        var subStateNode = this.getStateNode(subStateKey);

        var next = subStateNode._transition(subStateValue, state, eventObject);

        if (!next.tree) {
          noTransitionKeys.push(subStateKey);
        }

        transitionMap[subStateKey] = next;
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    var stateTransitions = (0, _utils.keys)(transitionMap).map(function (key) {
      return transitionMap[key];
    });
    var enabledTransitions = (0, _utils.flatten)(stateTransitions.map(function (st) {
      return st.transitions;
    }));
    var willTransition = stateTransitions.some(function (transition) {
      return transition.tree !== undefined;
    });

    if (!willTransition) {
      var _d = this.next(state, eventObject),
          actions = _d.actions,
          tree = _d.tree,
          transitions = _d.transitions,
          _configuration = _d.configuration;

      return {
        tree: tree,
        transitions: transitions,
        configuration: _configuration,
        source: state,
        actions: actions
      };
    }

    var targetNodes = (0, _utils.flatten)(stateTransitions.map(function (st) {
      return st.configuration;
    }));
    var prevNodes = this.getStateNodes(stateValue); // console.log(targetNodes.map(t => t.id));
    // console.log([...getConfiguration(prevNodes, targetNodes)].map(c => c.id));

    var stateValueFromConfiguration = (0, _stateUtils.getValue)(this.machine, (0, _stateUtils.getConfiguration)(prevNodes, targetNodes)); // console.log(sv);

    var combinedTree = new _StateTree.StateTree(this.machine, stateValueFromConfiguration); // const allTrees = keys(transitionMap)
    //   .map(key => transitionMap[key].tree)
    //   .filter(t => t !== undefined) as StateTree[];
    // const combinedTree = allTrees.reduce((acc, t) => {
    //   return acc.combine(t);
    // });

    var allPaths = combinedTree.paths;
    var configuration = (0, _utils.flatten)((0, _utils.keys)(transitionMap).map(function (key) {
      return transitionMap[key].configuration;
    })); // External transition that escapes orthogonal region

    if (allPaths.length === 1 && !(0, _utils.matchesState)((0, _utils.toStateValue)(this.path, this.delimiter), combinedTree.value)) {
      return {
        tree: combinedTree,
        transitions: enabledTransitions,
        configuration: configuration,
        source: state,
        actions: (0, _utils.flatten)((0, _utils.keys)(transitionMap).map(function (key) {
          return transitionMap[key].actions;
        }))
      };
    } // const allResolvedTrees = keys(transitionMap).map(key => {
    //   const { tree } = transitionMap[key];
    //   if (tree) {
    //     return tree;
    //   }
    //   const subValue = path(this.path)(state.value)[key];
    //   return new StateTree(this.getStateNode(key), subValue).absolute;
    // });
    // const finalCombinedTree = allResolvedTrees.reduce((acc, t) => {
    //   return acc.combine(t);
    // });


    return {
      tree: combinedTree,
      transitions: enabledTransitions,
      configuration: configuration,
      source: state,
      actions: (0, _utils.flatten)((0, _utils.keys)(transitionMap).map(function (key) {
        return transitionMap[key].actions;
      }))
    };
  };

  StateNode.prototype._transition = function (stateValue, state, event) {
    // leaf node
    if ((0, _utils.isString)(stateValue)) {
      return this.transitionLeafNode(stateValue, state, event);
    } // hierarchical node


    if ((0, _utils.keys)(stateValue).length === 1) {
      return this.transitionCompoundNode(stateValue, state, event);
    } // orthogonal node


    return this.transitionParallelNode(stateValue, state, event);
  };

  StateNode.prototype.next = function (state, eventObject) {
    var _this = this;

    var e_2, _a;

    var eventType = eventObject.type;
    var candidates = this.on[eventType];

    if (!candidates || !candidates.length) {
      return {
        tree: undefined,
        transitions: [],
        configuration: [],
        source: state,
        actions: []
      };
    }

    var actions = this._transient ? [{
      type: actionTypes.nullEvent
    }] : [];
    var nextStateStrings = [];
    var selectedTransition;

    try {
      for (var candidates_1 = __values(candidates), candidates_1_1 = candidates_1.next(); !candidates_1_1.done; candidates_1_1 = candidates_1.next()) {
        var candidate = candidates_1_1.value;
        var cond = candidate.cond,
            stateIn = candidate.in;
        var resolvedContext = state.context;
        var isInState = stateIn ? (0, _utils.isString)(stateIn) && isStateId(stateIn) ? // Check if in state by ID
        state.matches((0, _utils.toStateValue)(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent
        (0, _utils.matchesState)((0, _utils.toStateValue)(stateIn, this.delimiter), (0, _utils.path)(this.path.slice(0, -2))(state.value)) : true;
        var guardPassed = false;

        try {
          guardPassed = !cond || this.evaluateGuard(cond, resolvedContext, eventObject, state);
        } catch (err) {
          throw new Error("Unable to evaluate guard '" + (cond.name || cond.type) + "' in transition for event '" + eventType + "' in state node '" + this.id + "':\n" + err.message);
        }

        if (guardPassed && isInState) {
          if (candidate.target !== undefined) {
            nextStateStrings = candidate.target;
          }

          actions.push.apply(actions, __spread((0, _utils.toArray)(candidate.actions)));
          selectedTransition = candidate;
          break;
        }
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (candidates_1_1 && !candidates_1_1.done && (_a = candidates_1.return)) _a.call(candidates_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    if (!nextStateStrings.length) {
      return {
        tree: selectedTransition && state.value // targetless transition
        ? new _StateTree.StateTree(this, (0, _utils.path)(this.path)(state.value)).absolute : undefined,
        transitions: [selectedTransition],
        configuration: selectedTransition && state.value ? [this] : [],
        source: state,
        actions: actions
      };
    }

    var nextStateNodes = (0, _utils.flatten)(nextStateStrings.map(function (str) {
      if (str instanceof StateNode) {
        return str; // TODO: fix anys
      }

      return _this.getRelativeStateNodes(str, state.historyValue);
    }));
    var isInternal = !!selectedTransition.internal;
    var reentryNodes = isInternal ? [] : (0, _utils.flatten)(nextStateNodes.map(function (n) {
      return _this.nodesFromChild(n);
    }));
    var trees = nextStateNodes.map(function (stateNode) {
      return stateNode.tree;
    });
    var combinedTree = trees.reduce(function (acc, t) {
      return acc.combine(t);
    });
    reentryNodes.forEach(function (reentryNode) {
      return combinedTree.addReentryNode(reentryNode);
    });
    return {
      tree: combinedTree,
      transitions: [selectedTransition],
      configuration: nextStateNodes,
      source: state,
      actions: actions
    };
  };

  Object.defineProperty(StateNode.prototype, "tree", {
    /**
     * The state tree represented by this state node.
     */
    get: function () {
      var stateValue = (0, _utils.toStateValue)(this.path, this.delimiter);
      return new _StateTree.StateTree(this.machine, stateValue);
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.nodesFromChild = function (childStateNode) {
    if (childStateNode.escapes(this)) {
      return [];
    }

    var nodes = [];
    var marker = childStateNode;

    while (marker && marker !== this) {
      nodes.push(marker);
      marker = marker.parent;
    }

    nodes.push(this); // inclusive

    return nodes;
  };

  StateNode.prototype.getStateTree = function (stateValue) {
    return new _StateTree.StateTree(this, stateValue);
  };
  /**
   * Whether the given state node "escapes" this state node. If the `stateNode` is equal to or the parent of
   * this state node, it does not escape.
   */


  StateNode.prototype.escapes = function (stateNode) {
    if (this === stateNode) {
      return false;
    }

    var parent = this.parent;

    while (parent) {
      if (parent === stateNode) {
        return false;
      }

      parent = parent.parent;
    }

    return true;
  };

  StateNode.prototype.evaluateGuard = function (guard, context, eventObject, state) {
    var condFn;
    var guards = this.machine.options.guards;
    var guardMeta = {
      state: state,
      cond: guard
    }; // TODO: do not hardcode!

    if (guard.type === _constants.DEFAULT_GUARD_TYPE) {
      return guard.predicate(context, eventObject, guardMeta);
    }

    if (!guards[guard.type]) {
      throw new Error("Guard '" + guard.type + "' is not implemented on machine '" + this.machine.id + "'.");
    }

    condFn = guards[guard.type];
    return condFn(context, eventObject, guardMeta);
  };

  StateNode.prototype.getActions = function (transition, prevState) {
    var entryExitStates = transition.tree ? transition.tree.resolved.getEntryExitStates(prevState ? this.getStateTree(prevState.value) : undefined) : {
      entry: [],
      exit: []
    };
    var doneEvents = transition.tree ? transition.tree.getDoneEvents(new Set(entryExitStates.entry)) : [];

    if (!transition.source) {
      entryExitStates.exit = []; // Ensure that root StateNode (machine) is entered

      entryExitStates.entry.unshift(this);
    }

    var entryStates = new Set(entryExitStates.entry);
    var exitStates = new Set(entryExitStates.exit);

    var _a = __read([(0, _utils.flatten)(Array.from(entryStates).map(function (stateNode) {
      return __spread(stateNode.activities.map(function (activity) {
        return (0, _actions.start)(activity);
      }), stateNode.onEntry);
    })).concat(doneEvents.map(_actions.raise)), (0, _utils.flatten)(Array.from(exitStates).map(function (stateNode) {
      return __spread(stateNode.onExit, stateNode.activities.map(function (activity) {
        return (0, _actions.stop)(activity);
      }));
    }))], 2),
        entryActions = _a[0],
        exitActions = _a[1];

    var actions = (0, _actions.toActionObjects)(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);
    return actions;
  };
  /**
   * Determines the next state given the current `state` and sent `event`.
   *
   * @param state The current State instance or state value
   * @param event The event that was sent at the current state
   * @param context The current context (extended state) of the current state
   */


  StateNode.prototype.transition = function (state, event, context) {
    var currentState;

    if (state instanceof _State.State) {
      currentState = context === undefined ? state : this.resolveState(_State.State.from(state, context));
    } else {
      var resolvedStateValue = (0, _utils.isString)(state) ? this.resolve((0, _utils.pathToStateValue)(this.getResolvedPath(state))) : this.resolve(state);
      var resolvedContext = context ? context : this.machine.context;
      currentState = this.resolveState(_State.State.from(resolvedStateValue, resolvedContext));
    }

    var eventObject = (0, _actions.toEventObject)(event);
    var eventType = eventObject.type;

    if (this.strict) {
      if (this.events.indexOf(eventType) === -1 && !(0, _utils.isBuiltInEvent)(eventType)) {
        throw new Error("Machine '" + this.id + "' does not accept event '" + eventType + "'");
      }
    }

    var stateTransition = this._transition(currentState.value, currentState, eventObject);

    if (stateTransition.tree) {
      stateTransition.tree = stateTransition.tree.resolved;
    } // const prevConfig = this.machine.getStateNodes(currentState.value);
    // const cv = getValue(
    //   this.machine,
    //   getConfiguration(prevConfig, stateTransition.configuration)
    // );
    // if (stateTransition.tree) {
    //   const eq = stateValuesEqual(cv, stateTransition.tree.value);
    //   console.log(eq);
    // }
    // if (!eq) {
    //   console.log('prevConfig', prevConfig.map(c => c.id));
    //   console.log('config', [...stateTransition.configuration].map(c => c.id));
    //   console.log(cv, stateTransition.tree!.value);
    // }


    return this.resolveTransition(stateTransition, currentState, eventObject);
  };

  StateNode.prototype.resolveTransition = function (stateTransition, currentState, _eventObject) {
    var _this = this;

    var e_3, _a, _b;

    var resolvedStateValue = stateTransition.tree ? stateTransition.tree.value : undefined;
    var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;
    var currentContext = currentState ? currentState.context : stateTransition.context || this.machine.context;
    var eventObject = _eventObject || {
      type: _types.ActionTypes.Init
    };

    if (!_environment.IS_PRODUCTION && stateTransition.tree) {
      try {
        this.ensureValidPaths(stateTransition.tree.paths); // TODO: ensure code coverage for this
      } catch (e) {
        throw new Error("Event '" + (eventObject ? eventObject.type : 'none') + "' leads to an invalid configuration: " + e.message);
      }
    }

    var actions = this.getActions(stateTransition, currentState);
    var activities = currentState ? __assign({}, currentState.activities) : {};

    try {
      for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
        var action = actions_1_1.value;

        if (action.type === actionTypes.start) {
          activities[action.activity.type] = action;
        } else if (action.type === actionTypes.stop) {
          activities[action.activity.type] = false;
        }
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    var _c = __read((0, _utils.partition)(actions, function (action) {
      return action.type === actionTypes.raise || action.type === actionTypes.nullEvent;
    }), 2),
        raisedEvents = _c[0],
        otherActions = _c[1];

    var _d = __read((0, _utils.partition)(otherActions, function (action) {
      return action.type === actionTypes.assign;
    }), 2),
        assignActions = _d[0],
        nonEventActions = _d[1];

    var updatedContext = assignActions.length ? this.options.updater(currentContext, eventObject, assignActions) : currentContext;
    var resolvedActions = (0, _utils.flatten)(nonEventActions.map(function (actionObject) {
      if (actionObject.type === actionTypes.send) {
        var sendAction = (0, _actions.resolveSend)(actionObject, updatedContext, eventObject || {
          type: _types.ActionTypes.Init
        }); // TODO: fix ActionTypes.Init

        if ((0, _utils.isString)(sendAction.delay)) {
          if (!_this.machine.options.delays || _this.machine.options.delays[sendAction.delay] === undefined) {
            if (!_environment.IS_PRODUCTION) {
              (0, _utils.warn)(false, // tslint:disable-next-line:max-line-length
              "No delay reference for delay expression '" + sendAction.delay + "' was found on machine '" + _this.machine.id + "'");
            } // Do not send anything


            return sendAction;
          }

          var delayExpr = _this.machine.options.delays[sendAction.delay];
          sendAction.delay = typeof delayExpr === 'number' ? delayExpr : delayExpr(updatedContext, eventObject || {
            type: _types.ActionTypes.Init
          });
        }

        return sendAction;
      }

      if (actionObject.type === _types.ActionTypes.Pure) {
        return actionObject.get(updatedContext, eventObject) || [];
      }

      return (0, _actions.toActionObject)(actionObject, _this.options.actions);
    }));
    var stateNodes = resolvedStateValue ? this.getStateNodes(resolvedStateValue) : [];
    var isTransient = stateNodes.some(function (stateNode) {
      return stateNode._transient;
    });

    if (isTransient) {
      raisedEvents.push({
        type: actionTypes.nullEvent
      });
    }

    var meta = __spread([this], stateNodes).reduce(function (acc, stateNode) {
      if (stateNode.meta !== undefined) {
        acc[stateNode.id] = stateNode.meta;
      }

      return acc;
    }, {});

    var nextState = new _State.State({
      value: resolvedStateValue || currentState.value,
      context: updatedContext,
      event: eventObject || _actions.initEvent,
      historyValue: resolvedStateValue ? historyValue ? (0, _utils.updateHistoryValue)(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,
      history: !resolvedStateValue || stateTransition.source ? currentState : undefined,
      actions: resolvedStateValue ? resolvedActions : [],
      activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},
      meta: resolvedStateValue ? meta : currentState ? currentState.meta : undefined,
      events: resolvedStateValue ? raisedEvents : [],
      tree: resolvedStateValue ? stateTransition.tree : currentState ? currentState.tree : undefined
    });
    nextState.changed = eventObject.type === actionTypes.update || !!assignActions.length; // Dispose of penultimate histories to prevent memory leaks

    var history = nextState.history;

    if (history) {
      delete history.history;
    }

    if (!resolvedStateValue) {
      return nextState;
    }

    var maybeNextState = nextState;

    while (raisedEvents.length) {
      var currentActions = maybeNextState.actions;
      var raisedEvent = raisedEvents.shift();
      maybeNextState = this.transition(maybeNextState, raisedEvent.type === actionTypes.nullEvent ? NULL_EVENT : raisedEvent.event, maybeNextState.context); // Save original event to state

      maybeNextState.event = eventObject;

      (_b = maybeNextState.actions).unshift.apply(_b, __spread(currentActions));
    } // Detect if state changed


    var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || !!assignActions.length || typeof history.value !== typeof maybeNextState.value || !(0, _State.stateValuesEqual)(maybeNextState.value, history.value) : undefined);
    maybeNextState.changed = changed; // Preserve original history after raised events

    maybeNextState.historyValue = nextState.historyValue;
    maybeNextState.history = history;
    return maybeNextState;
  };

  StateNode.prototype.ensureValidPaths = function (paths) {
    var _this = this;

    var e_4, _a;

    if (!_environment.IS_PRODUCTION) {
      var visitedParents = new Map();
      var stateNodes = (0, _utils.flatten)(paths.map(function (_path) {
        return _this.getRelativeStateNodes(_path);
      }));

      try {
        outer: for (var stateNodes_1 = __values(stateNodes), stateNodes_1_1 = stateNodes_1.next(); !stateNodes_1_1.done; stateNodes_1_1 = stateNodes_1.next()) {
          var stateNode = stateNodes_1_1.value;
          var marker = stateNode;

          while (marker.parent) {
            if (visitedParents.has(marker.parent)) {
              if (marker.parent.type === 'parallel') {
                continue outer;
              }

              throw new Error("State node '" + stateNode.id + "' shares parent '" + marker.parent.id + "' with state node '" + visitedParents.get(marker.parent).map(function (a) {
                return a.id;
              }) + "'");
            }

            if (!visitedParents.get(marker.parent)) {
              visitedParents.set(marker.parent, [stateNode]);
            } else {
              visitedParents.get(marker.parent).push(stateNode);
            }

            marker = marker.parent;
          }
        }
      } catch (e_4_1) {
        e_4 = {
          error: e_4_1
        };
      } finally {
        try {
          if (stateNodes_1_1 && !stateNodes_1_1.done && (_a = stateNodes_1.return)) _a.call(stateNodes_1);
        } finally {
          if (e_4) throw e_4.error;
        }
      }
    } else {
      return;
    }
  };
  /**
   * Returns the child state node from its relative `stateKey`, or throws.
   */


  StateNode.prototype.getStateNode = function (stateKey) {
    if (isStateId(stateKey)) {
      return this.machine.getStateNodeById(stateKey);
    }

    if (!this.states) {
      throw new Error("Unable to retrieve child state '" + stateKey + "' from '" + this.id + "'; no child states exist.");
    }

    var result = this.states[stateKey];

    if (!result) {
      throw new Error("Child state '" + stateKey + "' does not exist on '" + this.id + "'");
    }

    return result;
  };
  /**
   * Returns the state node with the given `stateId`, or throws.
   *
   * @param stateId The state ID. The prefix "#" is removed.
   */


  StateNode.prototype.getStateNodeById = function (stateId) {
    var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;

    if (resolvedStateId === this.id) {
      return this;
    }

    var stateNode = this.machine.idMap[resolvedStateId];

    if (!stateNode) {
      throw new Error("Child state node '#" + resolvedStateId + "' does not exist on machine '" + this.id + "'");
    }

    return stateNode;
  };
  /**
   * Returns the relative state node from the given `statePath`, or throws.
   *
   * @param statePath The string or string array relative path to the state node.
   */


  StateNode.prototype.getStateNodeByPath = function (statePath) {
    if (typeof statePath === 'string' && isStateId(statePath)) {
      try {
        return this.getStateNodeById(statePath.slice(1));
      } catch (e) {// try individual paths
        // throw e;
      }
    }

    var arrayStatePath = (0, _utils.toStatePath)(statePath, this.delimiter).slice();
    var currentStateNode = this;

    while (arrayStatePath.length) {
      var key = arrayStatePath.shift();

      if (!key.length) {
        break;
      }

      currentStateNode = currentStateNode.getStateNode(key);
    }

    return currentStateNode;
  };
  /**
   * Resolves a partial state value with its full representation in this machine.
   *
   * @param stateValue The partial state value to resolve.
   */


  StateNode.prototype.resolve = function (stateValue) {
    var _this = this;

    var _a;

    if (!stateValue) {
      return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties
    }

    switch (this.type) {
      case 'parallel':
        return (0, _utils.mapValues)(this.initialStateValue, function (subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;
        });

      case 'compound':
        if ((0, _utils.isString)(stateValue)) {
          var subStateNode = this.getStateNode(stateValue);

          if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {
            return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;
          }

          return stateValue;
        }

        if (!(0, _utils.keys)(stateValue).length) {
          return this.initialStateValue || {};
        }

        return (0, _utils.mapValues)(stateValue, function (subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;
        });

      default:
        return stateValue || EMPTY_OBJECT;
    }
  };

  Object.defineProperty(StateNode.prototype, "resolvedStateValue", {
    get: function () {
      var _a, _b;

      var key = this.key;

      if (this.type === 'parallel') {
        return _a = {}, _a[key] = (0, _utils.mapFilterValues)(this.states, function (stateNode) {
          return stateNode.resolvedStateValue[stateNode.key];
        }, function (stateNode) {
          return !(stateNode.type === 'history');
        }), _a;
      }

      if (this.initial === undefined) {
        // If leaf node, value is just the state node's key
        return key;
      }

      if (!this.states[this.initial]) {
        throw new Error("Initial state '" + this.initial + "' not found on '" + key + "'");
      }

      return _b = {}, _b[key] = this.states[this.initial].resolvedStateValue, _b;
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.getResolvedPath = function (stateIdentifier) {
    if (isStateId(stateIdentifier)) {
      var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];

      if (!stateNode) {
        throw new Error("Unable to find state node '" + stateIdentifier + "'");
      }

      return stateNode.path;
    }

    return (0, _utils.toStatePath)(stateIdentifier, this.delimiter);
  };

  Object.defineProperty(StateNode.prototype, "initialStateValue", {
    get: function () {
      if (this.__cache.initialStateValue) {
        return this.__cache.initialStateValue;
      }

      var initialStateValue = this.type === 'parallel' ? (0, _utils.mapFilterValues)(this.states, function (state) {
        return state.initialStateValue || EMPTY_OBJECT;
      }, function (stateNode) {
        return !(stateNode.type === 'history');
      }) : (0, _utils.isString)(this.resolvedStateValue) ? undefined : this.resolvedStateValue[this.key];
      this.__cache.initialStateValue = initialStateValue;
      return this.__cache.initialStateValue;
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.getInitialState = function (stateValue, context) {
    if (context === void 0) {
      context = this.machine.context;
    }

    var tree = this.getStateTree(stateValue);
    var configuration = this.getStateNodes(stateValue);
    configuration.forEach(function (stateNode) {
      tree.addReentryNode(stateNode);
    });
    return this.resolveTransition({
      tree: tree,
      configuration: configuration,
      transitions: [],
      source: undefined,
      actions: [],
      context: context
    });
  };

  Object.defineProperty(StateNode.prototype, "initialState", {
    /**
     * The initial State instance, which includes all actions to be executed from
     * entering the initial state.
     */
    get: function () {
      if (this.__cache.initialState) {
        return this.__cache.initialState;
      }

      var initialStateValue = this.initialStateValue;

      if (!initialStateValue) {
        throw new Error("Cannot retrieve initial state from simple state '" + this.id + "'.");
      }

      this.__cache.initialState = this.getInitialState(initialStateValue);
      return this.__cache.initialState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "target", {
    /**
     * The target state value of the history state node, if it exists. This represents the
     * default state value to transition to if no history value exists yet.
     */
    get: function () {
      var target;

      if (this.type === 'history') {
        var historyConfig = this.config;

        if (historyConfig.target && (0, _utils.isString)(historyConfig.target)) {
          target = isStateId(historyConfig.target) ? (0, _utils.pathToStateValue)(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;
        } else {
          target = historyConfig.target;
        }
      }

      return target;
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.getStates = function (stateValue) {
    var e_5, _a;

    if ((0, _utils.isString)(stateValue)) {
      return [this.states[stateValue]];
    }

    var stateNodes = [];

    try {
      for (var _b = __values((0, _utils.keys)(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;
        stateNodes.push.apply(stateNodes, __spread(this.states[key].getStates(stateValue[key])));
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    return stateNodes;
  };
  /**
   * Returns the leaf nodes from a state path relative to this state node.
   *
   * @param relativeStateId The relative state path to retrieve the state nodes
   * @param history The previous state to retrieve history
   * @param resolve Whether state nodes should resolve to initial child state nodes
   */


  StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {
    if (resolve === void 0) {
      resolve = true;
    }

    if ((0, _utils.isString)(relativeStateId) && isStateId(relativeStateId)) {
      var unresolvedStateNode = this.getStateNodeById(relativeStateId);
      return resolve ? unresolvedStateNode.type === 'history' ? unresolvedStateNode.resolveHistory(historyValue) : unresolvedStateNode.initialStateNodes : [unresolvedStateNode];
    }

    var statePath = (0, _utils.toStatePath)(relativeStateId, this.delimiter);
    var rootStateNode = this.parent || this;
    var unresolvedStateNodes = rootStateNode.getFromRelativePath(statePath, historyValue);

    if (!resolve) {
      return unresolvedStateNodes;
    }

    return (0, _utils.flatten)(unresolvedStateNodes.map(function (stateNode) {
      return stateNode.initialStateNodes;
    }));
  };

  Object.defineProperty(StateNode.prototype, "initialStateNodes", {
    get: function () {
      var _this = this;

      if (this.type === 'atomic' || this.type === 'final') {
        return [this];
      } // Case when state node is compound but no initial state is defined


      if (this.type === 'compound' && !this.initial) {
        if (!_environment.IS_PRODUCTION) {
          (0, _utils.warn)(false, "Compound state node '" + this.id + "' has no initial state.");
        }

        return [this];
      }

      var initialStateNodePaths = (0, _utils.toStatePaths)(this.initialStateValue);
      return (0, _utils.flatten)(initialStateNodePaths.map(function (initialPath) {
        return _this.getFromRelativePath(initialPath);
      }));
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Retrieves state nodes from a relative path to this state node.
   *
   * @param relativePath The relative path from this state node
   * @param historyValue
   */

  StateNode.prototype.getFromRelativePath = function (relativePath, historyValue) {
    if (!relativePath.length) {
      return [this];
    }

    var _a = __read(relativePath),
        stateKey = _a[0],
        childStatePath = _a.slice(1);

    if (!this.states) {
      throw new Error("Cannot retrieve subPath '" + stateKey + "' from node with no states");
    }

    var childStateNode = this.getStateNode(stateKey);

    if (childStateNode.type === 'history') {
      return childStateNode.resolveHistory(historyValue);
    }

    if (!this.states[stateKey]) {
      throw new Error("Child state '" + stateKey + "' does not exist on '" + this.id + "'");
    }

    return this.states[stateKey].getFromRelativePath(childStatePath, historyValue);
  };

  StateNode.prototype.historyValue = function (relativeStateValue) {
    if (!(0, _utils.keys)(this.states).length) {
      return undefined;
    }

    return {
      current: relativeStateValue || this.initialStateValue,
      states: (0, _utils.mapFilterValues)(this.states, function (stateNode, key) {
        if (!relativeStateValue) {
          return stateNode.historyValue();
        }

        var subStateValue = (0, _utils.isString)(relativeStateValue) ? undefined : relativeStateValue[key];
        return stateNode.historyValue(subStateValue || stateNode.initialStateValue);
      }, function (stateNode) {
        return !stateNode.history;
      })
    };
  };
  /**
   * Resolves to the historical value(s) of the parent state node,
   * represented by state nodes.
   *
   * @param historyValue
   */


  StateNode.prototype.resolveHistory = function (historyValue) {
    var _this = this;

    if (this.type !== 'history') {
      return [this];
    }

    var parent = this.parent;

    if (!historyValue) {
      return this.target ? (0, _utils.flatten)((0, _utils.toStatePaths)(this.target).map(function (relativeChildPath) {
        return parent.getFromRelativePath(relativeChildPath);
      })) : parent.initialStateNodes;
    }

    var subHistoryValue = (0, _utils.nestedPath)(parent.path, 'states')(historyValue).current;

    if ((0, _utils.isString)(subHistoryValue)) {
      return [parent.getStateNode(subHistoryValue)];
    }

    return (0, _utils.flatten)((0, _utils.toStatePaths)(subHistoryValue).map(function (subStatePath) {
      return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];
    }));
  };

  Object.defineProperty(StateNode.prototype, "stateIds", {
    /**
     * All the state node IDs of this state node and its descendant state nodes.
     */
    get: function () {
      var _this = this;

      var childStateIds = (0, _utils.flatten)((0, _utils.keys)(this.states).map(function (stateKey) {
        return _this.states[stateKey].stateIds;
      }));
      return [this.id].concat(childStateIds);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "events", {
    /**
     * All the event types accepted by this state node and its descendants.
     */
    get: function () {
      var e_6, _a, e_7, _b;

      if (this.__cache.events) {
        return this.__cache.events;
      }

      var states = this.states;
      var events = new Set(this.ownEvents);

      if (states) {
        try {
          for (var _c = __values((0, _utils.keys)(states)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var stateId = _d.value;
            var state = states[stateId];

            if (state.states) {
              try {
                for (var _e = __values(state.events), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var event_1 = _f.value;
                  events.add("" + event_1);
                }
              } catch (e_7_1) {
                e_7 = {
                  error: e_7_1
                };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                  if (e_7) throw e_7.error;
                }
              }
            }
          }
        } catch (e_6_1) {
          e_6 = {
            error: e_6_1
          };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
          } finally {
            if (e_6) throw e_6.error;
          }
        }
      }

      return this.__cache.events = Array.from(events);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "ownEvents", {
    /**
     * All the events that have transitions directly from this state node.
     *
     * Excludes any inert events.
     */
    get: function () {
      var _this = this;

      var events = new Set((0, _utils.keys)(this.on).filter(function (key) {
        var transitions = _this.on[key];
        return transitions.some(function (transition) {
          return !(!transition.target && !transition.actions.length && transition.internal);
        });
      }));
      return Array.from(events);
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.formatTransition = function (target, transitionConfig, event) {
    var _this = this;

    var internal = transitionConfig ? transitionConfig.internal : undefined;
    var targets = (0, _utils.toArray)(target);
    var guards = this.machine.options.guards; // Format targets to their full string path

    var formattedTargets = targets.map(function (_target) {
      if (!(0, _utils.isString)(_target)) {
        return "#" + _target.id;
      }

      var isInternalTarget = _target[0] === _this.delimiter;
      internal = internal === undefined ? isInternalTarget : internal; // If internal target is defined on machine,
      // do not include machine key on target

      if (isInternalTarget && !_this.parent) {
        return "#" + _this.getStateNodeByPath(_target.slice(1)).id;
      }

      var resolvedTarget = isInternalTarget ? _this.key + _target : "" + _target;

      if (_this.parent) {
        try {
          var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);

          return "#" + targetStateNode.id;
        } catch (err) {
          throw new Error("Invalid transition for state node '" + _this.id + "' on event '" + event + "':\n" + err.message);
        }
      } else {
        return "#" + _this.getStateNodeByPath(resolvedTarget).id;
      }
    });

    if (transitionConfig === undefined) {
      return {
        target: target === undefined ? undefined : formattedTargets,
        source: this,
        actions: [],
        internal: target === undefined || internal,
        event: event
      };
    } // Check if there is no target (targetless)
    // An undefined transition signals that the state node should not transition from that event.


    var isTargetless = target === undefined || target === TARGETLESS_KEY;
    return __assign({}, transitionConfig, {
      actions: (0, _actions.toActionObjects)((0, _utils.toArray)(transitionConfig.actions)),
      cond: (0, _utils.toGuard)(transitionConfig.cond, guards),
      target: isTargetless ? undefined : formattedTargets,
      source: this,
      internal: isTargetless && internal === undefined || internal,
      event: event
    });
  };

  StateNode.prototype.formatTransitions = function () {
    var _this = this;

    var _a, e_8, _b;

    var onConfig = this.config.on || EMPTY_OBJECT;
    var doneConfig = this.config.onDone ? (_a = {}, _a["" + (0, _actions.done)(this.id)] = this.config.onDone, _a) : undefined;
    var invokeConfig = this.invoke.reduce(function (acc, invokeDef) {
      if (invokeDef.onDone) {
        acc[(0, _actions.doneInvoke)(invokeDef.id)] = invokeDef.onDone;
      }

      if (invokeDef.onError) {
        acc[(0, _actions.error)(invokeDef.id)] = invokeDef.onError;
      }

      return acc;
    }, {});
    var delayedTransitions = this.after;
    var formattedTransitions = (0, _utils.mapValues)(__assign({}, onConfig, doneConfig, invokeConfig), function (value, event) {
      var e_9, _a;

      if (value === undefined) {
        return [{
          target: undefined,
          event: event,
          actions: [],
          internal: true
        }];
      }

      if ((0, _utils.isArray)(value)) {
        return value.map(function (targetTransitionConfig) {
          return _this.formatTransition(targetTransitionConfig.target, targetTransitionConfig, event);
        });
      }

      if ((0, _utils.isString)(value) || (0, _utils.isMachine)(value)) {
        return [_this.formatTransition([value], undefined, event)];
      }

      if (!_environment.IS_PRODUCTION) {
        try {
          for (var _b = __values((0, _utils.keys)(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;

            if (['target', 'actions', 'internal', 'in', 'cond', 'event'].indexOf(key) === -1) {
              throw new Error( // tslint:disable-next-line:max-line-length
              "State object mapping of transitions is deprecated. Check the config for event '" + event + "' on state '" + _this.id + "'.");
            }
          }
        } catch (e_9_1) {
          e_9 = {
            error: e_9_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_9) throw e_9.error;
          }
        }
      }

      return [_this.formatTransition(value.target, value, event)];
    });

    try {
      for (var delayedTransitions_1 = __values(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {
        var delayedTransition = delayedTransitions_1_1.value;
        formattedTransitions[delayedTransition.event] = formattedTransitions[delayedTransition.event] || [];
        formattedTransitions[delayedTransition.event].push(delayedTransition);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_b = delayedTransitions_1.return)) _b.call(delayedTransitions_1);
      } finally {
        if (e_8) throw e_8.error;
      }
    }

    return formattedTransitions;
  };

  return StateNode;
}();

exports.StateNode = StateNode;
},{"./utils":"node_modules/xstate/es/utils.js","./types":"node_modules/xstate/es/types.js","./State":"node_modules/xstate/es/State.js","./actionTypes":"node_modules/xstate/es/actionTypes.js","./actions":"node_modules/xstate/es/actions.js","./StateTree":"node_modules/xstate/es/StateTree.js","./environment":"node_modules/xstate/es/environment.js","./constants":"node_modules/xstate/es/constants.js","./stateUtils":"node_modules/xstate/es/stateUtils.js"}],"node_modules/xstate/es/Machine.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Machine = Machine;

var _StateNode = require("./StateNode");

function Machine(config, options, initialContext) {
  if (initialContext === void 0) {
    initialContext = config.context;
  }

  return new _StateNode.StateNode(config, options, initialContext);
}
},{"./StateNode":"node_modules/xstate/es/StateNode.js"}],"node_modules/xstate/es/scheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scheduler = void 0;

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var defaultOptions = {
  deferEvents: false
};

var Scheduler =
/** @class */

/*#__PURE__*/
function () {
  function Scheduler(options) {
    this.processingEvent = false;
    this.queue = [];
    this.initialized = false;
    this.options = __assign({}, defaultOptions, options);
  }

  Scheduler.prototype.initialize = function (callback) {
    this.initialized = true;

    if (callback) {
      if (!this.options.deferEvents) {
        this.schedule(callback);
        return;
      }

      this.process(callback);
    }

    this.flushEvents();
  };

  Scheduler.prototype.schedule = function (task) {
    if (!this.initialized || this.processingEvent) {
      this.queue.push(task);
      return;
    }

    if (this.queue.length !== 0) {
      throw new Error('Event queue should be empty when it is not processing events');
    }

    this.process(task);
    this.flushEvents();
  };

  Scheduler.prototype.flushEvents = function () {
    var nextCallback = this.queue.shift();

    while (nextCallback) {
      this.process(nextCallback);
      nextCallback = this.queue.shift();
    }
  };

  Scheduler.prototype.process = function (callback) {
    this.processingEvent = true;

    try {
      callback();
    } catch (e) {
      // there is no use to keep the future events
      // as the situation is not anymore the same
      this.queue = [];
      throw e;
    } finally {
      this.processingEvent = false;
    }
  };

  return Scheduler;
}();

exports.Scheduler = Scheduler;
},{}],"node_modules/xstate/es/Actor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isActor = isActor;

function isActor(item) {
  try {
    return typeof item.send === 'function';
  } catch (e) {
    return false;
  }
}
},{}],"node_modules/xstate/es/interpreter.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spawn = spawn;
exports.interpret = interpret;
exports.Interpreter = void 0;

var _types = require("./types");

var _State = require("./State");

var actionTypes = _interopRequireWildcard(require("./actionTypes"));

var _actions = require("./actions");

var _environment = require("./environment");

var _utils = require("./utils");

var _scheduler = require("./scheduler");

var _Actor = require("./Actor");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __values = void 0 && (void 0).__values || function (o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
};

var DEFAULT_SPAWN_OPTIONS = {
  sync: false,
  autoForward: false
};
/**
 * Maintains a stack of the current service in scope.
 * This is used to provide the correct service to spawn().
 *
 * @private
 */

var withServiceScope = /*#__PURE__*/function () {
  var serviceStack = [];
  return function (service, fn) {
    service && serviceStack.push(service);
    var result = fn(service || serviceStack[serviceStack.length - 1]);
    service && serviceStack.pop();
    return result;
  };
}();

var Interpreter =
/** @class */

/*#__PURE__*/
function () {
  /**
   * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
   *
   * @param machine The machine to be interpreted
   * @param options Interpreter options
   */
  function Interpreter(machine, options) {
    var _this = this;

    if (options === void 0) {
      options = Interpreter.defaultOptions;
    }

    this.machine = machine;
    this.scheduler = new _scheduler.Scheduler();
    this.delayedEventsMap = {};
    this.listeners = new Set();
    this.contextListeners = new Set();
    this.stopListeners = new Set();
    this.doneListeners = new Set();
    this.eventListeners = new Set();
    this.sendListeners = new Set();
    /**
     * Whether the service is started.
     */

    this.initialized = false;
    this.children = new Map();
    this.forwardTo = new Set();
    /**
     * Alias for Interpreter.prototype.start
     */

    this.init = this.start;
    /**
     * Sends an event to the running interpreter to trigger a transition.
     *
     * An array of events (batched) can be sent as well, which will send all
     * batched events to the running interpreter. The listeners will be
     * notified only **once** when all events are processed.
     *
     * @param event The event(s) to send
     */

    this.send = function (event, payload) {
      if ((0, _utils.isArray)(event)) {
        _this.batch(event);

        return _this.state;
      }

      var eventObject = (0, _actions.toEventObject)(event, payload);

      if (!_this.initialized && _this.options.deferEvents) {
        // tslint:disable-next-line:no-console
        if (!_environment.IS_PRODUCTION) {
          (0, _utils.warn)(false, "Event \"" + eventObject.type + "\" was sent to uninitialized service \"" + _this.machine.id + "\" and is deferred. Make sure .start() is called for this service.\nEvent: " + JSON.stringify(event));
        }
      } else if (!_this.initialized) {
        throw new Error("Event \"" + eventObject.type + "\" was sent to uninitialized service \"" + _this.machine.id + "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: " + JSON.stringify(eventObject));
      }

      _this.scheduler.schedule(function () {
        var nextState = _this.nextState(eventObject);

        _this.update(nextState, eventObject); // Forward copy of event to child interpreters


        _this.forward(eventObject);
      });

      return _this.state; // TODO: deprecate (should return void)
      // tslint:disable-next-line:semicolon
    };

    this.sendTo = function (event, to) {
      var isParent = to === _types.SpecialTargets.Parent;
      var target = isParent ? _this.parent : (0, _Actor.isActor)(to) ? to : _this.children.get(to);

      if (!target) {
        if (!isParent) {
          throw new Error("Unable to send event to child '" + to + "' from service '" + _this.id + "'.");
        } // tslint:disable-next-line:no-console


        if (!_environment.IS_PRODUCTION) {
          (0, _utils.warn)(false, "Service '" + _this.id + "' has no parent: unable to send event " + event.type);
        }

        return;
      }

      target.send(event);
    };

    var resolvedOptions = __assign({}, Interpreter.defaultOptions, options);

    var clock = resolvedOptions.clock,
        logger = resolvedOptions.logger,
        parent = resolvedOptions.parent,
        id = resolvedOptions.id;
    var resolvedId = id !== undefined ? id : machine.id;
    this.id = resolvedId;
    this.logger = logger;
    this.clock = clock;
    this.parent = parent;
    this.options = resolvedOptions;
    this.scheduler = new _scheduler.Scheduler({
      deferEvents: this.options.deferEvents
    });
    this.initialState = this.state = withServiceScope(this, function () {
      return _this.machine.initialState;
    });
  }
  /**
   * Executes the actions of the given state, with that state's `context` and `event`.
   *
   * @param state The state whose actions will be executed
   * @param actionsConfig The action implementations to use
   */


  Interpreter.prototype.execute = function (state, actionsConfig) {
    var e_1, _a;

    try {
      for (var _b = __values(state.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var action = _c.value;
        this.exec(action, state.context, state.event, actionsConfig);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  Interpreter.prototype.update = function (state, event) {
    var e_2, _a, e_3, _b, e_4, _c, e_5, _d; // Update state


    this.state = state; // Execute actions

    if (this.options.execute) {
      this.execute(this.state);
    } // Dev tools


    if (this.devTools) {
      this.devTools.send(event, state);
    } // Execute listeners


    if (state.event) {
      try {
        for (var _e = __values(this.eventListeners), _f = _e.next(); !_f.done; _f = _e.next()) {
          var listener = _f.value;
          listener(state.event);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    }

    try {
      for (var _g = __values(this.listeners), _h = _g.next(); !_h.done; _h = _g.next()) {
        var listener = _h.value;
        listener(state, state.event);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    try {
      for (var _j = __values(this.contextListeners), _k = _j.next(); !_k.done; _k = _j.next()) {
        var contextListener = _k.value;
        contextListener(this.state.context, this.state.history ? this.state.history.context : undefined);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    if (this.state.tree && this.state.tree.done) {
      // get donedata
      var doneData = this.state.tree.getDoneData(this.state.context, (0, _actions.toEventObject)(event));

      try {
        for (var _l = __values(this.doneListeners), _m = _l.next(); !_m.done; _m = _l.next()) {
          var listener = _m.value;
          listener((0, _actions.doneInvoke)(this.id, doneData));
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      this.stop();
    }
  };
  /*
   * Adds a listener that is notified whenever a state transition happens. The listener is called with
   * the next state and the event object that caused the state transition.
   *
   * @param listener The state listener
   */


  Interpreter.prototype.onTransition = function (listener) {
    this.listeners.add(listener);
    return this;
  };

  Interpreter.prototype.subscribe = function (nextListener, // @ts-ignore
  errorListener, completeListener) {
    var _this = this;

    if (nextListener) {
      this.onTransition(nextListener);
    }

    if (completeListener) {
      this.onDone(completeListener);
    }

    return {
      unsubscribe: function () {
        nextListener && _this.listeners.delete(nextListener);
        completeListener && _this.doneListeners.delete(completeListener);
      }
    };
  };
  /**
   * Adds an event listener that is notified whenever an event is sent to the running interpreter.
   * @param listener The event listener
   */


  Interpreter.prototype.onEvent = function (listener) {
    this.eventListeners.add(listener);
    return this;
  };
  /**
   * Adds an event listener that is notified whenever a `send` event occurs.
   * @param listener The event listener
   */


  Interpreter.prototype.onSend = function (listener) {
    this.sendListeners.add(listener);
    return this;
  };
  /**
   * Adds a context listener that is notified whenever the state context changes.
   * @param listener The context listener
   */


  Interpreter.prototype.onChange = function (listener) {
    this.contextListeners.add(listener);
    return this;
  };
  /**
   * Adds a listener that is notified when the machine is stopped.
   * @param listener The listener
   */


  Interpreter.prototype.onStop = function (listener) {
    this.stopListeners.add(listener);
    return this;
  };
  /**
   * Adds a state listener that is notified when the statechart has reached its final state.
   * @param listener The state listener
   */


  Interpreter.prototype.onDone = function (listener) {
    this.doneListeners.add(listener);
    return this;
  };
  /**
   * Removes a listener.
   * @param listener The listener to remove
   */


  Interpreter.prototype.off = function (listener) {
    this.listeners.delete(listener);
    this.eventListeners.delete(listener);
    this.sendListeners.delete(listener);
    this.stopListeners.delete(listener);
    this.doneListeners.delete(listener);
    this.contextListeners.delete(listener);
    return this;
  };
  /**
   * Starts the interpreter from the given state, or the initial state.
   * @param initialState The state to start the statechart from
   */


  Interpreter.prototype.start = function (initialState) {
    var _this = this;

    if (this.initialized) {
      // Do not restart the service if it is already started
      return this;
    }

    this.initialized = true;
    var resolvedState = withServiceScope(this, function () {
      return initialState === undefined ? _this.machine.initialState : initialState instanceof _State.State ? _this.machine.resolveState(initialState) : _this.machine.resolveState(_State.State.from(initialState));
    });

    if (this.options.devTools) {
      this.attachDev();
    }

    this.scheduler.initialize(function () {
      _this.update(resolvedState, {
        type: actionTypes.init
      });
    });
    return this;
  };
  /**
   * Stops the interpreter and unsubscribe all listeners.
   *
   * This will also notify the `onStop` listeners.
   */


  Interpreter.prototype.stop = function () {
    var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;

    try {
      for (var _f = __values(this.listeners), _g = _f.next(); !_g.done; _g = _f.next()) {
        var listener = _g.value;
        this.listeners.delete(listener);
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    try {
      for (var _h = __values(this.stopListeners), _j = _h.next(); !_j.done; _j = _h.next()) {
        var listener = _j.value; // call listener, then remove

        listener();
        this.stopListeners.delete(listener);
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    try {
      for (var _k = __values(this.contextListeners), _l = _k.next(); !_l.done; _l = _k.next()) {
        var listener = _l.value;
        this.contextListeners.delete(listener);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
      } finally {
        if (e_8) throw e_8.error;
      }
    }

    try {
      for (var _m = __values(this.doneListeners), _o = _m.next(); !_o.done; _o = _m.next()) {
        var listener = _o.value;
        this.doneListeners.delete(listener);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
      } finally {
        if (e_9) throw e_9.error;
      }
    } // Stop all children


    this.children.forEach(function (child) {
      if ((0, _utils.isFunction)(child.stop)) {
        child.stop();
      }
    });

    try {
      // Cancel all delayed events
      for (var _p = __values((0, _utils.keys)(this.delayedEventsMap)), _q = _p.next(); !_q.done; _q = _p.next()) {
        var key = _q.value;
        this.clock.clearTimeout(this.delayedEventsMap[key]);
      }
    } catch (e_10_1) {
      e_10 = {
        error: e_10_1
      };
    } finally {
      try {
        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
      } finally {
        if (e_10) throw e_10.error;
      }
    }

    this.initialized = false;
    return this;
  };

  Interpreter.prototype.batch = function (events) {
    var _this = this;

    if (!this.initialized && this.options.deferEvents) {
      // tslint:disable-next-line:no-console
      if (!_environment.IS_PRODUCTION) {
        (0, _utils.warn)(false, events.length + " event(s) were sent to uninitialized service \"" + this.machine.id + "\" and are deferred. Make sure .start() is called for this service.\nEvent: " + JSON.stringify(event));
      }
    } else if (!this.initialized) {
      throw new Error( // tslint:disable-next-line:max-line-length
      events.length + " event(s) were sent to uninitialized service \"" + this.machine.id + "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.");
    }

    this.scheduler.schedule(function () {
      var e_11, _a, _b;

      var nextState = _this.state;

      try {
        for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var event_1 = events_1_1.value;
          var changed = nextState.changed;
          var eventObject = (0, _actions.toEventObject)(event_1);
          var actions = nextState.actions.map(function (a) {
            return (0, _utils.bindActionToState)(a, nextState);
          });
          nextState = _this.machine.transition(nextState, eventObject);

          (_b = nextState.actions).unshift.apply(_b, __spread(actions));

          nextState.changed = nextState.changed || !!changed;

          _this.forward(eventObject);
        }
      } catch (e_11_1) {
        e_11 = {
          error: e_11_1
        };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
        } finally {
          if (e_11) throw e_11.error;
        }
      }

      _this.update(nextState, (0, _actions.toEventObject)(events[events.length - 1]));
    });
  };
  /**
   * Returns a send function bound to this interpreter instance.
   *
   * @param event The event to be sent by the sender.
   */


  Interpreter.prototype.sender = function (event) {
    return this.send.bind(this, event);
  };
  /**
   * Returns the next state given the interpreter's current state and the event.
   *
   * This is a pure method that does _not_ update the interpreter's state.
   *
   * @param event The event to determine the next state
   */


  Interpreter.prototype.nextState = function (event) {
    var _this = this;

    var eventObject = (0, _actions.toEventObject)(event);

    if (eventObject.type.indexOf(actionTypes.errorPlatform) === 0 && !this.state.nextEvents.some(function (nextEvent) {
      return nextEvent.indexOf(actionTypes.errorPlatform) === 0;
    })) {
      throw eventObject.data;
    }

    var nextState = withServiceScope(this, function () {
      return _this.machine.transition(_this.state, eventObject, _this.state.context);
    });
    return nextState;
  };

  Interpreter.prototype.forward = function (event) {
    var e_12, _a;

    try {
      for (var _b = __values(this.forwardTo), _c = _b.next(); !_c.done; _c = _b.next()) {
        var id = _c.value;
        var child = this.children.get(id);

        if (!child) {
          throw new Error("Unable to forward event '" + event + "' from interpreter '" + this.id + "' to nonexistant child '" + id + "'.");
        }

        child.send(event);
      }
    } catch (e_12_1) {
      e_12 = {
        error: e_12_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_12) throw e_12.error;
      }
    }
  };

  Interpreter.prototype.defer = function (sendAction) {
    var _this = this;

    var delay = sendAction.delay;

    if ((0, _utils.isString)(delay)) {
      if (!this.machine.options.delays || this.machine.options.delays[delay] === undefined) {
        // tslint:disable-next-line:no-console
        if (!_environment.IS_PRODUCTION) {
          (0, _utils.warn)(false, // tslint:disable-next-line:max-line-length
          "No delay reference for delay expression '" + delay + "' was found on machine '" + this.machine.id + "' on service '" + this.id + "'.");
        } // Do not send anything


        return;
      } else {
        var delayExpr = this.machine.options.delays[delay];
        delay = typeof delayExpr === 'number' ? delayExpr : delayExpr(this.state.context, this.state.event);
      }
    }

    this.delayedEventsMap[sendAction.id] = this.clock.setTimeout(function () {
      if (sendAction.to) {
        _this.sendTo(sendAction.event, sendAction.to);
      } else {
        _this.send(sendAction.event);
      }
    }, delay || 0);
  };

  Interpreter.prototype.cancel = function (sendId) {
    this.clock.clearTimeout(this.delayedEventsMap[sendId]);
    delete this.delayedEventsMap[sendId];
  };

  Interpreter.prototype.exec = function (action, context, event, actionFunctionMap) {
    var actionOrExec = (0, _actions.getActionFunction)(action.type, actionFunctionMap) || action.exec;
    var exec = (0, _utils.isFunction)(actionOrExec) ? actionOrExec : actionOrExec ? actionOrExec.exec : action.exec;

    if (exec) {
      // @ts-ignore (TODO: fix for TypeDoc)
      return exec(context, event, {
        action: action,
        state: this.state
      });
    }

    switch (action.type) {
      case actionTypes.send:
        var sendAction = action;

        if (sendAction.delay) {
          this.defer(sendAction);
          return;
        } else {
          if (sendAction.to) {
            this.sendTo(sendAction.event, sendAction.to);
          } else {
            this.send(sendAction.event);
          }
        }

        break;

      case actionTypes.cancel:
        this.cancel(action.sendId);
        break;

      case actionTypes.start:
        {
          var activity = action.activity; // If the activity will be stopped right after it's started
          // (such as in transient states)
          // don't bother starting the activity.

          if (!this.state.activities[activity.type]) {
            break;
          } // Invoked services


          if (activity.type === _types.ActionTypes.Invoke) {
            var serviceCreator = this.machine.options.services ? this.machine.options.services[activity.src] : undefined;
            var id = activity.id,
                data = activity.data;

            if (!_environment.IS_PRODUCTION) {
              (0, _utils.warn)(!('forward' in activity), // tslint:disable-next-line:max-line-length
              "`forward` property is deprecated (found in invocation of '" + activity.src + "' in in machine '" + this.machine.id + "'). " + "Please use `autoForward` instead.");
            }

            var autoForward = 'autoForward' in activity ? activity.autoForward : !!activity.forward;

            if (!serviceCreator) {
              // tslint:disable-next-line:no-console
              if (!_environment.IS_PRODUCTION) {
                (0, _utils.warn)(false, "No service found for invocation '" + activity.src + "' in machine '" + this.machine.id + "'.");
              }

              return;
            }

            var source = (0, _utils.isFunction)(serviceCreator) ? serviceCreator(context, event) : serviceCreator;

            if ((0, _utils.isPromiseLike)(source)) {
              this.spawnPromise(Promise.resolve(source), id);
            } else if ((0, _utils.isFunction)(source)) {
              this.spawnCallback(source, id);
            } else if ((0, _utils.isObservable)(source)) {
              this.spawnObservable(source, id);
            } else if ((0, _utils.isMachine)(source)) {
              // TODO: try/catch here
              this.spawnMachine(data ? source.withContext((0, _utils.mapContext)(data, context, event)) : source, {
                id: id,
                autoForward: autoForward
              });
            } else {// service is string
            }
          } else {
            this.spawnActivity(activity);
          }

          break;
        }

      case actionTypes.stop:
        {
          this.stopChild(action.activity.id);
          break;
        }

      case actionTypes.log:
        var expr = action.expr ? action.expr(context, event) : undefined;

        if (action.label) {
          this.logger(action.label, expr);
        } else {
          this.logger(expr);
        }

        break;

      default:
        if (!_environment.IS_PRODUCTION) {
          (0, _utils.warn)(false, "No implementation found for action type '" + action.type + "'");
        }

        break;
    }

    return undefined;
  };

  Interpreter.prototype.stopChild = function (childId) {
    var child = this.children.get(childId);

    if (!child) {
      return;
    }

    this.children.delete(childId);
    this.forwardTo.delete(childId);

    if ((0, _utils.isFunction)(child.stop)) {
      child.stop();
    }
  };

  Interpreter.prototype.spawn = function (entity, name, options) {
    if ((0, _utils.isPromiseLike)(entity)) {
      return this.spawnPromise(Promise.resolve(entity), name);
    } else if ((0, _utils.isFunction)(entity)) {
      return this.spawnCallback(entity, name);
    } else if ((0, _utils.isObservable)(entity)) {
      return this.spawnObservable(entity, name);
    } else if ((0, _utils.isMachine)(entity)) {
      return this.spawnMachine(entity, __assign({}, options, {
        id: name
      }));
    } else {
      throw new Error("Unable to spawn entity \"" + name + "\" of type \"" + typeof entity + "\".");
    }
  };

  Interpreter.prototype.spawnMachine = function (machine, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    var childService = new Interpreter(machine, __assign({}, this.options, {
      parent: this,
      id: options.id || machine.id
    }));

    var resolvedOptions = __assign({}, DEFAULT_SPAWN_OPTIONS, options);

    if (resolvedOptions.sync) {
      childService.onTransition(function (state) {
        _this.send(actionTypes.update, {
          state: state,
          id: childService.id
        });
      });
    }

    childService.onDone(function (doneEvent) {
      _this.send(doneEvent);
    }).start();
    var actor = childService; // const actor = {
    //   id: childService.id,
    //   send: childService.send,
    //   state: childService.state,
    //   subscribe: childService.subscribe,
    //   toJSON() {
    //     return { id: childService.id };
    //   }
    // } as Actor<State<TChildContext, TChildEvents>>;

    this.children.set(childService.id, actor);

    if (resolvedOptions.autoForward) {
      this.forwardTo.add(childService.id);
    }

    return actor;
  };

  Interpreter.prototype.spawnPromise = function (promise, id) {
    var _this = this;

    var canceled = false;
    promise.then(function (response) {
      if (!canceled) {
        _this.send((0, _actions.doneInvoke)(id, response));
      }
    }, function (errorData) {
      if (!canceled) {
        var errorEvent = (0, _actions.error)(id, errorData);

        try {
          // Send "error.execution" to this (parent).
          _this.send(errorEvent);
        } catch (error) {
          _this.reportUnhandledExceptionOnInvocation(errorData, error, id);

          if (_this.devTools) {
            _this.devTools.send(errorEvent, _this.state);
          }

          if (_this.machine.strict) {
            // it would be better to always stop the state machine if unhandled
            // exception/promise rejection happens but because we don't want to
            // break existing code so enforce it on strict mode only especially so
            // because documentation says that onError is optional
            _this.stop();
          }
        }
      }
    });
    var actor = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        var unsubscribed = false;
        promise.then(function (response) {
          if (unsubscribed) {
            return;
          }

          next && next(response);

          if (unsubscribed) {
            return;
          }

          complete && complete();
        }, function (err) {
          if (unsubscribed) {
            return;
          }

          handleError(err);
        });
        return {
          unsubscribe: function () {
            return unsubscribed = true;
          }
        };
      },
      stop: function () {
        canceled = true;
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    };
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnCallback = function (callback, id) {
    var _this = this;

    var canceled = false;

    var receive = function (e) {
      if (canceled) {
        return;
      }

      _this.send(e);
    };

    var listeners = new Set();
    var callbackStop;

    try {
      callbackStop = callback(receive, function (newListener) {
        listeners.add(newListener);
      });
    } catch (err) {
      this.send((0, _actions.error)(id, err));
    }

    if ((0, _utils.isPromiseLike)(callbackStop)) {
      // it turned out to be an async function, can't reliably check this before calling `callback`
      // because transpiled async functions are not recognizable
      return this.spawnPromise(callbackStop, id);
    }

    var actor = {
      id: id,
      send: function (event) {
        return listeners.forEach(function (listener) {
          return listener(event);
        });
      },
      subscribe: function (next) {
        listeners.add(next);
        return {
          unsubscribe: function () {
            listeners.delete(next);
          }
        };
      },
      stop: function () {
        canceled = true;

        if ((0, _utils.isFunction)(callbackStop)) {
          callbackStop();
        }
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    };
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnObservable = function (source, id) {
    var _this = this;

    var subscription = source.subscribe(function (value) {
      _this.send(value);
    }, function (err) {
      _this.send((0, _actions.error)(id, err));
    }, function () {
      _this.send((0, _actions.doneInvoke)(id));
    });
    var actor = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        return source.subscribe(next, handleError, complete);
      },
      stop: function () {
        return subscription.unsubscribe();
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    };
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnActivity = function (activity) {
    var implementation = this.machine.options && this.machine.options.activities ? this.machine.options.activities[activity.type] : undefined;

    if (!implementation) {
      // tslint:disable-next-line:no-console
      if (!_environment.IS_PRODUCTION) {
        (0, _utils.warn)(false, "No implementation found for activity '" + activity.type + "'");
      }

      return;
    } // Start implementation


    var dispose = implementation(this.state.context, activity);
    this.spawnEffect(activity.id, dispose);
  };

  Interpreter.prototype.spawnEffect = function (id, dispose) {
    this.children.set(id, {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function () {
        return {
          unsubscribe: function () {
            return void 0;
          }
        };
      },
      stop: dispose || undefined,
      toJSON: function () {
        return {
          id: id
        };
      }
    });
  };

  Interpreter.prototype.reportUnhandledExceptionOnInvocation = function (originalError, currentError, id) {
    if (!_environment.IS_PRODUCTION) {
      var originalStackTrace = originalError.stack ? " Stacktrace was '" + originalError.stack + "'" : '';

      if (originalError === currentError) {
        // tslint:disable-next-line:no-console
        console.error("Missing onError handler for invocation '" + id + "', error was '" + originalError + "'." + originalStackTrace);
      } else {
        var stackTrace = currentError.stack ? " Stacktrace was '" + currentError.stack + "'" : ''; // tslint:disable-next-line:no-console

        console.error("Missing onError handler and/or unhandled exception/promise rejection for invocation '" + id + "'. " + ("Original error: '" + originalError + "'. " + originalStackTrace + " Current error is '" + currentError + "'." + stackTrace));
      }
    }
  };

  Interpreter.prototype.attachDev = function () {
    if (this.options.devTools && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__) {
      var devToolsOptions = typeof this.options.devTools === 'object' ? this.options.devTools : undefined;
      this.devTools = window.__REDUX_DEVTOOLS_EXTENSION__.connect(__assign({
        name: this.id,
        autoPause: true,
        stateSanitizer: function (state) {
          return {
            value: state.value,
            context: state.context,
            actions: state.actions
          };
        }
      }, devToolsOptions, {
        features: __assign({
          jump: false,
          skip: false
        }, devToolsOptions ? devToolsOptions.features : undefined)
      }));
      this.devTools.init(this.state);
    }
  };

  Interpreter.prototype.toJSON = function () {
    return {
      id: this.id
    };
  };
  /**
   * The default interpreter options:
   *
   * - `clock` uses the global `setTimeout` and `clearTimeout` functions
   * - `logger` uses the global `console.log()` method
   */


  Interpreter.defaultOptions = /*#__PURE__*/function (global) {
    return {
      execute: true,
      deferEvents: true,
      clock: {
        setTimeout: function (fn, ms) {
          return global.setTimeout.call(null, fn, ms);
        },
        clearTimeout: function (id) {
          return global.clearTimeout.call(null, id);
        }
      },
      logger: global.console.log.bind(console),
      devTools: false
    };
  }(typeof window === 'undefined' ? global : window);

  Interpreter.interpret = interpret;
  return Interpreter;
}();

exports.Interpreter = Interpreter;

var createNullActor = function (name) {
  if (name === void 0) {
    name = 'null';
  }

  return {
    id: name,
    send: function () {
      return void 0;
    },
    subscribe: function () {
      // tslint:disable-next-line:no-empty
      return {
        unsubscribe: function () {}
      };
    },
    toJSON: function () {
      return {
        id: name
      };
    }
  };
};

var resolveSpawnOptions = function (nameOrOptions) {
  if ((0, _utils.isString)(nameOrOptions)) {
    return __assign({}, DEFAULT_SPAWN_OPTIONS, {
      name: nameOrOptions
    });
  }

  return __assign({}, DEFAULT_SPAWN_OPTIONS, {
    name: (0, _utils.uniqueId)()
  }, nameOrOptions);
};

function spawn(entity, nameOrOptions) {
  var resolvedOptions = resolveSpawnOptions(nameOrOptions);
  return withServiceScope(undefined, function (service) {
    if (!_environment.IS_PRODUCTION) {
      (0, _utils.warn)(!!service, "Attempted to spawn an Actor (ID: \"" + ((0, _utils.isMachine)(entity) ? entity.id : 'undefined') + "\") outside of a service. This will have no effect.");
    }

    if (service) {
      return service.spawn(entity, resolvedOptions.name, resolvedOptions);
    } else {
      return createNullActor(resolvedOptions.name);
    }
  });
}
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to interpret
 * @param options Interpreter options
 */


function interpret(machine, options) {
  var interpreter = new Interpreter(machine, options);
  return interpreter;
}
},{"./types":"node_modules/xstate/es/types.js","./State":"node_modules/xstate/es/State.js","./actionTypes":"node_modules/xstate/es/actionTypes.js","./actions":"node_modules/xstate/es/actions.js","./environment":"node_modules/xstate/es/environment.js","./utils":"node_modules/xstate/es/utils.js","./scheduler":"node_modules/xstate/es/scheduler.js","./Actor":"node_modules/xstate/es/Actor.js"}],"node_modules/xstate/es/match.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchState = matchState;

var _State = require("./State");

var __values = void 0 && (void 0).__values || function (o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

function matchState(state, patterns, defaultValue) {
  var e_1, _a;

  var resolvedState = _State.State.from(state, state instanceof _State.State ? state.context : undefined);

  try {
    for (var patterns_1 = __values(patterns), patterns_1_1 = patterns_1.next(); !patterns_1_1.done; patterns_1_1 = patterns_1.next()) {
      var _b = __read(patterns_1_1.value, 2),
          stateValue = _b[0],
          getValue = _b[1];

      if (resolvedState.matches(stateValue)) {
        return getValue(resolvedState);
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (patterns_1_1 && !patterns_1_1.done && (_a = patterns_1.return)) _a.call(patterns_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return defaultValue(resolvedState);
}
},{"./State":"node_modules/xstate/es/State.js"}],"node_modules/xstate/es/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  actions: true,
  matchesState: true,
  mapState: true,
  StateNode: true,
  State: true,
  Machine: true,
  send: true,
  sendParent: true,
  assign: true,
  interpret: true,
  Interpreter: true,
  spawn: true,
  matchState: true
};
Object.defineProperty(exports, "matchesState", {
  enumerable: true,
  get: function () {
    return _utils.matchesState;
  }
});
Object.defineProperty(exports, "mapState", {
  enumerable: true,
  get: function () {
    return _mapState.mapState;
  }
});
Object.defineProperty(exports, "StateNode", {
  enumerable: true,
  get: function () {
    return _StateNode.StateNode;
  }
});
Object.defineProperty(exports, "State", {
  enumerable: true,
  get: function () {
    return _State.State;
  }
});
Object.defineProperty(exports, "Machine", {
  enumerable: true,
  get: function () {
    return _Machine.Machine;
  }
});
Object.defineProperty(exports, "send", {
  enumerable: true,
  get: function () {
    return _actions.send;
  }
});
Object.defineProperty(exports, "sendParent", {
  enumerable: true,
  get: function () {
    return _actions.sendParent;
  }
});
Object.defineProperty(exports, "assign", {
  enumerable: true,
  get: function () {
    return _actions.assign;
  }
});
Object.defineProperty(exports, "interpret", {
  enumerable: true,
  get: function () {
    return _interpreter.interpret;
  }
});
Object.defineProperty(exports, "Interpreter", {
  enumerable: true,
  get: function () {
    return _interpreter.Interpreter;
  }
});
Object.defineProperty(exports, "spawn", {
  enumerable: true,
  get: function () {
    return _interpreter.spawn;
  }
});
Object.defineProperty(exports, "matchState", {
  enumerable: true,
  get: function () {
    return _match.matchState;
  }
});
exports.actions = void 0;

var _utils = require("./utils");

var _mapState = require("./mapState");

var _StateNode = require("./StateNode");

var _State = require("./State");

var _Machine = require("./Machine");

var _actions = require("./actions");

var _interpreter = require("./interpreter");

var _match = require("./match");

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
var actions = {
  raise: _actions.raise,
  send: _actions.send,
  sendParent: _actions.sendParent,
  log: _actions.log,
  cancel: _actions.cancel,
  start: _actions.start,
  stop: _actions.stop,
  assign: _actions.assign,
  after: _actions.after,
  done: _actions.done
};
exports.actions = actions;
},{"./utils":"node_modules/xstate/es/utils.js","./mapState":"node_modules/xstate/es/mapState.js","./StateNode":"node_modules/xstate/es/StateNode.js","./State":"node_modules/xstate/es/State.js","./Machine":"node_modules/xstate/es/Machine.js","./actions":"node_modules/xstate/es/actions.js","./interpreter":"node_modules/xstate/es/interpreter.js","./match":"node_modules/xstate/es/match.js","./types":"node_modules/xstate/es/types.js"}],"play.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = gamePlay;

function gamePlay(answer, userAnswer) {
  return new Promise(function (resolve, reject) {
    console.log("playing...");
    console.log(answer);
    console.log(userAnswer);
    setTimeout(function () {
      //Timed play!
      //If we win before:
      if (answer === userAnswer) return resolve("You won!"); //Otherwise:

      return reject("You lost!");
    }, 1000); //5 seconds
  });
}
},{}],"stateMachine.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stateMachine = void 0;

var _xstate = require("xstate");

var _play = _interopRequireDefault(require("./play.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var stateMachine = (0, _xstate.Machine)({
  initial: "waiting",
  context: {
    //How we save the letters accepted
    answer: "",
    userAnswer: ""
  },
  states: {
    waiting: {
      on: {
        SUBMIT: "start"
      }
    },
    start: {
      invoke: {
        id: "play",
        src: function src(context, event) {
          var answer = context.answer,
              userAnswer = context.userAnswer;
          (0, _play.default)(answer, userAnswer);
        },
        onDone: {
          target: "endGame"
        },
        onError: {
          //Not sure 
          target: "endGame"
        }
      }
    },
    endGame: {
      type: "final"
    }
  },
  on: {
    INPUT_CHANGE: {
      //Event that updates the context aka answer and user answer
      actions: (0, _xstate.assign)(function (context, event) {
        console.log(event);
        return _defineProperty({}, event.name, event.value);
      })
    }
  }
});
exports.stateMachine = stateMachine;
},{"xstate":"node_modules/xstate/es/index.js","./play.js":"play.js"}],"utils/gamePlay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gameOn = gameOn;
exports.startCountdown = startCountdown;
exports.service = exports.userAnswer = exports.testString = void 0;

var _xstate = require("xstate");

var _stateMachine = require("../stateMachine.js");

//Gameplay
var testString = "YMCA";
exports.testString = testString;
var userAnswer = "";
exports.userAnswer = userAnswer;
var service;
exports.service = service;

function gameOn() {
  exports.service = service = (0, _xstate.interpret)(_stateMachine.stateMachine).start();
  service.send("SUBMIT");
  console.log("Submitting");
  service.onTransition(function (current) {
    console.log("transition");
    console.log(current);
  }); // document.getElementById('startButton').addEventListener('click', function () {
  //     // function handleSubmit () {
  //       console.log(stateMachine.states);
  //       console.log("Submitting");
  //       service.send("SUBMIT");
  //     // }
  //   }); 
}

function startCountdown() {
  var timeleft = 10;
  var downloadTimer = setInterval(function () {
    if (timeleft <= 0) {
      clearInterval(downloadTimer);
    }

    document.getElementById("progressBar").value = 10 - timeleft;
    timeleft -= 1;
  }, 1000);
}
},{"xstate":"node_modules/xstate/es/index.js","../stateMachine.js":"stateMachine.js"}],"utils/readyState.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.allSet = exports.readyState = void 0;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var readyState = 'NOT_READY';
exports.readyState = readyState;

var allSet = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            exports.readyState = readyState = "READY";
            return _context.abrupt("return", Promise.resolve());

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function allSet() {
    return _ref.apply(this, arguments);
  };
}();

exports.allSet = allSet;
},{}],"node_modules/easytimer.js/dist/easytimer.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/**
 * easytimer.js
 * Generated: 2021-03-16
 * Version: 4.3.4
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.easytimer = {}));
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function leftPadding(string, padLength, character) {
    var i;
    var characters = '';
    string = typeof string === 'number' ? String(string) : string;

    if (string.length > padLength) {
      return string;
    }

    for (i = 0; i < padLength; i = i + 1) {
      characters += String(character);
    }

    return (characters + string).slice(-characters.length);
  }

  function TimeCounter() {
    this.reset();
  }
  /**
   * [toString convert the counted values on a string]
   * @param  {array} units           [array with the units to display]
   * @param  {string} separator       [separator of the units]
   * @param  {number} leftZeroPadding [number of zero padding]
   * @return {string}                 [result string]
   */


  TimeCounter.prototype.toString = function () {
    var units = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['hours', 'minutes', 'seconds'];
    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ':';
    var leftZeroPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    units = units || ['hours', 'minutes', 'seconds'];
    separator = separator || ':';
    leftZeroPadding = leftZeroPadding || 2;
    var arrayTime = [];
    var i;

    for (i = 0; i < units.length; i = i + 1) {
      if (this[units[i]] !== undefined) {
        if (units[i] === 'secondTenths') {
          arrayTime.push(this[units[i]]);
        } else {
          arrayTime.push(leftPadding(this[units[i]], leftZeroPadding, '0'));
        }
      }
    }

    return arrayTime.join(separator);
  };
  /**
   * [reset reset counter]
   */


  TimeCounter.prototype.reset = function () {
    this.secondTenths = 0;
    this.seconds = 0;
    this.minutes = 0;
    this.hours = 0;
    this.days = 0;
  };

  function EventEmitter() {
    this.events = {};
  }

  EventEmitter.prototype.on = function (event, listener) {
    var _this = this;

    if (!Array.isArray(this.events[event])) {
      this.events[event] = [];
    }

    this.events[event].push(listener);
    return function () {
      return _this.removeListener(event, listener);
    };
  };

  EventEmitter.prototype.removeListener = function (event, listener) {
    if (Array.isArray(this.events[event])) {
      var eventIndex = this.events[event].indexOf(listener);

      if (eventIndex > -1) {
        this.events[event].splice(eventIndex, 1);
      }
    }
  };

  EventEmitter.prototype.emit = function (event) {
    var _this2 = this;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (Array.isArray(this.events[event])) {
      this.events[event].forEach(function (listener) {
        return listener.apply(_this2, args);
      });
    }
  };

  /*
   * General functions, variables and constants
   */

  var SECOND_TENTHS_PER_SECOND = 10;
  var SECONDS_PER_MINUTE = 60;
  var MINUTES_PER_HOUR = 60;
  var HOURS_PER_DAY = 24;
  var SECOND_TENTHS_POSITION = 0;
  var SECONDS_POSITION = 1;
  var MINUTES_POSITION = 2;
  var HOURS_POSITION = 3;
  var DAYS_POSITION = 4;
  var SECOND_TENTHS = 'secondTenths';
  var SECONDS = 'seconds';
  var MINUTES = 'minutes';
  var HOURS = 'hours';
  var DAYS = 'days';
  var VALID_INPUT_VALUES = [SECOND_TENTHS, SECONDS, MINUTES, HOURS, DAYS];
  var unitsInMilliseconds = {
    secondTenths: 100,
    seconds: 1000,
    minutes: 60000,
    hours: 3600000,
    days: 86400000
  };
  var groupedUnits = {
    secondTenths: SECOND_TENTHS_PER_SECOND,
    seconds: SECONDS_PER_MINUTE,
    minutes: MINUTES_PER_HOUR,
    hours: HOURS_PER_DAY
  };

  function mod(number, module) {
    return (number % module + module) % module;
  }
  /**
   * [Timer Timer/Chronometer/Countdown compatible with AMD and NodeJS.
   * Can update time values with different time intervals: tenth of seconds,
   * seconds, minutes and hours.]
   */


  function Timer() {
    var defaultParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    /*
    * PRIVATE variables and Functions
    */
    var counters = new TimeCounter();
    var totalCounters = new TimeCounter();
    var intervalId;
    var eventEmitter = new EventEmitter();
    var running = false;
    var paused = false;
    var precision;
    var timerTypeFactor;
    var customCallback;
    var timerConfig = {};
    var currentParams;
    var targetValues;
    var startValues;
    var countdown;
    var startingDate;
    var targetDate;
    var eventData = {
      detail: {
        timer: this
      }
    };
    setParams(defaultParams);

    function updateCounters(precision, roundedValue) {
      var unitsPerGroup = groupedUnits[precision];
      totalCounters[precision] = roundedValue;

      if (precision === DAYS) {
        counters[precision] = Math.abs(roundedValue);
      } else if (roundedValue >= 0) {
        counters[precision] = mod(roundedValue, unitsPerGroup);
      } else {
        counters[precision] = mod(unitsPerGroup - mod(roundedValue, unitsPerGroup), unitsPerGroup);
      }
    }

    function updateDays(value) {
      return updateUnitByPrecision(value, DAYS);
    }

    function updateHours(value) {
      return updateUnitByPrecision(value, HOURS);
    }

    function updateMinutes(value) {
      return updateUnitByPrecision(value, MINUTES);
    }

    function updateSeconds(value) {
      return updateUnitByPrecision(value, SECONDS);
    }

    function updateSecondTenths(value) {
      return updateUnitByPrecision(value, SECOND_TENTHS);
    }

    function updateUnitByPrecision(value, precision) {
      var previousValue = totalCounters[precision];
      updateCounters(precision, calculateIntegerUnitQuotient(value, unitsInMilliseconds[precision]));
      return totalCounters[precision] !== previousValue;
    }

    function stopTimerAndResetCounters() {
      stopTimer();
      resetCounters();
    }

    function stopTimer() {
      clearInterval(intervalId);
      intervalId = undefined;
      running = false;
      paused = false;
    }

    function setParamsAndStartTimer(params) {
      if (!isPaused()) {
        setParams(params);
      } else {
        startingDate = calculateStartingDate();
        targetValues = setTarget(currentParams.target);
      }

      startTimer();
    }

    function startTimer() {
      var interval = unitsInMilliseconds[precision];

      if (isTargetAchieved(roundTimestamp(Date.now()))) {
        return;
      }

      intervalId = setInterval(updateTimerAndDispatchEvents, interval);
      running = true;
      paused = false;
    }

    function calculateStartingDate() {
      return roundTimestamp(Date.now()) - totalCounters.secondTenths * unitsInMilliseconds[SECOND_TENTHS] * timerTypeFactor;
    }

    function updateTimerAndDispatchEvents() {
      var currentTime = roundTimestamp(Date.now());
      var valuesUpdated = updateTimer();
      dispatchEvents(valuesUpdated);
      customCallback(eventData.detail.timer);

      if (isTargetAchieved(currentTime)) {
        stop();
        dispatchEvent('targetAchieved', eventData);
      }
    }

    function updateTimer() {
      var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : roundTimestamp(Date.now());
      var elapsedTime = timerTypeFactor > 0 ? currentTime - startingDate : startingDate - currentTime;
      var valuesUpdated = {};
      valuesUpdated[SECOND_TENTHS] = updateSecondTenths(elapsedTime);
      valuesUpdated[SECONDS] = updateSeconds(elapsedTime);
      valuesUpdated[MINUTES] = updateMinutes(elapsedTime);
      valuesUpdated[HOURS] = updateHours(elapsedTime);
      valuesUpdated[DAYS] = updateDays(elapsedTime);
      return valuesUpdated;
    }

    function roundTimestamp(timestamp) {
      return Math.floor(timestamp / unitsInMilliseconds[precision]) * unitsInMilliseconds[precision];
    }

    function dispatchEvents(valuesUpdated) {
      if (valuesUpdated[SECOND_TENTHS]) {
        dispatchEvent('secondTenthsUpdated', eventData);
      }

      if (valuesUpdated[SECONDS]) {
        dispatchEvent('secondsUpdated', eventData);
      }

      if (valuesUpdated[MINUTES]) {
        dispatchEvent('minutesUpdated', eventData);
      }

      if (valuesUpdated[HOURS]) {
        dispatchEvent('hoursUpdated', eventData);
      }

      if (valuesUpdated[DAYS]) {
        dispatchEvent('daysUpdated', eventData);
      }
    }

    function isTargetAchieved(currentDate) {
      return targetValues instanceof Array && currentDate >= targetDate;
    }

    function resetCounters() {
      counters.reset();
      totalCounters.reset();
    }

    function setParams(params) {
      params = params || {};
      precision = checkPrecision(params.precision);
      customCallback = typeof params.callback === 'function' ? params.callback : function () {};
      countdown = params.countdown === true;
      timerTypeFactor = countdown === true ? -1 : 1;

      if (_typeof(params.startValues) === 'object') {
        setStartValues(params.startValues);
      } else {
        startValues = null;
      }

      startingDate = calculateStartingDate();
      updateTimer();

      if (_typeof(params.target) === 'object') {
        targetValues = setTarget(params.target);
      } else if (countdown) {
        params.target = {
          seconds: 0
        };
        targetValues = setTarget(params.target);
      } else {
        targetValues = null;
      }

      timerConfig = {
        precision: precision,
        callback: customCallback,
        countdown: _typeof(params) === 'object' && params.countdown === true,
        target: targetValues,
        startValues: startValues
      };
      currentParams = params;
    }

    function checkPrecision(precision) {
      precision = typeof precision === 'string' ? precision : SECONDS;

      if (!isValidInputValue(precision)) {
        throw new Error("Error in precision parameter: ".concat(precision, " is not a valid value"));
      }

      return precision;
    }

    function isValidInputValue(value) {
      return VALID_INPUT_VALUES.indexOf(value) >= 0;
    }

    function configInputValues(inputValues) {
      var values;

      if (_typeof(inputValues) === 'object') {
        if (inputValues instanceof Array) {
          if (inputValues.length !== 5) {
            throw new Error('Array size not valid');
          }

          values = inputValues;
        } else {
          for (var value in inputValues) {
            if (VALID_INPUT_VALUES.indexOf(value) < 0) {
              throw new Error("Error in startValues or target parameter: ".concat(value, " is not a valid input value"));
            }
          }

          values = [inputValues.secondTenths || 0, inputValues.seconds || 0, inputValues.minutes || 0, inputValues.hours || 0, inputValues.days || 0];
        }
      }

      var secondTenths = values[SECOND_TENTHS_POSITION];
      var seconds = values[SECONDS_POSITION] + calculateIntegerUnitQuotient(secondTenths, SECOND_TENTHS_PER_SECOND);
      var minutes = values[MINUTES_POSITION] + calculateIntegerUnitQuotient(seconds, SECONDS_PER_MINUTE);
      var hours = values[HOURS_POSITION] + calculateIntegerUnitQuotient(minutes, MINUTES_PER_HOUR);
      var days = values[DAYS_POSITION] + calculateIntegerUnitQuotient(hours, HOURS_PER_DAY);
      values[SECOND_TENTHS_POSITION] = secondTenths % SECOND_TENTHS_PER_SECOND;
      values[SECONDS_POSITION] = seconds % SECONDS_PER_MINUTE;
      values[MINUTES_POSITION] = minutes % MINUTES_PER_HOUR;
      values[HOURS_POSITION] = hours % HOURS_PER_DAY;
      values[DAYS_POSITION] = days;
      return values;
    }

    function calculateIntegerUnitQuotient(unit, divisor) {
      var quotient = unit / divisor;
      return quotient < 0 ? Math.ceil(quotient) : Math.floor(quotient);
    }

    function setTarget(inputTarget) {
      if (!inputTarget) {
        return;
      }

      targetValues = configInputValues(inputTarget);
      var targetCounter = calculateTotalCounterFromValues(targetValues);
      targetDate = startingDate + targetCounter.secondTenths * unitsInMilliseconds[SECOND_TENTHS] * timerTypeFactor;
      return targetValues;
    }

    function setStartValues(inputStartValues) {
      startValues = configInputValues(inputStartValues);
      counters.secondTenths = startValues[SECOND_TENTHS_POSITION];
      counters.seconds = startValues[SECONDS_POSITION];
      counters.minutes = startValues[MINUTES_POSITION];
      counters.hours = startValues[HOURS_POSITION];
      counters.days = startValues[DAYS_POSITION];
      totalCounters = calculateTotalCounterFromValues(startValues, totalCounters);
    }

    function calculateTotalCounterFromValues(values, outputCounter) {
      var total = outputCounter || {};
      total.days = values[DAYS_POSITION];
      total.hours = total.days * HOURS_PER_DAY + values[HOURS_POSITION];
      total.minutes = total.hours * MINUTES_PER_HOUR + values[MINUTES_POSITION];
      total.seconds = total.minutes * SECONDS_PER_MINUTE + values[SECONDS_POSITION];
      total.secondTenths = total.seconds * SECOND_TENTHS_PER_SECOND + values[[SECOND_TENTHS_POSITION]];
      return total;
    }
    /*
     * PUBLIC functions
     */

    /**
     * [stop stops the timer and resets the counters. Dispatch stopped event]
     */


    function stop() {
      stopTimerAndResetCounters();
      dispatchEvent('stopped', eventData);
    }
    /**
     * [stop stops and starts the timer. Dispatch stopped event]
     */


    function reset() {
      stopTimerAndResetCounters();
      setParamsAndStartTimer(currentParams);
      dispatchEvent('reset', eventData);
    }
    /**
     * [start starts the timer configured by the params object. Dispatch started event]
     * @param  {object} params [Configuration parameters]
     */


    function start() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      params = _objectSpread2(_objectSpread2({}, defaultParams), params);

      if (isRunning()) {
        return;
      }

      setParamsAndStartTimer(params);
      dispatchEvent('started', eventData);
    }
    /**
     * [pause stops the timer without resetting the counters. The timer it can be restarted with start function.
     * Dispatch paused event]
     * @return {type} [description]
     */


    function pause() {
      stopTimer();
      paused = true;
      dispatchEvent('paused', eventData);
    }
    /**
     * [addEventListener Adds event listener to the timer]
     * @param {string} eventType      [event to listen]
     * @param {function} listener   [the event listener function]
     */


    function addEventListener(eventType, listener) {
      eventEmitter.on(eventType, listener);
    }
    /**
     * [removeEventListener Removes event listener to the timer]
     * @param  {string} eventType    [event to remove listener]
     * @param  {function} listener [listener to remove]
     */


    function removeEventListener(eventType, listener) {
      eventEmitter.removeListener(eventType, listener);
    }
    /**
     * [dispatchEvent dispatches an event]
     * @param  {string} eventType [event to dispatch]
     * @param data
     */


    function dispatchEvent(eventType, data) {
      eventEmitter.emit(eventType, data);
    }
    /**
     * [isRunning return true if the timer is running]
     * @return {Boolean}
     */


    function isRunning() {
      return running;
    }
    /**
     * [isPaused returns true if the timer is paused]
     * @return {Boolean}
     */


    function isPaused() {
      return paused;
    }
    /**
     * [getTimeValues returns the counter with the current timer values]
     * @return {TimeCounter}
     */


    function getTimeValues() {
      return counters;
    }
    /**
     * [getTotalTimeValues returns the counter with the current timer total values]
     * @return {TimeCounter}
     */


    function getTotalTimeValues() {
      return totalCounters;
    }
    /**
     * [getConfig returns the configuration parameters]
     * @return {type}
     */


    function getConfig() {
      return timerConfig;
    }
    /**
     * Public API
     * Definition of Timer instance public functions
     */


    if (typeof this !== 'undefined') {
      this.start = start;
      this.pause = pause;
      this.stop = stop;
      this.reset = reset;
      this.isRunning = isRunning;
      this.isPaused = isPaused;
      this.getTimeValues = getTimeValues;
      this.getTotalTimeValues = getTotalTimeValues;
      this.getConfig = getConfig;
      this.addEventListener = addEventListener;
      this.on = addEventListener;
      this.removeEventListener = removeEventListener;
      this.off = removeEventListener;
    }
  }

  exports.Timer = Timer;
  exports.default = Timer;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],"utils/timer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.countDown = void 0;

var _easytimer = require("easytimer.js");

var countDown = function countDown(time) {
  var timer = new _easytimer.Timer();
  timer.start({
    countdown: true,
    precision: 'secondTenths',
    startValues: {
      seconds: time
    }
  });
  timer.addEventListener('secondTenthsUpdated', function (e) {
    document.getElementById("timer").innerHTML = timer.getTimeValues().toString(['seconds', 'secondTenths']);
  });
};

exports.countDown = countDown;
},{"easytimer.js":"node_modules/easytimer.js/dist/easytimer.js"}],"camera.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadModel = loadModel;
exports.bindPage = bindPage;

var posenet_module = _interopRequireWildcard(require("@tensorflow-models/posenet"));

var facemesh_module = _interopRequireWildcard(require("@tensorflow-models/facemesh"));

var tf = _interopRequireWildcard(require("@tensorflow/tfjs"));

var paper = _interopRequireWildcard(require("paper"));

var _demoUtils = require("./utils/demoUtils");

var _svgUtils = require("./utils/svgUtils");

var _illustration = require("./illustrationGen/illustration");

var _skeleton = require("./illustrationGen/skeleton");

var _fileUtils = require("./utils/fileUtils");

var girlSVG = _interopRequireWildcard(require("./resources/illustration/girl.svg"));

var boySVG = _interopRequireWildcard(require("./resources/illustration/boy.svg"));

var _faceApi = require("face-api.js");

var _gameUtils = require("./utils/gameUtils.js");

var _gamePlay = require("./utils/gamePlay.js");

var _readyState = require("./utils/readyState.js");

var _timer = require("./utils/timer.js");

var _easytimer = _interopRequireDefault(require("easytimer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

// levels info
var levelInfo = {
  easy: 'levels/easy.json',
  medium: 'levels/medium.json',
  difficult: 'levels/hard.json'
}; //This function will collect the Json file for particular level
//Since we need to use xmlhttp I had to make it async

function getOutput() {
  return _getOutput.apply(this, arguments);
} // Camera stream video element


function _getOutput() {
  _getOutput = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return (0, _gameUtils.readJson)(levelInfo.easy);

          case 2:
            console.log("data for level collected");

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getOutput.apply(this, arguments);
}

var video;
var videoWidth = 640;
var videoHeight = 480; // Canvas

var faceDetection = null;
var illustration = null;
var canvasScope;
var canvasWidth = 800;
var canvasHeight = 800; // ML models

var facemesh;
var posenet;
var minPoseConfidence = 0.15;
var minPartConfidence = 0.1;
var nmsRadius = 30.0; // Misc

var mobile = false;
var avatarSvgs = {
  'girl': girlSVG.default,
  'boy': boySVG.default
};
/**
 * Loads a the camera to be used in the demo
 *
 */

function setupCamera() {
  return _setupCamera.apply(this, arguments);
}

function _setupCamera() {
  _setupCamera = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    var video, stream;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)) {
              _context3.next = 2;
              break;
            }

            throw new Error('Browser API navigator.mediaDevices.getUserMedia not available');

          case 2:
            video = document.getElementById('video');
            video.width = videoWidth;
            video.height = videoHeight;
            _context3.next = 7;
            return navigator.mediaDevices.getUserMedia({
              'audio': false,
              'video': {
                facingMode: 'user',
                width: videoWidth,
                height: videoHeight
              }
            });

          case 7:
            stream = _context3.sent;
            video.srcObject = stream;
            return _context3.abrupt("return", new Promise(function (resolve) {
              video.onloadedmetadata = function () {
                resolve(video);
              };
            }));

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _setupCamera.apply(this, arguments);
}

function loadVideo() {
  return _loadVideo.apply(this, arguments);
}

function _loadVideo() {
  _loadVideo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
    var video;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return setupCamera();

          case 2:
            video = _context4.sent;
            video.play();
            return _context4.abrupt("return", video);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _loadVideo.apply(this, arguments);
}

var defaultPoseNetArchitecture = 'MobileNetV1';
var defaultQuantBytes = 2;
var defaultMultiplier = 1.0;
var defaultStride = 16;
var defaultInputResolution = 200;
var guiState = {
  avatarSVG: Object.keys(avatarSvgs)[0],
  debug: {
    showDetectionDebug: false,
    showIllustrationDebug: false
  }
}; //Model variables

var poseNet;
var pose;
var brain;
var skeleton;
var poseLabel = "Nothing yet!"; //This function sends the letter to the input letter hold

function draw() {
  document.getElementById('image-label').innerHTML = poseLabel;
}

function setupModel() {
  console.log('Setting up!');
  poseNet = ml5.poseNet(video, modelLoaded);
  poseNet.on('pose', gotPoses);
}

function loadModel() {
  var options = {
    inputs: 34,
    outputs: 7,
    task: 'classification',
    debug: true
  };
  brain = ml5.neuralNetwork(options);
  var modelInfo = {
    model: 'model/model.json',
    metadata: 'model/model_meta.json',
    weights: 'model/model.weights.bin'
  };
  brain.load(modelInfo, brainLoaded);
}

function brainLoaded() {
  console.log('pose classification ready!');
  classifyPose();
}

function classifyPose() {
  // console.log('Classify pose');
  if (pose) {
    var inputs = [];

    for (var i = 0; i < pose.keypoints.length; i++) {
      var x = pose.keypoints[i].position.x;
      var y = pose.keypoints[i].position.y;
      inputs.push(x);
      inputs.push(y);
    }

    brain.classify(inputs, gotResult);
  } else {
    setTimeout(classifyPose, 100);
  }
}

function gotResult(error, results) {
  if (results[0].confidence > 0.80) {
    poseLabel = results[0].label.toUpperCase(); // console.log(poseLabel);

    draw();

    if (Boolean(_gameUtils.loaded)) {
      (0, _gameUtils.insertInputText)(poseLabel);
    }
  }

  classifyPose();
}

function gotPoses(poses) {
  if (poses.length > 0) {
    pose = poses[0].pose;
    skeleton = poses[0].skeleton;
  }
}

function modelLoaded() {
  console.log('poseNet ready');
  var splash = document.getElementById("loader");
  splash.classList.add('display-none');
} //SVG animation

/**
 * Feeds an image to posenet to estimate poses - this is where the magic
 * happens. This function loops with a requestAnimationFrame method.
 */


function detectPoseInRealTime(video) {
  var canvas = document.getElementById('output');
  var keypointCanvas = document.getElementById('keypoints');
  var videoCtx = canvas.getContext('2d');
  var keypointCtx = keypointCanvas.getContext('2d');
  canvas.width = videoWidth;
  canvas.height = videoHeight;
  keypointCanvas.width = videoWidth;
  keypointCanvas.height = videoHeight;

  function poseDetectionFrame() {
    return _poseDetectionFrame.apply(this, arguments);
  }

  function _poseDetectionFrame() {
    _poseDetectionFrame = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var poses, input, all_poses, face;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              poses = [];
              videoCtx.clearRect(0, 0, videoWidth, videoHeight); // Draw video

              videoCtx.save();
              videoCtx.scale(-1, 1);
              videoCtx.translate(-videoWidth, 0); // videoCtx.drawImage(video, 0, 0, videoWidth, videoHeight); //this comment disables self-video

              videoCtx.restore(); // Creates a tensor from an image
              //keeping it in multi-person makes the svg detection better - sachin

              input = tf.browser.fromPixels(canvas);
              _context.next = 9;
              return facemesh.estimateFaces(input, false, false);

            case 9:
              faceDetection = _context.sent;
              _context.next = 12;
              return posenet.estimatePoses(video, {
                flipHorizontal: true,
                decodingMethod: 'multi-person',
                maxDetections: 1,
                scoreThreshold: minPartConfidence,
                nmsRadius: nmsRadius
              });

            case 12:
              all_poses = _context.sent;
              poses = poses.concat(all_poses);
              input.dispose();
              keypointCtx.clearRect(0, 0, videoWidth, videoHeight);

              if (guiState.debug.showDetectionDebug) {
                poses.forEach(function (_ref) {
                  var score = _ref.score,
                      keypoints = _ref.keypoints;

                  if (score >= minPoseConfidence) {
                    (0, _demoUtils.drawKeypoints)(keypoints, minPartConfidence, keypointCtx);
                    (0, _demoUtils.drawSkeleton)(keypoints, minPartConfidence, keypointCtx);
                  }
                });
                faceDetection.forEach(function (face) {
                  Object.values(_skeleton.facePartName2Index).forEach(function (index) {
                    var p = face.scaledMesh[index];
                    (0, _demoUtils.drawPoint)(keypointCtx, p[1], p[0], 2, 'red');
                  });
                });
              }

              canvasScope.project.clear();

              if (poses.length >= 1 && illustration) {
                _skeleton.Skeleton.flipPose(poses[0]);

                if (faceDetection && faceDetection.length > 0) {
                  face = _skeleton.Skeleton.toFaceFrame(faceDetection[0]);
                  illustration.updateSkeleton(poses[0], face);
                } else {
                  illustration.updateSkeleton(poses[0], null);
                }

                illustration.draw(canvasScope, videoWidth, videoHeight);

                if (guiState.debug.showIllustrationDebug) {
                  illustration.debugDraw(canvasScope);
                }
              }

              canvasScope.project.activeLayer.scale(canvasWidth / videoWidth, canvasHeight / videoHeight, new canvasScope.Point(0, 0));
              requestAnimationFrame(poseDetectionFrame);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _poseDetectionFrame.apply(this, arguments);
  }

  poseDetectionFrame();
}

function setupCanvas() {
  mobile = (0, _demoUtils.isMobile)();

  if (mobile) {
    canvasWidth = Math.min(window.innerWidth, window.innerHeight);
    canvasHeight = canvasWidth;
    videoWidth *= 0.7;
    videoHeight *= 0.7;
  }

  canvasScope = paper.default;
  var canvas = document.querySelector('.illustration-canvas');
  ;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  canvasScope.setup(canvas);
}
/**
 * Kicks off the game by loading the posenet model, finding and loading
 * available camera devices, and setting off the detectPoseInRealTime function.
 */


function bindPage() {
  return _bindPage.apply(this, arguments);
}

function _bindPage() {
  _bindPage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
    var p, t0, info;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            setupCanvas(); // toggleLoadingUI(true);

            (0, _demoUtils.setStatusText)('Loading the models...'); // attach evenListner to our start button start_btn

            p = document.getElementById("start_btn"); // Find the paragraph element in the page

            p.onclick = _gameUtils.readSetGo;
            _context5.next = 6;
            return posenet_module.load({
              architecture: defaultPoseNetArchitecture,
              outputStride: defaultStride,
              inputResolution: defaultInputResolution,
              multiplier: defaultMultiplier,
              quantBytes: defaultQuantBytes
            });

          case 6:
            posenet = _context5.sent;
            (0, _demoUtils.setStatusText)('Loading FaceMesh model...');
            _context5.next = 10;
            return facemesh_module.load();

          case 10:
            facemesh = _context5.sent;
            (0, _demoUtils.setStatusText)('Loading Avatar file...');
            t0 = new Date();
            _context5.next = 15;
            return parseSVG(Object.values(avatarSvgs)[0]);

          case 15:
            (0, _demoUtils.setStatusText)('Setting up camera...');
            _context5.prev = 16;
            _context5.next = 19;
            return loadVideo();

          case 19:
            video = _context5.sent;
            _context5.next = 28;
            break;

          case 22:
            _context5.prev = 22;
            _context5.t0 = _context5["catch"](16);
            info = document.getElementById('info');
            info.textContent = 'this device type is not supported yet, ' + 'or this browser does not support video capture: ' + _context5.t0.toString();
            info.style.display = 'block';
            throw _context5.t0;

          case 28:
            // toggleLoadingUI(false);
            setupModel(); // allSet().then(gameOn);

            detectPoseInRealTime(video, posenet);

          case 30:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[16, 22]]);
  }));
  return _bindPage.apply(this, arguments);
}

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

_fileUtils.FileUtils.setDragDropHandler(function (result) {
  parseSVG(result);
});

function parseSVG(_x) {
  return _parseSVG.apply(this, arguments);
}

function _parseSVG() {
  _parseSVG = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(target) {
    var avatar_select, svgScope, skeleton;
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            // let svgScope = await SVGUtils.importSVG(target /* SVG string or file path */);
            avatar_select = "";
            Math.floor(Math.random() * 2) === 0 ? avatar_select = "boy" : avatar_select = "girl";
            _context6.next = 4;
            return _svgUtils.SVGUtils.importSVG(avatarSvgs[avatar_select]);

          case 4:
            svgScope = _context6.sent;
            //forces just girl avatar
            skeleton = new _skeleton.Skeleton(svgScope);
            illustration = new _illustration.PoseIllustration(canvasScope);
            illustration.bindSkeleton(skeleton, svgScope);

          case 8:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _parseSVG.apply(this, arguments);
}

loadModel();
bindPage(); // startCountdown();
// gameOn();

getOutput(); // setTimeout(() =>{
//   readSetGo()
// },20000 )

(0, _timer.countDown)(30);
},{"@tensorflow-models/posenet":"node_modules/@tensorflow-models/posenet/dist/posenet.esm.js","@tensorflow-models/facemesh":"node_modules/@tensorflow-models/facemesh/dist/facemesh.esm.js","@tensorflow/tfjs":"node_modules/@tensorflow/tfjs/dist/tf.esm.js","paper":"node_modules/paper/dist/paper-full.js","./utils/demoUtils":"utils/demoUtils.js","./utils/svgUtils":"utils/svgUtils.js","./illustrationGen/illustration":"illustrationGen/illustration.js","./illustrationGen/skeleton":"illustrationGen/skeleton.js","./utils/fileUtils":"utils/fileUtils.js","./resources/illustration/girl.svg":"resources/illustration/girl.svg","./resources/illustration/boy.svg":"resources/illustration/boy.svg","face-api.js":"node_modules/face-api.js/build/es6/index.js","./utils/gameUtils.js":"utils/gameUtils.js","./utils/gamePlay.js":"utils/gamePlay.js","./utils/readyState.js":"utils/readyState.js","./utils/timer.js":"utils/timer.js","easytimer.js":"node_modules/easytimer.js/dist/easytimer.js"}]},{},["camera.js"], null)